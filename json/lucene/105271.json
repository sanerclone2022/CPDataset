[{"authorTime":"2013-02-20 12:29:42","codes":[{"authorDate":"2013-02-20 12:29:42","commitOrder":2,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2013-02-20 12:29:42","endLine":385,"groupId":"8565","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/1d/b957b2c6028bc8d0d43d545240e9fdf7d2af2e.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"MB"},{"authorDate":"2013-02-20 12:29:42","commitOrder":2,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedSetDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedSetDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2013-02-20 12:29:42","endLine":607,"groupId":"8744","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/1d/b957b2c6028bc8d0d43d545240e9fdf7d2af2e.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedSetDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedSetDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":393,"status":"B"}],"commitId":"b44aa6183484591e8db4a9490b8ce571d40458fe","commitMessage":"@@@LUCENE-4765: Multi-valued docvalues field\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1447999 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-02-20 12:29:42","modifiedFileCount":"57","status":"M","submitter":"Robert Muir"},{"authorTime":"2013-03-11 08:59:10","codes":[{"authorDate":"2013-03-11 08:59:10","commitOrder":3,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2013-03-11 08:59:10","endLine":383,"groupId":"8565","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/92/1b94dff6905711127d2419806086ddc713e73a.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"},{"authorDate":"2013-03-11 08:59:10","commitOrder":3,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2013-03-11 08:59:10","endLine":605,"groupId":"8744","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/92/1b94dff6905711127d2419806086ddc713e73a.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedSetDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedSetDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"M"}],"commitId":"dd0855c4fee7180f1c68185235da6aed357eaee1","commitMessage":"@@@LUCENE-4819: move Sorted(set)DocValuesTermsEnum to codec\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1454968 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-03-11 08:59:10","modifiedFileCount":"12","status":"M","submitter":"Robert Muir"},{"authorTime":"2013-03-11 12:40:47","codes":[{"authorDate":"2013-03-11 12:40:47","commitOrder":4,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2013-03-11 12:40:47","endLine":385,"groupId":"8565","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/1d/b957b2c6028bc8d0d43d545240e9fdf7d2af2e.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"M"},{"authorDate":"2013-03-11 12:40:47","commitOrder":4,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedSetDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedSetDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2013-03-11 12:40:47","endLine":607,"groupId":"8744","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/1d/b957b2c6028bc8d0d43d545240e9fdf7d2af2e.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":393,"status":"M"}],"commitId":"1600711a618eb8599a1a91b461661ecbe4da1b55","commitMessage":"@@@LUCENE-4819: revert\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1454996 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-03-11 12:40:47","modifiedFileCount":"12","status":"M","submitter":"Robert Muir"},{"authorTime":"2013-03-12 10:17:27","codes":[{"authorDate":"2013-03-12 10:17:27","commitOrder":5,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2013-03-12 10:17:27","endLine":383,"groupId":"8565","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/92/1b94dff6905711127d2419806086ddc713e73a.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"},{"authorDate":"2013-03-12 10:17:27","commitOrder":5,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2013-03-12 10:17:27","endLine":605,"groupId":"8744","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/92/1b94dff6905711127d2419806086ddc713e73a.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = new SortedSetDocValuesTermsEnum(dv);\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(new SortedSetDocValuesTermsEnum(dv), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"M"}],"commitId":"b25cc528d9e00a202507a9d6300cf10e4089f648","commitMessage":"@@@LUCENE-4819: move Sorted(set)DocValuesTermsEnum to codec\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1455391 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-03-12 10:17:27","modifiedFileCount":"13","status":"M","submitter":"Robert Muir"},{"authorTime":"2013-03-12 10:17:27","codes":[{"authorDate":"2013-08-21 05:30:55","commitOrder":6,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2013-08-21 05:30:55","endLine":402,"groupId":"8742","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e0/aac6d5cbe78067df156eb05a61d8b0a2c17e3d.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            bitset.set(dv.getOrd(i));\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"},{"authorDate":"2013-03-12 10:17:27","commitOrder":6,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2013-03-12 10:17:27","endLine":605,"groupId":"8744","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/92/1b94dff6905711127d2419806086ddc713e73a.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"N"}],"commitId":"39dbc26716009e1d3aefb744de2d8c722a6023a8","commitMessage":"@@@LUCENE-5178: add missing support for docvalues\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1515977 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-08-21 05:30:55","modifiedFileCount":"86","status":"M","submitter":"Robert Muir"},{"authorTime":"2013-10-29 16:35:02","codes":[{"authorDate":"2013-10-29 16:35:02","commitOrder":7,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2013-10-29 16:35:02","endLine":402,"groupId":"8742","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/d1/e31af098474ec674f158431ce623e5cab37455.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"},{"authorDate":"2013-10-29 16:35:02","commitOrder":7,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2013-10-29 16:35:02","endLine":624,"groupId":"22963","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/d1/e31af098474ec674f158431ce623e5cab37455.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getSegmentNumber(currentOrd);\n                long segmentOrd = map.getSegmentOrd(segmentNumber, currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":410,"status":"M"}],"commitId":"1dd6d53c0797016f5fb814c3b04b94ee6779eda1","commitMessage":"@@@LUCENE-5157: Rename OrdinalMap methods to clarify API and internal structure.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1536605 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-10-29 16:35:02","modifiedFileCount":"2","status":"M","submitter":"Adrien Grand"},{"authorTime":"2014-02-10 23:44:23","codes":[{"authorDate":"2014-02-10 23:44:23","commitOrder":8,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2014-02-10 23:44:23","endLine":402,"groupId":"8742","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e6/17b0fcdc8f2fd6ba4da8c40f4ac0c5d3cf7597.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"},{"authorDate":"2014-02-10 23:44:23","commitOrder":8,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2014-02-10 23:44:23","endLine":624,"groupId":"22963","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e6/17b0fcdc8f2fd6ba4da8c40f4ac0c5d3cf7597.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        OpenBitSet bitset = new OpenBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":410,"status":"M"}],"commitId":"b872f4b5c3c5324711ebb379e6c8e4c705ab3f42","commitMessage":"@@@LUCENE-5440: Add LongBitSet to handle large number of bits; replace usage of OpenBitSet by FixedBitSet/LongBitSet\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1566662 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-02-10 23:44:23","modifiedFileCount":"15","status":"M","submitter":"Shai Erera"},{"authorTime":"2014-06-05 23:54:49","codes":[{"authorDate":"2014-06-05 23:54:49","commitOrder":9,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2014-06-05 23:54:49","endLine":401,"groupId":"14033","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/97/7983a95fb5a611495510102103b8de8c1f9870.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"},{"authorDate":"2014-06-05 23:54:49","commitOrder":9,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2014-06-05 23:54:49","endLine":622,"groupId":"63043","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/97/7983a95fb5a611495510102103b8de8c1f9870.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              final BytesRef scratch = new BytesRef();\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                dvs[segmentNumber].lookupOrd(segmentOrd, scratch);\n                currentOrd++;\n                return scratch;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":409,"status":"M"}],"commitId":"8f267c8560cac15d140c5097dfd6392c4270d3d2","commitMessage":"@@@LUCENE-5703: BinaryDocValues producers don't allocate or copy bytes on each access anymore\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1600688 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-06-05 23:54:49","modifiedFileCount":"75","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-06-17 04:33:44","codes":[{"authorDate":"2014-06-17 04:33:44","commitOrder":10,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2014-06-17 04:33:44","endLine":565,"groupId":"0","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6e/1cd9d71f281ff8a163c62a51e5cab25a06ba45.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) map.getGlobalOrd(readerUpto, segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":437,"status":"M"},{"authorDate":"2014-06-17 04:33:44","commitOrder":10,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2014-06-17 04:33:44","endLine":788,"groupId":"63043","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6e/1cd9d71f281ff8a163c62a51e5cab25a06ba45.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = map.getGlobalOrd(readerUpto, ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":573,"status":"M"}],"commitId":"e7f81b4d6ccf72b218087527ec3cfc89dd12f16f","commitMessage":"@@@LUCENE-5767: OrdinalMap optimizations.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1602997 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-06-17 04:33:44","modifiedFileCount":"8","status":"M","submitter":"Adrien Grand"},{"authorTime":"2014-06-21 21:58:14","codes":[{"authorDate":"2014-06-21 21:58:14","commitOrder":11,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2014-06-21 21:58:14","endLine":569,"groupId":"52007","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3b/187bc910b1e73fce4b49ab5fbd50b2d43c67f7.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":438,"status":"M"},{"authorDate":"2014-06-21 21:58:14","commitOrder":11,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2014-06-21 21:58:14","endLine":795,"groupId":"63043","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3b/187bc910b1e73fce4b49ab5fbd50b2d43c67f7.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n      }\n    }\n    \n    \r\n    final OrdinalMap map = new OrdinalMap(this, liveTerms);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":577,"status":"M"}],"commitId":"e98bcb82549f362929b3334b29fb1287d7111fca","commitMessage":"@@@LUCENE-5782: Improve OrdinalMap compression by sorting the supplied terms enums\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1604387 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-06-21 21:58:14","modifiedFileCount":"2","status":"M","submitter":"Adrien Grand"},{"authorTime":"2014-09-24 07:51:55","codes":[{"authorDate":"2014-09-24 07:51:55","commitOrder":12,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final LeafReader readers[] = mergeState.readers.toArray(new LeafReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      LeafReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              LeafReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2014-09-24 07:51:55","endLine":652,"groupId":"52007","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3a/eb2470170b17ddfdbf99986df3dc2e703e1f13.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":521,"status":"M"},{"authorDate":"2014-09-24 07:51:55","commitOrder":12,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final LeafReader readers[] = mergeState.readers.toArray(new LeafReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      LeafReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              LeafReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              LeafReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2014-09-24 07:51:55","endLine":878,"groupId":"63043","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3a/eb2470170b17ddfdbf99986df3dc2e703e1f13.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final AtomicReader readers[] = mergeState.readers.toArray(new AtomicReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      AtomicReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              AtomicReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":660,"status":"M"}],"commitId":"85bf3181737a34e2d357f0c926d7ae8d07b9ae39","commitMessage":"@@@LUCENE-5569: *AtomicReader/AtomicReaderContext have been renamed to *LeafReader/LeafReaderContext\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1627178 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-24 07:51:55","modifiedFileCount":"459","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2014-10-05 22:01:13","codes":[{"authorDate":"2014-10-05 22:01:13","commitOrder":13,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              int currentMaxDoc;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == numReaders) {\n                    return false;\n                  }\n\n                  if (docIDUpto == currentMaxDoc) {\n                    readerUpto++;\n                    if (readerUpto < numReaders) {\n                      currentMap = map.getGlobalOrds(readerUpto);\n                      currentLiveDocs = mergeState.liveDocs[readerUpto];\n                      currentMaxDoc = mergeState.maxDocs[readerUpto];\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2014-10-05 22:01:13","endLine":694,"groupId":"52719","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/8b/25bcb4016e1f1d4dad2a7ab8e847d74a975b6e.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final LeafReader readers[] = mergeState.readers.toArray(new LeafReader[toMerge.size()]);\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      LeafReader reader = readers[sub];\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              LeafReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":563,"status":"M"},{"authorDate":"2014-10-05 22:01:13","commitOrder":13,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    final int numReaders = mergeState.maxDocs.length;\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              int currentMaxDoc;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == numReaders) {\n                    return false;\n                  }\n\n                  if (docIDUpto == currentMaxDoc) {\n                    readerUpto++;\n                    if (readerUpto < numReaders) {\n                      currentLiveDocs = mergeState.liveDocs[readerUpto];\n                      currentMaxDoc = mergeState.maxDocs[readerUpto];\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              int currentMaxDoc;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == numReaders) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (docIDUpto == currentMaxDoc) {\n                    readerUpto++;\n                    if (readerUpto < numReaders) {\n                      currentMap = map.getGlobalOrds(readerUpto);\n                      currentLiveDocs = mergeState.liveDocs[readerUpto];\n                      currentMaxDoc = mergeState.maxDocs[readerUpto];\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentMaxDoc;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2014-10-05 22:01:13","endLine":920,"groupId":"52718","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/8b/25bcb4016e1f1d4dad2a7ab8e847d74a975b6e.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final LeafReader readers[] = mergeState.readers.toArray(new LeafReader[toMerge.size()]);\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      LeafReader reader = readers[sub];\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = reader.getLiveDocs();\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < reader.maxDoc(); i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              LeafReader currentReader;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              LeafReader currentReader;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == readers.length) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                    readerUpto++;\n                    if (readerUpto < readers.length) {\n                      currentReader = readers[readerUpto];\n                      currentLiveDocs = currentReader.getLiveDocs();\n                      currentMap = map.getGlobalOrds(readerUpto);\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentReader.maxDoc();\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":702,"status":"M"}],"commitId":"35160fd56ac41c3ed5d3b460c419d58fd8574d66","commitMessage":"@@@LUCENE-5969: Lucene 5.0 codec.  round two\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1629499 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-05 22:01:13","modifiedFileCount":"173","status":"M","submitter":"Robert Muir"},{"authorTime":"2016-05-23 14:35:53","codes":[{"authorDate":"2016-05-23 14:35:53","commitOrder":14,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            \r\n            List<SortedDocValuesSub> subs = new ArrayList<>();\n            assert mergeState.docMaps.length == toMerge.size();\n            for(int i=0;i<toMerge.size();i++) {\n              subs.add(new SortedDocValuesSub(mergeState.docMaps[i], toMerge.get(i), mergeState.maxDocs[i], map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n            return new Iterator<Number>() {\n              int nextValue;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  SortedDocValuesSub sub = docIDMerger.next();\n                  if (sub == null) {\n                    return false;\n                  }\n\n                  nextIsSet = true;\n                  int segOrd = sub.values.getOrd(sub.docID);\n                  nextValue = segOrd == -1 ? -1 : (int) sub.map.get(segOrd);\n                  return true;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","date":"2016-05-23 14:35:53","endLine":728,"groupId":"0","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/42/7b520aa4a78475ab0210832130d6a6e644a6a3.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              int currentMaxDoc;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == numReaders) {\n                    return false;\n                  }\n\n                  if (docIDUpto == currentMaxDoc) {\n                    readerUpto++;\n                    if (readerUpto < numReaders) {\n                      currentMap = map.getGlobalOrds(readerUpto);\n                      currentLiveDocs = mergeState.liveDocs[readerUpto];\n                      currentMaxDoc = mergeState.maxDocs[readerUpto];\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    int segOrd = dvs[readerUpto].getOrd(docIDUpto);\n                    nextValue = segOrd == -1 ? -1 : (int) currentMap.get(segOrd);\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":608,"status":"M"},{"authorDate":"2016-05-23 14:35:53","commitOrder":14,"curCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n\n            \r\n            List<SortedSetDocValuesSub> subs = new ArrayList<>();\n            assert mergeState.docMaps.length == toMerge.size();\n            for(int i=0;i<toMerge.size();i++) {\n              subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], toMerge.get(i), mergeState.maxDocs[i], map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n            return new Iterator<Number>() {\n              int nextValue;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  SortedSetDocValuesSub sub = docIDMerger.next();\n                  if (sub == null) {\n                    return false;\n                  }\n                  sub.values.setDocument(sub.docID);\n                  nextValue = 0;\n                  while (sub.values.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                    nextValue++;\n                  }\n                  \r\n                  nextIsSet = true;\n                  return true;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n\n            \r\n            List<SortedSetDocValuesSub> subs = new ArrayList<>();\n            assert mergeState.docMaps.length == toMerge.size();\n            for(int i=0;i<toMerge.size();i++) {\n              subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], toMerge.get(i), mergeState.maxDocs[i], map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n            return new Iterator<Number>() {\n              long nextValue;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  SortedSetDocValuesSub sub = docIDMerger.next();\n                  if (sub == null) {\n                    return false;\n                  }\n                  sub.values.setDocument(sub.docID);\n\n                  ordUpto = ordLength = 0;\n                  long ord;\n                  while ((ord = sub.values.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                    if (ordLength == ords.length) {\n                      ords = ArrayUtil.grow(ords, ordLength+1);\n                    }\n                    ords[ordLength] = sub.map.get(ord);\n                    ordLength++;\n                  }\n                  continue;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","date":"2016-05-23 14:35:53","endLine":962,"groupId":"10390","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfofieldInfo@finalMergeStatemergeState@List<SortedSetDocValues>toMerge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/42/7b520aa4a78475ab0210832130d6a6e644a6a3.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n    final SortedSetDocValues dvs[] = toMerge.toArray(new SortedSetDocValues[toMerge.size()]);\n    final int numReaders = mergeState.maxDocs.length;\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              int nextValue;\n              int currentMaxDoc;\n              Bits currentLiveDocs;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == numReaders) {\n                    return false;\n                  }\n\n                  if (docIDUpto == currentMaxDoc) {\n                    readerUpto++;\n                    if (readerUpto < numReaders) {\n                      currentLiveDocs = mergeState.liveDocs[readerUpto];\n                      currentMaxDoc = mergeState.maxDocs[readerUpto];\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n\n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    nextIsSet = true;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    nextValue = 0;\n                    while (dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                      nextValue++;\n                    }\n                    docIDUpto++;\n                    return true;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            return new Iterator<Number>() {\n              int readerUpto = -1;\n              int docIDUpto;\n              long nextValue;\n              int currentMaxDoc;\n              Bits currentLiveDocs;\n              LongValues currentMap;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (!hasNext()) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (readerUpto == numReaders) {\n                    return false;\n                  }\n                  \n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  if (docIDUpto == currentMaxDoc) {\n                    readerUpto++;\n                    if (readerUpto < numReaders) {\n                      currentMap = map.getGlobalOrds(readerUpto);\n                      currentLiveDocs = mergeState.liveDocs[readerUpto];\n                      currentMaxDoc = mergeState.maxDocs[readerUpto];\n                    }\n                    docIDUpto = 0;\n                    continue;\n                  }\n                  \n                  if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                    assert docIDUpto < currentMaxDoc;\n                    SortedSetDocValues dv = dvs[readerUpto];\n                    dv.setDocument(docIDUpto);\n                    ordUpto = ordLength = 0;\n                    long ord;\n                    while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                      if (ordLength == ords.length) {\n                        ords = ArrayUtil.grow(ords, ordLength+1);\n                      }\n                      ords[ordLength] = currentMap.get(ord);\n                      ordLength++;\n                    }\n                    docIDUpto++;\n                    continue;\n                  }\n\n                  docIDUpto++;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":767,"status":"M"}],"commitId":"eae605b53294282e50452e60440c138a3529f11d","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n","date":"2016-05-23 14:35:53","modifiedFileCount":"309","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-10-03 03:18:22","codes":[{"authorDate":"2016-10-03 03:18:22","commitOrder":15,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             try {\n                               values = docValuesProducer.getSorted(readerFieldInfo);\n                             } catch (IOException ioe) {\n                               throw new RuntimeException(ioe);\n                             }\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger;\n                       try {\n                         docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       } catch (IOException ioe) {\n                         throw new RuntimeException(ioe);\n                       }\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-10-03 03:18:22","endLine":615,"groupId":"49342","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/87/c236cc2449ac3d0637ce1ce902a3aee5d507e3.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            int ord = dv.getOrd(i);\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              int currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                int segmentOrd = (int)map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = dvs[segmentNumber].lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            \r\n            List<SortedDocValuesSub> subs = new ArrayList<>();\n            assert mergeState.docMaps.length == toMerge.size();\n            for(int i=0;i<toMerge.size();i++) {\n              subs.add(new SortedDocValuesSub(mergeState.docMaps[i], toMerge.get(i), mergeState.maxDocs[i], map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n            return new Iterator<Number>() {\n              int nextValue;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  SortedDocValuesSub sub = docIDMerger.next();\n                  if (sub == null) {\n                    return false;\n                  }\n\n                  nextIsSet = true;\n                  int segOrd = sub.values.getOrd(sub.docID);\n                  nextValue = segOrd == -1 ? -1 : (int) sub.map.get(segOrd);\n                  return true;\n                }\n              }\n            };\n          }\n        }\n    );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"M"},{"authorDate":"2016-10-03 03:18:22","commitOrder":15,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                try {\n                                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                                } catch (IOException ioe) {\n                                  throw new RuntimeException(ioe);\n                                }\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger;\n                          try {\n                            docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          } catch (IOException ioe) {\n                            throw new RuntimeException(ioe);\n                          }\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-10-03 03:18:22","endLine":791,"groupId":"16186","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/87/c236cc2449ac3d0637ce1ce902a3aee5d507e3.src","preCode":"  public void mergeSortedSetField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedSetDocValues> toMerge) throws IOException {\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        for (int i = 0; i < maxDoc; i++) {\n          if (liveDocs.get(i)) {\n            dv.setDocument(i);\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(fieldInfo,\n        \r\n        new Iterable<BytesRef>() {\n          @Override\n          public Iterator<BytesRef> iterator() {\n            return new Iterator<BytesRef>() {\n              long currentOrd;\n\n              @Override\n              public boolean hasNext() {\n                return currentOrd < map.getValueCount();\n              }\n\n              @Override\n              public BytesRef next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                int segmentNumber = map.getFirstSegmentNumber(currentOrd);\n                long segmentOrd = map.getFirstSegmentOrd(currentOrd);\n                final BytesRef term = toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                currentOrd++;\n                return term;\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n\n            \r\n            List<SortedSetDocValuesSub> subs = new ArrayList<>();\n            assert mergeState.docMaps.length == toMerge.size();\n            for(int i=0;i<toMerge.size();i++) {\n              subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], toMerge.get(i), mergeState.maxDocs[i], map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n            return new Iterator<Number>() {\n              int nextValue;\n              boolean nextIsSet;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  SortedSetDocValuesSub sub = docIDMerger.next();\n                  if (sub == null) {\n                    return false;\n                  }\n                  sub.values.setDocument(sub.docID);\n                  nextValue = 0;\n                  while (sub.values.nextOrd() != SortedSetDocValues.NO_MORE_ORDS) {\n                    nextValue++;\n                  }\n                  \r\n                  nextIsSet = true;\n                  return true;\n                }\n              }\n            };\n          }\n        },\n        \r\n        new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n\n            \r\n            List<SortedSetDocValuesSub> subs = new ArrayList<>();\n            assert mergeState.docMaps.length == toMerge.size();\n            for(int i=0;i<toMerge.size();i++) {\n              subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], toMerge.get(i), mergeState.maxDocs[i], map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n            return new Iterator<Number>() {\n              long nextValue;\n              boolean nextIsSet;\n              long ords[] = new long[8];\n              int ordUpto;\n              int ordLength;\n\n              @Override\n              public boolean hasNext() {\n                return nextIsSet || setNext();\n              }\n\n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public Number next() {\n                if (hasNext() == false) {\n                  throw new NoSuchElementException();\n                }\n                assert nextIsSet;\n                nextIsSet = false;\n                \r\n                return nextValue;\n              }\n\n              private boolean setNext() {\n                while (true) {\n                  if (ordUpto < ordLength) {\n                    nextValue = ords[ordUpto];\n                    ordUpto++;\n                    nextIsSet = true;\n                    return true;\n                  }\n\n                  SortedSetDocValuesSub sub = docIDMerger.next();\n                  if (sub == null) {\n                    return false;\n                  }\n                  sub.values.setDocument(sub.docID);\n\n                  ordUpto = ordLength = 0;\n                  long ord;\n                  while ((ord = sub.values.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                    if (ordLength == ords.length) {\n                      ords = ArrayUtil.grow(ords, ordLength+1);\n                    }\n                    ords[ordLength] = sub.map.get(ord);\n                    ordLength++;\n                  }\n                  continue;\n                }\n              }\n            };\n          }\n        }\n     );\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":647,"status":"M"}],"commitId":"3182cd9872af3cb73a1f73e36de68b8d76646e59","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-10-03 03:18:22","modifiedFileCount":"570","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-10-06 02:18:55","codes":[{"authorDate":"2016-10-06 02:18:55","commitOrder":16,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             try {\n                               values = docValuesProducer.getSorted(readerFieldInfo);\n                             } catch (IOException ioe) {\n                               throw new RuntimeException(ioe);\n                             }\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger;\n                       try {\n                         docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       } catch (IOException ioe) {\n                         throw new RuntimeException(ioe);\n                       }\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-10-06 02:18:55","endLine":614,"groupId":"49342","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/35/aa1002ddf174af207a19df7f1e8430be256746.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             try {\n                               values = docValuesProducer.getSorted(readerFieldInfo);\n                             } catch (IOException ioe) {\n                               throw new RuntimeException(ioe);\n                             }\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger;\n                       try {\n                         docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       } catch (IOException ioe) {\n                         throw new RuntimeException(ioe);\n                       }\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"M"},{"authorDate":"2016-10-06 02:18:55","commitOrder":16,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                try {\n                                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                                } catch (IOException ioe) {\n                                  throw new RuntimeException(ioe);\n                                }\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger;\n                          try {\n                            docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          } catch (IOException ioe) {\n                            throw new RuntimeException(ioe);\n                          }\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-10-06 02:18:55","endLine":789,"groupId":"16186","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/35/aa1002ddf174af207a19df7f1e8430be256746.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      int maxDoc = mergeState.maxDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                try {\n                                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                                } catch (IOException ioe) {\n                                  throw new RuntimeException(ioe);\n                                }\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger;\n                          try {\n                            docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          } catch (IOException ioe) {\n                            throw new RuntimeException(ioe);\n                          }\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":646,"status":"M"}],"commitId":"001a3ca55b30656e0e42f612d927a7923f5370e9","commitMessage":"@@@LUCENE-7407: speed up iterating norms a bit by having default codec implement the iterator directly\n","date":"2016-10-06 02:18:55","modifiedFileCount":"14","status":"M","submitter":"Mike McCandless"},{"authorTime":"2016-10-07 16:59:11","codes":[{"authorDate":"2016-10-07 16:59:11","commitOrder":17,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             try {\n                               values = docValuesProducer.getSorted(readerFieldInfo);\n                             } catch (IOException ioe) {\n                               throw new RuntimeException(ioe);\n                             }\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger;\n                       try {\n                         docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       } catch (IOException ioe) {\n                         throw new RuntimeException(ioe);\n                       }\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-10-07 16:59:11","endLine":614,"groupId":"49342","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a0/7cc3d668f2b85c7a7f475b382de645bb1b1d9f.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             try {\n                               values = docValuesProducer.getSorted(readerFieldInfo);\n                             } catch (IOException ioe) {\n                               throw new RuntimeException(ioe);\n                             }\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger;\n                       try {\n                         docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       } catch (IOException ioe) {\n                         throw new RuntimeException(ioe);\n                       }\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"M"},{"authorDate":"2016-10-07 16:59:11","commitOrder":17,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                try {\n                                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                                } catch (IOException ioe) {\n                                  throw new RuntimeException(ioe);\n                                }\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger;\n                          try {\n                            docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          } catch (IOException ioe) {\n                            throw new RuntimeException(ioe);\n                          }\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-10-07 16:59:11","endLine":789,"groupId":"16186","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a0/7cc3d668f2b85c7a7f475b382de645bb1b1d9f.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                try {\n                                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                                } catch (IOException ioe) {\n                                  throw new RuntimeException(ioe);\n                                }\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger;\n                          try {\n                            docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          } catch (IOException ioe) {\n                            throw new RuntimeException(ioe);\n                          }\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":646,"status":"M"}],"commitId":"fb088817eb12df4c76c4369f98629003f1ab307c","commitMessage":"@@@LUCENE-7479: SimpleText should directly implement the new doc values APIs.\n","date":"2016-10-07 16:59:11","modifiedFileCount":"39","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-10-12 18:55:16","codes":[{"authorDate":"2016-10-12 18:55:16","commitOrder":18,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-10-17 15:28:20","endLine":596,"groupId":"49342","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e0/4d5b9962f737133f3ac4324c4e227e945a3812.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             try {\n                               values = docValuesProducer.getSorted(readerFieldInfo);\n                             } catch (IOException ioe) {\n                               throw new RuntimeException(ioe);\n                             }\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger;\n                       try {\n                         docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       } catch (IOException ioe) {\n                         throw new RuntimeException(ioe);\n                       }\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":463,"status":"M"},{"authorDate":"2016-10-12 18:55:16","commitOrder":18,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-10-17 15:28:20","endLine":762,"groupId":"47757","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e0/4d5b9962f737133f3ac4324c4e227e945a3812.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                try {\n                                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                                } catch (IOException ioe) {\n                                  throw new RuntimeException(ioe);\n                                }\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger;\n                          try {\n                            docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          } catch (IOException ioe) {\n                            throw new RuntimeException(ioe);\n                          }\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":628,"status":"M"}],"commitId":"927fd51d64a6e72843018786daea855847416487","commitMessage":"@@@LUCENE-7489: Better sparsity support for Lucene70DocValuesFormat.\n","date":"2016-10-17 15:28:20","modifiedFileCount":"13","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-10-24 19:15:53","codes":[{"authorDate":"2016-10-24 19:15:53","commitOrder":19,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-10-24 19:15:53","endLine":616,"groupId":"49342","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e6/1724fbab1d5ee133ac73dfe295fc6bc7c256de.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2016-10-24 19:15:53","commitOrder":19,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-10-24 19:15:53","endLine":787,"groupId":"47757","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e6/1724fbab1d5ee133ac73dfe295fc6bc7c256de.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":648,"status":"M"}],"commitId":"c9de11d02464a146c6ab2aa561622876d081a070","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n","date":"2016-10-24 19:15:53","modifiedFileCount":"58","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-11-23 03:10:16","codes":[{"authorDate":"2016-11-23 03:10:16","commitOrder":20,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-11-23 03:10:16","endLine":616,"groupId":"49342","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ba/2f2aa501cab811a5b32b8049672942646c2a99.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2016-11-23 03:10:16","commitOrder":20,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-11-23 03:10:16","endLine":787,"groupId":"47757","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ba/2f2aa501cab811a5b32b8049672942646c2a99.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":648,"status":"M"}],"commitId":"21735161dcbdfcad52220d0389637c43f0d7989d","commitMessage":"@@@LUCENE-7568: Optimize merging when index sorting is used but the index is already sorted\n","date":"2016-11-23 03:10:16","modifiedFileCount":"11","status":"M","submitter":"Mike McCandless"},{"authorTime":"2016-12-22 02:34:19","codes":[{"authorDate":"2016-12-22 02:34:19","commitOrder":21,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2016-12-22 03:44:56","endLine":616,"groupId":"49342","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3d/06b51a4ddcc13fde41ca4935872bc7c5cb1b3e.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2016-12-22 02:34:19","commitOrder":21,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2016-12-22 03:44:56","endLine":787,"groupId":"47757","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3d/06b51a4ddcc13fde41ca4935872bc7c5cb1b3e.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":648,"status":"M"}],"commitId":"0d3c64ab099a1ddd168971e05e6199894fe5dfe7","commitMessage":"@@@LUCENE-7600: Simplify DocIdMerger.\n","date":"2016-12-22 03:44:56","modifiedFileCount":"8","status":"M","submitter":"Adrien Grand"},{"authorTime":"2017-02-28 21:21:30","codes":[{"authorDate":"2017-02-28 21:21:30","commitOrder":22,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2017-02-28 21:46:45","endLine":616,"groupId":"49342","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/88/e34f64b495abdc9802a069a5a1e16a4d7d691a.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2017-02-28 21:21:30","commitOrder":22,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2017-02-28 21:46:45","endLine":787,"groupId":"47757","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/88/e34f64b495abdc9802a069a5a1e16a4d7d691a.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(this, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":648,"status":"M"}],"commitId":"df6f83072303b4891a296b700a50c743284d3c30","commitMessage":"@@@LUCENE-7410: Make cache keys and close listeners less trappy.\n","date":"2017-02-28 21:46:45","modifiedFileCount":"75","status":"M","submitter":"Adrien Grand"},{"authorTime":"2020-01-06 16:01:42","codes":[{"authorDate":"2020-01-06 16:01:42","commitOrder":23,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n\n                         @Override\n                         public TermsEnum termsEnum() throws IOException {\n                           TermsEnum[] subs = new TermsEnum[toMerge.size()];\n                           for (int sub = 0; sub < subs.length; ++sub) {\n                             subs[sub] = toMerge.get(sub).termsEnum();\n                           }\n                           return new MergedTermsEnum(map, subs);\n                         }\n                       };\n                     }\n                   });\n  }\n","date":"2020-01-06 16:01:42","endLine":725,"groupId":"49342","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/40/8d978147857bd8cdedaf2afb99f7068e3227d3.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState) throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n    \n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub=0;sub<numReaders;sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedField(fieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n                       if (fieldInfoIn != fieldInfo) {\n                         throw new IllegalArgumentException(\"wrong FieldInfo\");\n                       }\n\n                       \r\n\n                       List<SortedDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         SortedDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                             values = docValuesProducer.getSorted(readerFieldInfo);\n                           }\n                         }\n                         if (values == null) {\n                           values = DocValues.emptySorted();\n                         }\n                         cost += values.cost();\n                         \n                         subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                       }\n\n                       final long finalCost = cost;\n\n                       final DocIDMerger<SortedDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                       \n                       return new SortedDocValues() {\n                         private int docID = -1;\n                         private int ord;\n\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n\n                         @Override\n                         public int nextDoc() throws IOException {\n                           SortedDocValuesSub sub = docIDMerger.next();\n                           if (sub == null) {\n                             return docID = NO_MORE_DOCS;\n                           }\n                           int subOrd = sub.values.ordValue();\n                           assert subOrd != -1;\n                           ord = (int) sub.map.get(subOrd);\n                           docID = sub.mappedDocID;\n                           return docID;\n                         }\n\n                         @Override\n                         public int ordValue() {\n                           return ord;\n                         }\n                         \n                         @Override\n                         public int advance(int target) {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n\n                         @Override\n                         public int getValueCount() {\n                           return (int) map.getValueCount();\n                         }\n                         \n                         @Override\n                         public BytesRef lookupOrd(int ord) throws IOException {\n                           int segmentNumber = map.getFirstSegmentNumber(ord);\n                           int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                           return dvs[segmentNumber].lookupOrd(segmentOrd);\n                         }\n                       };\n                     }\n                   });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":578,"status":"M"},{"authorDate":"2020-01-06 16:01:42","commitOrder":23,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n\n                            @Override\n                            public TermsEnum termsEnum() throws IOException {\n                              TermsEnum[] subs = new TermsEnum[toMerge.size()];\n                              for (int sub = 0; sub < subs.length; ++sub) {\n                                subs[sub] = toMerge.get(sub).termsEnum();\n                              }\n                              return new MergedTermsEnum(map, subs);\n                            }\n                          };\n                        }\n                      });\n  }\n","date":"2020-01-06 16:01:42","endLine":905,"groupId":"47757","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/40/8d978147857bd8cdedaf2afb99f7068e3227d3.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n    \n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n    \n    \r\n    addSortedSetField(mergeFieldInfo,\n                      new EmptyDocValuesProducer() {\n                        @Override\n                        public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n                          if (fieldInfo != mergeFieldInfo) {\n                            throw new IllegalArgumentException(\"wrong FieldInfo\");\n                          }\n\n                          \r\n                          List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n                          long cost = 0;\n                          \n                          for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                            SortedSetDocValues values = null;\n                            DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                            if (docValuesProducer != null) {\n                              FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                              if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                                values = docValuesProducer.getSortedSet(readerFieldInfo);\n                              }\n                            }\n                            if (values == null) {\n                              values = DocValues.emptySortedSet();\n                            }\n                            cost += values.cost();\n                            subs.add(new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n                          }\n            \n                          final DocIDMerger<SortedSetDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                          \n                          final long finalCost = cost;\n\n                          return new SortedSetDocValues() {\n                            private int docID = -1;\n                            private SortedSetDocValuesSub currentSub;\n\n                            @Override\n                            public int docID() {\n                              return docID;\n                            }\n\n                            @Override\n                            public int nextDoc() throws IOException {\n                              currentSub = docIDMerger.next();\n                              if (currentSub == null) {\n                                docID = NO_MORE_DOCS;\n                              } else {\n                                docID = currentSub.mappedDocID;\n                              }\n\n                              return docID;\n                            }\n\n                            @Override\n                            public int advance(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public boolean advanceExact(int target) throws IOException {\n                              throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public long nextOrd() throws IOException {\n                              long subOrd = currentSub.values.nextOrd();\n                              if (subOrd == NO_MORE_ORDS) {\n                                return NO_MORE_ORDS;\n                              }\n                              return currentSub.map.get(subOrd);\n                            }\n\n                            @Override\n                            public long cost() {\n                              return finalCost;\n                            }\n\n                            @Override\n                            public BytesRef lookupOrd(long ord) throws IOException {\n                              int segmentNumber = map.getFirstSegmentNumber(ord);\n                              long segmentOrd = map.getFirstSegmentOrd(ord);\n                              return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n                            }\n\n                            @Override\n                            public long getValueCount() {\n                              return map.getValueCount();\n                            }\n                          };\n                        }\n                      });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":757,"status":"M"}],"commitId":"dcc01fdaa6841a94613f68b419799523a157fe4a","commitMessage":"@@@LUCENE-9113: Speed up merging doc values' terms dictionaries. (#1136)\n\n","date":"2020-01-06 16:01:42","modifiedFileCount":"1","status":"M","submitter":"Adrien Grand"},{"authorTime":"2021-08-26 05:06:41","codes":[{"authorDate":"2021-08-26 05:06:41","commitOrder":24,"curCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState)\n      throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues[] dvs = toMerge.toArray(new SortedDocValues[numReaders]);\n\n    \r\n    TermsEnum[] liveTerms = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < numReaders; sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n\n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n\n    \r\n    addSortedField(\n        fieldInfo,\n        new EmptyDocValuesProducer() {\n          @Override\n          public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n            if (fieldInfoIn != fieldInfo) {\n              throw new IllegalArgumentException(\"wrong FieldInfo\");\n            }\n\n            \r\n\n            List<SortedDocValuesSub> subs = new ArrayList<>();\n            long cost = 0;\n            for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n              SortedDocValues values = null;\n              DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n              if (docValuesProducer != null) {\n                FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                if (readerFieldInfo != null\n                    && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                  values = docValuesProducer.getSorted(readerFieldInfo);\n                }\n              }\n              if (values == null) {\n                values = DocValues.emptySorted();\n              }\n              cost += values.cost();\n\n              subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n            }\n\n            final long finalCost = cost;\n\n            final DocIDMerger<SortedDocValuesSub> docIDMerger =\n                DocIDMerger.of(subs, mergeState.needsIndexSort);\n\n            return new SortedDocValues() {\n              private int docID = -1;\n              private int ord;\n\n              @Override\n              public int docID() {\n                return docID;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                SortedDocValuesSub sub = docIDMerger.next();\n                if (sub == null) {\n                  return docID = NO_MORE_DOCS;\n                }\n                int subOrd = sub.values.ordValue();\n                assert subOrd != -1;\n                ord = (int) sub.map.get(subOrd);\n                docID = sub.mappedDocID;\n                return docID;\n              }\n\n              @Override\n              public int ordValue() {\n                return ord;\n              }\n\n              @Override\n              public int advance(int target) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public boolean advanceExact(int target) throws IOException {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long cost() {\n                return finalCost;\n              }\n\n              @Override\n              public int getValueCount() {\n                return (int) map.getValueCount();\n              }\n\n              @Override\n              public BytesRef lookupOrd(int ord) throws IOException {\n                int segmentNumber = map.getFirstSegmentNumber(ord);\n                int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                return dvs[segmentNumber].lookupOrd(segmentOrd);\n              }\n\n              @Override\n              public TermsEnum termsEnum() throws IOException {\n                TermsEnum[] subs = new TermsEnum[toMerge.size()];\n                for (int sub = 0; sub < subs.length; ++sub) {\n                  subs[sub] = toMerge.get(sub).termsEnum();\n                }\n                return new MergedTermsEnum(map, subs);\n              }\n            };\n          }\n        });\n  }\n","date":"2021-08-26 05:06:41","endLine":743,"groupId":"105271","id":45,"instanceNumber":1,"isCurCommit":1,"methodName":"mergeSortedField","params":"(FieldInfofieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6d/962be51e0ce377c73fe225ddd804f24beda540.src","preCode":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState)\n      throws IOException {\n    List<SortedDocValues> toMerge = new ArrayList<>();\n    for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n      SortedDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n          values = docValuesProducer.getSorted(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySorted();\n      }\n      toMerge.add(values);\n    }\n\n    final int numReaders = toMerge.size();\n    final SortedDocValues dvs[] = toMerge.toArray(new SortedDocValues[numReaders]);\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[dvs.length];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < numReaders; sub++) {\n      SortedDocValues dv = dvs[sub];\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            int ord = dv.ordValue();\n            if (ord >= 0) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n\n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n\n    \r\n    addSortedField(\n        fieldInfo,\n        new EmptyDocValuesProducer() {\n          @Override\n          public SortedDocValues getSorted(FieldInfo fieldInfoIn) throws IOException {\n            if (fieldInfoIn != fieldInfo) {\n              throw new IllegalArgumentException(\"wrong FieldInfo\");\n            }\n\n            \r\n\n            List<SortedDocValuesSub> subs = new ArrayList<>();\n            long cost = 0;\n            for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n              SortedDocValues values = null;\n              DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n              if (docValuesProducer != null) {\n                FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n                if (readerFieldInfo != null\n                    && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n                  values = docValuesProducer.getSorted(readerFieldInfo);\n                }\n              }\n              if (values == null) {\n                values = DocValues.emptySorted();\n              }\n              cost += values.cost();\n\n              subs.add(new SortedDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n            }\n\n            final long finalCost = cost;\n\n            final DocIDMerger<SortedDocValuesSub> docIDMerger =\n                DocIDMerger.of(subs, mergeState.needsIndexSort);\n\n            return new SortedDocValues() {\n              private int docID = -1;\n              private int ord;\n\n              @Override\n              public int docID() {\n                return docID;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                SortedDocValuesSub sub = docIDMerger.next();\n                if (sub == null) {\n                  return docID = NO_MORE_DOCS;\n                }\n                int subOrd = sub.values.ordValue();\n                assert subOrd != -1;\n                ord = (int) sub.map.get(subOrd);\n                docID = sub.mappedDocID;\n                return docID;\n              }\n\n              @Override\n              public int ordValue() {\n                return ord;\n              }\n\n              @Override\n              public int advance(int target) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public boolean advanceExact(int target) throws IOException {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long cost() {\n                return finalCost;\n              }\n\n              @Override\n              public int getValueCount() {\n                return (int) map.getValueCount();\n              }\n\n              @Override\n              public BytesRef lookupOrd(int ord) throws IOException {\n                int segmentNumber = map.getFirstSegmentNumber(ord);\n                int segmentOrd = (int) map.getFirstSegmentOrd(ord);\n                return dvs[segmentNumber].lookupOrd(segmentOrd);\n              }\n\n              @Override\n              public TermsEnum termsEnum() throws IOException {\n                TermsEnum[] subs = new TermsEnum[toMerge.size()];\n                for (int sub = 0; sub < subs.length; ++sub) {\n                  subs[sub] = toMerge.get(sub).termsEnum();\n                }\n                return new MergedTermsEnum(map, subs);\n              }\n            };\n          }\n        });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":592,"status":"M"},{"authorDate":"2021-08-26 05:06:41","commitOrder":24,"curCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState)\n      throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum[] liveTerms = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n\n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n\n    \r\n    addSortedSetField(\n        mergeFieldInfo,\n        new EmptyDocValuesProducer() {\n          @Override\n          public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n            if (fieldInfo != mergeFieldInfo) {\n              throw new IllegalArgumentException(\"wrong FieldInfo\");\n            }\n\n            \r\n            List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n            long cost = 0;\n\n            for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n              SortedSetDocValues values = null;\n              DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n              if (docValuesProducer != null) {\n                FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                if (readerFieldInfo != null\n                    && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                }\n              }\n              if (values == null) {\n                values = DocValues.emptySortedSet();\n              }\n              cost += values.cost();\n              subs.add(\n                  new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedSetDocValuesSub> docIDMerger =\n                DocIDMerger.of(subs, mergeState.needsIndexSort);\n\n            final long finalCost = cost;\n\n            return new SortedSetDocValues() {\n              private int docID = -1;\n              private SortedSetDocValuesSub currentSub;\n\n              @Override\n              public int docID() {\n                return docID;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                currentSub = docIDMerger.next();\n                if (currentSub == null) {\n                  docID = NO_MORE_DOCS;\n                } else {\n                  docID = currentSub.mappedDocID;\n                }\n\n                return docID;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public boolean advanceExact(int target) throws IOException {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long nextOrd() throws IOException {\n                long subOrd = currentSub.values.nextOrd();\n                if (subOrd == NO_MORE_ORDS) {\n                  return NO_MORE_ORDS;\n                }\n                return currentSub.map.get(subOrd);\n              }\n\n              @Override\n              public long cost() {\n                return finalCost;\n              }\n\n              @Override\n              public BytesRef lookupOrd(long ord) throws IOException {\n                int segmentNumber = map.getFirstSegmentNumber(ord);\n                long segmentOrd = map.getFirstSegmentOrd(ord);\n                return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n              }\n\n              @Override\n              public long getValueCount() {\n                return map.getValueCount();\n              }\n\n              @Override\n              public TermsEnum termsEnum() throws IOException {\n                TermsEnum[] subs = new TermsEnum[toMerge.size()];\n                for (int sub = 0; sub < subs.length; ++sub) {\n                  subs[sub] = toMerge.get(sub).termsEnum();\n                }\n                return new MergedTermsEnum(map, subs);\n              }\n            };\n          }\n        });\n  }\n","date":"2021-08-26 05:06:41","endLine":929,"groupId":"105271","id":46,"instanceNumber":2,"isCurCommit":1,"methodName":"mergeSortedSetField","params":"(FieldInfomergeFieldInfo@finalMergeStatemergeState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6d/962be51e0ce377c73fe225ddd804f24beda540.src","preCode":"  public void mergeSortedSetField(FieldInfo mergeFieldInfo, final MergeState mergeState)\n      throws IOException {\n\n    List<SortedSetDocValues> toMerge = new ArrayList<>();\n    for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n      SortedSetDocValues values = null;\n      DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n      if (docValuesProducer != null) {\n        FieldInfo fieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n        if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n          values = docValuesProducer.getSortedSet(fieldInfo);\n        }\n      }\n      if (values == null) {\n        values = DocValues.emptySortedSet();\n      }\n      toMerge.add(values);\n    }\n\n    \r\n    TermsEnum liveTerms[] = new TermsEnum[toMerge.size()];\n    long[] weights = new long[liveTerms.length];\n    for (int sub = 0; sub < liveTerms.length; sub++) {\n      SortedSetDocValues dv = toMerge.get(sub);\n      Bits liveDocs = mergeState.liveDocs[sub];\n      if (liveDocs == null) {\n        liveTerms[sub] = dv.termsEnum();\n        weights[sub] = dv.getValueCount();\n      } else {\n        LongBitSet bitset = new LongBitSet(dv.getValueCount());\n        int docID;\n        while ((docID = dv.nextDoc()) != NO_MORE_DOCS) {\n          if (liveDocs.get(docID)) {\n            long ord;\n            while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              bitset.set(ord);\n            }\n          }\n        }\n        liveTerms[sub] = new BitsFilteredTermsEnum(dv.termsEnum(), bitset);\n        weights[sub] = bitset.cardinality();\n      }\n    }\n\n    \r\n    final OrdinalMap map = OrdinalMap.build(null, liveTerms, weights, PackedInts.COMPACT);\n\n    \r\n    addSortedSetField(\n        mergeFieldInfo,\n        new EmptyDocValuesProducer() {\n          @Override\n          public SortedSetDocValues getSortedSet(FieldInfo fieldInfo) throws IOException {\n            if (fieldInfo != mergeFieldInfo) {\n              throw new IllegalArgumentException(\"wrong FieldInfo\");\n            }\n\n            \r\n            List<SortedSetDocValuesSub> subs = new ArrayList<>();\n\n            long cost = 0;\n\n            for (int i = 0; i < mergeState.docValuesProducers.length; i++) {\n              SortedSetDocValues values = null;\n              DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n              if (docValuesProducer != null) {\n                FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                if (readerFieldInfo != null\n                    && readerFieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n                  values = docValuesProducer.getSortedSet(readerFieldInfo);\n                }\n              }\n              if (values == null) {\n                values = DocValues.emptySortedSet();\n              }\n              cost += values.cost();\n              subs.add(\n                  new SortedSetDocValuesSub(mergeState.docMaps[i], values, map.getGlobalOrds(i)));\n            }\n\n            final DocIDMerger<SortedSetDocValuesSub> docIDMerger =\n                DocIDMerger.of(subs, mergeState.needsIndexSort);\n\n            final long finalCost = cost;\n\n            return new SortedSetDocValues() {\n              private int docID = -1;\n              private SortedSetDocValuesSub currentSub;\n\n              @Override\n              public int docID() {\n                return docID;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                currentSub = docIDMerger.next();\n                if (currentSub == null) {\n                  docID = NO_MORE_DOCS;\n                } else {\n                  docID = currentSub.mappedDocID;\n                }\n\n                return docID;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public boolean advanceExact(int target) throws IOException {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long nextOrd() throws IOException {\n                long subOrd = currentSub.values.nextOrd();\n                if (subOrd == NO_MORE_ORDS) {\n                  return NO_MORE_ORDS;\n                }\n                return currentSub.map.get(subOrd);\n              }\n\n              @Override\n              public long cost() {\n                return finalCost;\n              }\n\n              @Override\n              public BytesRef lookupOrd(long ord) throws IOException {\n                int segmentNumber = map.getFirstSegmentNumber(ord);\n                long segmentOrd = map.getFirstSegmentOrd(ord);\n                return toMerge.get(segmentNumber).lookupOrd(segmentOrd);\n              }\n\n              @Override\n              public long getValueCount() {\n                return map.getValueCount();\n              }\n\n              @Override\n              public TermsEnum termsEnum() throws IOException {\n                TermsEnum[] subs = new TermsEnum[toMerge.size()];\n                for (int sub = 0; sub < subs.length; ++sub) {\n                  subs[sub] = toMerge.get(sub).termsEnum();\n                }\n                return new MergedTermsEnum(map, subs);\n              }\n            };\n          }\n        });\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":776,"status":"M"}],"commitId":"8ac26737913d0c1555019e93bc6bf7db1ab9047e","commitMessage":"@@@LUCENE-10003: No C style array declaration (#206)\n\nMost cases of C-style array declarations have been switched.  The Google Java Format.  that which we adhere to.  disallows C-style array declarations: https://google.github.io/styleguide/javaguide.html#s4.8.3-arrays\nSome cases (esp. Snowball) can't be updated.","date":"2021-08-26 05:06:41","modifiedFileCount":"326","status":"M","submitter":"David Smiley"}]
