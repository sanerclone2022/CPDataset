[{"authorTime":"2020-02-21 18:26:30","codes":[{"authorDate":"2020-01-22 08:27:19","commitOrder":5,"curCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    double[] lats = new double[2*numPoints];\n    double[] lons = new double[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      lats[2*id] = quantizeLat(nextLatitude());\n      lons[2*id] = quantizeLon(nextLongitude());\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);\n      lats[2*id+1] = quantizeLat(nextLatitude());\n      lons[2*id+1] = quantizeLon(nextLongitude());\n      addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  lat=\" + lats[2*id] + \" lon=\" + lons[2*id]);\n        System.out.println(\"  lat=\" + lats[2*id+1] + \" lon=\" + lons[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      Rectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<lats.length/2;docID++) {\n        double latDoc1 = lats[2*docID];\n        double lonDoc1 = lons[2*docID];\n        double latDoc2 = lats[2*docID+1];\n        double lonDoc2 = lons[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, latDoc1, lonDoc1);\n        boolean result2 = rectContainsPoint(rect, latDoc2, lonDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  lat=\" + latDoc1 + \" lon=\" + lonDoc1 + \"\\n  lat=\" + latDoc2 + \" lon=\" + lonDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","date":"2020-01-22 08:27:19","endLine":639,"groupId":"60581","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiValued","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e6/7e2a72323f17fbc4d193f857e7cc7a60e1c525.src","preCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    double[] lats = new double[2*numPoints];\n    double[] lons = new double[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      lats[2*id] = quantizeLat(nextLatitude());\n      lons[2*id] = quantizeLon(nextLongitude());\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);\n      lats[2*id+1] = quantizeLat(nextLatitude());\n      lons[2*id+1] = quantizeLon(nextLongitude());\n      addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  lat=\" + lats[2*id] + \" lon=\" + lons[2*id]);\n        System.out.println(\"  lat=\" + lats[2*id+1] + \" lon=\" + lons[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      Rectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<lats.length/2;docID++) {\n        double latDoc1 = lats[2*docID];\n        double lonDoc1 = lons[2*docID];\n        double latDoc2 = lats[2*docID+1];\n        double lonDoc2 = lons[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, latDoc1, lonDoc1);\n        boolean result2 = rectContainsPoint(rect, latDoc2, lonDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  lat=\" + latDoc1 + \" lon=\" + lonDoc1 + \"\\n  lat=\" + latDoc2 + \" lon=\" + lonDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":534,"status":"NB"},{"authorDate":"2020-02-21 18:26:30","commitOrder":5,"curCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    float[] xs = new float[2*numPoints];\n    float[] ys = new float[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      xs[2*id] = nextX();\n      ys[2*id] = nextY();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, xs[2*id], ys[2*id]);\n      xs[2*id+1] = nextX();\n      ys[2*id+1] = nextY();\n      addPointToDoc(FIELD_NAME, doc, xs[2*id+1], ys[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  x=\" + xs[2*id] + \" y=\" + ys[2*id]);\n        System.out.println(\"  x=\" + xs[2*id+1] + \" y=\" + ys[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      XYRectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minX, rect.maxX, rect.minY, rect.maxY);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<ys.length/2;docID++) {\n        float yDoc1 = ys[2*docID];\n        float xDoc1 = xs[2*docID];\n        float yDoc2 = ys[2*docID+1];\n        float xDoc2 = xs[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, xDoc1, yDoc1);\n        boolean result2 = rectContainsPoint(rect, xDoc2, yDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  x=\" + xDoc1 + \" y=\" + yDoc1 + \"\\n  x=\" + xDoc2 + \" y\" + yDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","date":"2020-02-21 18:26:30","endLine":598,"groupId":"29082","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiValued","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a5/97ca5a04259ed2c202d8d7a82f8a0a5e37848e.src","preCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    float[] xs = new float[2*numPoints];\n    float[] ys = new float[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      xs[2*id] = nextX();\n      ys[2*id] = nextY();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, xs[2*id], ys[2*id]);\n      xs[2*id+1] = nextX();\n      ys[2*id+1] = nextY();\n      addPointToDoc(FIELD_NAME, doc, xs[2*id+1], ys[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  x=\" + xs[2*id] + \" y=\" + ys[2*id]);\n        System.out.println(\"  x=\" + xs[2*id+1] + \" y=\" + ys[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      XYRectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minX, rect.maxX, rect.minY, rect.maxY);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<ys.length/2;docID++) {\n        float yDoc1 = ys[2*docID];\n        float xDoc1 = xs[2*docID];\n        float yDoc2 = ys[2*docID+1];\n        float xDoc2 = xs[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, xDoc1, yDoc1);\n        boolean result2 = rectContainsPoint(rect, xDoc2, yDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  x=\" + xDoc1 + \" y=\" + yDoc1 + \"\\n  x=\" + xDoc2 + \" y\" + yDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseXYPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":493,"status":"B"}],"commitId":"88dd1c3f3d4eb37c522b9b00a5ccce979e6efad6","commitMessage":"@@@LUCENE-9238: Add new XYPointField.  queries and sorting capabilities (#1272)\n\nNew XYPointField field and Queries for indexing.  searching and sorting cartesian points.","date":"2020-02-21 18:26:30","modifiedFileCount":"0","status":"M","submitter":"Ignacio Vera"},{"authorTime":"2020-02-21 18:26:30","codes":[{"authorDate":"2020-11-03 15:51:28","commitOrder":6,"curCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    double[] lats = new double[2*numPoints];\n    double[] lons = new double[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      lats[2*id] = quantizeLat(nextLatitude());\n      lons[2*id] = quantizeLon(nextLongitude());\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);\n      lats[2*id+1] = quantizeLat(nextLatitude());\n      lons[2*id+1] = quantizeLon(nextLongitude());\n      addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  lat=\" + lats[2*id] + \" lon=\" + lons[2*id]);\n        System.out.println(\"  lat=\" + lats[2*id+1] + \" lon=\" + lons[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      Rectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      final FixedBitSet hits = searchIndex(s, query, r.maxDoc());\n      \n      boolean fail = false;\n\n      for(int docID=0;docID<lats.length/2;docID++) {\n        double latDoc1 = lats[2*docID];\n        double lonDoc1 = lons[2*docID];\n        double latDoc2 = lats[2*docID+1];\n        double lonDoc2 = lons[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, latDoc1, lonDoc1);\n        boolean result2 = rectContainsPoint(rect, latDoc2, lonDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  lat=\" + latDoc1 + \" lon=\" + lonDoc1 + \"\\n  lat=\" + latDoc2 + \" lon=\" + lonDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","date":"2020-11-03 15:51:28","endLine":637,"groupId":"50329","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiValued","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a4/b47f0cc053a381ea0bbf7c2f040b9eb6690f8a.src","preCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    double[] lats = new double[2*numPoints];\n    double[] lons = new double[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      lats[2*id] = quantizeLat(nextLatitude());\n      lons[2*id] = quantizeLon(nextLongitude());\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);\n      lats[2*id+1] = quantizeLat(nextLatitude());\n      lons[2*id+1] = quantizeLon(nextLongitude());\n      addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  lat=\" + lats[2*id] + \" lon=\" + lons[2*id]);\n        System.out.println(\"  lat=\" + lats[2*id+1] + \" lon=\" + lons[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      Rectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<lats.length/2;docID++) {\n        double latDoc1 = lats[2*docID];\n        double lonDoc1 = lons[2*docID];\n        double latDoc2 = lats[2*docID+1];\n        double lonDoc2 = lons[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, latDoc1, lonDoc1);\n        boolean result2 = rectContainsPoint(rect, latDoc2, lonDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  lat=\" + latDoc1 + \" lon=\" + lonDoc1 + \"\\n  lat=\" + latDoc2 + \" lon=\" + lonDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":551,"status":"M"},{"authorDate":"2020-02-21 18:26:30","commitOrder":6,"curCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    float[] xs = new float[2*numPoints];\n    float[] ys = new float[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      xs[2*id] = nextX();\n      ys[2*id] = nextY();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, xs[2*id], ys[2*id]);\n      xs[2*id+1] = nextX();\n      ys[2*id+1] = nextY();\n      addPointToDoc(FIELD_NAME, doc, xs[2*id+1], ys[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  x=\" + xs[2*id] + \" y=\" + ys[2*id]);\n        System.out.println(\"  x=\" + xs[2*id+1] + \" y=\" + ys[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      XYRectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minX, rect.maxX, rect.minY, rect.maxY);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<ys.length/2;docID++) {\n        float yDoc1 = ys[2*docID];\n        float xDoc1 = xs[2*docID];\n        float yDoc2 = ys[2*docID+1];\n        float xDoc2 = xs[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, xDoc1, yDoc1);\n        boolean result2 = rectContainsPoint(rect, xDoc2, yDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  x=\" + xDoc1 + \" y=\" + yDoc1 + \"\\n  x=\" + xDoc2 + \" y\" + yDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","date":"2020-02-21 18:26:30","endLine":598,"groupId":"29082","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiValued","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a5/97ca5a04259ed2c202d8d7a82f8a0a5e37848e.src","preCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    float[] xs = new float[2*numPoints];\n    float[] ys = new float[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      xs[2*id] = nextX();\n      ys[2*id] = nextY();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, xs[2*id], ys[2*id]);\n      xs[2*id+1] = nextX();\n      ys[2*id+1] = nextY();\n      addPointToDoc(FIELD_NAME, doc, xs[2*id+1], ys[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  x=\" + xs[2*id] + \" y=\" + ys[2*id]);\n        System.out.println(\"  x=\" + xs[2*id+1] + \" y=\" + ys[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      XYRectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minX, rect.maxX, rect.minY, rect.maxY);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<ys.length/2;docID++) {\n        float yDoc1 = ys[2*docID];\n        float xDoc1 = xs[2*docID];\n        float yDoc2 = ys[2*docID+1];\n        float xDoc2 = xs[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, xDoc1, yDoc1);\n        boolean result2 = rectContainsPoint(rect, xDoc2, yDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  x=\" + xDoc1 + \" y=\" + yDoc1 + \"\\n  x=\" + xDoc2 + \" y\" + yDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseXYPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":493,"status":"N"}],"commitId":"8bfbed8d4cd476a008ee85310b1f6535920b4622","commitMessage":"@@@LUCENE-9552: Adds a LatLonPoint query that accepts an array of LatLonGeometries (#1940)\n\n","date":"2020-11-03 15:51:28","modifiedFileCount":"15","status":"M","submitter":"Ignacio Vera"},{"authorTime":"2020-11-03 16:21:03","codes":[{"authorDate":"2020-11-03 15:51:28","commitOrder":7,"curCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    double[] lats = new double[2*numPoints];\n    double[] lons = new double[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      lats[2*id] = quantizeLat(nextLatitude());\n      lons[2*id] = quantizeLon(nextLongitude());\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);\n      lats[2*id+1] = quantizeLat(nextLatitude());\n      lons[2*id+1] = quantizeLon(nextLongitude());\n      addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  lat=\" + lats[2*id] + \" lon=\" + lons[2*id]);\n        System.out.println(\"  lat=\" + lats[2*id+1] + \" lon=\" + lons[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      Rectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      final FixedBitSet hits = searchIndex(s, query, r.maxDoc());\n      \n      boolean fail = false;\n\n      for(int docID=0;docID<lats.length/2;docID++) {\n        double latDoc1 = lats[2*docID];\n        double lonDoc1 = lons[2*docID];\n        double latDoc2 = lats[2*docID+1];\n        double lonDoc2 = lons[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, latDoc1, lonDoc1);\n        boolean result2 = rectContainsPoint(rect, latDoc2, lonDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  lat=\" + latDoc1 + \" lon=\" + lonDoc1 + \"\\n  lat=\" + latDoc2 + \" lon=\" + lonDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","date":"2020-11-03 15:51:28","endLine":637,"groupId":"103334","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiValued","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a4/b47f0cc053a381ea0bbf7c2f040b9eb6690f8a.src","preCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    double[] lats = new double[2*numPoints];\n    double[] lons = new double[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      lats[2*id] = quantizeLat(nextLatitude());\n      lons[2*id] = quantizeLon(nextLongitude());\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);\n      lats[2*id+1] = quantizeLat(nextLatitude());\n      lons[2*id+1] = quantizeLon(nextLongitude());\n      addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  lat=\" + lats[2*id] + \" lon=\" + lons[2*id]);\n        System.out.println(\"  lat=\" + lats[2*id+1] + \" lon=\" + lons[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      Rectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      final FixedBitSet hits = searchIndex(s, query, r.maxDoc());\n      \n      boolean fail = false;\n\n      for(int docID=0;docID<lats.length/2;docID++) {\n        double latDoc1 = lats[2*docID];\n        double lonDoc1 = lons[2*docID];\n        double latDoc2 = lats[2*docID+1];\n        double lonDoc2 = lons[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, latDoc1, lonDoc1);\n        boolean result2 = rectContainsPoint(rect, latDoc2, lonDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  lat=\" + latDoc1 + \" lon=\" + lonDoc1 + \"\\n  lat=\" + latDoc2 + \" lon=\" + lonDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":551,"status":"N"},{"authorDate":"2020-11-03 16:21:03","commitOrder":7,"curCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    float[] xs = new float[2*numPoints];\n    float[] ys = new float[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      xs[2*id] = nextX();\n      ys[2*id] = nextY();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, xs[2*id], ys[2*id]);\n      xs[2*id+1] = nextX();\n      ys[2*id+1] = nextY();\n      addPointToDoc(FIELD_NAME, doc, xs[2*id+1], ys[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  x=\" + xs[2*id] + \" y=\" + ys[2*id]);\n        System.out.println(\"  x=\" + xs[2*id+1] + \" y=\" + ys[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      XYRectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minX, rect.maxX, rect.minY, rect.maxY);\n\n      final FixedBitSet hits = searchIndex(s, query, r.maxDoc());\n\n      boolean fail = false;\n\n      for(int docID=0;docID<ys.length/2;docID++) {\n        float yDoc1 = ys[2*docID];\n        float xDoc1 = xs[2*docID];\n        float yDoc2 = ys[2*docID+1];\n        float xDoc2 = xs[2*docID+1];\n\n        boolean result1 = rectContainsPoint(rect, xDoc1, yDoc1);\n        boolean result2 = rectContainsPoint(rect, xDoc2, yDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  x=\" + xDoc1 + \" y=\" + yDoc1 + \"\\n  x=\" + xDoc2 + \" y\" + yDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","date":"2020-11-03 16:21:03","endLine":590,"groupId":"103334","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiValued","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/e3/1134ca7ea883b9044d90baec01e60519d274e6.src","preCode":"  public void testMultiValued() throws Exception {\n    int numPoints = atLeast(1000);\n    \r\n    float[] xs = new float[2*numPoints];\n    float[] ys = new float[2*numPoints];\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    \r\n    iwc.setMergePolicy(newLogMergePolicy());\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int id=0;id<numPoints;id++) {\n      Document doc = new Document();\n      xs[2*id] = nextX();\n      ys[2*id] = nextY();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.YES));\n      addPointToDoc(FIELD_NAME, doc, xs[2*id], ys[2*id]);\n      xs[2*id+1] = nextX();\n      ys[2*id+1] = nextY();\n      addPointToDoc(FIELD_NAME, doc, xs[2*id+1], ys[2*id+1]);\n\n      if (VERBOSE) {\n        System.out.println(\"id=\" + id);\n        System.out.println(\"  x=\" + xs[2*id] + \" y=\" + ys[2*id]);\n        System.out.println(\"  x=\" + xs[2*id+1] + \" y=\" + ys[2*id+1]);\n      }\n      w.addDocument(doc);\n    }\n\n    \r\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n    for (int iter=0;iter<iters;iter++) {\n      XYRectangle rect = nextBox();\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" rect=\" + rect);\n      }\n\n      Query query = newRectQuery(FIELD_NAME, rect.minX, rect.maxX, rect.minY, rect.maxY);\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n\n      for(int docID=0;docID<ys.length/2;docID++) {\n        float yDoc1 = ys[2*docID];\n        float xDoc1 = xs[2*docID];\n        float yDoc2 = ys[2*docID+1];\n        float xDoc2 = xs[2*docID+1];\n        \n        boolean result1 = rectContainsPoint(rect, xDoc1, yDoc1);\n        boolean result2 = rectContainsPoint(rect, xDoc2, yDoc2);\n\n        boolean expected = result1 || result2;\n\n        if (hits.get(docID) != expected) {\n          String id = s.doc(docID).get(\"id\");\n          if (expected) {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should match but did not\");\n          } else {\n            System.out.println(\"TEST: id=\" + id + \" docID=\" + docID + \" should not match but did\");\n          }\n          System.out.println(\"  rect=\" + rect);\n          System.out.println(\"  x=\" + xDoc1 + \" y=\" + yDoc1 + \"\\n  x=\" + xDoc2 + \" y\" + yDoc2);\n          System.out.println(\"  result1=\" + result1 + \" result2=\" + result2);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n    r.close();\n    dir.close();\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseXYPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":504,"status":"M"}],"commitId":"5c0273791865109be8495ecec385aeedf043bc89","commitMessage":"@@@ LUCENE-9553: Adds a XYPoint query that accepts an array of XYGeometries (#1939)\n\n","date":"2020-11-03 16:21:03","modifiedFileCount":"5","status":"M","submitter":"Ignacio Vera"}]
