[{"authorTime":"2013-02-08 04:48:21","codes":[{"authorDate":"2013-02-08 04:48:21","commitOrder":1,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","date":"2013-02-08 04:48:21","endLine":91,"groupId":"30510","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/64/16dcc5eef364606c30992a6aec2a8dc75ce904.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"B"},{"authorDate":"2013-02-08 04:48:21","commitOrder":1,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = BinaryDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n","date":"2013-02-08 04:48:21","endLine":180,"groupId":"34179","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/64/16dcc5eef364606c30992a6aec2a8dc75ce904.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = BinaryDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"B"}],"commitId":"a181dc07353975b9fbf8721bf24cc56edf262b96","commitMessage":"@@@LUCENE-4547: DocValues improvements\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1443717 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-02-08 04:48:21","modifiedFileCount":"253","status":"B","submitter":"Robert Muir"},{"authorTime":"2014-04-11 16:54:03","codes":[{"authorDate":"2014-04-11 16:54:03","commitOrder":2,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_NUMERIC;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","date":"2014-04-11 16:54:03","endLine":94,"groupId":"30510","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b0/e459c88bf4a22907a6f670f0b3e147ae37676a.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"},{"authorDate":"2014-04-11 16:54:03","commitOrder":2,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_BINARY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n","date":"2014-04-11 16:54:03","endLine":228,"groupId":"30513","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b0/e459c88bf4a22907a6f670f0b3e147ae37676a.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = BinaryDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"}],"commitId":"b72cd4b7d947590f3e9c29973b97c6e91504fef8","commitMessage":"@@@LUCENE-5573: Move docvalues constants and helper methods to o.a.l.index.DocValues\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1586600 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-04-11 16:54:03","modifiedFileCount":"20","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-06-05 23:54:49","codes":[{"authorDate":"2014-06-05 23:54:49","commitOrder":3,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = DocValues.emptyNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","date":"2014-06-05 23:54:49","endLine":95,"groupId":"30510","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/85/6dde03e5a073706c24e48f58d8733d87ed59bf.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_NUMERIC;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"M"},{"authorDate":"2014-06-05 23:54:49","commitOrder":3,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n","date":"2014-06-05 23:54:49","endLine":229,"groupId":"30513","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/85/6dde03e5a073706c24e48f58d8733d87ed59bf.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_BINARY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"8f267c8560cac15d140c5097dfd6392c4270d3d2","commitMessage":"@@@LUCENE-5703: BinaryDocValues producers don't allocate or copy bytes on each access anymore\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1600688 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-06-05 23:54:49","modifiedFileCount":"75","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-09-24 07:51:55","codes":[{"authorDate":"2014-09-24 07:51:55","commitOrder":4,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = DocValues.emptyNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","date":"2014-09-24 07:51:55","endLine":101,"groupId":"30510","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/45/321051652326d5d8afbaf35d6dc7c1c460098f.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = DocValues.emptyNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2014-09-24 07:51:55","commitOrder":4,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n","date":"2014-09-24 07:51:55","endLine":235,"groupId":"30513","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/45/321051652326d5d8afbaf35d6dc7c1c460098f.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"}],"commitId":"85bf3181737a34e2d357f0c926d7ae8d07b9ae39","commitMessage":"@@@LUCENE-5569: *AtomicReader/AtomicReaderContext have been renamed to *LeafReader/LeafReaderContext\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1627178 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-24 07:51:55","modifiedFileCount":"459","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2016-10-03 03:18:22","codes":[{"authorDate":"2016-10-03 03:18:22","commitOrder":5,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long longValue() {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-03 03:18:22","endLine":152,"groupId":"2081","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/40/54e90261ba0b1a3b887d4b8ce9856a9692311f.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    boolean anyReal = false;\n    final NumericDocValues[] values = new NumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      NumericDocValues v = context.reader().getNormValues(field);\n      if (v == null) {\n        v = DocValues.emptyNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    assert anyReal;\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, starts);\n        return values[subIndex].get(docID - starts[subIndex]);\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2016-10-03 03:18:22","commitOrder":5,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-03 03:18:22","endLine":361,"groupId":"45544","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/40/54e90261ba0b1a3b887d4b8ce9856a9692311f.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"M"}],"commitId":"3182cd9872af3cb73a1f73e36de68b8d76646e59","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-10-03 03:18:22","modifiedFileCount":"570","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-10-03 03:18:22","codes":[{"authorDate":"2016-10-06 02:18:55","commitOrder":6,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-06 02:18:55","endLine":152,"groupId":"2081","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6e/d257efd6d48c2ab7eb2a5c9b6ebde5c2276115.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long longValue() {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2016-10-03 03:18:22","commitOrder":6,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-03 03:18:22","endLine":361,"groupId":"45544","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/40/54e90261ba0b1a3b887d4b8ce9856a9692311f.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"N"}],"commitId":"001a3ca55b30656e0e42f612d927a7923f5370e9","commitMessage":"@@@LUCENE-7407: speed up iterating norms a bit by having default codec implement the iterator directly\n","date":"2016-10-06 02:18:55","modifiedFileCount":"14","status":"M","submitter":"Mike McCandless"},{"authorTime":"2016-10-07 16:59:11","codes":[{"authorDate":"2016-10-06 02:18:55","commitOrder":7,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-06 02:18:55","endLine":152,"groupId":"2081","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6e/d257efd6d48c2ab7eb2a5c9b6ebde5c2276115.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"N"},{"authorDate":"2016-10-07 16:59:11","commitOrder":7,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-07 16:59:11","endLine":361,"groupId":"45544","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ae/b49c574913320a5626b33f611e8fb32a0a45a7.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"M"}],"commitId":"fb088817eb12df4c76c4369f98629003f1ab307c","commitMessage":"@@@LUCENE-7479: SimpleText should directly implement the new doc values APIs.\n","date":"2016-10-07 16:59:11","modifiedFileCount":"39","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-10-24 19:15:53","codes":[{"authorDate":"2016-10-24 19:15:53","commitOrder":8,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-24 19:15:53","endLine":173,"groupId":"2081","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/51/d684d3a270c07b1b71dd33dcbbd318b43c8cdb.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2016-10-24 19:15:53","commitOrder":8,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-24 19:15:53","endLine":423,"groupId":"45544","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/51/d684d3a270c07b1b71dd33dcbbd318b43c8cdb.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"M"}],"commitId":"c9de11d02464a146c6ab2aa561622876d081a070","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n","date":"2016-10-24 19:15:53","modifiedFileCount":"58","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-10-31 17:34:48","codes":[{"authorDate":"2016-10-31 17:34:48","commitOrder":9,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-31 17:54:54","endLine":173,"groupId":"2081","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/39/70e0a6524e313cce393488fbda4401c6bc6d18.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2016-10-31 17:34:48","commitOrder":9,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-31 17:54:54","endLine":423,"groupId":"45544","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/39/70e0a6524e313cce393488fbda4401c6bc6d18.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"M"}],"commitId":"325b74e0e3e9c9ce265d8d7844f01209394b920a","commitMessage":"@@@LUCENE-7529: Fix argument checks of MultiDocValues' advanceExact impls.\n","date":"2016-10-31 17:54:54","modifiedFileCount":"2","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-10-31 17:34:48","codes":[{"authorDate":"2018-10-19 07:49:13","commitOrder":10,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = FieldInfos.getMergedFieldInfos(r).fieldInfo(field); \r\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2018-10-19 07:49:14","endLine":162,"groupId":"2081","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b9/ee2f58bb7359968b9d9d20fe9539c63a74c956.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"},{"authorDate":"2016-10-31 17:34:48","commitOrder":10,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2016-10-31 17:54:54","endLine":423,"groupId":"45544","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/39/70e0a6524e313cce393488fbda4401c6bc6d18.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"N"}],"commitId":"fd9164801e703b278922dae6cc3c53e0578fa1d6","commitMessage":"@@@LUCENE-7875: Moved MultiFields static methods to MultiTerms.  FieldInfos and MultiBits.\nMultiBits is now public and has getLiveDocs.\n","date":"2018-10-19 07:49:14","modifiedFileCount":"107","status":"M","submitter":"David Smiley"},{"authorTime":"2021-08-24 01:01:23","codes":[{"authorDate":"2021-08-24 01:01:23","commitOrder":11,"curCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field)\n      throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = FieldInfos.getMergedFieldInfos(r).fieldInfo(field); \r\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n\n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex + 1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex + 1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2021-08-24 01:01:23","endLine":166,"groupId":"105152","id":21,"instanceNumber":1,"isCurCommit":1,"methodName":"getNormValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a5/9814259976f9e76d81575dfed13116187e096c.src","preCode":"  public static NumericDocValues getNormValues(final IndexReader r, final String field)\n      throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getNormValues(field);\n    }\n    FieldInfo fi = FieldInfos.getMergedFieldInfos(r).fieldInfo(field); \r\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n\n    return new NumericDocValues() {\n      private int nextLeaf;\n      private NumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getNormValues(field);\n            nextLeaf++;\n            continue;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n\n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          if (currentValues == null) {\n            return nextDoc();\n          }\n          nextLeaf = readerIndex + 1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getNormValues(field);\n          nextLeaf = readerIndex + 1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long longValue() throws IOException {\n        return currentValues.longValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2021-08-24 01:01:23","commitOrder":11,"curCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field)\n      throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for (LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n\n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex + 1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex + 1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","date":"2021-08-24 01:01:23","endLine":432,"groupId":"105152","id":22,"instanceNumber":2,"isCurCommit":1,"methodName":"getBinaryValues","params":"(finalIndexReaderr@finalStringfield)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a5/9814259976f9e76d81575dfed13116187e096c.src","preCode":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field)\n      throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for (LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n\n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex + 1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\n              \"can only advance beyond current document: on docID=\"\n                  + docID\n                  + \" but targetDocID=\"\n                  + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex + 1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        \r\n        return 0;\n      }\n    };\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":302,"status":"M"}],"commitId":"46fa09d265b7ad7945bf06d13c5ffa4ee99407a6","commitMessage":"@@@LUCENE-5309: Optimize facet counting for single-valued SSDV / StringValueFacetCounts (#255)\n\n","date":"2021-08-24 01:01:23","modifiedFileCount":"6","status":"M","submitter":"Greg Miller"}]
