[{"authorTime":"2018-04-04 19:44:17","codes":[{"authorDate":"2018-04-04 19:44:17","commitOrder":1,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-04 19:45:14","endLine":94,"groupId":"19485","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c4/28a4b2599bde9247ed278fd915d0bd21537907.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"B"},{"authorDate":"2018-04-04 19:44:17","commitOrder":1,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"test\", 3, false, Codec.getDefault(),\n        Collections.emptyMap(), StringHelper.randomId(), new HashMap<>(), null);\n    PendingSoftDeletes deletes = newPendingDeletes(segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    deletes.onDocValuesUpdate(fieldInfo, updates);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-04 19:45:14","endLine":176,"groupId":"20364","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c4/28a4b2599bde9247ed278fd915d0bd21537907.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"test\", 3, false, Codec.getDefault(),\n        Collections.emptyMap(), StringHelper.randomId(), new HashMap<>(), null);\n    PendingSoftDeletes deletes = newPendingDeletes(segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    deletes.onDocValuesUpdate(fieldInfo, updates);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"B"}],"commitId":"ecc17f9023309ca2c46eaf65fd031e4af0ef5a25","commitMessage":"@@@LUCENE-8233: Add support for soft deletes to IndexWriter \n\nThis change adds support for soft deletes as a fully supported feature\nby the index writer. Soft deletes are accounted for inside the index\nwriter and therefor also by merge policies.\n\nThis change also adds a SoftDeletesRetentionMergePolicy that allows\nusers to selectively carry over soft_deleted document across merges\nfor renention policies. The merge policy selects documents that should\nbe kept around in the merged segment based on a user provided query.","date":"2018-04-04 19:45:14","modifiedFileCount":"24","status":"B","submitter":"Simon Willnauer"},{"authorTime":"2018-04-12 19:09:30","codes":[{"authorDate":"2018-04-04 19:44:17","commitOrder":2,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-04 19:45:14","endLine":94,"groupId":"19485","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c4/28a4b2599bde9247ed278fd915d0bd21537907.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"N"},{"authorDate":"2018-04-12 19:09:30","commitOrder":2,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    deletes.onDocValuesUpdate(fieldInfo, updates);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-12 19:09:30","endLine":187,"groupId":"20364","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/25/5ff9ec49eab9dfa4f792313217ba199956d4ef.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"test\", 3, false, Codec.getDefault(),\n        Collections.emptyMap(), StringHelper.randomId(), new HashMap<>(), null);\n    PendingSoftDeletes deletes = newPendingDeletes(segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    deletes.onDocValuesUpdate(fieldInfo, updates);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"}],"commitId":"7a4937106c0a551a958a726c6c6fbf9145c4637d","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2018-04-12 19:09:30","modifiedFileCount":"7","status":"M","submitter":"Karl Wright"},{"authorTime":"2018-04-16 22:16:43","codes":[{"authorDate":"2018-04-16 22:16:43","commitOrder":3,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-16 22:17:06","endLine":94,"groupId":"19485","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ea/c438826d12a468f21733b47b64aac211953bdf.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2018-04-16 22:16:43","commitOrder":3,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(update.field, update.iterator());\n    }\n    deletes.onDocValuesUpdate(fieldInfo);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-16 22:17:06","endLine":196,"groupId":"4443","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ea/c438826d12a468f21733b47b64aac211953bdf.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()); \r\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    deletes.onDocValuesUpdate(fieldInfo, updates);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"c70cceaee56cecf35875cd2b5c8d5700f2b3cedb","commitMessage":"@@@LUCENE-8253: Account for soft-deletes before they are flushed to disk\n\nInside the IndexWriter buffers are only written to disk if it's needed\nor \"worth it\" which doesn't guarantee soft deletes to be accounted\nin time. This is not necessarily a problem since they are eventually\ncollected and segments that have soft-deletes will me merged eventually\nbut for tests and on par behavior compared to hard deletes this behavior\nis tricky.\nThis change cuts over to accounting in-place just like hard-deletes. This\nresults in accurate delete numbers for soft deletes at any give point in time\nonce the reader is loaded or a pending soft delete occurs.\n\nThis change also fixes an issue where all updates to a DV field are allowed\nevent if the field is unknown. Now this only works if the field is equal\nto the soft deletes field. This behavior was never released.\n","date":"2018-04-16 22:17:06","modifiedFileCount":"9","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-04-18 23:45:55","codes":[{"authorDate":"2018-04-16 22:16:43","commitOrder":4,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-16 22:17:06","endLine":94,"groupId":"19485","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ea/c438826d12a468f21733b47b64aac211953bdf.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"N"},{"authorDate":"2018-04-18 23:45:55","commitOrder":4,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(update.field, update.iterator());\n    }\n    deletes.onDocValuesUpdate(fieldInfo);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-18 23:46:45","endLine":199,"groupId":"4443","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/98/78b16f4d9dad1bd49013843ef666ebf6328eb5.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(update.field, update.iterator());\n    }\n    deletes.onDocValuesUpdate(fieldInfo);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"dd39128eaeeaae3ab607d27b1e6707409ca436e7","commitMessage":"@@@[TEST] Ensure IW doesn't autoflush since test relies on it producing a single segment\n","date":"2018-04-18 23:46:45","modifiedFileCount":"1","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-02 22:17:15","codes":[{"authorDate":"2018-04-16 22:16:43","commitOrder":5,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-04-16 22:17:06","endLine":94,"groupId":"19485","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ea/c438826d12a468f21733b47b64aac211953bdf.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"N"},{"authorDate":"2018-05-02 22:17:15","commitOrder":5,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-03 19:38:35","endLine":197,"groupId":"34377","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/df0be64dc2d0487c509ae188401569091a7f1c.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(update.field, update.iterator());\n    }\n    deletes.onDocValuesUpdate(fieldInfo);\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"}],"commitId":"591fc6627acffdc75ce88feb8a912b3225b47f9d","commitMessage":"@@@LUCENE-8290: Keep soft deletes in sync with on-disk DocValues\n\nToday we pass on the doc values update to the PendingDeletes\nwhen it's applied. This might cause issues with a rentention policy\nmerge policy that will see a deleted document but not it's value on\ndisk.\nThis change moves back the PendingDeletes callback to flush time\nin order to be consistent with what is actually updated on disk.\n\nThis change also makes sure we write values to disk on flush that\nare in the reader pool as well as extra best effort checks to drop\nfully deleted segments on flush.  commit and getReader.\n","date":"2018-05-03 19:38:35","modifiedFileCount":"6","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-02 22:17:15","codes":[{"authorDate":"2018-05-03 15:29:12","commitOrder":6,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-04 18:16:03","endLine":100,"groupId":"19485","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ae/b5819c72f9d1df54be7aec7725487217aa41f9.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2018-05-02 22:17:15","commitOrder":6,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-03 19:38:35","endLine":197,"groupId":"34377","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/df0be64dc2d0487c509ae188401569091a7f1c.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"N"}],"commitId":"3a6f5313d6b4a23dea2030cb5d63ad522536f501","commitMessage":"@@@LUCENE-8293: Ensure only hard deletes are carried over in a merge\n\nToday we carry over hard deletes based on the SegmentReaders liveDocs.\nThis is not correct if soft-deletes are used especially with rentention\npolicies. If a soft delete is added while a segment is merged the document\nmight end up hard deleted in the target segment. This isn't necessarily a\ncorrectness issue but causes unnecessary writes of hard-deletes. The biggest\nissue here is that we assert that previously deleted documents are still deleted\nin the live-docs we apply and that might be violated by the retention policy.\n","date":"2018-05-04 18:16:03","modifiedFileCount":"7","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-09 21:12:23","codes":[{"authorDate":"2018-05-09 21:12:23","commitOrder":7,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-09 21:40:14","endLine":99,"groupId":"19485","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/90/3f84726f6f13ec322587a263c925566f810afc.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.liveDocsShared();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2018-05-09 21:12:23","commitOrder":7,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-09 21:40:14","endLine":200,"groupId":"34377","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/90/3f84726f6f13ec322587a263c925566f810afc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    deletes.liveDocsShared();\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"7873cf845e1d513026b6836769b7cbd4d237c2aa","commitMessage":"@@@LUCENE-8296: PendingDeletes may no longer write to live docs after they are shared.\n","date":"2018-05-09 21:40:14","modifiedFileCount":"5","status":"M","submitter":"Adrien Grand"},{"authorTime":"2018-05-07 17:52:51","codes":[{"authorDate":"2018-05-09 21:12:23","commitOrder":8,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-09 21:40:14","endLine":99,"groupId":"19485","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/90/3f84726f6f13ec322587a263c925566f810afc.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"N"},{"authorDate":"2018-05-07 17:52:51","commitOrder":8,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-10 00:57:57","endLine":200,"groupId":"36543","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/82/7c6e34d2c3751d598374ab59ab1e931381b215.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"a3c86373e47ddd43368c5800eea63b50d2064759","commitMessage":"@@@LUCENE-8298: Allow DocValues updates to reset a value\n\nToday once a document has a value in a certain DV field this values\ncan only be changed but not removed. While resetting / removing a value\nfrom a field is certainly a corner case it can be used to undelete a\nsoft-deleted document unless it's merged away.\nThis allows to rollback changes without rolling back to another commitpoint\nor trashing all uncommitted changes. In certain cenarios it can be used to\n\"repair\" history of documents in distributed systems.\n","date":"2018-05-10 00:57:57","modifiedFileCount":"17","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-07 17:52:51","codes":[{"authorDate":"2018-05-14 21:29:42","commitOrder":9,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-14 21:30:16","endLine":103,"groupId":"19485","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"_soft_deletes\"));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2018-05-07 17:52:51","commitOrder":9,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-10 00:57:57","endLine":200,"groupId":"36543","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/82/7c6e34d2c3751d598374ab59ab1e931381b215.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"N"}],"commitId":"02849fb707626cf4312f59324fd894be117787c1","commitMessage":"@@@Fix TestPendingSoftDeletes.\n","date":"2018-05-14 21:30:16","modifiedFileCount":"1","status":"M","submitter":"Adrien Grand"},{"authorTime":"2018-06-02 18:30:02","codes":[{"authorDate":"2018-05-14 21:29:42","commitOrder":10,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-14 21:30:16","endLine":103,"groupId":"19485","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"N"},{"authorDate":"2018-06-02 18:30:02","commitOrder":10,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-02 19:14:53","endLine":204,"groupId":"62762","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/30/47364781e1d6c788da0e6daa63f9ba31f545dc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"a2d927667418d17a1f5f31a193092d5b04a4219e","commitMessage":"@@@LUCENE-8335: Enforce soft-deletes field up-front.\n\nSoft deletes field must be marked as such once it's introduced\nand can't be changed after the fact.\n","date":"2018-06-02 19:14:53","modifiedFileCount":"19","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-06-02 19:47:24","codes":[{"authorDate":"2018-05-14 21:29:42","commitOrder":11,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-14 21:30:16","endLine":103,"groupId":"19485","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"N"},{"authorDate":"2018-06-02 19:47:24","commitOrder":11,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-02 19:47:24","endLine":204,"groupId":"36543","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"3dc4fa199c175ed6351f66bac5c23c73b4e3f89a","commitMessage":"@@@Revert \"LUCENE-8335: Enforce soft-deletes field up-front.\"\n\nThis reverts commit a2d927667418d17a1f5f31a193092d5b04a4219e.\n","date":"2018-06-02 19:47:24","modifiedFileCount":"19","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-06-04 14:23:31","codes":[{"authorDate":"2018-05-14 21:29:42","commitOrder":12,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-14 21:30:16","endLine":103,"groupId":"19485","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"N"},{"authorDate":"2018-06-04 14:23:31","commitOrder":12,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-04 14:28:38","endLine":204,"groupId":"62762","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/30/47364781e1d6c788da0e6daa63f9ba31f545dc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"}],"commitId":"e7a0a12926c399758a4021715a7419e22e59dab6","commitMessage":"@@@LUCENE-8335: Enforce soft-deletes field up-front\n\nSoft deletes field must be marked as such once it's introduced\nand can't be changed after the fact.\n\nCo-authored-by: Nhat Nguyen <nhat.nguyen@elastic.co>\n","date":"2018-06-04 14:28:38","modifiedFileCount":"24","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-27 03:35:46","codes":[{"authorDate":"2018-05-27 03:35:46","commitOrder":13,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-04 21:05:12","endLine":145,"groupId":"19485","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b6/4385529766bec26e461c918f04c7123c28e95b.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(1, pendingSoftDeletes.numPendingDeletes());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"},{"authorDate":"2018-05-27 03:35:46","commitOrder":13,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-04 21:05:12","endLine":250,"groupId":"62762","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b6/4385529766bec26e461c918f04c7123c28e95b.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"}],"commitId":"fe83838ec3768f25964a04510cd10772cf034d34","commitMessage":"@@@LUCENE-8341: Record soft deletes in SegmentCommitInfo\n\nThis change add the number of documents that are soft deletes but\nnot hard deleted to the segment commit info. This is the last step\ntowards making soft deletes as powerful as hard deltes since now the\nnumber of document can be read from commit points without opening a\nfull blown reader. This also allows merge posliies to make decisions\nwithout requiring an NRT reader to get the relevant statistics. This\nchange doesn't enforce any field to be used as soft deletes and the statistic\nis maintained per segment.\n","date":"2018-06-04 21:05:12","modifiedFileCount":"35","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-27 03:35:46","codes":[{"authorDate":"2018-07-18 00:30:23","commitOrder":14,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-07-18 00:31:06","endLine":147,"groupId":"19485","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/70/f43a00fe32c0834844cb4dd9887152d8e2274d.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2018-05-27 03:35:46","commitOrder":14,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-04 21:05:12","endLine":250,"groupId":"62762","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b6/4385529766bec26e461c918f04c7123c28e95b.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"N"}],"commitId":"8093c450c1fd22e2bfd5b2a4a1e45c6f95f16189","commitMessage":"@@@LUCENE-8263: Replace TieredMergePolicy's reclaimDeletesWeight with deletesPctAllowed.\n","date":"2018-07-18 00:31:06","modifiedFileCount":"14","status":"M","submitter":"Adrien Grand"},{"authorTime":"2018-08-24 20:33:18","codes":[{"authorDate":"2018-08-24 20:33:18","commitOrder":15,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-08-24 20:33:18","endLine":147,"groupId":"9135","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2018-08-24 20:33:18","commitOrder":15,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-08-24 20:33:18","endLine":252,"groupId":"9135","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"f26dd13b34e3d3a6921230cfe44ff34b2c319e7b","commitMessage":"@@@LUCENE-8458: Ensure init PendingSoftDeletes when carry-over deletes\n\nToday when carrying over hard-deletes after merging segments.  we might\nnot adjust soft-deletes count accordingly because we do not always\nensure that the PendingSoftDeletes of the new segment is initialized.\n\nThis change fixes the initialization condition in PendingSoftDeletes and\nmakes sure it is initialized before accepting deletes.\n\nCo-authored-by: Simon Willnauer <simonw@apache.org>\n","date":"2018-08-24 20:33:18","modifiedFileCount":"5","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2018-10-09 07:51:03","codes":[{"authorDate":"2018-08-24 20:33:18","commitOrder":16,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-08-24 20:33:18","endLine":147,"groupId":"9135","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"},{"authorDate":"2018-10-09 07:51:03","commitOrder":16,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-10-09 07:51:03","endLine":252,"groupId":"23568","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c8/82a3b88f39098e60b66afd8afd879bdc393785.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"1118299c338253cea09640acdc48dc930dc27fda","commitMessage":"@@@LUCENE-8496: Selective indexing - modify BKDReader/BKDWriter to allow users to select a fewer number of dimensions to be used for creating the index than the total number of dimensions used for field encoding. i.e..  dimensions 0 to N may be used to determine how to split the inner nodes.  and dimensions N+1 to D are ignored and stored as data dimensions at the leaves.\n","date":"2018-10-09 07:51:03","modifiedFileCount":"72","status":"M","submitter":"Nicholas Knize"},{"authorTime":"2020-09-26 19:11:04","codes":[{"authorDate":"2018-08-24 20:33:18","commitOrder":17,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-08-24 20:33:18","endLine":147,"groupId":"9135","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"},{"authorDate":"2020-09-26 19:11:04","commitOrder":17,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, 0, NONE, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2020-10-18 19:49:36","endLine":254,"groupId":"9134","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/22/6f199c9dea9e971a9efd3271a4e923da6d0b1c.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"}],"commitId":"c02f07f2d5db5c983c2eedf71febf9516189595d","commitMessage":"@@@LUCENE-9322: Add Lucene90 codec.  including VectorFormat\n\nThis commit adds support for dense floating point VectorFields.\nThe new VectorValues class provides access to the indexed vectors.\n","date":"2020-10-18 19:49:36","modifiedFileCount":"58","status":"M","submitter":"Michael Sokolov"},{"authorTime":"2021-07-21 16:06:27","codes":[{"authorDate":"2018-08-24 20:33:18","commitOrder":18,"curCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-08-24 20:33:18","endLine":147,"groupId":"105985","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeleteSoft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testDeleteSoft() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        \r\n        .setMaxBufferedDocs(10)\n        .setMergePolicy(NoMergePolicy.INSTANCE)\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNull(pendingSoftDeletes.getHardLiveDocs());\n    \r\n    Bits liveDocs = pendingSoftDeletes.getLiveDocs();\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(1, pendingSoftDeletes.getDelCount());\n    assertSame(liveDocs, pendingSoftDeletes.getLiveDocs());\n\n    \r\n    writer.deleteDocuments(new Term(\"id\", \"1\"));\n    writer.commit();\n    IOUtils.close(reader);\n    reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    segmentInfo = segmentReader.getSegmentInfo();\n    pendingSoftDeletes = newPendingDeletes(segmentInfo);\n    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);\n    assertEquals(0, pendingSoftDeletes.numPendingDeletes());\n    assertEquals(2, pendingSoftDeletes.getDelCount());\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));\n    assertFalse(pendingSoftDeletes.getLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getLiveDocs().get(2));\n    assertNotNull(pendingSoftDeletes.getHardLiveDocs());\n    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(0));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));\n    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(2));\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"N"},{"authorDate":"2021-07-21 16:06:27","commitOrder":18,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer =\n        new IndexWriter(\n            dir,\n            newIndexWriterConfig()\n                .setSoftDeletesField(\"_soft_deletes\")\n                .setMaxBufferedDocs(3) \r\n                .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"1\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            VectorSimilarityFunction.EUCLIDEAN,\n            true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2021-07-21 16:06:27","endLine":320,"groupId":"105985","id":36,"instanceNumber":2,"isCurCommit":1,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ec/d3795dcefe8de62b92181a2984a0d24bf841a3.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer =\n        new IndexWriter(\n            dir,\n            newIndexWriterConfig()\n                .setSoftDeletesField(\"_soft_deletes\")\n                .setMaxBufferedDocs(3) \r\n                .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"1\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            NONE,\n            true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":255,"status":"M"}],"commitId":"28ba8b77975fc1b5a1a07da373916a2b21ea09aa","commitMessage":"@@@LUCENE-10015: Remove VectorSimilarityFunction#NONE. (#219)\n\n","date":"2021-07-21 16:06:27","modifiedFileCount":"21","status":"M","submitter":"Adrien Grand"}]
