[{"authorTime":"2016-02-19 16:24:22","codes":[{"authorDate":"2016-02-19 16:24:22","commitOrder":1,"curCode":"    protected List refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n                continue;\n            }\n\n        }\n        return result;\n\n    }\n","date":"2016-02-19 16:24:22","endLine":1718,"groupId":"1196","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshTicksHorizontal","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/ee/184d1d2e73c43e3f244f0b49b29c9ba0cc6bd3.src","preCode":"    protected List refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n                continue;\n            }\n\n        }\n        return result;\n\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/DateAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":1611,"status":"B"},{"authorDate":"2016-02-19 16:24:22","commitOrder":1,"curCode":"    protected List refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    if (edge == RectangleEdge.LEFT) {\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n    }\n","date":"2016-02-19 16:24:22","endLine":1831,"groupId":"3099","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"refreshTicksVertical","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/ee/184d1d2e73c43e3f244f0b49b29c9ba0cc6bd3.src","preCode":"    protected List refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    if (edge == RectangleEdge.LEFT) {\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/DateAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":1729,"status":"B"}],"commitId":"2228e7e92f418078706f2134d2ecce11888b1cb7","commitMessage":"@@@Move source files to standard Maven location.","date":"2016-02-19 16:24:22","modifiedFileCount":"0","status":"B","submitter":"David Gilbert"},{"authorTime":"2016-02-19 16:24:22","codes":[{"authorDate":"2020-03-11 13:25:04","commitOrder":2,"curCode":"    protected List refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n\n    }\n","date":"2020-03-11 13:25:04","endLine":1566,"groupId":"1196","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshTicksHorizontal","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/51/9b7fab85b6bbd850edcc5fd039960e45bd655a.src","preCode":"    protected List refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n                continue;\n            }\n\n        }\n        return result;\n\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/DateAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":1461,"status":"M"},{"authorDate":"2016-02-19 16:24:22","commitOrder":2,"curCode":"    protected List refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    if (edge == RectangleEdge.LEFT) {\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n    }\n","date":"2016-02-19 16:24:22","endLine":1831,"groupId":"3099","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"refreshTicksVertical","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/ee/184d1d2e73c43e3f244f0b49b29c9ba0cc6bd3.src","preCode":"    protected List refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    if (edge == RectangleEdge.LEFT) {\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/DateAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":1729,"status":"N"}],"commitId":"a8c2d498c283cc679d70e36d4eb7d50e8ad8f17f","commitMessage":"@@@Fix NetBeans warning","date":"2020-03-11 13:25:04","modifiedFileCount":"1","status":"M","submitter":"David Gilbert"},{"authorTime":"2020-03-22 15:56:31","codes":[{"authorDate":"2020-03-22 15:56:31","commitOrder":3,"curCode":"    protected List<? extends Tick> refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List<DateTick> result = new ArrayList<>();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                DateTick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n\n    }\n","date":"2020-03-22 15:56:31","endLine":1567,"groupId":"101863","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshTicksHorizontal","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/c6/ccde67f72b9b6896ebf530fc0ebe40aa3d308e.src","preCode":"    protected List refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/DateAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":1462,"status":"M"},{"authorDate":"2020-03-22 15:56:31","commitOrder":3,"curCode":"    protected List<? extends Tick> refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List<DateTick> result = new ArrayList<>();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    if (edge == RectangleEdge.LEFT) {\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                DateTick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n    }\n","date":"2020-03-22 15:56:31","endLine":1680,"groupId":"101863","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"refreshTicksVertical","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/c6/ccde67f72b9b6896ebf530fc0ebe40aa3d308e.src","preCode":"    protected List refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit = getTickUnit();\n        Date tickDate = calculateLowestVisibleTickValue(unit);\n        Date upperDate = getMaximumDate();\n\n        boolean hasRolled = false;\n        while (tickDate.before(upperDate)) {\n\n            \r\n            if (!hasRolled) {\n                tickDate = correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime = tickDate.getTime();\n            long distance = unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces = getMinorTickCount();\n            if (minorTickSpaces <= 0) {\n                minorTickSpaces = unit.getMinorTickCount();\n            }\n            for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) {\n                long minorTickTime = lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime > 0 && getRange().contains(minorTickTime)\n                        && (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                \r\n                String tickLabel;\n                DateFormat formatter = getDateFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(tickDate);\n                }\n                else {\n                    tickLabel = this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    if (edge == RectangleEdge.LEFT) {\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                Tick tick = new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled = false;\n\n                long currentTickTime = tickDate.getTime();\n                tickDate = unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime = tickDate.getTime();\n                for (int minorTick = 1; minorTick < minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime = currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            && (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate = unit.rollDate(tickDate, this.timeZone);\n                hasRolled = true;\n            }\n        }\n        return result;\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/DateAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":1578,"status":"M"}],"commitId":"ac710c9a373e94040c30b33a2746fde18518c6b1","commitMessage":"@@@Add generics.","date":"2020-03-22 15:56:31","modifiedFileCount":"2","status":"M","submitter":"David Gilbert"}]
