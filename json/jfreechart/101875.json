[{"authorTime":"2016-02-19 16:24:22","codes":[{"authorDate":"2016-02-19 16:24:22","commitOrder":1,"curCode":"    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = false;\n\n        CycleBoundTick lastTick = null;\n        float lastX = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double xx = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n            float x = (float) xx;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n                if (edge == RectangleEdge.TOP) {\n                    angle = Math.PI / 2.0;\n                }\n                else {\n                    angle = -Math.PI / 2.0;\n                }\n                anchor = TextAnchor.CENTER_RIGHT;\n                \r\n                if ((lastTick != null) && (lastX == x)\n                        && (currentTickValue != cycleBound)) {\n                    anchor = isInverted()\n                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    result.remove(result.size() - 1);\n                    result.add(new CycleBoundTick(\n                        this.boundMappedToLastCycle, lastTick.getNumber(),\n                        lastTick.getText(), anchor, anchor,\n                        lastTick.getAngle())\n                    );\n                    this.internalMarkerWhenTicksOverlap = true;\n                    anchor = isInverted()\n                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                }\n                rotationAnchor = anchor;\n            }\n            else {\n                if (edge == RectangleEdge.TOP) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.TOP_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle,\n                new Double(currentTickValue), tickLabel, anchor,\n                rotationAnchor, angle\n            );\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastX = x;\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = true;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n\n    }\n","date":"2016-02-19 16:24:22","endLine":556,"groupId":"3244","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshTicksHorizontal","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/bc/245c7e9b15316276a37b611a25a5e42a6999f2.src","preCode":"    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = false;\n\n        CycleBoundTick lastTick = null;\n        float lastX = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double xx = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n            float x = (float) xx;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n                if (edge == RectangleEdge.TOP) {\n                    angle = Math.PI / 2.0;\n                }\n                else {\n                    angle = -Math.PI / 2.0;\n                }\n                anchor = TextAnchor.CENTER_RIGHT;\n                \r\n                if ((lastTick != null) && (lastX == x)\n                        && (currentTickValue != cycleBound)) {\n                    anchor = isInverted()\n                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    result.remove(result.size() - 1);\n                    result.add(new CycleBoundTick(\n                        this.boundMappedToLastCycle, lastTick.getNumber(),\n                        lastTick.getText(), anchor, anchor,\n                        lastTick.getAngle())\n                    );\n                    this.internalMarkerWhenTicksOverlap = true;\n                    anchor = isInverted()\n                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                }\n                rotationAnchor = anchor;\n            }\n            else {\n                if (edge == RectangleEdge.TOP) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.TOP_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle,\n                new Double(currentTickValue), tickLabel, anchor,\n                rotationAnchor, angle\n            );\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastX = x;\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = true;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/CyclicNumberAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"B"},{"authorDate":"2016-02-19 16:24:22","commitOrder":1,"curCode":"    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = true;\n\n        NumberTick lastTick = null;\n        float lastY = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double yy = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y = (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = -Math.PI / 2.0;\n                }\n                else {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.CENTER_LEFT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle, new Double(currentTickValue),\n                tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastY = y;\n\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = false;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n    }\n","date":"2016-02-19 16:24:22","endLine":726,"groupId":"4087","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"refreshVerticalTicks","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/bc/245c7e9b15316276a37b611a25a5e42a6999f2.src","preCode":"    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = true;\n\n        NumberTick lastTick = null;\n        float lastY = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double yy = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y = (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = -Math.PI / 2.0;\n                }\n                else {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.CENTER_LEFT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle, new Double(currentTickValue),\n                tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastY = y;\n\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = false;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/CyclicNumberAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":568,"status":"B"}],"commitId":"2228e7e92f418078706f2134d2ecce11888b1cb7","commitMessage":"@@@Move source files to standard Maven location.","date":"2016-02-19 16:24:22","modifiedFileCount":"0","status":"B","submitter":"David Gilbert"},{"authorTime":"2020-02-25 22:29:50","codes":[{"authorDate":"2020-02-25 22:29:50","commitOrder":2,"curCode":"    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = false;\n\n        CycleBoundTick lastTick = null;\n        float lastX = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double xx = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n            float x = (float) xx;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n                if (edge == RectangleEdge.TOP) {\n                    angle = Math.PI / 2.0;\n                }\n                else {\n                    angle = -Math.PI / 2.0;\n                }\n                anchor = TextAnchor.CENTER_RIGHT;\n                \r\n                if ((lastTick != null) && (lastX == x)\n                        && (currentTickValue != cycleBound)) {\n                    anchor = isInverted()\n                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    result.remove(result.size() - 1);\n                    result.add(new CycleBoundTick(\n                        this.boundMappedToLastCycle, lastTick.getNumber(),\n                        lastTick.getText(), anchor, anchor,\n                        lastTick.getAngle())\n                    );\n                    this.internalMarkerWhenTicksOverlap = true;\n                    anchor = isInverted()\n                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                }\n                rotationAnchor = anchor;\n            }\n            else {\n                if (edge == RectangleEdge.TOP) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.TOP_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(this.boundMappedToLastCycle, \n                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastX = x;\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = true;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n\n    }\n","date":"2020-02-25 22:29:50","endLine":538,"groupId":"101875","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshTicksHorizontal","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/c3/da0d7eeb6ed8314477fb48e25e3ad9ee9eecc9.src","preCode":"    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = false;\n\n        CycleBoundTick lastTick = null;\n        float lastX = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double xx = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n            float x = (float) xx;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n                if (edge == RectangleEdge.TOP) {\n                    angle = Math.PI / 2.0;\n                }\n                else {\n                    angle = -Math.PI / 2.0;\n                }\n                anchor = TextAnchor.CENTER_RIGHT;\n                \r\n                if ((lastTick != null) && (lastX == x)\n                        && (currentTickValue != cycleBound)) {\n                    anchor = isInverted()\n                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    result.remove(result.size() - 1);\n                    result.add(new CycleBoundTick(\n                        this.boundMappedToLastCycle, lastTick.getNumber(),\n                        lastTick.getText(), anchor, anchor,\n                        lastTick.getAngle())\n                    );\n                    this.internalMarkerWhenTicksOverlap = true;\n                    anchor = isInverted()\n                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                }\n                rotationAnchor = anchor;\n            }\n            else {\n                if (edge == RectangleEdge.TOP) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.TOP_CENTER;\n                    if ((lastTick != null) && (lastX == x)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle,\n                new Double(currentTickValue), tickLabel, anchor,\n                rotationAnchor, angle\n            );\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastX = x;\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = true;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/CyclicNumberAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":401,"status":"M"},{"authorDate":"2020-02-25 22:29:50","commitOrder":2,"curCode":"    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = true;\n\n        NumberTick lastTick = null;\n        float lastY = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double yy = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y = (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = -Math.PI / 2.0;\n                }\n                else {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.CENTER_LEFT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(this.boundMappedToLastCycle, \n                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastY = y;\n\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = false;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n    }\n","date":"2020-02-25 22:29:50","endLine":707,"groupId":"101875","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"refreshVerticalTicks","params":"(Graphics2Dg2@Rectangle2DdataArea@RectangleEdgeedge)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jfreechart-10-0.7/blobInfo/CC_OUT/blobs/c3/da0d7eeb6ed8314477fb48e25e3ad9ee9eecc9.src","preCode":"    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit = getTickUnit().getSize();\n        double cycleBound = getCycleBound();\n        double currentTickValue = Math.ceil(cycleBound / unit) * unit;\n        double upperValue = getRange().getUpperBound();\n        boolean cycled = false;\n\n        boolean boundMapping = this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle = true;\n\n        NumberTick lastTick = null;\n        float lastY = 0.0f;\n\n        if (upperValue == cycleBound) {\n            currentTickValue = calculateLowestVisibleTickValue();\n            cycled = true;\n            this.boundMappedToLastCycle = true;\n        }\n\n        while (currentTickValue <= upperValue) {\n\n            \r\n            boolean cyclenow = false;\n            if ((currentTickValue + unit > upperValue) && !cycled) {\n                cyclenow = true;\n            }\n\n            double yy = valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                tickLabel = formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel = getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y = (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle = 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = -Math.PI / 2.0;\n                }\n                else {\n                    anchor = TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                    angle = Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge == RectangleEdge.LEFT) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor = anchor;\n                }\n                else {\n                    anchor = TextAnchor.CENTER_LEFT;\n                    if ((lastTick != null) && (lastY == y)\n                            && (currentTickValue != cycleBound)) {\n                        anchor = isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap = true;\n                        anchor = isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor = anchor;\n                }\n            }\n\n            CycleBoundTick tick = new CycleBoundTick(\n                this.boundMappedToLastCycle, new Double(currentTickValue),\n                tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n            result.add(tick);\n            lastTick = tick;\n            lastY = y;\n\n            if (currentTickValue == cycleBound) {\n                this.internalMarkerCycleBoundTick = tick;\n            }\n\n            currentTickValue += unit;\n\n            if (cyclenow) {\n                currentTickValue = calculateLowestVisibleTickValue();\n                upperValue = cycleBound;\n                cycled = true;\n                this.boundMappedToLastCycle = false;\n            }\n\n        }\n        this.boundMappedToLastCycle = boundMapping;\n        return result;\n    }\n","realPath":"src/main/java/org/jfree/chart/axis/CyclicNumberAxis.java","repoName":"jfreechart","snippetEndLine":0,"snippetStartLine":0,"startLine":550,"status":"M"}],"commitId":"0ef26bf09d0f2fc511d7f03a874024a70c133595","commitMessage":"@@@Add generics and fix compiler warnings.","date":"2020-02-25 22:29:50","modifiedFileCount":"12","status":"M","submitter":"David Gilbert"}]
