[{"authorTime":"2019-03-04 14:09:20","codes":[{"authorDate":"2020-10-17 14:31:18","commitOrder":2,"curCode":"  protected void serviceStop() throws Exception {\n    if (stopped.getAndSet(true)) {\n      \r\n      return;\n    }\n    if (allocatorThread != null) {\n      allocatorThread.interrupt();\n      try {\n        allocatorThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"InterruptedException while stopping\", ie);\n      }\n    }\n    if (isApplicationMasterRegistered && shouldUnregister) {\n      unregister();\n    }\n    super.serviceStop();\n  }\n","date":"2020-10-17 14:31:18","endLine":270,"groupId":"4506","id":1,"instanceNumber":1,"isCurCommit":1,"methodName":"serviceStop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/87/5726647b2c7d16f63d5f11741cfa2f8bffa424.src","preCode":"  protected void serviceStop() throws Exception {\n    if (stopped.getAndSet(true)) {\n      \r\n      return;\n    }\n    if (allocatorThread != null) {\n      allocatorThread.interrupt();\n      try {\n        allocatorThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"InterruptedException while stopping\", ie);\n      }\n    }\n    if (isApplicationMasterRegistered && shouldUnregister) {\n      unregister();\n    }\n    super.serviceStop();\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMCommunicator.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"B"},{"authorDate":"2019-03-04 14:09:20","commitOrder":2,"curCode":"  protected void serviceStop() throws Exception {\n    if (drainEventsOnStop) {\n      blockNewEvents = true;\n      LOG.info(\"AsyncDispatcher is draining to stop, ignoring any new events.\");\n      long endTime = System.currentTimeMillis() + getConfig()\n          .getLong(YarnConfiguration.DISPATCHER_DRAIN_EVENTS_TIMEOUT,\n              YarnConfiguration.DEFAULT_DISPATCHER_DRAIN_EVENTS_TIMEOUT);\n\n      synchronized (waitForDrained) {\n        while (!isDrained() && eventHandlingThread != null\n            && eventHandlingThread.isAlive()\n            && System.currentTimeMillis() < endTime) {\n          waitForDrained.wait(100);\n          LOG.info(\"Waiting for AsyncDispatcher to drain. Thread state is :\" +\n              eventHandlingThread.getState());\n        }\n      }\n    }\n    stopped = true;\n    if (eventHandlingThread != null) {\n      eventHandlingThread.interrupt();\n      try {\n        eventHandlingThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted Exception while stopping\", ie);\n      }\n    }\n\n    \r\n    super.serviceStop();\n  }\n","date":"2019-03-04 15:59:20","endLine":187,"groupId":"34133","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"serviceStop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/33/3faa5de7da36b9f9632f93a93ce070cadf7ae9.src","preCode":"  protected void serviceStop() throws Exception {\n    if (drainEventsOnStop) {\n      blockNewEvents = true;\n      LOG.info(\"AsyncDispatcher is draining to stop, ignoring any new events.\");\n      long endTime = System.currentTimeMillis() + getConfig()\n          .getLong(YarnConfiguration.DISPATCHER_DRAIN_EVENTS_TIMEOUT,\n              YarnConfiguration.DEFAULT_DISPATCHER_DRAIN_EVENTS_TIMEOUT);\n\n      synchronized (waitForDrained) {\n        while (!isDrained() && eventHandlingThread != null\n            && eventHandlingThread.isAlive()\n            && System.currentTimeMillis() < endTime) {\n          waitForDrained.wait(100);\n          LOG.info(\"Waiting for AsyncDispatcher to drain. Thread state is :\" +\n              eventHandlingThread.getState());\n        }\n      }\n    }\n    stopped = true;\n    if (eventHandlingThread != null) {\n      eventHandlingThread.interrupt();\n      try {\n        eventHandlingThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted Exception while stopping\", ie);\n      }\n    }\n\n    \r\n    super.serviceStop();\n  }\n","realPath":"hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/event/AsyncDispatcher.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"NB"}],"commitId":"1e3a6efcef2924a7966c44ca63476c853956691d","commitMessage":"@@@HADOOP-17288. Use shaded guava from thirdparty. (#2342). Contributed by Ayush Saxena.\n\n","date":"2020-10-17 14:31:18","modifiedFileCount":"1728","status":"M","submitter":"Ayush Saxena"},{"authorTime":"2021-04-27 20:01:53","codes":[{"authorDate":"2020-10-17 14:31:18","commitOrder":3,"curCode":"  protected void serviceStop() throws Exception {\n    if (stopped.getAndSet(true)) {\n      \r\n      return;\n    }\n    if (allocatorThread != null) {\n      allocatorThread.interrupt();\n      try {\n        allocatorThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"InterruptedException while stopping\", ie);\n      }\n    }\n    if (isApplicationMasterRegistered && shouldUnregister) {\n      unregister();\n    }\n    super.serviceStop();\n  }\n","date":"2020-10-17 14:31:18","endLine":270,"groupId":"10421","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"serviceStop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/87/5726647b2c7d16f63d5f11741cfa2f8bffa424.src","preCode":"  protected void serviceStop() throws Exception {\n    if (stopped.getAndSet(true)) {\n      \r\n      return;\n    }\n    if (allocatorThread != null) {\n      allocatorThread.interrupt();\n      try {\n        allocatorThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"InterruptedException while stopping\", ie);\n      }\n    }\n    if (isApplicationMasterRegistered && shouldUnregister) {\n      unregister();\n    }\n    super.serviceStop();\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMCommunicator.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"N"},{"authorDate":"2021-04-27 20:01:53","commitOrder":3,"curCode":"  protected void serviceStop() throws Exception {\n    if (drainEventsOnStop) {\n      blockNewEvents = true;\n      LOG.info(\"AsyncDispatcher is draining to stop, ignoring any new events.\");\n      long endTime = System.currentTimeMillis() + getConfig()\n          .getLong(YarnConfiguration.DISPATCHER_DRAIN_EVENTS_TIMEOUT,\n              YarnConfiguration.DEFAULT_DISPATCHER_DRAIN_EVENTS_TIMEOUT);\n\n      synchronized (waitForDrained) {\n        while (!isDrained() && eventHandlingThread != null\n            && eventHandlingThread.isAlive()\n            && System.currentTimeMillis() < endTime) {\n          waitForDrained.wait(100);\n          LOG.info(\"Waiting for AsyncDispatcher to drain. Thread state is :\" +\n              eventHandlingThread.getState());\n        }\n      }\n    }\n    stopped = true;\n    if (eventHandlingThread != null) {\n      eventHandlingThread.interrupt();\n      try {\n        eventHandlingThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted Exception while stopping\", ie);\n      }\n    }\n    printEventDetailsExecutor.shutdownNow();\n\n    \r\n    super.serviceStop();\n  }\n","date":"2021-04-27 20:01:53","endLine":244,"groupId":"10421","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"serviceStop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/ba/6bb435ec25bdbff1de01051a8a6f3513d5a009.src","preCode":"  protected void serviceStop() throws Exception {\n    if (drainEventsOnStop) {\n      blockNewEvents = true;\n      LOG.info(\"AsyncDispatcher is draining to stop, ignoring any new events.\");\n      long endTime = System.currentTimeMillis() + getConfig()\n          .getLong(YarnConfiguration.DISPATCHER_DRAIN_EVENTS_TIMEOUT,\n              YarnConfiguration.DEFAULT_DISPATCHER_DRAIN_EVENTS_TIMEOUT);\n\n      synchronized (waitForDrained) {\n        while (!isDrained() && eventHandlingThread != null\n            && eventHandlingThread.isAlive()\n            && System.currentTimeMillis() < endTime) {\n          waitForDrained.wait(100);\n          LOG.info(\"Waiting for AsyncDispatcher to drain. Thread state is :\" +\n              eventHandlingThread.getState());\n        }\n      }\n    }\n    stopped = true;\n    if (eventHandlingThread != null) {\n      eventHandlingThread.interrupt();\n      try {\n        eventHandlingThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted Exception while stopping\", ie);\n      }\n    }\n\n    \r\n    super.serviceStop();\n  }\n","realPath":"hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/event/AsyncDispatcher.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":213,"status":"M"}],"commitId":"a967ab06f2e802f30ed34eb4ceb2742e4df8be52","commitMessage":"@@@YARN-10739. GenericEventHandler.printEventQueueDetails causes RM recovery to take too much time. Contributed by Qi Zhu.\n","date":"2021-04-27 20:01:53","modifiedFileCount":"2","status":"M","submitter":"Peter Bacsko"}]
