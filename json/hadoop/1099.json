[{"authorTime":"2018-01-31 17:42:42","codes":[{"authorDate":"2018-01-31 17:42:42","commitOrder":1,"curCode":"  public void testConcurrentTaskLimitsDisabledIfSmaller() throws Exception {\n    final int MAP_COUNT = 1;\n    final int REDUCE_COUNT = 1;\n    final int MAP_LIMIT = 1;\n    final int REDUCE_LIMIT = 1;\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator =\n        new MyContainerAllocator(null, conf, appAttemptId, mockJob,\n            SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n\n          @Override\n          protected void setRequestLimit(Priority priority,\n              Resource capability, int limit) {\n            Assert.fail(\"setRequestLimit() should not be invoked\");\n          }\n        };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = createReq(jobId, i, 1024, new String[] { \"h\" + i });\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents =\n        new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] =\n          createReq(jobId, i, 1024, new String[] {}, false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n    allocator.schedule();\n    allocator.schedule();\n    allocator.close();\n  }\n","date":"2018-01-31 17:42:42","endLine":2938,"groupId":"24617","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testConcurrentTaskLimitsDisabledIfSmaller","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/78/75917b68eec03cc7f44ed43633ed880e626905.src","preCode":"  public void testConcurrentTaskLimitsDisabledIfSmaller() throws Exception {\n    final int MAP_COUNT = 1;\n    final int REDUCE_COUNT = 1;\n    final int MAP_LIMIT = 1;\n    final int REDUCE_LIMIT = 1;\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator =\n        new MyContainerAllocator(null, conf, appAttemptId, mockJob,\n            SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n\n          @Override\n          protected void setRequestLimit(Priority priority,\n              Resource capability, int limit) {\n            Assert.fail(\"setRequestLimit() should not be invoked\");\n          }\n        };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = createReq(jobId, i, 1024, new String[] { \"h\" + i });\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents =\n        new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] =\n          createReq(jobId, i, 1024, new String[] {}, false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n    allocator.schedule();\n    allocator.schedule();\n    allocator.close();\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/test/java/org/apache/hadoop/mapreduce/v2/app/rm/TestRMContainerAllocator.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":2880,"status":"B"},{"authorDate":"2018-01-31 17:42:42","commitOrder":1,"curCode":"  public void testConcurrentTaskLimits() throws Exception {\n    final int MAP_COUNT = 5;\n    final int REDUCE_COUNT = 2;\n    final int MAP_LIMIT = 3;\n    final int REDUCE_LIMIT = 1;\n    LOG.info(\"Running testConcurrentTaskLimits\");\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(\n        appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator = new MyContainerAllocator(null, conf,\n        appAttemptId, mockJob, SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n    };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = createReq(jobId, i, 1024, new String[] { \"h\" + i });\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents = new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] = createReq(jobId, i, 1024, new String[] {},\n          false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n\n    \r\n    \r\n    Assert.assertEquals(reqMapEvents.length + 2, mockScheduler.lastAsk.size());\n\n    \r\n    Assert.assertEquals(MAP_LIMIT, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid0 = mockScheduler.assignContainer(\"h0\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(2, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(3, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid1 = mockScheduler.assignContainer(\"h1\", false);\n    ContainerId cid2 = mockScheduler.assignContainer(\"h2\", false);\n    ContainerId cid3 = mockScheduler.assignContainer(\"h3\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid2);\n    mockScheduler.completeContainer(cid3);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid1);\n    ContainerId cid4 = mockScheduler.assignContainer(\"h4\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid4);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    Assert.assertEquals(REDUCE_LIMIT, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n    allocator.close();\n  }\n","date":"2018-01-31 17:42:42","endLine":3066,"groupId":"24616","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testConcurrentTaskLimits","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/78/75917b68eec03cc7f44ed43633ed880e626905.src","preCode":"  public void testConcurrentTaskLimits() throws Exception {\n    final int MAP_COUNT = 5;\n    final int REDUCE_COUNT = 2;\n    final int MAP_LIMIT = 3;\n    final int REDUCE_LIMIT = 1;\n    LOG.info(\"Running testConcurrentTaskLimits\");\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(\n        appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator = new MyContainerAllocator(null, conf,\n        appAttemptId, mockJob, SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n    };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = createReq(jobId, i, 1024, new String[] { \"h\" + i });\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents = new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] = createReq(jobId, i, 1024, new String[] {},\n          false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n\n    \r\n    \r\n    Assert.assertEquals(reqMapEvents.length + 2, mockScheduler.lastAsk.size());\n\n    \r\n    Assert.assertEquals(MAP_LIMIT, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid0 = mockScheduler.assignContainer(\"h0\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(2, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(3, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid1 = mockScheduler.assignContainer(\"h1\", false);\n    ContainerId cid2 = mockScheduler.assignContainer(\"h2\", false);\n    ContainerId cid3 = mockScheduler.assignContainer(\"h3\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid2);\n    mockScheduler.completeContainer(cid3);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid1);\n    ContainerId cid4 = mockScheduler.assignContainer(\"h4\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid4);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    Assert.assertEquals(REDUCE_LIMIT, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n    allocator.close();\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/test/java/org/apache/hadoop/mapreduce/v2/app/rm/TestRMContainerAllocator.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":2941,"status":"B"}],"commitId":"8d1e2c6409a44f4515a1549ae82c7e2597e96467","commitMessage":"@@@Merge branch 'YARN-6592' into trunk\n","date":"2018-01-31 17:42:42","modifiedFileCount":"83","status":"B","submitter":"Arun Suresh"},{"authorTime":"2018-05-11 00:31:59","codes":[{"authorDate":"2018-05-11 00:31:59","commitOrder":2,"curCode":"  public void testConcurrentTaskLimitsDisabledIfSmaller() throws Exception {\n    final int MAP_COUNT = 1;\n    final int REDUCE_COUNT = 1;\n    final int MAP_LIMIT = 1;\n    final int REDUCE_LIMIT = 1;\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator =\n        new MyContainerAllocator(null, conf, appAttemptId, mockJob,\n            SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n\n          @Override\n          protected void setRequestLimit(Priority priority,\n              Resource capability, int limit) {\n            Assert.fail(\"setRequestLimit() should not be invoked\");\n          }\n        };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = ContainerRequestCreator.createRequest(jobId, i,\n              Resource.newInstance(1024, 1),\n              new String[] {\"h\" + i});\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents =\n        new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] =\n          createRequest(jobId, i, Resource.newInstance(1024, 1),\n                  new String[] {}, false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n    allocator.schedule();\n    allocator.schedule();\n    allocator.close();\n  }\n","date":"2018-05-11 00:31:59","endLine":2965,"groupId":"1099","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testConcurrentTaskLimitsDisabledIfSmaller","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/42/7e6ea228f07be943dfedeb58106a10db30d900.src","preCode":"  public void testConcurrentTaskLimitsDisabledIfSmaller() throws Exception {\n    final int MAP_COUNT = 1;\n    final int REDUCE_COUNT = 1;\n    final int MAP_LIMIT = 1;\n    final int REDUCE_LIMIT = 1;\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator =\n        new MyContainerAllocator(null, conf, appAttemptId, mockJob,\n            SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n\n          @Override\n          protected void setRequestLimit(Priority priority,\n              Resource capability, int limit) {\n            Assert.fail(\"setRequestLimit() should not be invoked\");\n          }\n        };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = createReq(jobId, i, 1024, new String[] { \"h\" + i });\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents =\n        new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] =\n          createReq(jobId, i, 1024, new String[] {}, false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n    allocator.schedule();\n    allocator.schedule();\n    allocator.close();\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/test/java/org/apache/hadoop/mapreduce/v2/app/rm/TestRMContainerAllocator.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":2904,"status":"M"},{"authorDate":"2018-05-11 00:31:59","commitOrder":2,"curCode":"  public void testConcurrentTaskLimits() throws Exception {\n    final int MAP_COUNT = 5;\n    final int REDUCE_COUNT = 2;\n    final int MAP_LIMIT = 3;\n    final int REDUCE_LIMIT = 1;\n    LOG.info(\"Running testConcurrentTaskLimits\");\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(\n        appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator = new MyContainerAllocator(null, conf,\n        appAttemptId, mockJob, SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n    };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = ContainerRequestCreator.createRequest(jobId, i,\n          Resource.newInstance(1024, 1), new String[] {\"h\" + i});\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents =\n        new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] =\n          createRequest(jobId, i, Resource.newInstance(1024, 1),\n              new String[] {}, false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n\n    \r\n    \r\n    Assert.assertEquals(reqMapEvents.length + 2, mockScheduler.lastAsk.size());\n\n    \r\n    Assert.assertEquals(MAP_LIMIT, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid0 = mockScheduler.assignContainer(\"h0\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(2, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(3, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid1 = mockScheduler.assignContainer(\"h1\", false);\n    ContainerId cid2 = mockScheduler.assignContainer(\"h2\", false);\n    ContainerId cid3 = mockScheduler.assignContainer(\"h3\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid2);\n    mockScheduler.completeContainer(cid3);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid1);\n    ContainerId cid4 = mockScheduler.assignContainer(\"h4\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid4);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    Assert.assertEquals(REDUCE_LIMIT, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n    allocator.close();\n  }\n","date":"2018-05-11 00:31:59","endLine":3096,"groupId":"1099","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testConcurrentTaskLimits","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/42/7e6ea228f07be943dfedeb58106a10db30d900.src","preCode":"  public void testConcurrentTaskLimits() throws Exception {\n    final int MAP_COUNT = 5;\n    final int REDUCE_COUNT = 2;\n    final int MAP_LIMIT = 3;\n    final int REDUCE_LIMIT = 1;\n    LOG.info(\"Running testConcurrentTaskLimits\");\n    Configuration conf = new Configuration();\n    conf.setInt(MRJobConfig.JOB_RUNNING_MAP_LIMIT, MAP_LIMIT);\n    conf.setInt(MRJobConfig.JOB_RUNNING_REDUCE_LIMIT, REDUCE_LIMIT);\n    conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, 0.0f);\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId appAttemptId = ApplicationAttemptId.newInstance(\n        appId, 1);\n    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);\n    Job mockJob = mock(Job.class);\n    when(mockJob.getReport()).thenReturn(\n        MRBuilderUtils.newJobReport(jobId, \"job\", \"user\", JobState.RUNNING, 0,\n            0, 0, 0, 0, 0, 0, \"jobfile\", null, false, \"\"));\n    when(mockJob.getTotalMaps()).thenReturn(MAP_COUNT);\n    when(mockJob.getTotalReduces()).thenReturn(REDUCE_COUNT);\n\n    final MockScheduler mockScheduler = new MockScheduler(appAttemptId);\n    MyContainerAllocator allocator = new MyContainerAllocator(null, conf,\n        appAttemptId, mockJob, SystemClock.getInstance()) {\n          @Override\n          protected void register() {\n          }\n\n          @Override\n          protected ApplicationMasterProtocol createSchedulerProxy() {\n            return mockScheduler;\n          }\n    };\n\n    \r\n    ContainerRequestEvent[] reqMapEvents = new ContainerRequestEvent[MAP_COUNT];\n    for (int i = 0; i < reqMapEvents.length; ++i) {\n      reqMapEvents[i] = createReq(jobId, i, 1024, new String[] { \"h\" + i });\n    }\n    allocator.sendRequests(Arrays.asList(reqMapEvents));\n    \r\n    ContainerRequestEvent[] reqReduceEvents = new ContainerRequestEvent[REDUCE_COUNT];\n    for (int i = 0; i < reqReduceEvents.length; ++i) {\n      reqReduceEvents[i] = createReq(jobId, i, 1024, new String[] {},\n          false, true);\n    }\n    allocator.sendRequests(Arrays.asList(reqReduceEvents));\n    allocator.schedule();\n\n    \r\n    \r\n    Assert.assertEquals(reqMapEvents.length + 2, mockScheduler.lastAsk.size());\n\n    \r\n    Assert.assertEquals(MAP_LIMIT, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid0 = mockScheduler.assignContainer(\"h0\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(2, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(3, mockScheduler.lastAnyAskMap);\n\n    \r\n    ContainerId cid1 = mockScheduler.assignContainer(\"h1\", false);\n    ContainerId cid2 = mockScheduler.assignContainer(\"h2\", false);\n    ContainerId cid3 = mockScheduler.assignContainer(\"h3\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid2);\n    mockScheduler.completeContainer(cid3);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskMap);\n\n    \r\n    \r\n    mockScheduler.completeContainer(cid1);\n    ContainerId cid4 = mockScheduler.assignContainer(\"h4\", false);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    mockScheduler.completeContainer(cid4);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskMap);\n\n    \r\n    Assert.assertEquals(REDUCE_LIMIT, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(1, mockScheduler.lastAnyAskReduce);\n\n    \r\n    cid0 = mockScheduler.assignContainer(\"h0\", true);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n\n    \r\n    mockScheduler.completeContainer(cid0);\n    allocator.schedule();\n    allocator.schedule();\n    Assert.assertEquals(0, mockScheduler.lastAnyAskReduce);\n    allocator.close();\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/test/java/org/apache/hadoop/mapreduce/v2/app/rm/TestRMContainerAllocator.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":2968,"status":"M"}],"commitId":"c8b53c43644b4ad22d5385c22cad8ed573c0b1ba","commitMessage":"@@@YARN-8202. DefaultAMSProcessor should properly check units of requested custom resource types against minimum/maximum allocation (snemeth via rkanter)\n","date":"2018-05-11 00:31:59","modifiedFileCount":"6","status":"M","submitter":"Robert Kanter"}]
