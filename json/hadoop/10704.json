[{"authorTime":"2018-05-02 05:19:53","codes":[{"authorDate":"2018-05-02 05:19:53","commitOrder":1,"curCode":"  private List<FileStatus> singleThreadedListStatus(JobContext job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (int i=0; i < dirs.length; ++i) {\n      Path p = dirs[i];\n      FileSystem fs = p.getFileSystem(job.getConfiguration()); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","date":"2018-05-02 05:19:53","endLine":335,"groupId":"4722","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"singleThreadedListStatus","params":"(JobContextjob@Path[]dirs@PathFilterinputFilter@booleanrecursive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/e2/d8e6fa7ce88b0900f472bebae0076edb038062.src","preCode":"  private List<FileStatus> singleThreadedListStatus(JobContext job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (int i=0; i < dirs.length; ++i) {\n      Path p = dirs[i];\n      FileSystem fs = p.getFileSystem(job.getConfiguration()); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":296,"status":"B"},{"authorDate":"2018-05-02 05:19:53","commitOrder":1,"curCode":"  private List<FileStatus> singleThreadedListStatus(JobConf job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (Path p: dirs) {\n      FileSystem fs = p.getFileSystem(job); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","date":"2018-05-02 05:19:53","endLine":300,"groupId":"4722","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"singleThreadedListStatus","params":"(JobConfjob@Path[]dirs@PathFilterinputFilter@booleanrecursive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/fe/43991a0e7b83831c22173b0564575f6f66733d.src","preCode":"  private List<FileStatus> singleThreadedListStatus(JobConf job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (Path p: dirs) {\n      FileSystem fs = p.getFileSystem(job); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/FileInputFormat.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"B"}],"commitId":"68c6ec719da8e79ada31c8f3a82124f90b9a71fd","commitMessage":"@@@MAPREDUCE-7086. Add config to allow FileInputFormat to ignore directories when recursive=false. Contributed by Sergey Shelukhin\n","date":"2018-05-02 05:19:53","modifiedFileCount":"4","status":"B","submitter":"Jason Lowe"},{"authorTime":"2020-04-01 20:45:42","codes":[{"authorDate":"2020-04-01 20:45:42","commitOrder":2,"curCode":"  private List<FileStatus> singleThreadedListStatus(JobContext job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (int i=0; i < dirs.length; ++i) {\n      Path p = dirs[i];\n      FileSystem fs = p.getFileSystem(job.getConfiguration()); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(shrinkStatus(stat));\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","date":"2020-04-01 20:46:33","endLine":343,"groupId":"10704","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"singleThreadedListStatus","params":"(JobContextjob@Path[]dirs@PathFilterinputFilter@booleanrecursive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/1b/3365c2cf162f6b2b6ca706f3072e34f55fe212.src","preCode":"  private List<FileStatus> singleThreadedListStatus(JobContext job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (int i=0; i < dirs.length; ++i) {\n      Path p = dirs[i];\n      FileSystem fs = p.getFileSystem(job.getConfiguration()); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":304,"status":"M"},{"authorDate":"2020-04-01 20:45:42","commitOrder":2,"curCode":"  private List<FileStatus> singleThreadedListStatus(JobConf job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (Path p: dirs) {\n      FileSystem fs = p.getFileSystem(job); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(org.apache.hadoop.mapreduce.lib.input.\n                      FileInputFormat.shrinkStatus(stat));\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","date":"2020-04-01 20:46:33","endLine":309,"groupId":"10704","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"singleThreadedListStatus","params":"(JobConfjob@Path[]dirs@PathFilterinputFilter@booleanrecursive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hadoop-10-0.7/blobInfo/CC_OUT/blobs/b7/380379fdd37e4cc9ff7786888a69d71a3c9db9.src","preCode":"  private List<FileStatus> singleThreadedListStatus(JobConf job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List<FileStatus> result = new ArrayList<FileStatus>();\n    List<IOException> errors = new ArrayList<IOException>();\n    for (Path p: dirs) {\n      FileSystem fs = p.getFileSystem(job); \n      FileStatus[] matches = fs.globStatus(p, inputFilter);\n      if (matches == null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length == 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator<LocatedFileStatus> iter =\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat = iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive && stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }\n","realPath":"hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/FileInputFormat.java","repoName":"hadoop","snippetEndLine":0,"snippetStartLine":0,"startLine":271,"status":"M"}],"commitId":"c613296dc85ac7b22c171c84f578106b315cc012","commitMessage":"@@@MAPREDUCE-7241. FileInputFormat listStatus with less memory footprint. Contributed by Zhihua Deng\n","date":"2020-04-01 20:46:33","modifiedFileCount":"4","status":"M","submitter":"Jason Lowe"}]
