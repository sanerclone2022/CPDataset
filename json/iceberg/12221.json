[{"authorTime":"2019-07-13 03:55:36","codes":[{"authorDate":"2020-04-10 00:11:46","commitOrder":4,"curCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", expected.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        OffsetDateTime actualTs = EPOCH.plusNanos(\n            (ts.getTime() * 1_000_000) + (ts.getNanos() % 1_000_000));\n        Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection<?>) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2020-04-10 00:11:46","endLine":182,"groupId":"2882","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"assertEqualsSafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6b/7c504a83b9e95990dddb370d3dac1dd4bdfabb.src","preCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", expected.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        OffsetDateTime actualTs = EPOCH.plusNanos(\n            (ts.getTime() * 1_000_000) + (ts.getNanos() % 1_000_000));\n        Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection<?>) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":106,"status":"B"},{"authorDate":"2019-07-13 03:55:36","commitOrder":4,"curCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should be an int\", expected instanceof Integer);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        int daysFromEpoch = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFromEpoch);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a long\", expected instanceof Long);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2019-07-13 03:55:36","endLine":194,"groupId":"4570","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"assertEqualsSafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/c2/0bc67a69e1564229e6b78c2afa15a2cb360eaf.src","preCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should be an int\", expected instanceof Integer);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        int daysFromEpoch = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFromEpoch);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a long\", expected instanceof Long);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"NB"}],"commitId":"898c122118ba99847216c80ca7e0d12821133a8a","commitMessage":"@@@Spark: Add ORC to parameterized tests (#892)\n\n* Spark: Add ORC to parameterized tests.\n\n* Fix GenericsHelpers.\n\n* Build: Increase JVM heap size.\n\n* Fix review comments.\n\n* Revert \"Build: Increase JVM heap size.\"\n\nThis reverts commit 1f0996113923c5d279a5877a03af2db7b7e4e076.\n\n* Avoid keeping records in memory for TestDataFrameWrites.","date":"2020-04-10 00:11:46","modifiedFileCount":"6","status":"M","submitter":"Ryan Blue"},{"authorTime":"2019-07-13 03:55:36","codes":[{"authorDate":"2021-07-16 01:06:44","commitOrder":5,"curCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", expected.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        OffsetDateTime actualTs = EPOCH.plusNanos(\n            (ts.getTime() * 1_000_000) + (ts.getNanos() % 1_000_000));\n        Types.TimestampType timestampType = (Types.TimestampType) type;\n        if (timestampType.shouldAdjustToUTC()) {\n          Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n          Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs);\n        } else {\n          Assert.assertTrue(\"Should expect an LocalDateTime\", expected instanceof LocalDateTime);\n          Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs.toLocalDateTime());\n        }\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection<?>) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-07-16 01:06:44","endLine":190,"groupId":"2882","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"assertEqualsSafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/24/724d3d12bf927ba7cab671e726fdcbf5695a80.src","preCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", expected.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        OffsetDateTime actualTs = EPOCH.plusNanos(\n            (ts.getTime() * 1_000_000) + (ts.getNanos() % 1_000_000));\n        Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection<?>) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2019-07-13 03:55:36","commitOrder":5,"curCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should be an int\", expected instanceof Integer);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        int daysFromEpoch = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFromEpoch);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a long\", expected instanceof Long);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2019-07-13 03:55:36","endLine":194,"groupId":"4570","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"assertEqualsSafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/c2/0bc67a69e1564229e6b78c2afa15a2cb360eaf.src","preCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should be an int\", expected instanceof Integer);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        int daysFromEpoch = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFromEpoch);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a long\", expected instanceof Long);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"N"}],"commitId":"9a0d154b0ba5e6d10d79e30470295c91c89c1e09","commitMessage":"@@@Add support for reading/writing timestamps without timezone.  (#2757)\n\nPreviously Spark could not handle Iceberg tables which contained Timestamp.withoutTimeZone. New parameters are introduced to allow Timestamp without TimeZone to be treated as Timestamp with Timezone.  \n\nCo-authored-by: bkahloon <kahlonbakht@gmail.com>\nCo-authored-by: shardulm94 ","date":"2021-07-16 01:06:44","modifiedFileCount":"15","status":"M","submitter":"sshkvar"},{"authorTime":"2021-07-19 18:57:09","codes":[{"authorDate":"2021-07-19 18:57:09","commitOrder":6,"curCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assertions.assertThat(expected).as(\"Should expect a LocalDate\").isInstanceOf(LocalDate.class);\n        Assertions.assertThat(actual).as(\"Should be a Date\").isInstanceOf(Date.class);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", expected.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assertions.assertThat(actual).as(\"Should be a Timestamp\").isInstanceOf(Timestamp.class);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        OffsetDateTime actualTs = EPOCH.plusNanos(\n            (ts.getTime() * 1_000_000) + (ts.getNanos() % 1_000_000));\n        Types.TimestampType timestampType = (Types.TimestampType) type;\n        if (timestampType.shouldAdjustToUTC()) {\n          Assertions.assertThat(expected).as(\"Should expect an OffsetDateTime\").isInstanceOf(OffsetDateTime.class);\n          Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs);\n        } else {\n          Assertions.assertThat(expected).as(\"Should expect an LocalDateTime\").isInstanceOf(LocalDateTime.class);\n          Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs.toLocalDateTime());\n        }\n        break;\n      case STRING:\n        Assertions.assertThat(actual).as(\"Should be a String\").isInstanceOf(String.class);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assertions.assertThat(expected).as(\"Should expect a UUID\").isInstanceOf(UUID.class);\n        Assertions.assertThat(actual).as(\"Should be a String\").isInstanceOf(String.class);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assertions.assertThat(expected).as(\"Should expect a byte[]\").isInstanceOf(byte[].class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assertions.assertThat(expected).as(\"Should expect a ByteBuffer\").isInstanceOf(ByteBuffer.class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assertions.assertThat(expected).as(\"Should expect a BigDecimal\").isInstanceOf(BigDecimal.class);\n        Assertions.assertThat(actual).as(\"Should be a BigDecimal\").isInstanceOf(BigDecimal.class);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assertions.assertThat(expected).as(\"Should expect a Record\").isInstanceOf(Record.class);\n        Assertions.assertThat(actual).as(\"Should be a Row\").isInstanceOf(Row.class);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assertions.assertThat(expected).as(\"Should expect a Collection\").isInstanceOf(Collection.class);\n        Assertions.assertThat(actual).as(\"Should be a Seq\").isInstanceOf(Seq.class);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection<?>) expected, asList);\n        break;\n      case MAP:\n        Assertions.assertThat(expected).as(\"Should expect a Collection\").isInstanceOf(Map.class);\n        Assertions.assertThat(actual).as(\"Should be a Map\").isInstanceOf(scala.collection.Map.class);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-07-19 18:57:09","endLine":191,"groupId":"12221","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"assertEqualsSafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/46/c95cef112d64a35b0d1e8384fd260d16232898.src","preCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", expected.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        OffsetDateTime actualTs = EPOCH.plusNanos(\n            (ts.getTime() * 1_000_000) + (ts.getNanos() % 1_000_000));\n        Types.TimestampType timestampType = (Types.TimestampType) type;\n        if (timestampType.shouldAdjustToUTC()) {\n          Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n          Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs);\n        } else {\n          Assert.assertTrue(\"Should expect an LocalDateTime\", expected instanceof LocalDateTime);\n          Assert.assertEquals(\"Timestamp should be equal\", expected, actualTs.toLocalDateTime());\n        }\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection<?>) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"},{"authorDate":"2021-07-19 18:57:09","commitOrder":6,"curCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assertions.assertThat(expected).as(\"Should be an int\").isInstanceOf(Integer.class);\n        Assertions.assertThat(actual).as(\"Should be a Date\").isInstanceOf(Date.class);\n        int daysFromEpoch = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFromEpoch);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assertions.assertThat(expected).as(\"Should be a long\").isInstanceOf(Long.class);\n        Assertions.assertThat(actual).as(\"Should be a Timestamp\").isInstanceOf(Timestamp.class);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assertions.assertThat(actual).as(\"Should be a String\").isInstanceOf(String.class);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assertions.assertThat(expected).as(\"Should expect a UUID\").isInstanceOf(UUID.class);\n        Assertions.assertThat(actual).as(\"Should be a String\").isInstanceOf(String.class);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assertions.assertThat(expected).as(\"Should expect a Fixed\").isInstanceOf(GenericData.Fixed.class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assertions.assertThat(expected).as(\"Should expect a ByteBuffer\").isInstanceOf(ByteBuffer.class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assertions.assertThat(expected).as(\"Should expect a BigDecimal\").isInstanceOf(BigDecimal.class);\n        Assertions.assertThat(actual).as(\"Should be a BigDecimal\").isInstanceOf(BigDecimal.class);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assertions.assertThat(expected).as(\"Should expect a Record\").isInstanceOf(Record.class);\n        Assertions.assertThat(actual).as(\"Should be a Row\").isInstanceOf(Row.class);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assertions.assertThat(expected).as(\"Should expect a Collection\").isInstanceOf(Collection.class);\n        Assertions.assertThat(actual).as(\"Should be a Seq\").isInstanceOf(Seq.class);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assertions.assertThat(expected).as(\"Should expect a Collection\").isInstanceOf(Map.class);\n        Assertions.assertThat(actual).as(\"Should be a Map\").isInstanceOf(scala.collection.Map.class);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-07-19 18:57:09","endLine":223,"groupId":"12221","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"assertEqualsSafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/53/d5e8763e6f3e6e5eb342cc3f22f8f461357446.src","preCode":"  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should be an int\", expected instanceof Integer);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        int daysFromEpoch = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFromEpoch);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a long\", expected instanceof Long);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n        \r\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", String.valueOf(expected), actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"}],"commitId":"0055e855ccabbd6a592b3b49e1f38131f62e0fdd","commitMessage":"@@@Move Assert.assertTrue(..) instance checks to AssertJ assertions (#2756)\n\n","date":"2021-07-19 18:57:09","modifiedFileCount":"25","status":"M","submitter":"Eduard Tudenh?fner"}]
