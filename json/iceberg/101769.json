[{"authorTime":"2019-08-01 08:20:03","codes":[{"authorDate":"2019-08-01 08:20:03","commitOrder":1,"curCode":"  public void testTruncateStringMin() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    \r\n    String test3 = \"\\uFFFF\\uFFFF\";\n    \r\n    String test4 = \"\\uD800\\uDC00\\uD800\\uDC00\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have the first two characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have the first three characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 16).value(), test2) <= 0);\n    Assert.assertTrue(\"Output must have the first seven characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4) <= 0);\n    Assert.assertTrue(\"Output must have the first 4 byte UTF-8 character of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n  }\n","date":"2019-08-01 08:20:03","endLine":121,"groupId":"1259","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTruncateStringMin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/7a/999048ba3001222439625eb359af1667d2f56b.src","preCode":"  public void testTruncateStringMin() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    \r\n    String test3 = \"\\uFFFF\\uFFFF\";\n    \r\n    String test4 = \"\\uD800\\uDC00\\uD800\\uDC00\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have the first two characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have the first three characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 16).value(), test2) <= 0);\n    Assert.assertTrue(\"Output must have the first seven characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4) <= 0);\n    Assert.assertTrue(\"Output must have the first 4 byte UTF-8 character of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMetricsTruncation.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"B"},{"authorDate":"2019-08-01 08:20:03","commitOrder":1,"curCode":"  public void testTruncateStringMax() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    String test3 = \"a������������������\\uFFFF\\uFFFF\";\n    String test3_3_expected = \"a������������������\";\n    \r\n    String test4 = \"\\uFFFF\\uFFFF\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    \r\n    String test5 = \"\\uDBFF\\uDFFF\\uDBFF\\uDFFF\";\n    String test6 = \"\\uD800\\uDFFF\\uD800\\uDFFF\";\n    \r\n    String test6_2_expected = \"\\uD801\\uDC00\";\n\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 4).value(), test1) >= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 7).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have two characters and the second character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test2), 8).value(), test2) >= 0);\n    Assert.assertTrue(\"Output must have seven characters and the seventh character of the input \" +\n        \"must be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test3), 3).value(), test3) >= 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented. The second perceivable character in this string is actually a glyph. It consists of \" +\n        \"two unicode characters\", cmp.compare(\n        truncateStringMax(Literal.of(test3), 3).value(), test3_3_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4) >= 0);\n    Assert.assertTrue(\"Output must have one character. Since the first character is the max 3 byte \" +\n            \"UTF-8 character, it should be incremented to the lowest 4 byte UTF-8 character\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n    Assert.assertNull(\"An upper bound doesn't exist since the first two characters are max UTF-8 \" +\n        \"characters\", truncateStringMax(Literal.of(test5), 1));\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test6), 2).value(), test6) >= 0);\n    Assert.assertTrue(\"Test 4 byte UTF-8 character increment. Output must have one character with \" +\n        \"the first character incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test6), 1).value(), test6_2_expected) == 0);\n  }\n","date":"2019-08-01 08:20:03","endLine":179,"groupId":"5042","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncateStringMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/7a/999048ba3001222439625eb359af1667d2f56b.src","preCode":"  public void testTruncateStringMax() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    String test3 = \"a������������������\\uFFFF\\uFFFF\";\n    String test3_3_expected = \"a������������������\";\n    \r\n    String test4 = \"\\uFFFF\\uFFFF\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    \r\n    String test5 = \"\\uDBFF\\uDFFF\\uDBFF\\uDFFF\";\n    String test6 = \"\\uD800\\uDFFF\\uD800\\uDFFF\";\n    \r\n    String test6_2_expected = \"\\uD801\\uDC00\";\n\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 4).value(), test1) >= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 7).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have two characters and the second character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test2), 8).value(), test2) >= 0);\n    Assert.assertTrue(\"Output must have seven characters and the seventh character of the input \" +\n        \"must be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test3), 3).value(), test3) >= 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented. The second perceivable character in this string is actually a glyph. It consists of \" +\n        \"two unicode characters\", cmp.compare(\n        truncateStringMax(Literal.of(test3), 3).value(), test3_3_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4) >= 0);\n    Assert.assertTrue(\"Output must have one character. Since the first character is the max 3 byte \" +\n            \"UTF-8 character, it should be incremented to the lowest 4 byte UTF-8 character\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n    Assert.assertNull(\"An upper bound doesn't exist since the first two characters are max UTF-8 \" +\n        \"characters\", truncateStringMax(Literal.of(test5), 1));\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test6), 2).value(), test6) >= 0);\n    Assert.assertTrue(\"Test 4 byte UTF-8 character increment. Output must have one character with \" +\n        \"the first character incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test6), 1).value(), test6_2_expected) == 0);\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMetricsTruncation.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"B"}],"commitId":"26765c8f0f6986c7aa8b7a2e456cb7e85d2e23f5","commitMessage":"@@@Refactor metrics tests for reuse (#331)\n\n","date":"2019-08-01 08:20:03","modifiedFileCount":"1","status":"B","submitter":"Edgar Rodriguez"},{"authorTime":"2019-07-31 10:18:59","codes":[{"authorDate":"2019-08-01 08:20:03","commitOrder":2,"curCode":"  public void testTruncateStringMin() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    \r\n    String test3 = \"\\uFFFF\\uFFFF\";\n    \r\n    String test4 = \"\\uD800\\uDC00\\uD800\\uDC00\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have the first two characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have the first three characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 16).value(), test2) <= 0);\n    Assert.assertTrue(\"Output must have the first seven characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4) <= 0);\n    Assert.assertTrue(\"Output must have the first 4 byte UTF-8 character of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n  }\n","date":"2019-08-01 08:20:03","endLine":121,"groupId":"101769","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTruncateStringMin","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/7a/999048ba3001222439625eb359af1667d2f56b.src","preCode":"  public void testTruncateStringMin() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    \r\n    String test3 = \"\\uFFFF\\uFFFF\";\n    \r\n    String test4 = \"\\uD800\\uDC00\\uD800\\uDC00\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have the first two characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have the first three characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 16).value(), test2) <= 0);\n    Assert.assertTrue(\"Output must have the first seven characters of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) <= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMin(Literal.of(test3), 2).value(), test3) == 0);\n    Assert.assertTrue(\"Truncated lower bound should be lower than or equal to the actual lower bound\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4) <= 0);\n    Assert.assertTrue(\"Output must have the first 4 byte UTF-8 character of the input\",\n        cmp.compare(truncateStringMin(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMetricsTruncation.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"N"},{"authorDate":"2019-07-31 10:18:59","commitOrder":2,"curCode":"  public void testTruncateStringMax() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    String test3 = \"a������������������\\uFFFF\\uFFFF\";\n    String test3_3_expected = \"a������������������\";\n    \r\n    String test4 = \"\\uFFFF\\uFFFF\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    \r\n    String test5 = \"\\uDBFF\\uDFFF\\uDBFF\\uDFFF\";\n    String test6 = \"\\uD800\\uDFFF\\uD800\\uDFFF\";\n    \r\n    String test6_2_expected = \"\\uD801\\uDC00\";\n    String test7 = \"\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\";\n    String test7_2_expected = \"\\uD83D\\uDE02\\uD83D\\uDE03\";\n    String test7_1_expected = \"\\uD83D\\uDE03\";\n\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 4).value(), test1) >= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 7).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have two characters and the second character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test2), 8).value(), test2) >= 0);\n    Assert.assertTrue(\"Output must have seven characters and the seventh character of the input \" +\n        \"must be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test3), 3).value(), test3) >= 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented. The second perceivable character in this string is actually a glyph. It consists of \" +\n        \"two unicode characters\", cmp.compare(\n        truncateStringMax(Literal.of(test3), 3).value(), test3_3_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4) >= 0);\n    Assert.assertTrue(\"Output must have one character. Since the first character is the max 3 byte \" +\n            \"UTF-8 character, it should be incremented to the lowest 4 byte UTF-8 character\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n    Assert.assertNull(\"An upper bound doesn't exist since the first two characters are max UTF-8 \" +\n        \"characters\", truncateStringMax(Literal.of(test5), 1));\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test6), 2).value(), test6) >= 0);\n    Assert.assertTrue(\"Test 4 byte UTF-8 character increment. Output must have one character with \" +\n        \"the first character incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test6), 1).value(), test6_2_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test7), 2).value(), test7) >= 0);\n    Assert.assertTrue(\"Test input with multiple 4 byte UTF-8 character where the second unicode \" +\n        \"character should be incremented\", cmp.compare(\n            truncateStringMax(Literal.of(test7), 2).value(), test7_2_expected) == 0);\n    Assert.assertTrue(\"Test input with multiple 4 byte UTF-8 character where the first unicode \" +\n        \"character should be incremented\", cmp.compare(\n            truncateStringMax(Literal.of(test7), 1).value(), test7_1_expected) == 0);\n  }\n","date":"2019-08-02 04:50:10","endLine":190,"groupId":"101769","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTruncateStringMax","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/af/304dac35809b92d0716a6b2e0a2478d1867384.src","preCode":"  public void testTruncateStringMax() {\n    String test1 = \"���������������������������������������������������������������\";\n    \r\n    String test1_2_expected = \"������������������\";\n    String test1_3_expected = \"���������������������������\";\n    String test2 = \"������������������������������������������������������������������������������������������������������������������������������������\";\n    String test2_7_expected = \"���������������������������������������������\";\n    String test3 = \"a������������������\\uFFFF\\uFFFF\";\n    String test3_3_expected = \"a������������������\";\n    \r\n    String test4 = \"\\uFFFF\\uFFFF\";\n    String test4_1_expected = \"\\uD800\\uDC00\";\n    \r\n    String test5 = \"\\uDBFF\\uDFFF\\uDBFF\\uDFFF\";\n    String test6 = \"\\uD800\\uDFFF\\uD800\\uDFFF\";\n    \r\n    String test6_2_expected = \"\\uD801\\uDC00\";\n\n    Comparator<CharSequence> cmp = Literal.of(test1).comparator();\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 4).value(), test1) >= 0);\n    Assert.assertTrue(\"No truncation required as truncate length is equal to the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 7).value(), test1) == 0);\n    Assert.assertTrue(\"Output must have two characters and the second character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 2).value(), test1_2_expected) == 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test1), 3).value(), test1_3_expected) == 0);\n    Assert.assertTrue(\"No truncation required as truncate length is greater than the input size\",\n        cmp.compare(truncateStringMax(Literal.of(test1), 8).value(), test1) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test2), 8).value(), test2) >= 0);\n    Assert.assertTrue(\"Output must have seven characters and the seventh character of the input \" +\n        \"must be incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test2), 7).value(), test2_7_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper \" +\n        \"bound\", cmp.compare(truncateStringMax(Literal.of(test3), 3).value(), test3) >= 0);\n    Assert.assertTrue(\"Output must have three characters and the third character of the input must \" +\n        \"be incremented. The second perceivable character in this string is actually a glyph. It consists of \" +\n        \"two unicode characters\", cmp.compare(\n        truncateStringMax(Literal.of(test3), 3).value(), test3_3_expected) == 0);\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4) >= 0);\n    Assert.assertTrue(\"Output must have one character. Since the first character is the max 3 byte \" +\n            \"UTF-8 character, it should be incremented to the lowest 4 byte UTF-8 character\",\n        cmp.compare(truncateStringMax(Literal.of(test4), 1).value(), test4_1_expected) == 0);\n    Assert.assertNull(\"An upper bound doesn't exist since the first two characters are max UTF-8 \" +\n        \"characters\", truncateStringMax(Literal.of(test5), 1));\n    Assert.assertTrue(\"Truncated upper bound should be greater than or equal to the actual upper bound\",\n        cmp.compare(truncateStringMax(Literal.of(test6), 2).value(), test6) >= 0);\n    Assert.assertTrue(\"Test 4 byte UTF-8 character increment. Output must have one character with \" +\n        \"the first character incremented\", cmp.compare(\n        truncateStringMax(Literal.of(test6), 1).value(), test6_2_expected) == 0);\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMetricsTruncation.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"M"}],"commitId":"30d45f88d1f10afdef0884b89860e6fd1f25365d","commitMessage":"@@@Fix truncateStringMax in UnicodeUtil (#334)\n\nFixes #328.  fixes #329.\n\nIndex to codePointAt should be the offset calculated by code points\n","date":"2019-08-02 04:50:10","modifiedFileCount":"2","status":"M","submitter":"Vinitha Gankidi"}]
