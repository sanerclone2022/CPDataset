[{"authorTime":"2020-07-28 01:04:13","codes":[{"authorDate":"2020-06-03 03:43:03","commitOrder":3,"curCode":"  public void dataFilesCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","date":"2020-06-03 03:43:03","endLine":405,"groupId":"2498","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"dataFilesCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/49/f0c4a85a3edf5da85be9ae63a1afc0b0e4613f.src","preCode":"  public void dataFilesCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"NB"},{"authorDate":"2020-07-28 01:04:13","commitOrder":3,"curCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","date":"2020-07-28 01:04:13","endLine":539,"groupId":"2498","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"dataFilesCleanupWithParallelTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/40/bf9e72b654a91defade78293e1c6158c5c11a8.src","preCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":479,"status":"B"}],"commitId":"ceb6533a593989a86c78277205c0c83108104ded","commitMessage":"@@@Support parallel deletes in snapshot expiration (#1187)\n\n","date":"2020-07-28 01:04:13","modifiedFileCount":"3","status":"M","submitter":"Filip Bocse"},{"authorTime":"2020-08-12 01:20:43","codes":[{"authorDate":"2020-06-03 03:43:03","commitOrder":4,"curCode":"  public void dataFilesCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","date":"2020-06-03 03:43:03","endLine":405,"groupId":"102003","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"dataFilesCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/49/f0c4a85a3edf5da85be9ae63a1afc0b0e4613f.src","preCode":"  public void dataFilesCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"N"},{"authorDate":"2020-08-12 01:20:43","commitOrder":4,"curCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","date":"2020-08-12 01:20:43","endLine":539,"groupId":"102003","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"dataFilesCleanupWithParallelTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e9/152561f959f1004e1666412cc4bb73a10b81e5.src","preCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":479,"status":"M"}],"commitId":"209eb53d7ff2e1132f29c418da2e4fec22c10500","commitMessage":"@@@API: Rename ExpireSnapshots executeWith to executeDeleteWith (#1322)\n\nThe executor passed in executeWith is only used for deletes so we will rename it\nto executeDeleteWith. The JavaDoc already states it will only effect deletes and\nthe implementation already match this name so no other changes are needed.","date":"2020-08-12 01:20:43","modifiedFileCount":"3","status":"M","submitter":"Russell Spitzer"}]
