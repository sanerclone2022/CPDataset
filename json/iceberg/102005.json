[{"authorTime":"2020-07-29 03:40:50","codes":[{"authorDate":"2020-07-28 01:04:13","commitOrder":2,"curCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","date":"2020-07-28 01:04:13","endLine":539,"groupId":"2498","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"dataFilesCleanupWithParallelTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/40/bf9e72b654a91defade78293e1c6158c5c11a8.src","preCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":479,"status":"NB"},{"authorDate":"2020-07-29 03:40:50","commitOrder":2,"curCode":"  public void noDataFileCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .cleanExpiredFiles(false)\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"No files should have been deleted\", deletedFiles.isEmpty());\n  }\n","date":"2020-07-29 03:40:50","endLine":573,"groupId":"2472","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"noDataFileCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f3/09336c124b49e5e24da60a97e7dfdebe798382.src","preCode":"  public void noDataFileCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .cleanExpiredFiles(false)\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"No files should have been deleted\", deletedFiles.isEmpty());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":542,"status":"B"}],"commitId":"c5b08eb228499db089d5d4698dd241a60bad955c","commitMessage":"@@@Core: Allow ExpireSnapshots to run without cleaning files (#1244)\n\nPreviously ExpireSnapshots would always follow the expiration of Snapshots\nwith a deletion of local DataFiles and Manifests which were no longer relevant\nto the Table. This patch introduces an API to skip this deletion phase.  which\nwas always run locally.  and instead just expire the snapshots. This allows for\nfuture implementations which can read and remove unused files in parallel or\non distributed frameworks.","date":"2020-07-29 03:40:50","modifiedFileCount":"3","status":"M","submitter":"Russell Spitzer"},{"authorTime":"2020-07-29 03:40:50","codes":[{"authorDate":"2020-08-12 01:20:43","commitOrder":3,"curCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeDeleteWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","date":"2020-08-12 01:20:43","endLine":539,"groupId":"102005","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"dataFilesCleanupWithParallelTasks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e9/152561f959f1004e1666412cc4bb73a10b81e5.src","preCode":"  public void dataFilesCleanupWithParallelTasks() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n    long thirdSnapshotId = table.currentSnapshot().snapshotId();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n    long fourthSnapshotId = table.currentSnapshot().snapshotId();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    List<ManifestFile> manifests = table.currentSnapshot().dataManifests();\n\n    ManifestFile newManifest = writeManifest(\n        \"manifest-file-1.avro\",\n        manifestEntry(Status.EXISTING, thirdSnapshotId, FILE_C),\n        manifestEntry(Status.EXISTING, fourthSnapshotId, FILE_D));\n\n    RewriteManifests rewriteManifests = table.rewriteManifests();\n    manifests.forEach(rewriteManifests::deleteManifest);\n    rewriteManifests.addManifest(newManifest);\n    rewriteManifests.commit();\n\n    Set<String> deletedFiles = Sets.newHashSet();\n    Set<String> deleteThreads = ConcurrentHashMap.newKeySet();\n    AtomicInteger deleteThreadsIndex = new AtomicInteger(0);\n\n    table.expireSnapshots()\n        .executeWith(Executors.newFixedThreadPool(4, runnable -> {\n          Thread thread = new Thread(runnable);\n          thread.setName(\"remove-snapshot-\" + deleteThreadsIndex.getAndIncrement());\n          thread.setDaemon(true); \r\n          return thread;\n        }))\n        .expireOlderThan(t4)\n        .deleteWith(s -> {\n          deleteThreads.add(Thread.currentThread().getName());\n          deletedFiles.add(s);\n        })\n        .commit();\n\n    \r\n    Assert.assertEquals(deleteThreads,\n            Sets.newHashSet(\"remove-snapshot-0\", \"remove-snapshot-1\", \"remove-snapshot-2\", \"remove-snapshot-3\"));\n\n    Assert.assertTrue(\"FILE_A should be deleted\", deletedFiles.contains(FILE_A.path().toString()));\n    Assert.assertTrue(\"FILE_B should be deleted\", deletedFiles.contains(FILE_B.path().toString()));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":479,"status":"M"},{"authorDate":"2020-07-29 03:40:50","commitOrder":3,"curCode":"  public void noDataFileCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .cleanExpiredFiles(false)\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"No files should have been deleted\", deletedFiles.isEmpty());\n  }\n","date":"2020-07-29 03:40:50","endLine":573,"groupId":"102005","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"noDataFileCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f3/09336c124b49e5e24da60a97e7dfdebe798382.src","preCode":"  public void noDataFileCleanup() throws IOException {\n    table.newFastAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.newFastAppend()\n        .appendFile(FILE_B)\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_B), ImmutableSet.of(FILE_D))\n        .commit();\n\n    table.newRewrite()\n        .rewriteFiles(ImmutableSet.of(FILE_A), ImmutableSet.of(FILE_C))\n        .commit();\n\n    long t4 = System.currentTimeMillis();\n    while (t4 <= table.currentSnapshot().timestampMillis()) {\n      t4 = System.currentTimeMillis();\n    }\n\n    Set<String> deletedFiles = Sets.newHashSet();\n\n    table.expireSnapshots()\n        .cleanExpiredFiles(false)\n        .expireOlderThan(t4)\n        .deleteWith(deletedFiles::add)\n        .commit();\n\n    Assert.assertTrue(\"No files should have been deleted\", deletedFiles.isEmpty());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestRemoveSnapshots.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":542,"status":"N"}],"commitId":"209eb53d7ff2e1132f29c418da2e4fec22c10500","commitMessage":"@@@API: Rename ExpireSnapshots executeWith to executeDeleteWith (#1322)\n\nThe executor passed in executeWith is only used for deletes so we will rename it\nto executeDeleteWith. The JavaDoc already states it will only effect deletes and\nthe implementation already match this name so no other changes are needed.","date":"2020-08-12 01:20:43","modifiedFileCount":"3","status":"M","submitter":"Russell Spitzer"}]
