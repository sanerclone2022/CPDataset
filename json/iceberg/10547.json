[{"authorTime":"2021-06-24 18:11:06","codes":[{"authorDate":"2021-06-24 18:11:06","commitOrder":7,"curCode":"  BaseDataReader(CombinedScanTask task, FileIO io, EncryptionManager encryptionManager) {\n    this.tasks = task.files().iterator();\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    task.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(task.files().size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.inputFiles = ImmutableMap.copyOf(files);\n\n    this.currentIterator = CloseableIterator.empty();\n  }\n","date":"2021-06-24 18:11:06","endLine":82,"groupId":"1500","id":1,"instanceNumber":1,"isCurCommit":1,"methodName":"BaseDataReader","params":"(CombinedScanTasktask@FileIOio@EncryptionManagerencryptionManager)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/c8/b33dd2f7067a7deb8aafd32e5487f6c1601664.src","preCode":"  BaseDataReader(CombinedScanTask task, FileIO io, EncryptionManager encryptionManager) {\n    this.tasks = task.files().iterator();\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    task.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(task.files().size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.inputFiles = ImmutableMap.copyOf(files);\n\n    this.currentIterator = CloseableIterator.empty();\n  }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/source/BaseDataReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"MB"},{"authorDate":"2021-06-24 18:11:06","commitOrder":7,"curCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      this.fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","date":"2021-06-24 18:11:06","endLine":235,"groupId":"5102","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"VectorizedCombinedScanIterator","params":"(CloseableIterable<CombinedScanTask>tasks@SchemaexpectedSchema@StringnameMapping@FileIOio@EncryptionManagerencryptionManager@booleancaseSensitive@intbatchSize@booleanreuseContainers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/50/3a273fe477143fdb198a0d0ba9ec0e1b5b982c.src","preCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      this.fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","realPath":"arrow/src/main/java/org/apache/iceberg/arrow/vectorized/ArrowReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"MB"}],"commitId":"92a264b4406fd933eed5685d25defc9e0dcb8617","commitMessage":"@@@Use bulk decryption interface in ArrowReader (#2720)\n\n","date":"2021-06-24 18:11:06","modifiedFileCount":"3","status":"M","submitter":"Eduard Tudenh?fner"},{"authorTime":"2021-09-18 02:36:45","codes":[{"authorDate":"2021-06-24 18:11:06","commitOrder":8,"curCode":"  BaseDataReader(CombinedScanTask task, FileIO io, EncryptionManager encryptionManager) {\n    this.tasks = task.files().iterator();\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    task.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(task.files().size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.inputFiles = ImmutableMap.copyOf(files);\n\n    this.currentIterator = CloseableIterator.empty();\n  }\n","date":"2021-06-24 18:11:06","endLine":82,"groupId":"10547","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"BaseDataReader","params":"(CombinedScanTasktask@FileIOio@EncryptionManagerencryptionManager)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/c8/b33dd2f7067a7deb8aafd32e5487f6c1601664.src","preCode":"  BaseDataReader(CombinedScanTask task, FileIO io, EncryptionManager encryptionManager) {\n    this.tasks = task.files().iterator();\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    task.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(task.files().size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.inputFiles = ImmutableMap.copyOf(files);\n\n    this.currentIterator = CloseableIterator.empty();\n  }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/source/BaseDataReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"N"},{"authorDate":"2021-09-18 02:36:45","commitOrder":8,"curCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      List<FileScanTask> fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      if (fileTasks.stream().anyMatch(TableScanUtil::hasDeletes)) {\n        throw new UnsupportedOperationException(\"Cannot read files that require applying delete files\");\n      }\n\n      if (expectedSchema.columns().isEmpty()) {\n        throw new UnsupportedOperationException(\"Cannot read without at least one projected column\");\n      }\n\n      Set<TypeID> unsupportedTypes = Sets.difference(\n          expectedSchema.columns().stream().map(c -> c.type().typeId()).collect(Collectors.toSet()),\n          SUPPORTED_TYPES);\n      if (!unsupportedTypes.isEmpty()) {\n        throw new UnsupportedOperationException(\"Cannot read unsupported column types: \" + unsupportedTypes);\n      }\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .map(FileScanTask::file)\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","date":"2021-09-18 02:36:45","endLine":282,"groupId":"10547","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"VectorizedCombinedScanIterator","params":"(CloseableIterable<CombinedScanTask>tasks@SchemaexpectedSchema@StringnameMapping@FileIOio@EncryptionManagerencryptionManager@booleancaseSensitive@intbatchSize@booleanreuseContainers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f0/9774e9f6ce7c2212df0d1d57a786be0631730e.src","preCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      this.fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","realPath":"arrow/src/main/java/org/apache/iceberg/arrow/vectorized/ArrowReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"}],"commitId":"f220f2534f3ae6e77c4ab9cae2ebe02185655d6a","commitMessage":"@@@Arrow: Fix assertions and correctness checks (#2933)\n\n","date":"2021-09-18 02:36:45","modifiedFileCount":"2","status":"M","submitter":"mayursrivastava"}]
