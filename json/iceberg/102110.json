[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"  public static <T, F> T visit(Schema schema, AvroCustomOrderSchemaVisitor<T, F> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<Supplier<F>> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(new VisitFieldFuture<>(field, visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, Iterables.transform(results, Supplier::get));\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<Supplier<T>> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(new VisitFuture<>(type, visitor));\n        }\n        return visitor.union(schema, Iterables.transform(options, Supplier::get));\n\n      case ARRAY:\n        return visitor.array(schema, new VisitFuture<>(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, new VisitFuture<>(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","date":"2019-03-21 07:25:05","endLine":70,"groupId":"4162","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"visit","params":"(Schemaschema@AvroCustomOrderSchemaVisitor<T@F>visitor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/3d/6779614111b38da333416ea6c0324daa75584a.src","preCode":"  public static <T, F> T visit(Schema schema, AvroCustomOrderSchemaVisitor<T, F> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<Supplier<F>> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(new VisitFieldFuture<>(field, visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, Iterables.transform(results, Supplier::get));\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<Supplier<T>> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(new VisitFuture<>(type, visitor));\n        }\n        return visitor.union(schema, Iterables.transform(options, Supplier::get));\n\n      case ARRAY:\n        return visitor.array(schema, new VisitFuture<>(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, new VisitFuture<>(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/AvroCustomOrderSchemaVisitor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":31,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"  public static <T> T visit(Schema schema, AvroSchemaVisitor<T> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(visit(field.schema(), visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, results);\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<T> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(visit(type, visitor));\n        }\n        return visitor.union(schema, options);\n\n      case ARRAY:\n        return visitor.array(schema, visit(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, visit(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","date":"2019-03-21 07:25:05","endLine":68,"groupId":"3347","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"visit","params":"(Schemaschema@AvroSchemaVisitor<T>visitor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/c2/011b5cae7f242d695bef05d0723704d17fc583.src","preCode":"  public static <T> T visit(Schema schema, AvroSchemaVisitor<T> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(visit(field.schema(), visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, results);\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<T> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(visit(type, visitor));\n        }\n        return visitor.union(schema, options);\n\n      case ARRAY:\n        return visitor.array(schema, visit(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, visit(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/AvroSchemaVisitor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":29,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-10-23 01:47:52","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"  public static <T, F> T visit(Schema schema, AvroCustomOrderSchemaVisitor<T, F> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<Supplier<F>> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(new VisitFieldFuture<>(field, visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, Iterables.transform(results, Supplier::get));\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<Supplier<T>> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(new VisitFuture<>(type, visitor));\n        }\n        return visitor.union(schema, Iterables.transform(options, Supplier::get));\n\n      case ARRAY:\n        return visitor.array(schema, new VisitFuture<>(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, new VisitFuture<>(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","date":"2019-03-21 07:25:05","endLine":70,"groupId":"4162","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"visit","params":"(Schemaschema@AvroCustomOrderSchemaVisitor<T@F>visitor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/3d/6779614111b38da333416ea6c0324daa75584a.src","preCode":"  public static <T, F> T visit(Schema schema, AvroCustomOrderSchemaVisitor<T, F> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<Supplier<F>> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(new VisitFieldFuture<>(field, visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, Iterables.transform(results, Supplier::get));\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<Supplier<T>> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(new VisitFuture<>(type, visitor));\n        }\n        return visitor.union(schema, Iterables.transform(options, Supplier::get));\n\n      case ARRAY:\n        return visitor.array(schema, new VisitFuture<>(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, new VisitFuture<>(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/AvroCustomOrderSchemaVisitor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":31,"status":"N"},{"authorDate":"2019-10-23 01:47:52","commitOrder":2,"curCode":"  public static <T> T visit(Schema schema, AvroSchemaVisitor<T> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          T result = visitWithName(field.name(), field.schema(), visitor);\n          results.add(result);\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, results);\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<T> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(visit(type, visitor));\n        }\n        return visitor.union(schema, options);\n\n      case ARRAY:\n        if (schema.getLogicalType() instanceof LogicalMap || AvroSchemaUtil.isKeyValueSchema(schema.getElementType())) {\n          return visitor.array(schema, visit(schema.getElementType(), visitor));\n        } else {\n          return visitor.array(schema, visitWithName(\"element\", schema.getElementType(), visitor));\n        }\n\n      case MAP:\n        return visitor.map(schema, visitWithName(\"value\", schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","date":"2019-10-23 01:47:52","endLine":73,"groupId":"3347","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"visit","params":"(Schemaschema@AvroSchemaVisitor<T>visitor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/15/d670d45fd60f09da5ec1c66a9e2009a0455667.src","preCode":"  public static <T> T visit(Schema schema, AvroSchemaVisitor<T> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(visit(field.schema(), visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, results);\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<T> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(visit(type, visitor));\n        }\n        return visitor.union(schema, options);\n\n      case ARRAY:\n        return visitor.array(schema, visit(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, visit(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/AvroSchemaVisitor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":29,"status":"M"}],"commitId":"9f1598e7f9c3409e2ce38365f928ad6d5d58e485","commitMessage":"@@@Avro: Add name to ID mapping for files with name-based schemas (#207)\n\nFixes #40.","date":"2019-10-23 01:47:52","modifiedFileCount":"7","status":"M","submitter":"Ratandeep Ratti"},{"authorTime":"2019-11-09 09:24:29","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":3,"curCode":"  public static <T, F> T visit(Schema schema, AvroCustomOrderSchemaVisitor<T, F> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<Supplier<F>> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(new VisitFieldFuture<>(field, visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, Iterables.transform(results, Supplier::get));\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<Supplier<T>> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(new VisitFuture<>(type, visitor));\n        }\n        return visitor.union(schema, Iterables.transform(options, Supplier::get));\n\n      case ARRAY:\n        return visitor.array(schema, new VisitFuture<>(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, new VisitFuture<>(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","date":"2019-03-21 07:25:05","endLine":70,"groupId":"102110","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"visit","params":"(Schemaschema@AvroCustomOrderSchemaVisitor<T@F>visitor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/3d/6779614111b38da333416ea6c0324daa75584a.src","preCode":"  public static <T, F> T visit(Schema schema, AvroCustomOrderSchemaVisitor<T, F> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<Supplier<F>> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          results.add(new VisitFieldFuture<>(field, visitor));\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, Iterables.transform(results, Supplier::get));\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<Supplier<T>> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(new VisitFuture<>(type, visitor));\n        }\n        return visitor.union(schema, Iterables.transform(options, Supplier::get));\n\n      case ARRAY:\n        return visitor.array(schema, new VisitFuture<>(schema.getElementType(), visitor));\n\n      case MAP:\n        return visitor.map(schema, new VisitFuture<>(schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/AvroCustomOrderSchemaVisitor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":31,"status":"N"},{"authorDate":"2019-11-09 09:24:29","commitOrder":3,"curCode":"  public static <T> T visit(Schema schema, AvroSchemaVisitor<T> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          T result = visitWithName(field.name(), field.schema(), visitor);\n          results.add(result);\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, results);\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<T> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(visit(type, visitor));\n        }\n        return visitor.union(schema, options);\n\n      case ARRAY:\n        if (schema.getLogicalType() instanceof LogicalMap) {\n          return visitor.array(schema, visit(schema.getElementType(), visitor));\n        } else {\n          return visitor.array(schema, visitWithName(\"element\", schema.getElementType(), visitor));\n        }\n\n      case MAP:\n        return visitor.map(schema, visitWithName(\"value\", schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","date":"2019-11-09 09:24:29","endLine":73,"groupId":"102110","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"visit","params":"(Schemaschema@AvroSchemaVisitor<T>visitor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/26/31983d42a58ce60e5490b00c319e3f103e06c1.src","preCode":"  public static <T> T visit(Schema schema, AvroSchemaVisitor<T> visitor) {\n    switch (schema.getType()) {\n      case RECORD:\n        \r\n        String name = schema.getFullName();\n        Preconditions.checkState(!visitor.recordLevels.contains(name),\n            \"Cannot process recursive Avro record %s\", name);\n\n        visitor.recordLevels.push(name);\n\n        List<Schema.Field> fields = schema.getFields();\n        List<String> names = Lists.newArrayListWithExpectedSize(fields.size());\n        List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n        for (Schema.Field field : schema.getFields()) {\n          names.add(field.name());\n          T result = visitWithName(field.name(), field.schema(), visitor);\n          results.add(result);\n        }\n\n        visitor.recordLevels.pop();\n\n        return visitor.record(schema, names, results);\n\n      case UNION:\n        List<Schema> types = schema.getTypes();\n        List<T> options = Lists.newArrayListWithExpectedSize(types.size());\n        for (Schema type : types) {\n          options.add(visit(type, visitor));\n        }\n        return visitor.union(schema, options);\n\n      case ARRAY:\n        if (schema.getLogicalType() instanceof LogicalMap || AvroSchemaUtil.isKeyValueSchema(schema.getElementType())) {\n          return visitor.array(schema, visit(schema.getElementType(), visitor));\n        } else {\n          return visitor.array(schema, visitWithName(\"element\", schema.getElementType(), visitor));\n        }\n\n      case MAP:\n        return visitor.map(schema, visitWithName(\"value\", schema.getValueType(), visitor));\n\n      default:\n        return visitor.primitive(schema);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/AvroSchemaVisitor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":29,"status":"M"}],"commitId":"f1cba908f7e7aae26f901b89879fff0bd4278efa","commitMessage":"@@@Fix reading Avro with arrays of structs with 2 fields (#618)\n\nFixes #605","date":"2019-11-09 09:24:29","modifiedFileCount":"4","status":"M","submitter":"Ratandeep Ratti"}]
