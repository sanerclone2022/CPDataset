[{"authorTime":"2020-06-16 23:27:45","codes":[{"authorDate":"2020-06-16 23:27:45","commitOrder":2,"curCode":"  private boolean manifestHasDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestReader<F> reader, StructLikeWrapper partitionWrapper) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    boolean hasDeletedFiles = false;\n    for (ManifestEntry<F> entry : reader.entries()) {\n      F file = entry.file();\n      boolean fileDelete = deletePaths.contains(file.path()) ||\n          dropPartitions.contains(partitionWrapper.set(file.partition())) ||\n          (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n      if (fileDelete || inclusive.eval(file.partition())) {\n        ValidationException.check(\n            fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n            \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n            this.deleteExpression, file.path());\n\n        hasDeletedFiles = true;\n        if (failAnyDelete) {\n          throw new DeleteException(reader.spec().partitionToPath(file.partition()));\n        }\n        break; \r\n      }\n    }\n    return hasDeletedFiles;\n  }\n","date":"2020-06-16 23:27:45","endLine":368,"groupId":"991","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"manifestHasDeletedFiles","params":"(StrictMetricsEvaluatormetricsEvaluator@ManifestReader<F>reader@StructLikeWrapperpartitionWrapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/cc/b0fc2286fa7dddc6012598eef645b6b0b3fef8.src","preCode":"  private boolean manifestHasDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestReader<F> reader, StructLikeWrapper partitionWrapper) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    boolean hasDeletedFiles = false;\n    for (ManifestEntry<F> entry : reader.entries()) {\n      F file = entry.file();\n      boolean fileDelete = deletePaths.contains(file.path()) ||\n          dropPartitions.contains(partitionWrapper.set(file.partition())) ||\n          (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n      if (fileDelete || inclusive.eval(file.partition())) {\n        ValidationException.check(\n            fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n            \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n            this.deleteExpression, file.path());\n\n        hasDeletedFiles = true;\n        if (failAnyDelete) {\n          throw new DeleteException(reader.spec().partitionToPath(file.partition()));\n        }\n        break; \r\n      }\n    }\n    return hasDeletedFiles;\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestFilterManager.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":343,"status":"MB"},{"authorDate":"2020-06-16 23:27:45","commitOrder":2,"curCode":"  private ManifestFile filterManifestWithDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestFile manifest, ManifestReader<F> reader,\n      StructLikeWrapper partitionWrapper) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    \r\n    \r\n    List<F> deletedFiles = Lists.newArrayList();\n    Set<CharSequenceWrapper> deletedPaths = Sets.newHashSet();\n\n    try {\n      ManifestWriter<F> writer = newManifestWriter(reader.spec());\n      try {\n        reader.entries().forEach(entry -> {\n          F file = entry.file();\n          boolean fileDelete = deletePaths.contains(file.path()) ||\n              dropPartitions.contains(partitionWrapper.set(file.partition())) ||\n              (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n          if (entry.status() != ManifestEntry.Status.DELETED) {\n            if (fileDelete || inclusive.eval(file.partition())) {\n              ValidationException.check(\n                  fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n                  \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n                  this.deleteExpression, file.path());\n\n              writer.delete(entry);\n\n              CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(entry.file().path());\n              if (deletedPaths.contains(wrapper)) {\n                LOG.warn(\"Deleting a duplicate path from manifest {}: {}\",\n                    manifest.path(), wrapper.get());\n                duplicateDeleteCount += 1;\n              } else {\n                \r\n                \r\n                deletedFiles.add(entry.file().copyWithoutStats());\n              }\n              deletedPaths.add(wrapper);\n\n            } else {\n              writer.existing(entry);\n            }\n          }\n        });\n      } finally {\n        writer.close();\n      }\n\n      \r\n      ManifestFile filtered = writer.toManifestFile();\n\n      \r\n      filteredManifests.put(manifest, filtered);\n      filteredManifestToDeletedFiles.put(filtered, deletedFiles);\n\n      return filtered;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Failed to close manifest writer\", e);\n    }\n  }\n","date":"2020-06-16 23:27:45","endLine":431,"groupId":"2144","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"filterManifestWithDeletedFiles","params":"(StrictMetricsEvaluatormetricsEvaluator@ManifestFilemanifest@ManifestReader<F>reader@StructLikeWrapperpartitionWrapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/cc/b0fc2286fa7dddc6012598eef645b6b0b3fef8.src","preCode":"  private ManifestFile filterManifestWithDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestFile manifest, ManifestReader<F> reader,\n      StructLikeWrapper partitionWrapper) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    \r\n    \r\n    List<F> deletedFiles = Lists.newArrayList();\n    Set<CharSequenceWrapper> deletedPaths = Sets.newHashSet();\n\n    try {\n      ManifestWriter<F> writer = newManifestWriter(reader.spec());\n      try {\n        reader.entries().forEach(entry -> {\n          F file = entry.file();\n          boolean fileDelete = deletePaths.contains(file.path()) ||\n              dropPartitions.contains(partitionWrapper.set(file.partition())) ||\n              (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n          if (entry.status() != ManifestEntry.Status.DELETED) {\n            if (fileDelete || inclusive.eval(file.partition())) {\n              ValidationException.check(\n                  fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n                  \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n                  this.deleteExpression, file.path());\n\n              writer.delete(entry);\n\n              CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(entry.file().path());\n              if (deletedPaths.contains(wrapper)) {\n                LOG.warn(\"Deleting a duplicate path from manifest {}: {}\",\n                    manifest.path(), wrapper.get());\n                duplicateDeleteCount += 1;\n              } else {\n                \r\n                \r\n                deletedFiles.add(entry.file().copyWithoutStats());\n              }\n              deletedPaths.add(wrapper);\n\n            } else {\n              writer.existing(entry);\n            }\n          }\n        });\n      } finally {\n        writer.close();\n      }\n\n      \r\n      ManifestFile filtered = writer.toManifestFile();\n\n      \r\n      filteredManifests.put(manifest, filtered);\n      filteredManifestToDeletedFiles.put(filtered, deletedFiles);\n\n      return filtered;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Failed to close manifest writer\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestFilterManager.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"MB"}],"commitId":"e0180f783f62f4cd0f30b13a62ef5fcd1cc6f3b9","commitMessage":"@@@Support DeleteFile in MergingSnapshotProducer (#1105)\n\n","date":"2020-06-16 23:27:45","modifiedFileCount":"13","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-08-13 02:09:02","codes":[{"authorDate":"2020-08-13 02:09:02","commitOrder":3,"curCode":"  private boolean manifestHasDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestReader<F> reader) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    boolean hasDeletedFiles = false;\n    for (ManifestEntry<F> entry : reader.entries()) {\n      F file = entry.file();\n      boolean fileDelete = deletePaths.contains(file.path()) ||\n          dropPartitions.contains(file.specId(), file.partition()) ||\n          (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n      if (fileDelete || inclusive.eval(file.partition())) {\n        ValidationException.check(\n            fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n            \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n            this.deleteExpression, file.path());\n\n        hasDeletedFiles = true;\n        if (failAnyDelete) {\n          throw new DeleteException(reader.spec().partitionToPath(file.partition()));\n        }\n        break; \r\n      }\n    }\n    return hasDeletedFiles;\n  }\n","date":"2020-08-13 02:09:02","endLine":365,"groupId":"991","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"manifestHasDeletedFiles","params":"(StrictMetricsEvaluatormetricsEvaluator@ManifestReader<F>reader)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/15/c01e9eb6bd39d69ee604529710429c79a1bfb5.src","preCode":"  private boolean manifestHasDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestReader<F> reader, StructLikeWrapper partitionWrapper) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    boolean hasDeletedFiles = false;\n    for (ManifestEntry<F> entry : reader.entries()) {\n      F file = entry.file();\n      boolean fileDelete = deletePaths.contains(file.path()) ||\n          dropPartitions.contains(partitionWrapper.set(file.partition())) ||\n          (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n      if (fileDelete || inclusive.eval(file.partition())) {\n        ValidationException.check(\n            fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n            \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n            this.deleteExpression, file.path());\n\n        hasDeletedFiles = true;\n        if (failAnyDelete) {\n          throw new DeleteException(reader.spec().partitionToPath(file.partition()));\n        }\n        break; \r\n      }\n    }\n    return hasDeletedFiles;\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestFilterManager.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"},{"authorDate":"2020-08-13 02:09:02","commitOrder":3,"curCode":"  private ManifestFile filterManifestWithDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestFile manifest, ManifestReader<F> reader) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    \r\n    \r\n    List<F> deletedFiles = Lists.newArrayList();\n    Set<CharSequenceWrapper> deletedPaths = Sets.newHashSet();\n\n    try {\n      ManifestWriter<F> writer = newManifestWriter(reader.spec());\n      try {\n        reader.entries().forEach(entry -> {\n          F file = entry.file();\n          boolean fileDelete = deletePaths.contains(file.path()) ||\n              dropPartitions.contains(file.specId(), file.partition()) ||\n              (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n          if (entry.status() != ManifestEntry.Status.DELETED) {\n            if (fileDelete || inclusive.eval(file.partition())) {\n              ValidationException.check(\n                  fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n                  \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n                  this.deleteExpression, file.path());\n\n              writer.delete(entry);\n\n              CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(entry.file().path());\n              if (deletedPaths.contains(wrapper)) {\n                LOG.warn(\"Deleting a duplicate path from manifest {}: {}\",\n                    manifest.path(), wrapper.get());\n                duplicateDeleteCount += 1;\n              } else {\n                \r\n                \r\n                deletedFiles.add(entry.file().copyWithoutStats());\n              }\n              deletedPaths.add(wrapper);\n\n            } else {\n              writer.existing(entry);\n            }\n          }\n        });\n      } finally {\n        writer.close();\n      }\n\n      \r\n      ManifestFile filtered = writer.toManifestFile();\n\n      \r\n      filteredManifests.put(manifest, filtered);\n      filteredManifestToDeletedFiles.put(filtered, deletedFiles);\n\n      return filtered;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Failed to close manifest writer\", e);\n    }\n  }\n","date":"2020-08-13 02:09:02","endLine":427,"groupId":"2144","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"filterManifestWithDeletedFiles","params":"(StrictMetricsEvaluatormetricsEvaluator@ManifestFilemanifest@ManifestReader<F>reader)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/15/c01e9eb6bd39d69ee604529710429c79a1bfb5.src","preCode":"  private ManifestFile filterManifestWithDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestFile manifest, ManifestReader<F> reader,\n      StructLikeWrapper partitionWrapper) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    \r\n    \r\n    List<F> deletedFiles = Lists.newArrayList();\n    Set<CharSequenceWrapper> deletedPaths = Sets.newHashSet();\n\n    try {\n      ManifestWriter<F> writer = newManifestWriter(reader.spec());\n      try {\n        reader.entries().forEach(entry -> {\n          F file = entry.file();\n          boolean fileDelete = deletePaths.contains(file.path()) ||\n              dropPartitions.contains(partitionWrapper.set(file.partition())) ||\n              (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n          if (entry.status() != ManifestEntry.Status.DELETED) {\n            if (fileDelete || inclusive.eval(file.partition())) {\n              ValidationException.check(\n                  fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n                  \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n                  this.deleteExpression, file.path());\n\n              writer.delete(entry);\n\n              CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(entry.file().path());\n              if (deletedPaths.contains(wrapper)) {\n                LOG.warn(\"Deleting a duplicate path from manifest {}: {}\",\n                    manifest.path(), wrapper.get());\n                duplicateDeleteCount += 1;\n              } else {\n                \r\n                \r\n                deletedFiles.add(entry.file().copyWithoutStats());\n              }\n              deletedPaths.add(wrapper);\n\n            } else {\n              writer.existing(entry);\n            }\n          }\n        });\n      } finally {\n        writer.close();\n      }\n\n      \r\n      ManifestFile filtered = writer.toManifestFile();\n\n      \r\n      filteredManifests.put(manifest, filtered);\n      filteredManifestToDeletedFiles.put(filtered, deletedFiles);\n\n      return filtered;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Failed to close manifest writer\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestFilterManager.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"M"}],"commitId":"01986ea77b761fe2190699bba6f3dbb25fa93042","commitMessage":"@@@Core: Fix partition sets (#1308)\n\n","date":"2020-08-13 02:09:02","modifiedFileCount":"9","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-09-23 06:35:35","codes":[{"authorDate":"2020-08-13 02:09:02","commitOrder":4,"curCode":"  private boolean manifestHasDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestReader<F> reader) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    boolean hasDeletedFiles = false;\n    for (ManifestEntry<F> entry : reader.entries()) {\n      F file = entry.file();\n      boolean fileDelete = deletePaths.contains(file.path()) ||\n          dropPartitions.contains(file.specId(), file.partition()) ||\n          (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n      if (fileDelete || inclusive.eval(file.partition())) {\n        ValidationException.check(\n            fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n            \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n            this.deleteExpression, file.path());\n\n        hasDeletedFiles = true;\n        if (failAnyDelete) {\n          throw new DeleteException(reader.spec().partitionToPath(file.partition()));\n        }\n        break; \r\n      }\n    }\n    return hasDeletedFiles;\n  }\n","date":"2020-08-13 02:09:02","endLine":365,"groupId":"102142","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"manifestHasDeletedFiles","params":"(StrictMetricsEvaluatormetricsEvaluator@ManifestReader<F>reader)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/15/c01e9eb6bd39d69ee604529710429c79a1bfb5.src","preCode":"  private boolean manifestHasDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestReader<F> reader) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    boolean hasDeletedFiles = false;\n    for (ManifestEntry<F> entry : reader.entries()) {\n      F file = entry.file();\n      boolean fileDelete = deletePaths.contains(file.path()) ||\n          dropPartitions.contains(file.specId(), file.partition()) ||\n          (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n      if (fileDelete || inclusive.eval(file.partition())) {\n        ValidationException.check(\n            fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n            \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n            this.deleteExpression, file.path());\n\n        hasDeletedFiles = true;\n        if (failAnyDelete) {\n          throw new DeleteException(reader.spec().partitionToPath(file.partition()));\n        }\n        break; \r\n      }\n    }\n    return hasDeletedFiles;\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestFilterManager.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"N"},{"authorDate":"2020-09-23 06:35:35","commitOrder":4,"curCode":"  private ManifestFile filterManifestWithDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestFile manifest, ManifestReader<F> reader) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    \r\n    \r\n    List<F> deletedFiles = Lists.newArrayList();\n    Set<CharSequenceWrapper> deletedPaths = Sets.newHashSet();\n\n    try {\n      ManifestWriter<F> writer = newManifestWriter(reader.spec());\n      try {\n        reader.entries().forEach(entry -> {\n          F file = entry.file();\n          boolean fileDelete = deletePaths.contains(file.path()) ||\n              dropPartitions.contains(file.specId(), file.partition()) ||\n              (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n          if (entry.status() != ManifestEntry.Status.DELETED) {\n            if (fileDelete || inclusive.eval(file.partition())) {\n              ValidationException.check(\n                  fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n                  \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n                  this.deleteExpression, file.path());\n\n              writer.delete(entry);\n\n              CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(entry.file().path());\n              if (deletedPaths.contains(wrapper)) {\n                LOG.warn(\"Deleting a duplicate path from manifest {}: {}\",\n                    manifest.path(), wrapper.get());\n                duplicateDeleteCount += 1;\n              } else {\n                \r\n                \r\n                deletedFiles.add(entry.file().copyWithoutStats());\n              }\n              deletedPaths.add(wrapper);\n\n            } else {\n              writer.existing(entry);\n            }\n          }\n        });\n      } finally {\n        writer.close();\n      }\n\n      \r\n      ManifestFile filtered = writer.toManifestFile();\n\n      \r\n      filteredManifests.put(manifest, filtered);\n      filteredManifestToDeletedFiles.put(filtered, deletedFiles);\n\n      return filtered;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(e, \"Failed to close manifest writer\");\n    }\n  }\n","date":"2020-09-23 06:35:35","endLine":427,"groupId":"102142","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"filterManifestWithDeletedFiles","params":"(StrictMetricsEvaluatormetricsEvaluator@ManifestFilemanifest@ManifestReader<F>reader)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/50/6d2579a7f05cc558b71a2e34b3ac77042a46b9.src","preCode":"  private ManifestFile filterManifestWithDeletedFiles(\n      StrictMetricsEvaluator metricsEvaluator, ManifestFile manifest, ManifestReader<F> reader) {\n    boolean isDelete = reader.isDeleteManifestReader();\n    Evaluator inclusive = inclusiveDeleteEvaluator(reader.spec());\n    Evaluator strict = strictDeleteEvaluator(reader.spec());\n    \r\n    \r\n    List<F> deletedFiles = Lists.newArrayList();\n    Set<CharSequenceWrapper> deletedPaths = Sets.newHashSet();\n\n    try {\n      ManifestWriter<F> writer = newManifestWriter(reader.spec());\n      try {\n        reader.entries().forEach(entry -> {\n          F file = entry.file();\n          boolean fileDelete = deletePaths.contains(file.path()) ||\n              dropPartitions.contains(file.specId(), file.partition()) ||\n              (isDelete && entry.sequenceNumber() > 0 && entry.sequenceNumber() < minSequenceNumber);\n          if (entry.status() != ManifestEntry.Status.DELETED) {\n            if (fileDelete || inclusive.eval(file.partition())) {\n              ValidationException.check(\n                  fileDelete || strict.eval(file.partition()) || metricsEvaluator.eval(file),\n                  \"Cannot delete file where some, but not all, rows match filter %s: %s\",\n                  this.deleteExpression, file.path());\n\n              writer.delete(entry);\n\n              CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(entry.file().path());\n              if (deletedPaths.contains(wrapper)) {\n                LOG.warn(\"Deleting a duplicate path from manifest {}: {}\",\n                    manifest.path(), wrapper.get());\n                duplicateDeleteCount += 1;\n              } else {\n                \r\n                \r\n                deletedFiles.add(entry.file().copyWithoutStats());\n              }\n              deletedPaths.add(wrapper);\n\n            } else {\n              writer.existing(entry);\n            }\n          }\n        });\n      } finally {\n        writer.close();\n      }\n\n      \r\n      ManifestFile filtered = writer.toManifestFile();\n\n      \r\n      filteredManifests.put(manifest, filtered);\n      filteredManifestToDeletedFiles.put(filtered, deletedFiles);\n\n      return filtered;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Failed to close manifest writer\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestFilterManager.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"M"}],"commitId":"96959ece9faeb795757388908274cfd0ff1856ca","commitMessage":"@@@Build: Fix warnings (#1427)\n\n","date":"2020-09-23 06:35:35","modifiedFileCount":"72","status":"M","submitter":"Russell Spitzer"}]
