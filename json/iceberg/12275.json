[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyResult.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyResult.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","date":"2019-03-21 07:25:05","endLine":179,"groupId":"757","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"map","params":"(Types.MapTypemap@Supplier<Object>keyResult@Supplier<Object>valueResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/65/158a62212d96320fd84c6b3bec6a77b961725c.src","preCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyResult.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyResult.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Supplier<Object> keyFunc;\n      if (map.keyType() == Types.StringType.get()) {\n        keyFunc = () -> keyResult.get().toString();\n      } else {\n        keyFunc = keyResult;\n      }\n\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyFunc.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyFunc.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","date":"2019-03-21 07:25:05","endLine":139,"groupId":"1974","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"map","params":"(Types.MapTypemap@Supplier<Object>keyResult@Supplier<Object>valueResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/8c/6668a27b1cd888faec17eb38ae36f8be16f32b.src","preCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Supplier<Object> keyFunc;\n      if (map.keyType() == Types.StringType.get()) {\n        keyFunc = () -> keyResult.get().toString();\n      } else {\n        keyFunc = keyResult;\n      }\n\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyFunc.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyFunc.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","realPath":"data/src/test/java/org/apache/iceberg/data/RandomGenericData.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2020-06-16 06:16:19","commitOrder":2,"curCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyResult.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyResult.get();\n        }\n\n        keySet.add(key);\n\n        if (map.isValueOptional() && isNull()) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","date":"2020-06-16 06:16:19","endLine":213,"groupId":"757","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"map","params":"(Types.MapTypemap@Supplier<Object>keyResult@Supplier<Object>valueResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f9/9c0fccb89c4208d661ef47bcec51a05dbcb534.src","preCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyResult.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyResult.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"},{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Supplier<Object> keyFunc;\n      if (map.keyType() == Types.StringType.get()) {\n        keyFunc = () -> keyResult.get().toString();\n      } else {\n        keyFunc = keyResult;\n      }\n\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyFunc.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyFunc.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","date":"2019-03-21 07:25:05","endLine":139,"groupId":"1974","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"map","params":"(Types.MapTypemap@Supplier<Object>keyResult@Supplier<Object>valueResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/8c/6668a27b1cd888faec17eb38ae36f8be16f32b.src","preCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Supplier<Object> keyFunc;\n      if (map.keyType() == Types.StringType.get()) {\n        keyFunc = () -> keyResult.get().toString();\n      } else {\n        keyFunc = keyResult;\n      }\n\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyFunc.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyFunc.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","realPath":"data/src/test/java/org/apache/iceberg/data/RandomGenericData.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"N"}],"commitId":"ffdcf09027e09460b7d7505e65aea119107934a3","commitMessage":"@@@Spark: Support vectorized Parquet reads for flat projections (#828)\n\n","date":"2020-06-16 06:16:19","modifiedFileCount":"21","status":"M","submitter":"Samarth Jain"},{"authorTime":"2020-06-30 01:56:46","codes":[{"authorDate":"2020-06-16 06:16:19","commitOrder":3,"curCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyResult.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyResult.get();\n        }\n\n        keySet.add(key);\n\n        if (map.isValueOptional() && isNull()) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","date":"2020-06-16 06:16:19","endLine":213,"groupId":"12275","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"map","params":"(Types.MapTypemap@Supplier<Object>keyResult@Supplier<Object>valueResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f9/9c0fccb89c4208d661ef47bcec51a05dbcb534.src","preCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyResult.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyResult.get();\n        }\n\n        keySet.add(key);\n\n        if (map.isValueOptional() && isNull()) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/RandomData.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"N"},{"authorDate":"2020-06-30 01:56:46","commitOrder":3,"curCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(getMaxEntries());\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Supplier<Object> keyFunc;\n      if (map.keyType() == Types.StringType.get()) {\n        keyFunc = () -> keyResult.get().toString();\n      } else {\n        keyFunc = keyResult;\n      }\n\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyFunc.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyFunc.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","date":"2020-06-30 01:56:46","endLine":156,"groupId":"12275","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"map","params":"(Types.MapTypemap@Supplier<Object>keyResult@Supplier<Object>valueResult)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/19/179c0b1de47bb44c8e8872303fa7fab5bc83d9.src","preCode":"    public Object map(Types.MapType map, Supplier<Object> keyResult, Supplier<Object> valueResult) {\n      int numEntries = random.nextInt(20);\n\n      Map<Object, Object> result = Maps.newLinkedHashMap();\n      Supplier<Object> keyFunc;\n      if (map.keyType() == Types.StringType.get()) {\n        keyFunc = () -> keyResult.get().toString();\n      } else {\n        keyFunc = keyResult;\n      }\n\n      Set<Object> keySet = Sets.newHashSet();\n      for (int i = 0; i < numEntries; i += 1) {\n        Object key = keyFunc.get();\n        \r\n        while (keySet.contains(key)) {\n          key = keyFunc.get();\n        }\n\n        keySet.add(key);\n\n        \r\n        if (map.isValueOptional() && random.nextInt(20) == 1) {\n          result.put(key, null);\n        } else {\n          result.put(key, valueResult.get());\n        }\n      }\n\n      return result;\n    }\n","realPath":"data/src/test/java/org/apache/iceberg/data/RandomGenericData.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"}],"commitId":"edb8d7759d74418daa677a8c39420f29e28edb66","commitMessage":"@@@Flink: Add Parquet value reader.  writer implementations (#1125)\n\n","date":"2020-06-30 01:56:46","modifiedFileCount":"5","status":"M","submitter":"openinx"}]
