[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":271,"groupId":"4001","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"eq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d3/c009eaf5527b086825bdea6dbe71e30557d4d3.src","preCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":258,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":290,"groupId":"4001","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d3/c009eaf5527b086825bdea6dbe71e30557d4d3.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-03-25 06:44:37","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":271,"groupId":"4001","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"eq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d3/c009eaf5527b086825bdea6dbe71e30557d4d3.src","preCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":258,"status":"N"},{"authorDate":"2019-03-25 06:44:37","commitOrder":2,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1 || mayContainNulls.get(id)) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","date":"2019-03-25 06:44:37","endLine":293,"groupId":"4001","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/57/f728ce39ff67834bc487f2b58c4e108205dc19.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":277,"status":"M"}],"commitId":"783fa7af5d68ca6ed32d00b464b9049d9d42c6da","commitMessage":"@@@Fix row group dictionary filter handling of null values. (#86)\n\n","date":"2019-03-25 06:44:37","modifiedFileCount":"2","status":"M","submitter":"Ryan Blue"},{"authorTime":"2019-05-29 03:40:04","codes":[{"authorDate":"2019-05-29 03:40:04","commitOrder":3,"curCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","date":"2019-05-29 03:40:04","endLine":268,"groupId":"4001","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"eq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/ae/84cb2579d12acef9066c1a0bc8b0f74dcc7e69.src","preCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":257,"status":"M"},{"authorDate":"2019-05-29 03:40:04","commitOrder":3,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1 || mayContainNulls.get(id)) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","date":"2019-05-29 03:40:04","endLine":285,"groupId":"4001","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/ae/84cb2579d12acef9066c1a0bc8b0f74dcc7e69.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1 || mayContainNulls.get(id)) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":271,"status":"M"}],"commitId":"81f29e2f80cc2e6b3b6f715573893aff696f579a","commitMessage":"@@@Support filtering based on nested struct fields (#123)\n\n","date":"2019-05-29 03:40:04","modifiedFileCount":"9","status":"M","submitter":"Gautam"},{"authorTime":"2019-10-23 02:17:28","codes":[{"authorDate":"2019-10-23 02:17:28","commitOrder":4,"curCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      int id = ref.fieldId();\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","date":"2019-10-23 02:17:28","endLine":262,"groupId":"1089","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"eq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a7/d341e1a0dfe7c975cf952a5eb302b3910433af.src","preCode":"    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n\n      return dictionary.contains(lit.value()) ? ROWS_MIGHT_MATCH : ROWS_CANNOT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"M"},{"authorDate":"2019-10-23 02:17:28","commitOrder":4,"curCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      int id = ref.fieldId();\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1 || mayContainNulls.get(id)) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","date":"2019-10-23 02:17:28","endLine":279,"groupId":"1089","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"notEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a7/d341e1a0dfe7c975cf952a5eb302b3910433af.src","preCode":"    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n\n      Boolean hasNonDictPage = isFallback.get(id);\n      if (hasNonDictPage == null || hasNonDictPage) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      Set<T> dictionary = dict(id, lit.comparator());\n      if (dictionary.size() > 1 || mayContainNulls.get(id)) {\n        return ROWS_MIGHT_MATCH;\n      }\n\n      return dictionary.contains(lit.value()) ? ROWS_CANNOT_MATCH : ROWS_MIGHT_MATCH;\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/parquet/ParquetDictionaryRowGroupFilter.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":265,"status":"M"}],"commitId":"336174b0a4438ed68cdb8e208833e380adaa15fc","commitMessage":"@@@Baseline: Add Baseline to iceberg-parquet (#526)\n\n","date":"2019-10-23 02:17:28","modifiedFileCount":"29","status":"M","submitter":"Fokko Driesprong"}]
