[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2020-04-10 00:11:46","commitOrder":2,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        long expectedDays = ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2020-04-10 00:11:46","endLine":294,"groupId":"2884","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6b/7c504a83b9e95990dddb370d3dac1dd4bdfabb.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        long expectedDays = ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2019-03-21 07:25:05","endLine":295,"groupId":"4572","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a7/60455ba076b1aec03ff58ae18586130f09e552.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"NB"}],"commitId":"898c122118ba99847216c80ca7e0d12821133a8a","commitMessage":"@@@Spark: Add ORC to parameterized tests (#892)\n\n* Spark: Add ORC to parameterized tests.\n\n* Fix GenericsHelpers.\n\n* Build: Increase JVM heap size.\n\n* Fix review comments.\n\n* Revert \"Build: Increase JVM heap size.\"\n\nThis reverts commit 1f0996113923c5d279a5877a03af2db7b7e4e076.\n\n* Avoid keeping records in memory for TestDataFrameWrites.","date":"2020-04-10 00:11:46","modifiedFileCount":"6","status":"M","submitter":"Ryan Blue"},{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2020-08-07 23:58:24","commitOrder":3,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2020-08-07 23:58:24","endLine":294,"groupId":"2884","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/0c/4598a209e878aafb6d6ef54527627d3a1f6f64.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        long expectedDays = ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"M"},{"authorDate":"2019-03-21 07:25:05","commitOrder":3,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2019-03-21 07:25:05","endLine":295,"groupId":"4572","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a7/60455ba076b1aec03ff58ae18586130f09e552.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"N"}],"commitId":"6f96b36a39f26cfbc6f66dc762148577e5697534","commitMessage":"@@@ORC: Fix decimal and timestamp bugs (#1271)\n\n","date":"2020-08-07 23:58:24","modifiedFileCount":"5","status":"M","submitter":"openinx"},{"authorTime":"2021-01-19 08:51:06","codes":[{"authorDate":"2020-08-07 23:58:24","commitOrder":4,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2020-08-07 23:58:24","endLine":294,"groupId":"2884","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/0c/4598a209e878aafb6d6ef54527627d3a1f6f64.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"N"},{"authorDate":"2021-01-19 08:51:06","commitOrder":4,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case LONG:\n        Assert.assertTrue(\"Should be a long\", actual instanceof Long);\n        if (expected instanceof Integer) {\n          Assert.assertEquals(\"Values didn't match\", ((Number) expected).longValue(), actual);\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case DOUBLE:\n        Assert.assertTrue(\"Should be a double\", actual instanceof Double);\n        if (expected instanceof Float) {\n          Assert.assertEquals(\"Values didn't match\", Double.doubleToLongBits(((Number) expected).doubleValue()),\n                  Double.doubleToLongBits((double) actual));\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case INTEGER:\n      case FLOAT:\n      case BOOLEAN:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-01-19 08:51:06","endLine":341,"groupId":"4572","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/96/5659bc2dd179f18ba924fe728fcb2b40cc2698.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":264,"status":"M"}],"commitId":"e3e712c80a4ad99f7d6a03f6d7937fcfc8a29246","commitMessage":"@@@Spark: Fix parquet vectorized reads with promoted types (#2091)\n\n","date":"2021-01-19 08:51:06","modifiedFileCount":"4","status":"M","submitter":"Samarth Jain"},{"authorTime":"2021-01-19 08:51:06","codes":[{"authorDate":"2021-07-16 01:06:44","commitOrder":5,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Types.TimestampType timestampType = (Types.TimestampType) type;\n        if (timestampType.shouldAdjustToUTC()) {\n          Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n          long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        } else {\n          Assert.assertTrue(\"Should expect an LocalDateTime\", expected instanceof LocalDateTime);\n          long expectedMicros = ChronoUnit.MICROS.between(EPOCH, ((LocalDateTime) expected).atZone(ZoneId.of(\"UTC\")));\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        }\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-07-16 01:06:44","endLine":309,"groupId":"2884","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/24/724d3d12bf927ba7cab671e726fdcbf5695a80.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n        long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"M"},{"authorDate":"2021-01-19 08:51:06","commitOrder":5,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case LONG:\n        Assert.assertTrue(\"Should be a long\", actual instanceof Long);\n        if (expected instanceof Integer) {\n          Assert.assertEquals(\"Values didn't match\", ((Number) expected).longValue(), actual);\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case DOUBLE:\n        Assert.assertTrue(\"Should be a double\", actual instanceof Double);\n        if (expected instanceof Float) {\n          Assert.assertEquals(\"Values didn't match\", Double.doubleToLongBits(((Number) expected).doubleValue()),\n                  Double.doubleToLongBits((double) actual));\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case INTEGER:\n      case FLOAT:\n      case BOOLEAN:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-01-19 08:51:06","endLine":341,"groupId":"4572","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/96/5659bc2dd179f18ba924fe728fcb2b40cc2698.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case LONG:\n        Assert.assertTrue(\"Should be a long\", actual instanceof Long);\n        if (expected instanceof Integer) {\n          Assert.assertEquals(\"Values didn't match\", ((Number) expected).longValue(), actual);\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case DOUBLE:\n        Assert.assertTrue(\"Should be a double\", actual instanceof Double);\n        if (expected instanceof Float) {\n          Assert.assertEquals(\"Values didn't match\", Double.doubleToLongBits(((Number) expected).doubleValue()),\n                  Double.doubleToLongBits((double) actual));\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case INTEGER:\n      case FLOAT:\n      case BOOLEAN:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":264,"status":"N"}],"commitId":"9a0d154b0ba5e6d10d79e30470295c91c89c1e09","commitMessage":"@@@Add support for reading/writing timestamps without timezone.  (#2757)\n\nPreviously Spark could not handle Iceberg tables which contained Timestamp.withoutTimeZone. New parameters are introduced to allow Timestamp without TimeZone to be treated as Timestamp with Timezone.  \n\nCo-authored-by: bkahloon <kahlonbakht@gmail.com>\nCo-authored-by: shardulm94 ","date":"2021-07-16 01:06:44","modifiedFileCount":"15","status":"M","submitter":"sshkvar"},{"authorTime":"2021-07-19 18:57:09","codes":[{"authorDate":"2021-07-19 18:57:09","commitOrder":6,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assertions.assertThat(expected).as(\"Should expect a LocalDate\").isInstanceOf(LocalDate.class);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Types.TimestampType timestampType = (Types.TimestampType) type;\n        if (timestampType.shouldAdjustToUTC()) {\n          Assertions.assertThat(expected).as(\"Should expect an OffsetDateTime\").isInstanceOf(OffsetDateTime.class);\n          long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        } else {\n          Assertions.assertThat(expected).as(\"Should expect an LocalDateTime\").isInstanceOf(LocalDateTime.class);\n          long expectedMicros = ChronoUnit.MICROS.between(EPOCH, ((LocalDateTime) expected).atZone(ZoneId.of(\"UTC\")));\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        }\n        break;\n      case STRING:\n        Assertions.assertThat(actual).as(\"Should be a UTF8String\").isInstanceOf(UTF8String.class);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assertions.assertThat(expected).as(\"Should expect a UUID\").isInstanceOf(UUID.class);\n        Assertions.assertThat(actual).as(\"Should be a UTF8String\").isInstanceOf(UTF8String.class);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assertions.assertThat(expected).as(\"Should expect a byte[]\").isInstanceOf(byte[].class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assertions.assertThat(expected).as(\"Should expect a ByteBuffer\").isInstanceOf(ByteBuffer.class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assertions.assertThat(expected).as(\"Should expect a BigDecimal\").isInstanceOf(BigDecimal.class);\n        Assertions.assertThat(actual).as(\"Should be a Decimal\").isInstanceOf(Decimal.class);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assertions.assertThat(expected).as(\"Should expect a Record\").isInstanceOf(Record.class);\n        Assertions.assertThat(actual).as(\"Should be an InternalRow\").isInstanceOf(InternalRow.class);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assertions.assertThat(expected).as(\"Should expect a Collection\").isInstanceOf(Collection.class);\n        Assertions.assertThat(actual).as(\"Should be an ArrayData\").isInstanceOf(ArrayData.class);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assertions.assertThat(expected).as(\"Should expect a Map\").isInstanceOf(Map.class);\n        Assertions.assertThat(actual).as(\"Should be an ArrayBasedMapData\").isInstanceOf(MapData.class);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-07-19 18:57:09","endLine":310,"groupId":"12229","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/46/c95cef112d64a35b0d1e8384fd260d16232898.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should expect a LocalDate\", expected instanceof LocalDate);\n        int expectedDays = (int) ChronoUnit.DAYS.between(EPOCH_DAY, (LocalDate) expected);\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expectedDays, actual);\n        break;\n      case TIMESTAMP:\n        Types.TimestampType timestampType = (Types.TimestampType) type;\n        if (timestampType.shouldAdjustToUTC()) {\n          Assert.assertTrue(\"Should expect an OffsetDateTime\", expected instanceof OffsetDateTime);\n          long expectedMicros = ChronoUnit.MICROS.between(EPOCH, (OffsetDateTime) expected);\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        } else {\n          Assert.assertTrue(\"Should expect an LocalDateTime\", expected instanceof LocalDateTime);\n          long expectedMicros = ChronoUnit.MICROS.between(EPOCH, ((LocalDateTime) expected).atZone(ZoneId.of(\"UTC\")));\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expectedMicros, actual);\n        }\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a byte[]\", expected instanceof byte[]);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\", (byte[]) expected, (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection<?>) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map<?, ?>) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/GenericsHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"},{"authorDate":"2021-07-19 18:57:09","commitOrder":6,"curCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case LONG:\n        Assertions.assertThat(actual).as(\"Should be a long\").isInstanceOf(Long.class);\n        if (expected instanceof Integer) {\n          Assert.assertEquals(\"Values didn't match\", ((Number) expected).longValue(), actual);\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case DOUBLE:\n        Assertions.assertThat(actual).as(\"Should be a double\").isInstanceOf(Double.class);\n        if (expected instanceof Float) {\n          Assert.assertEquals(\"Values didn't match\", Double.doubleToLongBits(((Number) expected).doubleValue()),\n                  Double.doubleToLongBits((double) actual));\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case INTEGER:\n      case FLOAT:\n      case BOOLEAN:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assertions.assertThat(actual).as(\"Should be a UTF8String\").isInstanceOf(UTF8String.class);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assertions.assertThat(expected).as(\"Should expect a UUID\").isInstanceOf(UUID.class);\n        Assertions.assertThat(actual).as(\"Should be a UTF8String\").isInstanceOf(UTF8String.class);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assertions.assertThat(expected).as(\"Should expect a Fixed\").isInstanceOf(GenericData.Fixed.class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assertions.assertThat(expected).as(\"Should expect a ByteBuffer\").isInstanceOf(ByteBuffer.class);\n        Assertions.assertThat(actual).as(\"Should be a byte[]\").isInstanceOf(byte[].class);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assertions.assertThat(expected).as(\"Should expect a BigDecimal\").isInstanceOf(BigDecimal.class);\n        Assertions.assertThat(actual).as(\"Should be a Decimal\").isInstanceOf(Decimal.class);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assertions.assertThat(expected).as(\"Should expect a Record\").isInstanceOf(Record.class);\n        Assertions.assertThat(actual).as(\"Should be an InternalRow\").isInstanceOf(InternalRow.class);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assertions.assertThat(expected).as(\"Should expect a Collection\").isInstanceOf(Collection.class);\n        Assertions.assertThat(actual).as(\"Should be an ArrayData\").isInstanceOf(ArrayData.class);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assertions.assertThat(expected).as(\"Should expect a Map\").isInstanceOf(Map.class);\n        Assertions.assertThat(actual).as(\"Should be an ArrayBasedMapData\").isInstanceOf(MapData.class);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","date":"2021-07-19 18:57:09","endLine":343,"groupId":"12229","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"assertEqualsUnsafe","params":"(Typetype@Objectexpected@Objectactual)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/53/d5e8763e6f3e6e5eb342cc3f22f8f461357446.src","preCode":"  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case LONG:\n        Assert.assertTrue(\"Should be a long\", actual instanceof Long);\n        if (expected instanceof Integer) {\n          Assert.assertEquals(\"Values didn't match\", ((Number) expected).longValue(), actual);\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case DOUBLE:\n        Assert.assertTrue(\"Should be a double\", actual instanceof Double);\n        if (expected instanceof Float) {\n          Assert.assertEquals(\"Values didn't match\", Double.doubleToLongBits(((Number) expected).doubleValue()),\n                  Double.doubleToLongBits((double) actual));\n        } else {\n          Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        }\n        break;\n      case INTEGER:\n      case FLOAT:\n      case BOOLEAN:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n","realPath":"spark/src/test/java/org/apache/iceberg/spark/data/TestHelpers.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"}],"commitId":"0055e855ccabbd6a592b3b49e1f38131f62e0fdd","commitMessage":"@@@Move Assert.assertTrue(..) instance checks to AssertJ assertions (#2756)\n\n","date":"2021-07-19 18:57:09","modifiedFileCount":"25","status":"M","submitter":"Eduard Tudenh?fner"}]
