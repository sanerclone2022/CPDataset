[{"authorTime":"2020-12-05 05:06:32","codes":[{"authorDate":"2020-12-05 05:06:32","commitOrder":1,"curCode":"  public void testExpireSnapshotsUsingPositionalArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n    Snapshot firstSnapshot = table.currentSnapshot();\n\n    waitUntilAfter(firstSnapshot.timestampMillis());\n\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    table.refresh();\n\n    Snapshot secondSnapshot = table.currentSnapshot();\n    Timestamp secondSnapshotTimestamp = Timestamp.from(Instant.ofEpochMilli(secondSnapshot.timestampMillis()));\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output1 = sql(\n        \"CALL %s.system.expire_snapshots('%s', '%s', TIMESTAMP '%s')\",\n        catalogName, tableIdent.namespace(), tableIdent.name(), secondSnapshotTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output1);\n\n    table.refresh();\n\n    Assert.assertEquals(\"Should expire one snapshot\", 1, Iterables.size(table.snapshots()));\n\n    sql(\"INSERT OVERWRITE %s VALUES (3, 'c')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (4, 'd')\", tableName);\n    assertEquals(\"Should have expected rows\",\n        ImmutableList.of(row(3L, \"c\"), row(4L, \"d\")),\n        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n\n    table.refresh();\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    Assert.assertEquals(\"Should be 3 snapshots\", 3, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots('%s', '%s', TIMESTAMP '%s', 2)\",\n        catalogName, tableIdent.namespace(), tableIdent.name(), currentTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(2L, 2L, 1L)),\n        output);\n  }\n","date":"2020-12-05 05:06:32","endLine":113,"groupId":"1878","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testExpireSnapshotsUsingPositionalArgs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/85/4985e95c2b3e0e78453e12693ae42392983566.src","preCode":"  public void testExpireSnapshotsUsingPositionalArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n    Snapshot firstSnapshot = table.currentSnapshot();\n\n    waitUntilAfter(firstSnapshot.timestampMillis());\n\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    table.refresh();\n\n    Snapshot secondSnapshot = table.currentSnapshot();\n    Timestamp secondSnapshotTimestamp = Timestamp.from(Instant.ofEpochMilli(secondSnapshot.timestampMillis()));\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output1 = sql(\n        \"CALL %s.system.expire_snapshots('%s', '%s', TIMESTAMP '%s')\",\n        catalogName, tableIdent.namespace(), tableIdent.name(), secondSnapshotTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output1);\n\n    table.refresh();\n\n    Assert.assertEquals(\"Should expire one snapshot\", 1, Iterables.size(table.snapshots()));\n\n    sql(\"INSERT OVERWRITE %s VALUES (3, 'c')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (4, 'd')\", tableName);\n    assertEquals(\"Should have expected rows\",\n        ImmutableList.of(row(3L, \"c\"), row(4L, \"d\")),\n        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n\n    table.refresh();\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    Assert.assertEquals(\"Should be 3 snapshots\", 3, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots('%s', '%s', TIMESTAMP '%s', 2)\",\n        catalogName, tableIdent.namespace(), tableIdent.name(), currentTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(2L, 2L, 1L)),\n        output);\n  }\n","realPath":"spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestExpireSnapshotsProcedure.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"B"},{"authorDate":"2020-12-05 05:06:32","commitOrder":1,"curCode":"  public void testExpireSnapshotUsingNamedArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots(\" +\n            \"older_than => TIMESTAMP '%s',\" +\n            \"namespace => '%s',\" +\n            \"table => '%s',\" +\n            \"retain_last => 1)\",\n        catalogName, currentTimestamp, tableIdent.namespace(), tableIdent.name());\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output);\n  }\n","date":"2020-12-05 05:06:32","endLine":140,"groupId":"1879","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testExpireSnapshotUsingNamedArgs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/85/4985e95c2b3e0e78453e12693ae42392983566.src","preCode":"  public void testExpireSnapshotUsingNamedArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots(\" +\n            \"older_than => TIMESTAMP '%s',\" +\n            \"namespace => '%s',\" +\n            \"table => '%s',\" +\n            \"retain_last => 1)\",\n        catalogName, currentTimestamp, tableIdent.namespace(), tableIdent.name());\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output);\n  }\n","realPath":"spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestExpireSnapshotsProcedure.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"B"}],"commitId":"b5f08d28e63efcfd0e564e61faab6f4e8c8c29da","commitMessage":"@@@Spark: Add ExpireSnapshotsProcedure (#1874)\n\n","date":"2020-12-05 05:06:32","modifiedFileCount":"1","status":"B","submitter":"Anton Okolnychyi"},{"authorTime":"2020-12-09 23:37:55","codes":[{"authorDate":"2020-12-09 23:37:55","commitOrder":2,"curCode":"  public void testExpireSnapshotsUsingPositionalArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n    Snapshot firstSnapshot = table.currentSnapshot();\n\n    waitUntilAfter(firstSnapshot.timestampMillis());\n\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    table.refresh();\n\n    Snapshot secondSnapshot = table.currentSnapshot();\n    Timestamp secondSnapshotTimestamp = Timestamp.from(Instant.ofEpochMilli(secondSnapshot.timestampMillis()));\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output1 = sql(\n        \"CALL %s.system.expire_snapshots('%s', TIMESTAMP '%s')\",\n        catalogName, tableIdent, secondSnapshotTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output1);\n\n    table.refresh();\n\n    Assert.assertEquals(\"Should expire one snapshot\", 1, Iterables.size(table.snapshots()));\n\n    sql(\"INSERT OVERWRITE %s VALUES (3, 'c')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (4, 'd')\", tableName);\n    assertEquals(\"Should have expected rows\",\n        ImmutableList.of(row(3L, \"c\"), row(4L, \"d\")),\n        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n\n    table.refresh();\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    Assert.assertEquals(\"Should be 3 snapshots\", 3, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots('%s', TIMESTAMP '%s', 2)\",\n        catalogName, tableIdent, currentTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(2L, 2L, 1L)),\n        output);\n  }\n","date":"2020-12-09 23:37:55","endLine":115,"groupId":"10766","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testExpireSnapshotsUsingPositionalArgs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/ce/1bf9be67c175af90fd13589ec0e054e396e305.src","preCode":"  public void testExpireSnapshotsUsingPositionalArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n    Snapshot firstSnapshot = table.currentSnapshot();\n\n    waitUntilAfter(firstSnapshot.timestampMillis());\n\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    table.refresh();\n\n    Snapshot secondSnapshot = table.currentSnapshot();\n    Timestamp secondSnapshotTimestamp = Timestamp.from(Instant.ofEpochMilli(secondSnapshot.timestampMillis()));\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output1 = sql(\n        \"CALL %s.system.expire_snapshots('%s', '%s', TIMESTAMP '%s')\",\n        catalogName, tableIdent.namespace(), tableIdent.name(), secondSnapshotTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output1);\n\n    table.refresh();\n\n    Assert.assertEquals(\"Should expire one snapshot\", 1, Iterables.size(table.snapshots()));\n\n    sql(\"INSERT OVERWRITE %s VALUES (3, 'c')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (4, 'd')\", tableName);\n    assertEquals(\"Should have expected rows\",\n        ImmutableList.of(row(3L, \"c\"), row(4L, \"d\")),\n        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n\n    table.refresh();\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    Assert.assertEquals(\"Should be 3 snapshots\", 3, Iterables.size(table.snapshots()));\n\n    \r\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots('%s', '%s', TIMESTAMP '%s', 2)\",\n        catalogName, tableIdent.namespace(), tableIdent.name(), currentTimestamp);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(2L, 2L, 1L)),\n        output);\n  }\n","realPath":"spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestExpireSnapshotsProcedure.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2020-12-09 23:37:55","commitOrder":2,"curCode":"  public void testExpireSnapshotUsingNamedArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots(\" +\n            \"older_than => TIMESTAMP '%s',\" +\n            \"table => '%s',\" +\n            \"retain_last => 1)\",\n        catalogName, currentTimestamp, tableIdent);\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output);\n  }\n","date":"2020-12-09 23:37:55","endLine":141,"groupId":"10766","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testExpireSnapshotUsingNamedArgs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/ce/1bf9be67c175af90fd13589ec0e054e396e305.src","preCode":"  public void testExpireSnapshotUsingNamedArgs() {\n    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING iceberg\", tableName);\n\n    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n    sql(\"INSERT INTO TABLE %s VALUES (2, 'b')\", tableName);\n\n    Table table = validationCatalog.loadTable(tableIdent);\n\n    Assert.assertEquals(\"Should be 2 snapshots\", 2, Iterables.size(table.snapshots()));\n\n    waitUntilAfter(table.currentSnapshot().timestampMillis());\n\n    Timestamp currentTimestamp = Timestamp.from(Instant.ofEpochMilli(System.currentTimeMillis()));\n\n    List<Object[]> output = sql(\n        \"CALL %s.system.expire_snapshots(\" +\n            \"older_than => TIMESTAMP '%s',\" +\n            \"namespace => '%s',\" +\n            \"table => '%s',\" +\n            \"retain_last => 1)\",\n        catalogName, currentTimestamp, tableIdent.namespace(), tableIdent.name());\n    assertEquals(\"Procedure output must match\",\n        ImmutableList.of(row(0L, 0L, 1L)),\n        output);\n  }\n","realPath":"spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestExpireSnapshotsProcedure.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"}],"commitId":"e39584ed89356cacf006610bffd475a3ad3a1ac4","commitMessage":"@@@Spark: Migrate to identifiers in procedures (#1890)\n\n","date":"2020-12-09 23:37:55","modifiedFileCount":"16","status":"M","submitter":"Russell Spitzer"}]
