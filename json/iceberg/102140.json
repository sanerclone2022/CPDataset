[{"authorTime":"2020-08-06 04:22:25","codes":[{"authorDate":"2020-08-06 04:22:25","commitOrder":16,"curCode":"    private Iterable<Pair<Integer, CloseableIterable<ManifestEntry<DeleteFile>>>> deleteManifestReaders() {\n      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n          Caffeine.newBuilder().build(specId -> {\n            PartitionSpec spec = specsById.get(specId);\n            return ManifestEvaluator.forPartitionFilter(\n                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n                spec, caseSensitive);\n          });\n\n      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n          Iterables.filter(deleteManifests, manifest ->\n              manifest.content() == ManifestContent.DELETES &&\n                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n      return Iterables.transform(\n          matchingManifests,\n          manifest -> Pair.of(\n              manifest.partitionSpecId(),\n              ManifestFiles.readDeleteManifest(manifest, io, specsById)\n                  .filterRows(dataFilter)\n                  .filterPartitions(partitionFilter)\n                  .caseSensitive(caseSensitive)\n                  .liveEntries())\n      );\n    }\n","date":"2020-08-06 04:22:25","endLine":268,"groupId":"2055","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"deleteManifestReaders","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/b6/8ba901a8b658246b6e029eda0587a326873eb0.src","preCode":"    private Iterable<Pair<Integer, CloseableIterable<ManifestEntry<DeleteFile>>>> deleteManifestReaders() {\n      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n          Caffeine.newBuilder().build(specId -> {\n            PartitionSpec spec = specsById.get(specId);\n            return ManifestEvaluator.forPartitionFilter(\n                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n                spec, caseSensitive);\n          });\n\n      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n          Iterables.filter(deleteManifests, manifest ->\n              manifest.content() == ManifestContent.DELETES &&\n                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n      return Iterables.transform(\n          matchingManifests,\n          manifest -> Pair.of(\n              manifest.partitionSpecId(),\n              ManifestFiles.readDeleteManifest(manifest, io, specsById)\n                  .filterRows(dataFilter)\n                  .filterPartitions(partitionFilter)\n                  .caseSensitive(caseSensitive)\n                  .liveEntries())\n      );\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/DeleteFileIndex.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":243,"status":"B"},{"authorDate":"2020-08-06 04:22:25","commitOrder":16,"curCode":"  private <T> Iterable<CloseableIterable<T>> entries(\n      BiFunction<ManifestFile, CloseableIterable<ManifestEntry<DataFile>>, CloseableIterable<T>> entryFn) {\n    LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ?\n        null : Caffeine.newBuilder().build(specId -> {\n          PartitionSpec spec = specsById.get(specId);\n          return ManifestEvaluator.forPartitionFilter(\n              Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n              spec, caseSensitive);\n        });\n\n    Evaluator evaluator = new Evaluator(DataFile.getType(EMPTY_STRUCT), fileFilter, caseSensitive);\n\n    Iterable<ManifestFile> matchingManifests = evalCache == null ? dataManifests :\n        Iterables.filter(dataManifests, manifest -> evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n    if (ignoreDeleted) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasExistingFiles());\n    }\n\n    if (ignoreExisting) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasDeletedFiles());\n    }\n\n    matchingManifests = Iterables.filter(matchingManifests, manifestPredicate::test);\n\n    return Iterables.transform(\n        matchingManifests,\n        manifest -> {\n          ManifestReader<DataFile> reader = ManifestFiles.read(manifest, io, specsById)\n              .filterRows(dataFilter)\n              .filterPartitions(partitionFilter)\n              .caseSensitive(caseSensitive)\n              .select(columns);\n\n          CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n          if (ignoreDeleted) {\n            entries = reader.liveEntries();\n          }\n\n          if (ignoreExisting) {\n            entries = CloseableIterable.filter(entries,\n                entry -> entry.status() != ManifestEntry.Status.EXISTING);\n          }\n\n          if (fileFilter != null && fileFilter != Expressions.alwaysTrue()) {\n            entries = CloseableIterable.filter(entries,\n                entry -> evaluator.eval((GenericDataFile) entry.file()));\n          }\n\n          entries = CloseableIterable.filter(entries, manifestEntryPredicate);\n          return entryFn.apply(manifest, entries);\n        });\n  }\n","date":"2020-08-06 04:22:25","endLine":261,"groupId":"721","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"entries","params":"(BiFunction<ManifestFile@CloseableIterable<ManifestEntry<DataFile>>@CloseableIterable<T>>entryFn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a4/91080ee980ef1058f4c564174ea3af46cf1eb4.src","preCode":"  private <T> Iterable<CloseableIterable<T>> entries(\n      BiFunction<ManifestFile, CloseableIterable<ManifestEntry<DataFile>>, CloseableIterable<T>> entryFn) {\n    LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ?\n        null : Caffeine.newBuilder().build(specId -> {\n          PartitionSpec spec = specsById.get(specId);\n          return ManifestEvaluator.forPartitionFilter(\n              Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n              spec, caseSensitive);\n        });\n\n    Evaluator evaluator = new Evaluator(DataFile.getType(EMPTY_STRUCT), fileFilter, caseSensitive);\n\n    Iterable<ManifestFile> matchingManifests = evalCache == null ? dataManifests :\n        Iterables.filter(dataManifests, manifest -> evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n    if (ignoreDeleted) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasExistingFiles());\n    }\n\n    if (ignoreExisting) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasDeletedFiles());\n    }\n\n    matchingManifests = Iterables.filter(matchingManifests, manifestPredicate::test);\n\n    return Iterables.transform(\n        matchingManifests,\n        manifest -> {\n          ManifestReader<DataFile> reader = ManifestFiles.read(manifest, io, specsById)\n              .filterRows(dataFilter)\n              .filterPartitions(partitionFilter)\n              .caseSensitive(caseSensitive)\n              .select(columns);\n\n          CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n          if (ignoreDeleted) {\n            entries = reader.liveEntries();\n          }\n\n          if (ignoreExisting) {\n            entries = CloseableIterable.filter(entries,\n                entry -> entry.status() != ManifestEntry.Status.EXISTING);\n          }\n\n          if (fileFilter != null && fileFilter != Expressions.alwaysTrue()) {\n            entries = CloseableIterable.filter(entries,\n                entry -> evaluator.eval((GenericDataFile) entry.file()));\n          }\n\n          entries = CloseableIterable.filter(entries, manifestEntryPredicate);\n          return entryFn.apply(manifest, entries);\n        });\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestGroup.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"MB"}],"commitId":"0cd284978c3800a30d44aa2454dd5730b9bebfa7","commitMessage":"@@@Update scan planning with DeleteFiles in each task (#1288)\n\nThis adds `DeleteFileIndex` to scan delete manifests and index delete files.  updates `ManifestGroup` to use the index when planning tasks.  and adds delete files to `FileScanTask`.\n\nThe `DeleteFileIndex` uses a map keyed by partition spec ID and partition tuple. Values of the map are sorted list of sequence numbers and corresponding `DeleteFile` instances. When looking up a `DataFile`.  the potentially matching delete files are fetched using its partition tuple.  then the sequence numbers are binary searched to find the matching set of delete files with sequence numbers higher than the data file.\n\nThe index also supports global equality delete files. If an equality delete file is added to the table with an unpartitioned spec.  it will be returned for all data files with a lower sequence number.  regardless of partition.","date":"2020-08-06 04:22:25","modifiedFileCount":"11","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-08-06 04:22:25","codes":[{"authorDate":"2020-08-13 02:09:02","commitOrder":17,"curCode":"    private Iterable<CloseableIterable<ManifestEntry<DeleteFile>>> deleteManifestReaders() {\n      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n          Caffeine.newBuilder().build(specId -> {\n            PartitionSpec spec = specsById.get(specId);\n            return ManifestEvaluator.forPartitionFilter(\n                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n                spec, caseSensitive);\n          });\n\n      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n          Iterables.filter(deleteManifests, manifest ->\n              manifest.content() == ManifestContent.DELETES &&\n                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n      return Iterables.transform(\n          matchingManifests,\n          manifest ->\n              ManifestFiles.readDeleteManifest(manifest, io, specsById)\n                  .filterRows(dataFilter)\n                  .filterPartitions(partitionFilter)\n                  .caseSensitive(caseSensitive)\n                  .liveEntries()\n      );\n    }\n","date":"2020-08-13 02:09:02","endLine":284,"groupId":"2055","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"deleteManifestReaders","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/5e/c4e1354941cf1d577e1bfca02e255a3470dd4f.src","preCode":"    private Iterable<Pair<Integer, CloseableIterable<ManifestEntry<DeleteFile>>>> deleteManifestReaders() {\n      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n          Caffeine.newBuilder().build(specId -> {\n            PartitionSpec spec = specsById.get(specId);\n            return ManifestEvaluator.forPartitionFilter(\n                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n                spec, caseSensitive);\n          });\n\n      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n          Iterables.filter(deleteManifests, manifest ->\n              manifest.content() == ManifestContent.DELETES &&\n                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n      return Iterables.transform(\n          matchingManifests,\n          manifest -> Pair.of(\n              manifest.partitionSpecId(),\n              ManifestFiles.readDeleteManifest(manifest, io, specsById)\n                  .filterRows(dataFilter)\n                  .filterPartitions(partitionFilter)\n                  .caseSensitive(caseSensitive)\n                  .liveEntries())\n      );\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/DeleteFileIndex.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"M"},{"authorDate":"2020-08-06 04:22:25","commitOrder":17,"curCode":"  private <T> Iterable<CloseableIterable<T>> entries(\n      BiFunction<ManifestFile, CloseableIterable<ManifestEntry<DataFile>>, CloseableIterable<T>> entryFn) {\n    LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ?\n        null : Caffeine.newBuilder().build(specId -> {\n          PartitionSpec spec = specsById.get(specId);\n          return ManifestEvaluator.forPartitionFilter(\n              Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n              spec, caseSensitive);\n        });\n\n    Evaluator evaluator = new Evaluator(DataFile.getType(EMPTY_STRUCT), fileFilter, caseSensitive);\n\n    Iterable<ManifestFile> matchingManifests = evalCache == null ? dataManifests :\n        Iterables.filter(dataManifests, manifest -> evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n    if (ignoreDeleted) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasExistingFiles());\n    }\n\n    if (ignoreExisting) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasDeletedFiles());\n    }\n\n    matchingManifests = Iterables.filter(matchingManifests, manifestPredicate::test);\n\n    return Iterables.transform(\n        matchingManifests,\n        manifest -> {\n          ManifestReader<DataFile> reader = ManifestFiles.read(manifest, io, specsById)\n              .filterRows(dataFilter)\n              .filterPartitions(partitionFilter)\n              .caseSensitive(caseSensitive)\n              .select(columns);\n\n          CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n          if (ignoreDeleted) {\n            entries = reader.liveEntries();\n          }\n\n          if (ignoreExisting) {\n            entries = CloseableIterable.filter(entries,\n                entry -> entry.status() != ManifestEntry.Status.EXISTING);\n          }\n\n          if (fileFilter != null && fileFilter != Expressions.alwaysTrue()) {\n            entries = CloseableIterable.filter(entries,\n                entry -> evaluator.eval((GenericDataFile) entry.file()));\n          }\n\n          entries = CloseableIterable.filter(entries, manifestEntryPredicate);\n          return entryFn.apply(manifest, entries);\n        });\n  }\n","date":"2020-08-06 04:22:25","endLine":261,"groupId":"721","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"entries","params":"(BiFunction<ManifestFile@CloseableIterable<ManifestEntry<DataFile>>@CloseableIterable<T>>entryFn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a4/91080ee980ef1058f4c564174ea3af46cf1eb4.src","preCode":"  private <T> Iterable<CloseableIterable<T>> entries(\n      BiFunction<ManifestFile, CloseableIterable<ManifestEntry<DataFile>>, CloseableIterable<T>> entryFn) {\n    LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ?\n        null : Caffeine.newBuilder().build(specId -> {\n          PartitionSpec spec = specsById.get(specId);\n          return ManifestEvaluator.forPartitionFilter(\n              Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n              spec, caseSensitive);\n        });\n\n    Evaluator evaluator = new Evaluator(DataFile.getType(EMPTY_STRUCT), fileFilter, caseSensitive);\n\n    Iterable<ManifestFile> matchingManifests = evalCache == null ? dataManifests :\n        Iterables.filter(dataManifests, manifest -> evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n    if (ignoreDeleted) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasExistingFiles());\n    }\n\n    if (ignoreExisting) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasDeletedFiles());\n    }\n\n    matchingManifests = Iterables.filter(matchingManifests, manifestPredicate::test);\n\n    return Iterables.transform(\n        matchingManifests,\n        manifest -> {\n          ManifestReader<DataFile> reader = ManifestFiles.read(manifest, io, specsById)\n              .filterRows(dataFilter)\n              .filterPartitions(partitionFilter)\n              .caseSensitive(caseSensitive)\n              .select(columns);\n\n          CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n          if (ignoreDeleted) {\n            entries = reader.liveEntries();\n          }\n\n          if (ignoreExisting) {\n            entries = CloseableIterable.filter(entries,\n                entry -> entry.status() != ManifestEntry.Status.EXISTING);\n          }\n\n          if (fileFilter != null && fileFilter != Expressions.alwaysTrue()) {\n            entries = CloseableIterable.filter(entries,\n                entry -> evaluator.eval((GenericDataFile) entry.file()));\n          }\n\n          entries = CloseableIterable.filter(entries, manifestEntryPredicate);\n          return entryFn.apply(manifest, entries);\n        });\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestGroup.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"N"}],"commitId":"01986ea77b761fe2190699bba6f3dbb25fa93042","commitMessage":"@@@Core: Fix partition sets (#1308)\n\n","date":"2020-08-13 02:09:02","modifiedFileCount":"9","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-10-30 02:29:11","codes":[{"authorDate":"2020-08-13 02:09:02","commitOrder":18,"curCode":"    private Iterable<CloseableIterable<ManifestEntry<DeleteFile>>> deleteManifestReaders() {\n      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n          Caffeine.newBuilder().build(specId -> {\n            PartitionSpec spec = specsById.get(specId);\n            return ManifestEvaluator.forPartitionFilter(\n                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n                spec, caseSensitive);\n          });\n\n      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n          Iterables.filter(deleteManifests, manifest ->\n              manifest.content() == ManifestContent.DELETES &&\n                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n      return Iterables.transform(\n          matchingManifests,\n          manifest ->\n              ManifestFiles.readDeleteManifest(manifest, io, specsById)\n                  .filterRows(dataFilter)\n                  .filterPartitions(partitionFilter)\n                  .caseSensitive(caseSensitive)\n                  .liveEntries()\n      );\n    }\n","date":"2020-08-13 02:09:02","endLine":284,"groupId":"102140","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"deleteManifestReaders","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/5e/c4e1354941cf1d577e1bfca02e255a3470dd4f.src","preCode":"    private Iterable<CloseableIterable<ManifestEntry<DeleteFile>>> deleteManifestReaders() {\n      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n          Caffeine.newBuilder().build(specId -> {\n            PartitionSpec spec = specsById.get(specId);\n            return ManifestEvaluator.forPartitionFilter(\n                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n                spec, caseSensitive);\n          });\n\n      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n          Iterables.filter(deleteManifests, manifest ->\n              manifest.content() == ManifestContent.DELETES &&\n                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n      return Iterables.transform(\n          matchingManifests,\n          manifest ->\n              ManifestFiles.readDeleteManifest(manifest, io, specsById)\n                  .filterRows(dataFilter)\n                  .filterPartitions(partitionFilter)\n                  .caseSensitive(caseSensitive)\n                  .liveEntries()\n      );\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/DeleteFileIndex.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"N"},{"authorDate":"2020-10-30 02:29:11","commitOrder":18,"curCode":"  private <T> Iterable<CloseableIterable<T>> entries(\n      BiFunction<ManifestFile, CloseableIterable<ManifestEntry<DataFile>>, CloseableIterable<T>> entryFn) {\n    LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ?\n        null : Caffeine.newBuilder().build(specId -> {\n          PartitionSpec spec = specsById.get(specId);\n          return ManifestEvaluator.forPartitionFilter(\n              Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n              spec, caseSensitive);\n        });\n\n    Evaluator evaluator;\n    if (fileFilter != null && fileFilter != Expressions.alwaysTrue()) {\n      evaluator = new Evaluator(DataFile.getType(EMPTY_STRUCT), fileFilter, caseSensitive);\n    } else {\n      evaluator = null;\n    }\n\n    Iterable<ManifestFile> matchingManifests = evalCache == null ? dataManifests :\n        Iterables.filter(dataManifests, manifest -> evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n    if (ignoreDeleted) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasExistingFiles());\n    }\n\n    if (ignoreExisting) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasDeletedFiles());\n    }\n\n    matchingManifests = Iterables.filter(matchingManifests, manifestPredicate::test);\n\n    return Iterables.transform(\n        matchingManifests,\n        manifest -> {\n          ManifestReader<DataFile> reader = ManifestFiles.read(manifest, io, specsById)\n              .filterRows(dataFilter)\n              .filterPartitions(partitionFilter)\n              .caseSensitive(caseSensitive)\n              .select(columns);\n\n          CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n          if (ignoreDeleted) {\n            entries = reader.liveEntries();\n          }\n\n          if (ignoreExisting) {\n            entries = CloseableIterable.filter(entries,\n                entry -> entry.status() != ManifestEntry.Status.EXISTING);\n          }\n\n          if (evaluator != null) {\n            entries = CloseableIterable.filter(entries,\n                entry -> evaluator.eval((GenericDataFile) entry.file()));\n          }\n\n          entries = CloseableIterable.filter(entries, manifestEntryPredicate);\n          return entryFn.apply(manifest, entries);\n        });\n  }\n","date":"2020-10-30 02:29:11","endLine":271,"groupId":"102140","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"entries","params":"(BiFunction<ManifestFile@CloseableIterable<ManifestEntry<DataFile>>@CloseableIterable<T>>entryFn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/52/9867c457746c1488a00029dbf25156ab31f857.src","preCode":"  private <T> Iterable<CloseableIterable<T>> entries(\n      BiFunction<ManifestFile, CloseableIterable<ManifestEntry<DataFile>>, CloseableIterable<T>> entryFn) {\n    LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ?\n        null : Caffeine.newBuilder().build(specId -> {\n          PartitionSpec spec = specsById.get(specId);\n          return ManifestEvaluator.forPartitionFilter(\n              Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n              spec, caseSensitive);\n        });\n\n    Evaluator evaluator = new Evaluator(DataFile.getType(EMPTY_STRUCT), fileFilter, caseSensitive);\n\n    Iterable<ManifestFile> matchingManifests = evalCache == null ? dataManifests :\n        Iterables.filter(dataManifests, manifest -> evalCache.get(manifest.partitionSpecId()).eval(manifest));\n\n    if (ignoreDeleted) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasExistingFiles());\n    }\n\n    if (ignoreExisting) {\n      \r\n      \r\n      \r\n      matchingManifests = Iterables.filter(matchingManifests,\n          manifest -> manifest.hasAddedFiles() || manifest.hasDeletedFiles());\n    }\n\n    matchingManifests = Iterables.filter(matchingManifests, manifestPredicate::test);\n\n    return Iterables.transform(\n        matchingManifests,\n        manifest -> {\n          ManifestReader<DataFile> reader = ManifestFiles.read(manifest, io, specsById)\n              .filterRows(dataFilter)\n              .filterPartitions(partitionFilter)\n              .caseSensitive(caseSensitive)\n              .select(columns);\n\n          CloseableIterable<ManifestEntry<DataFile>> entries = reader.entries();\n          if (ignoreDeleted) {\n            entries = reader.liveEntries();\n          }\n\n          if (ignoreExisting) {\n            entries = CloseableIterable.filter(entries,\n                entry -> entry.status() != ManifestEntry.Status.EXISTING);\n          }\n\n          if (fileFilter != null && fileFilter != Expressions.alwaysTrue()) {\n            entries = CloseableIterable.filter(entries,\n                entry -> evaluator.eval((GenericDataFile) entry.file()));\n          }\n\n          entries = CloseableIterable.filter(entries, manifestEntryPredicate);\n          return entryFn.apply(manifest, entries);\n        });\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/ManifestGroup.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"d3e986ab04151294fdf4622c17bbb91d1fc2af17","commitMessage":"@@@Core: Do not create an Evaluator in ManifestGroup unless the file filter is used (#1678)\n\n","date":"2020-10-30 02:29:11","modifiedFileCount":"1","status":"M","submitter":"Ryan Blue"}]
