[{"authorTime":"2020-08-20 08:36:46","codes":[{"authorDate":"2020-08-14 03:27:26","commitOrder":2,"curCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      if (expected == null) {\n        return null;\n      }\n\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new ParquetValueReaders.StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            Types.TimestampType tsMicrosType = (Types.TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            Types.TimestampType tsMillisType = (Types.TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case TIME_MICROS:\n            return new TimeReader(desc);\n          case TIME_MILLIS:\n            return new TimeMillisReader(desc);\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new ParquetValueReaders.BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new ParquetValueReaders.LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new ParquetValueReaders.IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new ParquetValueReaders.BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        case INT96:\n          \r\n          \r\n          return new TimestampInt96Reader(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-08-14 03:27:26","endLine":316,"groupId":"4774","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(org.apache.iceberg.types.Type.PrimitiveTypeexpected@PrimitiveTypeprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/71/0c771036d4ae5f9e1e5bac7591099b5aaa9819.src","preCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      if (expected == null) {\n        return null;\n      }\n\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new ParquetValueReaders.StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            Types.TimestampType tsMicrosType = (Types.TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            Types.TimestampType tsMillisType = (Types.TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case TIME_MICROS:\n            return new TimeReader(desc);\n          case TIME_MILLIS:\n            return new TimeMillisReader(desc);\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new ParquetValueReaders.BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new ParquetValueReaders.LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new ParquetValueReaders.IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new ParquetValueReaders.BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        case INT96:\n          \r\n          \r\n          return new TimestampInt96Reader(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/data/parquet/BaseParquetReaders.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"NB"},{"authorDate":"2020-08-20 08:36:46","commitOrder":2,"curCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected != null && expected.typeId() == Types.LongType.get().typeId()) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case TIME_MICROS:\n            return new LossyMicrosToMillisTimeReader(desc);\n          case TIME_MILLIS:\n            return new MillisTimeReader(desc);\n          case DATE:\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case TIMESTAMP_MICROS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MicrosToTimestampTzReader(desc);\n            } else {\n              return new MicrosToTimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MillisToTimestampTzReader(desc);\n            } else {\n              return new MillisToTimestampReader(desc);\n            }\n          case DECIMAL:\n            DecimalLogicalTypeAnnotation decimal = (DecimalLogicalTypeAnnotation) primitive.getLogicalTypeAnnotation();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT64:\n                return new LongDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT32:\n                return new IntegerDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.ByteArrayReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n        case BINARY:\n          return new ParquetValueReaders.ByteArrayReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-08-20 08:36:46","endLine":249,"groupId":"898","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(org.apache.iceberg.types.Type.PrimitiveTypeexpected@PrimitiveTypeprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/30/12544cba8367880b92039dd5d6a9552d50f001.src","preCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected != null && expected.typeId() == Types.LongType.get().typeId()) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case TIME_MICROS:\n            return new LossyMicrosToMillisTimeReader(desc);\n          case TIME_MILLIS:\n            return new MillisTimeReader(desc);\n          case DATE:\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case TIMESTAMP_MICROS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MicrosToTimestampTzReader(desc);\n            } else {\n              return new MicrosToTimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MillisToTimestampTzReader(desc);\n            } else {\n              return new MillisToTimestampReader(desc);\n            }\n          case DECIMAL:\n            DecimalLogicalTypeAnnotation decimal = (DecimalLogicalTypeAnnotation) primitive.getLogicalTypeAnnotation();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT64:\n                return new LongDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT32:\n                return new IntegerDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.ByteArrayReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n        case BINARY:\n          return new ParquetValueReaders.ByteArrayReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"flink/src/main/java/org/apache/iceberg/flink/data/FlinkParquetReaders.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"B"}],"commitId":"6cb2db7acb06891502ac4af1845b239ed7cb521d","commitMessage":"@@@Flink: Read Parquet as RowData using a schema visitor (#1266)\n\n","date":"2020-08-20 08:36:46","modifiedFileCount":"5","status":"M","submitter":"Chen Junjie"},{"authorTime":"2020-12-08 10:16:47","codes":[{"authorDate":"2020-08-14 03:27:26","commitOrder":3,"curCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      if (expected == null) {\n        return null;\n      }\n\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new ParquetValueReaders.StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            Types.TimestampType tsMicrosType = (Types.TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            Types.TimestampType tsMillisType = (Types.TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case TIME_MICROS:\n            return new TimeReader(desc);\n          case TIME_MILLIS:\n            return new TimeMillisReader(desc);\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new ParquetValueReaders.BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new ParquetValueReaders.LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new ParquetValueReaders.IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new ParquetValueReaders.BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        case INT96:\n          \r\n          \r\n          return new TimestampInt96Reader(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-08-14 03:27:26","endLine":316,"groupId":"10140","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(org.apache.iceberg.types.Type.PrimitiveTypeexpected@PrimitiveTypeprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/71/0c771036d4ae5f9e1e5bac7591099b5aaa9819.src","preCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      if (expected == null) {\n        return null;\n      }\n\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new ParquetValueReaders.StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            Types.TimestampType tsMicrosType = (Types.TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            Types.TimestampType tsMillisType = (Types.TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case TIME_MICROS:\n            return new TimeReader(desc);\n          case TIME_MILLIS:\n            return new TimeMillisReader(desc);\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new ParquetValueReaders.BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new ParquetValueReaders.LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new ParquetValueReaders.IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new ParquetValueReaders.BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        case INT96:\n          \r\n          \r\n          return new TimestampInt96Reader(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"parquet/src/main/java/org/apache/iceberg/data/parquet/BaseParquetReaders.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"N"},{"authorDate":"2020-12-08 10:16:47","commitOrder":3,"curCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      if (expected == null) {\n        return null;\n      }\n\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == Types.LongType.get().typeId()) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case TIME_MICROS:\n            return new LossyMicrosToMillisTimeReader(desc);\n          case TIME_MILLIS:\n            return new MillisTimeReader(desc);\n          case DATE:\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case TIMESTAMP_MICROS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MicrosToTimestampTzReader(desc);\n            } else {\n              return new MicrosToTimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MillisToTimestampTzReader(desc);\n            } else {\n              return new MillisToTimestampReader(desc);\n            }\n          case DECIMAL:\n            DecimalLogicalTypeAnnotation decimal = (DecimalLogicalTypeAnnotation) primitive.getLogicalTypeAnnotation();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT64:\n                return new LongDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT32:\n                return new IntegerDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.ByteArrayReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n        case BINARY:\n          return new ParquetValueReaders.ByteArrayReader(desc);\n        case INT32:\n          if (expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-12-08 10:16:47","endLine":267,"groupId":"10140","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(org.apache.iceberg.types.Type.PrimitiveTypeexpected@PrimitiveTypeprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6f/95d652ceab5aa73312fb1adc5c22471d9a946d.src","preCode":"    public ParquetValueReader<?> primitive(org.apache.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected != null && expected.typeId() == Types.LongType.get().typeId()) {\n              return new ParquetValueReaders.IntAsLongReader(desc);\n            } else {\n              return new ParquetValueReaders.UnboxedReader<>(desc);\n            }\n          case TIME_MICROS:\n            return new LossyMicrosToMillisTimeReader(desc);\n          case TIME_MILLIS:\n            return new MillisTimeReader(desc);\n          case DATE:\n          case INT_64:\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          case TIMESTAMP_MICROS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MicrosToTimestampTzReader(desc);\n            } else {\n              return new MicrosToTimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n              return new MillisToTimestampTzReader(desc);\n            } else {\n              return new MillisToTimestampReader(desc);\n            }\n          case DECIMAL:\n            DecimalLogicalTypeAnnotation decimal = (DecimalLogicalTypeAnnotation) primitive.getLogicalTypeAnnotation();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT64:\n                return new LongDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              case INT32:\n                return new IntegerDecimalReader(desc, decimal.getPrecision(), decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new ParquetValueReaders.ByteArrayReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n        case BINARY:\n          return new ParquetValueReaders.ByteArrayReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.LONG) {\n            return new ParquetValueReaders.IntAsLongReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == org.apache.iceberg.types.Type.TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new ParquetValueReaders.UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new ParquetValueReaders.UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"flink/src/main/java/org/apache/iceberg/flink/data/FlinkParquetReaders.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"}],"commitId":"c3dd3e19a766b2111fb8378eb7834587dd65eb1d","commitMessage":"@@@Flink: fix projection NPE caused by timestamp type (#1882)\n\n","date":"2020-12-08 10:16:47","modifiedFileCount":"2","status":"M","submitter":"Chen Junjie"}]
