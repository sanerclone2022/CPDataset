[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":170,"groupId":"1311","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6a/f5b2131c4c2af675dda90c4192ebe9c3c73b8a.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-03-21 07:25:05","endLine":227,"groupId":"1311","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"gtEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6a/f5b2131c4c2af675dda90c4192ebe9c3c73b8a.src","preCode":"    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-08-27 01:23:12","codes":[{"authorDate":"2019-08-27 01:23:12","commitOrder":2,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (canContainNulls(id)) {\n        return ROWS_MIGHT_NOT_MATCH;\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-08-27 01:23:12","endLine":172,"groupId":"3958","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/17/ef0b15b502c55a73b39e56f0d53130b823abd1.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"},{"authorDate":"2019-08-27 01:23:12","commitOrder":2,"curCode":"    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (canContainNulls(id)) {\n        return ROWS_MIGHT_NOT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-08-27 01:23:12","endLine":241,"groupId":"3958","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"gtEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/17/ef0b15b502c55a73b39e56f0d53130b823abd1.src","preCode":"    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"M"}],"commitId":"e7197a7e9cda676ddce402a258ca6e3ebfb2dcad","commitMessage":"@@@Use null counts in metrics evaluators (#412)\n\n","date":"2019-08-27 01:23:12","modifiedFileCount":"4","status":"M","submitter":"Anton Okolnychyi"},{"authorTime":"2021-01-21 01:03:55","codes":[{"authorDate":"2021-01-21 01:03:55","commitOrder":3,"curCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (canContainNulls(id) || canContainNaNs(id)) {\n        return ROWS_MIGHT_NOT_MATCH;\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2021-01-21 01:03:55","endLine":202,"groupId":"101506","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"lt","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6e/a293a0b562bf42d7874b3ada59687787c298ea.src","preCode":"    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (canContainNulls(id)) {\n        return ROWS_MIGHT_NOT_MATCH;\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"M"},{"authorDate":"2021-01-21 01:03:55","commitOrder":3,"curCode":"    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (canContainNulls(id) || canContainNaNs(id)) {\n        return ROWS_MIGHT_NOT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        if (NaNUtil.isNaN(lower)) {\n          \r\n          return ROWS_MIGHT_NOT_MATCH;\n        }\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2021-01-21 01:03:55","endLine":281,"groupId":"101506","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"gtEq","params":"(BoundReference<T>ref@Literal<T>lit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6e/a293a0b562bf42d7874b3ada59687787c298ea.src","preCode":"    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      \r\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (canContainNulls(id)) {\n        return ROWS_MIGHT_NOT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"M"}],"commitId":"b018e21a814808c70990c3d1f29a998d6036aa90","commitMessage":"@@@API: Handle NaN lower or upper bound in stats evaluators (#2069)\n\n","date":"2021-01-21 01:03:55","modifiedFileCount":"2","status":"M","submitter":"yyanyy"}]
