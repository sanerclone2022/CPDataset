[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n    StructType s = (StructType) current;\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    \r\n    Map<String, Types.NestedField> projectedFields = Maps.newLinkedHashMap();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        projectedFields.put(field.name(), field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    \r\n    boolean reordered = false;\n    StructField[] requestedFields = s.fields();\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(requestedFields.length);\n    for (int i = 0; i < requestedFields.length; i += 1) {\n      \r\n      String name = requestedFields[i].name();\n      if (!fields.get(i).name().equals(name)) {\n        reordered = true;\n      }\n      newFields.add(projectedFields.remove(name));\n    }\n\n    \r\n    if (!projectedFields.isEmpty()) {\n      newFields.addAll(projectedFields.values());\n      changed = true; \r\n    }\n\n    if (reordered || changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","date":"2019-03-21 07:25:05","endLine":129,"groupId":"1484","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"struct","params":"(Types.StructTypestruct@Iterable<Type>fieldResults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d3/5a423fc211931c263e74e7b8b2fb444a637b4b.src","preCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n    StructType s = (StructType) current;\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    \r\n    Map<String, Types.NestedField> projectedFields = Maps.newLinkedHashMap();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        projectedFields.put(field.name(), field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    \r\n    boolean reordered = false;\n    StructField[] requestedFields = s.fields();\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(requestedFields.length);\n    for (int i = 0; i < requestedFields.length; i += 1) {\n      \r\n      String name = requestedFields[i].name();\n      if (!fields.get(i).name().equals(name)) {\n        reordered = true;\n      }\n      newFields.add(projectedFields.remove(name));\n    }\n\n    \r\n    if (!projectedFields.isEmpty()) {\n      newFields.addAll(projectedFields.values());\n      changed = true; \r\n    }\n\n    if (reordered || changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/PruneColumnsWithReordering.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        newFields.add(field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        newFields.add(Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        newFields.add(Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    if (changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","date":"2019-03-21 07:25:05","endLine":105,"groupId":"1484","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"struct","params":"(Types.StructTypestruct@Iterable<Type>fieldResults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6c/773740f067f11e13ae9bb94425d445fb55f2e3.src","preCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        newFields.add(field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        newFields.add(Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        newFields.add(Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    if (changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/PruneColumnsWithoutReordering.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-06-24 23:57:49","commitOrder":2,"curCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n    StructType requestedStruct = (StructType) current;\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    \r\n    Map<String, Types.NestedField> projectedFields = Maps.newLinkedHashMap();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        projectedFields.put(field.name(), field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    \r\n    boolean reordered = false;\n    StructField[] requestedFields = requestedStruct.fields();\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(requestedFields.length);\n    for (int i = 0; i < requestedFields.length; i += 1) {\n      \r\n      String name = requestedFields[i].name();\n      if (!fields.get(i).name().equals(name)) {\n        reordered = true;\n      }\n      newFields.add(projectedFields.remove(name));\n    }\n\n    \r\n    if (!projectedFields.isEmpty()) {\n      newFields.addAll(projectedFields.values());\n      changed = true; \r\n    }\n\n    if (reordered || changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","date":"2019-06-24 23:57:49","endLine":129,"groupId":"10527","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"struct","params":"(Types.StructTypestruct@Iterable<Type>fieldResults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/ed/be39015c429c30f69e858fc15ea407d35fcbc3.src","preCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n    StructType s = (StructType) current;\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    \r\n    Map<String, Types.NestedField> projectedFields = Maps.newLinkedHashMap();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        projectedFields.put(field.name(), field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        projectedFields.put(field.name(),\n            Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    \r\n    boolean reordered = false;\n    StructField[] requestedFields = s.fields();\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(requestedFields.length);\n    for (int i = 0; i < requestedFields.length; i += 1) {\n      \r\n      String name = requestedFields[i].name();\n      if (!fields.get(i).name().equals(name)) {\n        reordered = true;\n      }\n      newFields.add(projectedFields.remove(name));\n    }\n\n    \r\n    if (!projectedFields.isEmpty()) {\n      newFields.addAll(projectedFields.values());\n      changed = true; \r\n    }\n\n    if (reordered || changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/PruneColumnsWithReordering.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        newFields.add(field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        newFields.add(Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        newFields.add(Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    if (changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","date":"2019-03-21 07:25:05","endLine":105,"groupId":"10527","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"struct","params":"(Types.StructTypestruct@Iterable<Type>fieldResults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6c/773740f067f11e13ae9bb94425d445fb55f2e3.src","preCode":"  public Type struct(Types.StructType struct, Iterable<Type> fieldResults) {\n    Preconditions.checkNotNull(struct, \"Cannot prune null struct. Pruning must start with a schema.\");\n    Preconditions.checkArgument(current instanceof StructType, \"Not a struct: %s\", current);\n\n    List<Types.NestedField> fields = struct.fields();\n    List<Type> types = Lists.newArrayList(fieldResults);\n\n    boolean changed = false;\n    List<Types.NestedField> newFields = Lists.newArrayListWithExpectedSize(types.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      Type type = types.get(i);\n\n      if (type == null) {\n        changed = true;\n\n      } else if (field.type() == type) {\n        newFields.add(field);\n\n      } else if (field.isOptional()) {\n        changed = true;\n        newFields.add(Types.NestedField.optional(field.fieldId(), field.name(), type));\n\n      } else {\n        changed = true;\n        newFields.add(Types.NestedField.required(field.fieldId(), field.name(), type));\n      }\n    }\n\n    if (changed) {\n      return Types.StructType.of(newFields);\n    }\n\n    return struct;\n  }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/PruneColumnsWithoutReordering.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"N"}],"commitId":"5f6fc3be3400cfae858a938213ba8516acc983a5","commitMessage":"@@@[Baseline] Apply Baseline plugin to iceberg-spark (#226)\n\n","date":"2019-06-24 23:57:49","modifiedFileCount":"36","status":"M","submitter":"Anton Okolnychyi"}]
