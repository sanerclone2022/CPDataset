[{"authorTime":"2019-12-19 01:58:30","codes":[{"authorDate":"2019-12-19 01:58:30","commitOrder":5,"curCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      ValidationException.check(pred.term() instanceof BoundReference,\n          \"Visitor %s does not support expression: %s\", this, pred.term());\n\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt((BoundReference<T>) pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT:\n            return gt((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case EQ:\n            return eq((BoundReference<T>) pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith((BoundReference<T>) pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull((BoundReference<T>) pred.term());\n          case NOT_NULL:\n            return notNull((BoundReference<T>) pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","date":"2019-12-19 01:58:30","endLine":161,"groupId":"1487","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"predicate","params":"(BoundPredicate<T>pred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/46/77953b1a0b8d72313f49c9f2101611c2e86878.src","preCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      ValidationException.check(pred.term() instanceof BoundReference,\n          \"Visitor %s does not support expression: %s\", this, pred.term());\n\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt((BoundReference<T>) pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT:\n            return gt((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case EQ:\n            return eq((BoundReference<T>) pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith((BoundReference<T>) pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull((BoundReference<T>) pred.term());\n          case NOT_NULL:\n            return notNull((BoundReference<T>) pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"MB"},{"authorDate":"2019-12-19 01:58:30","commitOrder":5,"curCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt(pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq(pred.term(), literalPred.literal());\n          case GT:\n            return gt(pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq(pred.term(), literalPred.literal());\n          case EQ:\n            return eq(pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq(pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith(pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull(pred.term());\n          case NOT_NULL:\n            return notNull(pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in(pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn(pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","date":"2019-12-19 01:58:30","endLine":259,"groupId":"1488","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"predicate","params":"(BoundPredicate<T>pred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/46/77953b1a0b8d72313f49c9f2101611c2e86878.src","preCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt(pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq(pred.term(), literalPred.literal());\n          case GT:\n            return gt(pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq(pred.term(), literalPred.literal());\n          case EQ:\n            return eq(pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq(pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith(pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull(pred.term());\n          case NOT_NULL:\n            return notNull(pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in(pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn(pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":215,"status":"B"}],"commitId":"686fcb752dd5a7204094266cd3c4363431dddb43","commitMessage":"@@@Add transform expressions (#686)\n\n* Add transform expressions.\n\n* Fix checkstyle violations.\n\n* Rename ValueExpression to Term and clean up class hierarchy.\n\n* Restore BoundExpressionVisitor to avoid compatibility problems.\n\n* Fix documentation typo.\n\n* Add missing BoundTransform.toString method.\n\n* Revert unnecessary change to TestExpressionSerialization.\n\n* Rename child to term.\n","date":"2019-12-19 01:58:30","modifiedFileCount":"23","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-12-06 09:14:27","codes":[{"authorDate":"2020-12-06 09:14:27","commitOrder":6,"curCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      ValidationException.check(pred.term() instanceof BoundReference,\n          \"Visitor %s does not support expression: %s\", this, pred.term());\n\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt((BoundReference<T>) pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT:\n            return gt((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case EQ:\n            return eq((BoundReference<T>) pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith((BoundReference<T>) pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull((BoundReference<T>) pred.term());\n          case NOT_NULL:\n            return notNull((BoundReference<T>) pred.term());\n          case IS_NAN:\n            return isNaN((BoundReference<T>) pred.term());\n          case NOT_NAN:\n            return notNaN((BoundReference<T>) pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","date":"2020-12-06 09:14:27","endLine":174,"groupId":"111500","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"predicate","params":"(BoundPredicate<T>pred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/cb/ec7485521d46a2489f7d7464660f32b031f804.src","preCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      ValidationException.check(pred.term() instanceof BoundReference,\n          \"Visitor %s does not support expression: %s\", this, pred.term());\n\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt((BoundReference<T>) pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT:\n            return gt((BoundReference<T>) pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case EQ:\n            return eq((BoundReference<T>) pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq((BoundReference<T>) pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith((BoundReference<T>) pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull((BoundReference<T>) pred.term());\n          case NOT_NULL:\n            return notNull((BoundReference<T>) pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn((BoundReference<T>) pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"},{"authorDate":"2020-12-06 09:14:27","commitOrder":6,"curCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt(pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq(pred.term(), literalPred.literal());\n          case GT:\n            return gt(pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq(pred.term(), literalPred.literal());\n          case EQ:\n            return eq(pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq(pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith(pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull(pred.term());\n          case NOT_NULL:\n            return notNull(pred.term());\n          case IS_NAN:\n            return isNaN(pred.term());\n          case NOT_NAN:\n            return notNaN(pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in(pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn(pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","date":"2020-12-06 09:14:27","endLine":284,"groupId":"111500","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"predicate","params":"(BoundPredicate<T>pred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/cb/ec7485521d46a2489f7d7464660f32b031f804.src","preCode":"    public <T> R predicate(BoundPredicate<T> pred) {\n      if (pred.isLiteralPredicate()) {\n        BoundLiteralPredicate<T> literalPred = pred.asLiteralPredicate();\n        switch (pred.op()) {\n          case LT:\n            return lt(pred.term(), literalPred.literal());\n          case LT_EQ:\n            return ltEq(pred.term(), literalPred.literal());\n          case GT:\n            return gt(pred.term(), literalPred.literal());\n          case GT_EQ:\n            return gtEq(pred.term(), literalPred.literal());\n          case EQ:\n            return eq(pred.term(), literalPred.literal());\n          case NOT_EQ:\n            return notEq(pred.term(), literalPred.literal());\n          case STARTS_WITH:\n            return startsWith(pred.term(),  literalPred.literal());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundLiteralPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isUnaryPredicate()) {\n        switch (pred.op()) {\n          case IS_NULL:\n            return isNull(pred.term());\n          case NOT_NULL:\n            return notNull(pred.term());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundUnaryPredicate: \" + pred.op());\n        }\n\n      } else if (pred.isSetPredicate()) {\n        switch (pred.op()) {\n          case IN:\n            return in(pred.term(), pred.asSetPredicate().literalSet());\n          case NOT_IN:\n            return notIn(pred.term(), pred.asSetPredicate().literalSet());\n          default:\n            throw new IllegalStateException(\"Invalid operation for BoundSetPredicate: \" + pred.op());\n        }\n      }\n\n      throw new IllegalStateException(\"Unsupported bound predicate: \" + pred.getClass().getName());\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/ExpressionVisitors.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"M"}],"commitId":"fab4a5f2db140fdb132205e78934a145e646758b","commitMessage":"@@@API: add isNaN and notNaN predicates (#1747)\n\n","date":"2020-12-06 09:14:27","modifiedFileCount":"27","status":"M","submitter":"yyanyy"}]
