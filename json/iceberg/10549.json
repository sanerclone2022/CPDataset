[{"authorTime":"2021-09-07 11:20:09","codes":[{"authorDate":"2021-06-24 18:11:06","commitOrder":3,"curCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      this.fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","date":"2021-06-24 18:11:06","endLine":235,"groupId":"5102","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"VectorizedCombinedScanIterator","params":"(CloseableIterable<CombinedScanTask>tasks@SchemaexpectedSchema@StringnameMapping@FileIOio@EncryptionManagerencryptionManager@booleancaseSensitive@intbatchSize@booleanreuseContainers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/50/3a273fe477143fdb198a0d0ba9ec0e1b5b982c.src","preCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      this.fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","realPath":"arrow/src/main/java/org/apache/iceberg/arrow/vectorized/ArrowReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"NB"},{"authorDate":"2021-09-07 11:20:09","commitOrder":3,"curCode":"  public InputFilesDecryptor(CombinedScanTask combinedTask, FileIO io, EncryptionManager encryption) {\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    combinedTask.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryption.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(keyMetadata.size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.decryptedInputFiles = Collections.unmodifiableMap(files);\n  }\n","date":"2021-09-07 11:20:09","endLine":51,"groupId":"1812","id":2,"instanceNumber":2,"isCurCommit":1,"methodName":"InputFilesDecryptor","params":"(CombinedScanTaskcombinedTask@FileIOio@EncryptionManagerencryption)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6c/1e0eb8b250ec4bcfa33ec602cbdeaca6d05c26.src","preCode":"  public InputFilesDecryptor(CombinedScanTask combinedTask, FileIO io, EncryptionManager encryption) {\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    combinedTask.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryption.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(keyMetadata.size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.decryptedInputFiles = Collections.unmodifiableMap(files);\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/encryption/InputFilesDecryptor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"B"}],"commitId":"5f9047602bb23fa4d0f5cf63eea00f38329fb7bf","commitMessage":"@@@Flink: Refactor DataIterator to use composition instead of inheritance (#2905)\n\n","date":"2021-09-07 11:20:09","modifiedFileCount":"3","status":"M","submitter":"Steven Zhen Wu"},{"authorTime":"2021-09-07 11:20:09","codes":[{"authorDate":"2021-09-18 02:36:45","commitOrder":4,"curCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      List<FileScanTask> fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      if (fileTasks.stream().anyMatch(TableScanUtil::hasDeletes)) {\n        throw new UnsupportedOperationException(\"Cannot read files that require applying delete files\");\n      }\n\n      if (expectedSchema.columns().isEmpty()) {\n        throw new UnsupportedOperationException(\"Cannot read without at least one projected column\");\n      }\n\n      Set<TypeID> unsupportedTypes = Sets.difference(\n          expectedSchema.columns().stream().map(c -> c.type().typeId()).collect(Collectors.toSet()),\n          SUPPORTED_TYPES);\n      if (!unsupportedTypes.isEmpty()) {\n        throw new UnsupportedOperationException(\"Cannot read unsupported column types: \" + unsupportedTypes);\n      }\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .map(FileScanTask::file)\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","date":"2021-09-18 02:36:45","endLine":282,"groupId":"10549","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"VectorizedCombinedScanIterator","params":"(CloseableIterable<CombinedScanTask>tasks@SchemaexpectedSchema@StringnameMapping@FileIOio@EncryptionManagerencryptionManager@booleancaseSensitive@intbatchSize@booleanreuseContainers)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f0/9774e9f6ce7c2212df0d1d57a786be0631730e.src","preCode":"    VectorizedCombinedScanIterator(\n        CloseableIterable<CombinedScanTask> tasks,\n        Schema expectedSchema,\n        String nameMapping,\n        FileIO io,\n        EncryptionManager encryptionManager,\n        boolean caseSensitive,\n        int batchSize,\n        boolean reuseContainers) {\n      this.fileTasks = StreamSupport.stream(tasks.spliterator(), false)\n          .map(CombinedScanTask::files)\n          .flatMap(Collection::stream)\n          .collect(Collectors.toList());\n      this.fileItr = fileTasks.iterator();\n\n      Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n      fileTasks.stream()\n          .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n          .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n\n      Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n          .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n      \r\n      Iterable<InputFile> decryptedFiles = encryptionManager.decrypt(encrypted::iterator);\n\n      Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(fileTasks.size());\n      decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n      this.inputFiles = ImmutableMap.copyOf(files);\n      this.currentIterator = CloseableIterator.empty();\n      this.expectedSchema = expectedSchema;\n      this.nameMapping = nameMapping;\n      this.caseSensitive = caseSensitive;\n      this.batchSize = batchSize;\n      this.reuseContainers = reuseContainers;\n    }\n","realPath":"arrow/src/main/java/org/apache/iceberg/arrow/vectorized/ArrowReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"},{"authorDate":"2021-09-07 11:20:09","commitOrder":4,"curCode":"  public InputFilesDecryptor(CombinedScanTask combinedTask, FileIO io, EncryptionManager encryption) {\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    combinedTask.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryption.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(keyMetadata.size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.decryptedInputFiles = Collections.unmodifiableMap(files);\n  }\n","date":"2021-09-07 11:20:09","endLine":51,"groupId":"10549","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"InputFilesDecryptor","params":"(CombinedScanTaskcombinedTask@FileIOio@EncryptionManagerencryption)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6c/1e0eb8b250ec4bcfa33ec602cbdeaca6d05c26.src","preCode":"  public InputFilesDecryptor(CombinedScanTask combinedTask, FileIO io, EncryptionManager encryption) {\n    Map<String, ByteBuffer> keyMetadata = Maps.newHashMap();\n    combinedTask.files().stream()\n        .flatMap(fileScanTask -> Stream.concat(Stream.of(fileScanTask.file()), fileScanTask.deletes().stream()))\n        .forEach(file -> keyMetadata.put(file.path().toString(), file.keyMetadata()));\n    Stream<EncryptedInputFile> encrypted = keyMetadata.entrySet().stream()\n        .map(entry -> EncryptedFiles.encryptedInput(io.newInputFile(entry.getKey()), entry.getValue()));\n\n    \r\n    Iterable<InputFile> decryptedFiles = encryption.decrypt(encrypted::iterator);\n\n    Map<String, InputFile> files = Maps.newHashMapWithExpectedSize(keyMetadata.size());\n    decryptedFiles.forEach(decrypted -> files.putIfAbsent(decrypted.location(), decrypted));\n    this.decryptedInputFiles = Collections.unmodifiableMap(files);\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/encryption/InputFilesDecryptor.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"N"}],"commitId":"f220f2534f3ae6e77c4ab9cae2ebe02185655d6a","commitMessage":"@@@Arrow: Fix assertions and correctness checks (#2933)\n\n","date":"2021-09-18 02:36:45","modifiedFileCount":"2","status":"M","submitter":"mayursrivastava"}]
