[{"authorTime":"2020-04-16 04:13:35","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","date":"2019-03-21 07:25:05","endLine":264,"groupId":"4241","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testChangedPartitionSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/33/b2b09cd9bdde5ca84aa0bf8d57d6e60b88ab92.src","preCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"NB"},{"authorDate":"2020-04-16 04:13:35","commitOrder":2,"curCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry entry = ManifestReader.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestReader.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","date":"2020-04-16 04:13:35","endLine":745,"groupId":"281","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testManifestEntryFieldIdsForChangedPartitionSpecForV1Table","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d7/b3a48b002a10589db40105fc36b6bc1fbc621c.src","preCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry entry = ManifestReader.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestReader.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":696,"status":"B"}],"commitId":"b6cdc694b6b5a1040d6a2ffb4e72446fe52309c4","commitMessage":"@@@Add persistent IDs to partition fields (#845)\n\n","date":"2020-04-16 04:13:35","modifiedFileCount":"10","status":"M","submitter":"jun-he"},{"authorTime":"2020-04-16 07:44:35","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":3,"curCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","date":"2019-03-21 07:25:05","endLine":264,"groupId":"4241","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testChangedPartitionSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/33/b2b09cd9bdde5ca84aa0bf8d57d6e60b88ab92.src","preCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"N"},{"authorDate":"2020-04-16 07:44:35","commitOrder":3,"curCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry entry = ManifestFiles.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","date":"2020-04-16 07:44:35","endLine":745,"groupId":"281","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testManifestEntryFieldIdsForChangedPartitionSpecForV1Table","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d4/dcff9c542118ebaf8a51d3ede0c5376bc1f40f.src","preCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry entry = ManifestReader.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestReader.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":696,"status":"M"}],"commitId":"a5e77369c330873a6a292b8952b1ca09b7712bb7","commitMessage":"@@@Move manifest factory methods (#925)\n\n","date":"2020-04-16 07:44:35","modifiedFileCount":"18","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-05-30 03:26:56","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":4,"curCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","date":"2019-03-21 07:25:05","endLine":264,"groupId":"4241","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testChangedPartitionSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/33/b2b09cd9bdde5ca84aa0bf8d57d6e60b88ab92.src","preCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"N"},{"authorDate":"2020-05-30 03:26:56","commitOrder":4,"curCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","date":"2020-05-30 03:26:56","endLine":760,"groupId":"281","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testManifestEntryFieldIdsForChangedPartitionSpecForV1Table","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a3/93adf638549b0e75a1ac2d1b37280577323e63.src","preCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry entry = ManifestFiles.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":711,"status":"M"}],"commitId":"527240b445b23cef1a655eccbb3b2c0eb7d178c1","commitMessage":"@@@Add DeleteFile and manifest reader and writer for deletes (#1064)\n\n","date":"2020-05-30 03:26:56","modifiedFileCount":"28","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-06-03 03:43:03","codes":[{"authorDate":"2020-06-03 03:43:03","commitOrder":5,"curCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.allManifests().size());\n\n    \r\n    validateManifest(pending.allManifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.allManifests().get(1));\n  }\n","date":"2020-06-03 03:43:03","endLine":412,"groupId":"4241","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testChangedPartitionSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/bc/6c6a3d5bc29e3bac1de485296afb17bde3e6ab.src","preCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"M"},{"authorDate":"2020-06-03 03:43:03","commitOrder":5,"curCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.allManifests().size());\n\n    \r\n    validateManifest(pending.allManifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.allManifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(pending.allManifests().get(0), FILE_IO)\n        .entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(pending.allManifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","date":"2020-06-03 03:43:03","endLine":761,"groupId":"281","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testManifestEntryFieldIdsForChangedPartitionSpecForV1Table","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/bc/6c6a3d5bc29e3bac1de485296afb17bde3e6ab.src","preCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.manifests().size());\n\n    \r\n    validateManifest(pending.manifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.manifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(pending.manifests().get(0), FILE_IO).entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(pending.manifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":711,"status":"M"}],"commitId":"482f420141486f5b7b02bd62dc14cdb94b9a9cca","commitMessage":"@@@Split Snapshot.manifests into dataManifests and deleteManifests (#1080)\n\nThis replaces all calls to Snapshot.manifests with calls to one of 3 new methods:\n\n* `Snapshot.allManifests` returns both delete and data manifests\n* `Snapshot.deleteManifests` returns only delete manifests\n* `Snapshot.dataManifests` returns only data manifests\n\nExisting references mostly use either `allManifests` or `dataManifests`.  depending on the context. For example.  tests with assertions for the number of manifests use `allManifests` because the test cases should validate there are no new delete manifests.  but other tests that validate rewritten manifests are deleted use `dataManifests` because only data manifests are rewritten and deleted.\n\nThis tries to make minimal changes that preserve the current behavior. Operations are not updated to support delete manifests (rewrite still only rewrites data manifests).  but will carry through the list of delete manifests correctly.","date":"2020-06-03 03:43:03","modifiedFileCount":"46","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-08-08 09:28:52","codes":[{"authorDate":"2020-08-08 09:28:52","commitOrder":6,"curCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    Snapshot snap = table.currentSnapshot();\n    long commitId = snap.snapshotId();\n    validateSnapshot(null, snap, 1, FILE_A, FILE_B);\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n    validateManifest(initialManifest,\n        seqs(1, 1),\n        ids(commitId, commitId),\n        files(FILE_A, FILE_B),\n        statuses(Status.ADDED, Status.ADDED));\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n    Snapshot snap2 = table.currentSnapshot();\n    V2Assert.assertEquals(\"Snapshot sequence number should be 1\", 1, snap2.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 1\", 1, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    table.newAppend()\n        .appendFile(newFileC)\n        .commit();\n\n    Snapshot lastSnapshot = table.currentSnapshot();\n    V2Assert.assertEquals(\"Snapshot sequence number should be 2\", 2, lastSnapshot.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 2\", 2, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, lastSnapshot.allManifests().size());\n\n    \r\n    validateManifest(lastSnapshot.allManifests().get(0),\n        seqs(2),\n        ids(lastSnapshot.snapshotId()),\n        files(newFileC),\n        statuses(Status.ADDED)\n    );\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, lastSnapshot.allManifests().get(1));\n  }\n","date":"2020-08-08 09:28:52","endLine":711,"groupId":"2540","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testChangedPartitionSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e8/8f9bf12c6bf66e32edccb75c5866b62815a9c4.src","preCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFileC)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.allManifests().size());\n\n    \r\n    validateManifest(pending.allManifests().get(0), ids(pending.snapshotId()), files(newFileC));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.allManifests().get(1));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":651,"status":"M"},{"authorDate":"2020-08-08 09:28:52","commitOrder":6,"curCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    Snapshot snap = table.currentSnapshot();\n    long commitId = snap.snapshotId();\n    validateSnapshot(null, snap, 1, FILE_A);\n    TableMetadata base = readMetadata();\n\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n    validateManifest(initialManifest, seqs(1), ids(commitId), files(FILE_A), statuses(Status.ADDED));\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n    V2Assert.assertEquals(\"Last sequence number should be 1\", 1, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    table.newAppend()\n        .appendFile(newFile)\n        .commit();\n    Snapshot committedSnapshot = table.currentSnapshot();\n\n    V2Assert.assertEquals(\"Snapshot sequence number should be 2\", 2, committedSnapshot.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 2\", 2, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, committedSnapshot.allManifests().size());\n\n    \r\n    validateManifest(committedSnapshot.allManifests().get(0),\n        seqs(2),\n        ids(committedSnapshot.snapshotId()), files(newFile),\n        statuses(Status.ADDED)\n    );\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, committedSnapshot.allManifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(committedSnapshot.allManifests().get(0), FILE_IO)\n        .entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(committedSnapshot.allManifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","date":"2020-08-08 09:28:52","endLine":1172,"groupId":"0","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testManifestEntryFieldIdsForChangedPartitionSpecForV1Table","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e8/8f9bf12c6bf66e32edccb75c5866b62815a9c4.src","preCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    Snapshot pending = table.newAppend()\n        .appendFile(newFile)\n        .apply();\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, pending.allManifests().size());\n\n    \r\n    validateManifest(pending.allManifests().get(0), ids(pending.snapshotId()), files(newFile));\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, pending.allManifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(pending.allManifests().get(0), FILE_IO)\n        .entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(pending.allManifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":1106,"status":"M"}],"commitId":"a624f6f247eb7ef5c3d6446ab98d400025d96176","commitMessage":"@@@Core: Add sequence number assertions in merge append tests (#1101)\n\n","date":"2020-08-08 09:28:52","modifiedFileCount":"2","status":"M","submitter":"Chen Junjie"},{"authorTime":"2020-08-12 07:02:14","codes":[{"authorDate":"2020-08-12 07:02:14","commitOrder":7,"curCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    Snapshot snap = table.currentSnapshot();\n    long commitId = snap.snapshotId();\n    validateSnapshot(null, snap, 1, FILE_A, FILE_B);\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n    validateManifest(initialManifest,\n        seqs(1, 1),\n        ids(commitId, commitId),\n        files(FILE_A, FILE_B),\n        statuses(Status.ADDED, Status.ADDED));\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n    Snapshot snap2 = table.currentSnapshot();\n    V2Assert.assertEquals(\"Snapshot sequence number should be 1\", 1, snap2.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 1\", 1, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    DataFile newFileY = DataFiles.builder(newSpec)\n        .withPath(\"/path/to/data-y.parquet\")\n        .withFileSizeInBytes(10)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .withRecordCount(1)\n        .build();\n\n    table.newAppend()\n        .appendFile(newFileY)\n        .commit();\n\n    Snapshot lastSnapshot = table.currentSnapshot();\n    V2Assert.assertEquals(\"Snapshot sequence number should be 2\", 2, lastSnapshot.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 2\", 2, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, lastSnapshot.allManifests().size());\n\n    \r\n    validateManifest(lastSnapshot.allManifests().get(0),\n        seqs(2),\n        ids(lastSnapshot.snapshotId()),\n        files(newFileY),\n        statuses(Status.ADDED)\n    );\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, lastSnapshot.allManifests().get(1));\n  }\n","date":"2020-08-12 07:02:14","endLine":713,"groupId":"101817","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testChangedPartitionSpec","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/dc/4780263ecde7b2438140ab79354b61759bbac8.src","preCode":"  public void testChangedPartitionSpec() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    Snapshot snap = table.currentSnapshot();\n    long commitId = snap.snapshotId();\n    validateSnapshot(null, snap, 1, FILE_A, FILE_B);\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n    validateManifest(initialManifest,\n        seqs(1, 1),\n        ids(commitId, commitId),\n        files(FILE_A, FILE_B),\n        statuses(Status.ADDED, Status.ADDED));\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"data\", 16)\n        .bucket(\"id\", 4)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n    Snapshot snap2 = table.currentSnapshot();\n    V2Assert.assertEquals(\"Snapshot sequence number should be 1\", 1, snap2.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 1\", 1, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    DataFile newFileC = DataFiles.builder(newSpec)\n        .copy(FILE_C)\n        .withPartitionPath(\"data_bucket=2/id_bucket=3\")\n        .build();\n\n    table.newAppend()\n        .appendFile(newFileC)\n        .commit();\n\n    Snapshot lastSnapshot = table.currentSnapshot();\n    V2Assert.assertEquals(\"Snapshot sequence number should be 2\", 2, lastSnapshot.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 2\", 2, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, lastSnapshot.allManifests().size());\n\n    \r\n    validateManifest(lastSnapshot.allManifests().get(0),\n        seqs(2),\n        ids(lastSnapshot.snapshotId()),\n        files(newFileC),\n        statuses(Status.ADDED)\n    );\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, lastSnapshot.allManifests().get(1));\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":651,"status":"M"},{"authorDate":"2020-08-12 07:02:14","commitOrder":7,"curCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    Snapshot snap = table.currentSnapshot();\n    long commitId = snap.snapshotId();\n    validateSnapshot(null, snap, 1, FILE_A);\n    TableMetadata base = readMetadata();\n\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n    validateManifest(initialManifest, seqs(1), ids(commitId), files(FILE_A), statuses(Status.ADDED));\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n    V2Assert.assertEquals(\"Last sequence number should be 1\", 1, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    \r\n    DataFile newFile = DataFiles.builder(table.spec())\n        .withPath(\"/path/to/data-x.parquet\")\n        .withFileSizeInBytes(10)\n        .withPartitionPath(\"id_bucket=1/data_bucket=1\")\n        .withRecordCount(1)\n        .build();\n\n    table.newAppend()\n        .appendFile(newFile)\n        .commit();\n    Snapshot committedSnapshot = table.currentSnapshot();\n\n    V2Assert.assertEquals(\"Snapshot sequence number should be 2\", 2, committedSnapshot.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 2\", 2, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, committedSnapshot.allManifests().size());\n\n    \r\n    validateManifest(committedSnapshot.allManifests().get(0),\n        seqs(2),\n        ids(committedSnapshot.snapshotId()), files(newFile),\n        statuses(Status.ADDED)\n    );\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, committedSnapshot.allManifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(committedSnapshot.allManifests().get(0), FILE_IO)\n        .entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(committedSnapshot.allManifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","date":"2020-08-12 07:02:14","endLine":1180,"groupId":"101817","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testManifestEntryFieldIdsForChangedPartitionSpecForV1Table","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/dc/4780263ecde7b2438140ab79354b61759bbac8.src","preCode":"  public void testManifestEntryFieldIdsForChangedPartitionSpecForV1Table() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    Snapshot snap = table.currentSnapshot();\n    long commitId = snap.snapshotId();\n    validateSnapshot(null, snap, 1, FILE_A);\n    TableMetadata base = readMetadata();\n\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().allManifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().allManifests().get(0);\n    validateManifest(initialManifest, seqs(1), ids(commitId), files(FILE_A), statuses(Status.ADDED));\n\n    \r\n    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())\n        .bucket(\"id\", 8)\n        .bucket(\"data\", 8)\n        .build();\n\n    \r\n    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n    V2Assert.assertEquals(\"Last sequence number should be 1\", 1, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    DataFile newFile = DataFiles.builder(table.spec())\n        .copy(FILE_B)\n        .build();\n\n    table.newAppend()\n        .appendFile(newFile)\n        .commit();\n    Snapshot committedSnapshot = table.currentSnapshot();\n\n    V2Assert.assertEquals(\"Snapshot sequence number should be 2\", 2, committedSnapshot.sequenceNumber());\n    V2Assert.assertEquals(\"Last sequence number should be 2\", 2, readMetadata().lastSequenceNumber());\n    V1Assert.assertEquals(\"Table should end with last-sequence-number 0\", 0, readMetadata().lastSequenceNumber());\n\n    Assert.assertEquals(\"Should use 2 manifest files\",\n        2, committedSnapshot.allManifests().size());\n\n    \r\n    validateManifest(committedSnapshot.allManifests().get(0),\n        seqs(2),\n        ids(committedSnapshot.snapshotId()), files(newFile),\n        statuses(Status.ADDED)\n    );\n\n    Assert.assertEquals(\"Second manifest should be the initial manifest with the old spec\",\n        initialManifest, committedSnapshot.allManifests().get(1));\n\n    \r\n    ManifestEntry<DataFile> entry = ManifestFiles.read(committedSnapshot.allManifests().get(0), FILE_IO)\n        .entries().iterator().next();\n    Types.NestedField field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"id_bucket\", field.name());\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(1);\n    Assert.assertEquals(1001, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n\n    entry = ManifestFiles.read(committedSnapshot.allManifests().get(1), FILE_IO).entries().iterator().next();\n    field = ((PartitionData) entry.file().partition()).getPartitionType().fields().get(0);\n    Assert.assertEquals(1000, field.fieldId());\n    Assert.assertEquals(\"data_bucket\", field.name());\n  }\n","realPath":"core/src/test/java/org/apache/iceberg/TestMergeAppend.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":1110,"status":"M"}],"commitId":"700fc9eaf91317e08287bbc23c5088494e74184a","commitMessage":"@@@Core: Add specId to DataFile (#1317)\n\n","date":"2020-08-12 07:02:14","modifiedFileCount":"18","status":"M","submitter":"Ryan Blue"}]
