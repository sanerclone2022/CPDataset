[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"  public static long getLong(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing int %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isNumber(),\n        \"Cannot parse %s from non-numeric value: %s\", property, pNode);\n    return pNode.asLong();\n  }\n","date":"2019-03-21 07:25:05","endLine":58,"groupId":"4448","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getLong","params":"(Stringproperty@JsonNodenode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/11/cb6913a13bad771588843fa11b308102cd195c.src","preCode":"  public static long getLong(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing int %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isNumber(),\n        \"Cannot parse %s from non-numeric value: %s\", property, pNode);\n    return pNode.asLong();\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/util/JsonUtil.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"  public static Map<String, String> getStringMap(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing map %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isObject(),\n        \"Cannot parse %s from non-object value: %s\", property, pNode);\n\n    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n    Iterator<String> fields = pNode.fieldNames();\n    while (fields.hasNext()) {\n      String field = fields.next();\n      builder.put(field, getString(field, pNode));\n    }\n    return builder.build();\n  }\n","date":"2019-03-21 07:25:05","endLine":99,"groupId":"4448","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getStringMap","params":"(Stringproperty@JsonNodenode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/11/cb6913a13bad771588843fa11b308102cd195c.src","preCode":"  public static Map<String, String> getStringMap(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing map %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isObject(),\n        \"Cannot parse %s from non-object value: %s\", property, pNode);\n\n    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n    Iterator<String> fields = pNode.fieldNames();\n    while (fields.hasNext()) {\n      String field = fields.next();\n      builder.put(field, getString(field, pNode));\n    }\n    return builder.build();\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/util/JsonUtil.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2020-04-11 07:02:33","commitOrder":2,"curCode":"  public static long getLong(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing long %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isNumber(),\n        \"Cannot parse %s from non-numeric value: %s\", property, pNode);\n    return pNode.asLong();\n  }\n","date":"2020-04-11 07:02:33","endLine":71,"groupId":"102171","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getLong","params":"(Stringproperty@JsonNodenode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e7/0351fcb99d5244071686cedb7343c76962270f.src","preCode":"  public static long getLong(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing int %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isNumber(),\n        \"Cannot parse %s from non-numeric value: %s\", property, pNode);\n    return pNode.asLong();\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/util/JsonUtil.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"},{"authorDate":"2019-03-21 07:25:05","commitOrder":2,"curCode":"  public static Map<String, String> getStringMap(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing map %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isObject(),\n        \"Cannot parse %s from non-object value: %s\", property, pNode);\n\n    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n    Iterator<String> fields = pNode.fieldNames();\n    while (fields.hasNext()) {\n      String field = fields.next();\n      builder.put(field, getString(field, pNode));\n    }\n    return builder.build();\n  }\n","date":"2019-03-21 07:25:05","endLine":99,"groupId":"102171","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getStringMap","params":"(Stringproperty@JsonNodenode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/11/cb6913a13bad771588843fa11b308102cd195c.src","preCode":"  public static Map<String, String> getStringMap(String property, JsonNode node) {\n    Preconditions.checkArgument(node.has(property), \"Cannot parse missing map %s\", property);\n    JsonNode pNode = node.get(property);\n    Preconditions.checkArgument(pNode != null && !pNode.isNull() && pNode.isObject(),\n        \"Cannot parse %s from non-object value: %s\", property, pNode);\n\n    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n    Iterator<String> fields = pNode.fieldNames();\n    while (fields.hasNext()) {\n      String field = fields.next();\n      builder.put(field, getString(field, pNode));\n    }\n    return builder.build();\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/util/JsonUtil.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"N"}],"commitId":"720b240a3e6a32b6f01173ebcc448c2c6e32e13a","commitMessage":"@@@Update Snapshot and TableMetadata with sequence numbers (#910)\n\n","date":"2020-04-11 07:02:33","modifiedFileCount":"11","status":"M","submitter":"Ryan Blue"}]
