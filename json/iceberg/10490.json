[{"authorTime":"2019-03-21 07:25:05","codes":[{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2019-03-21 07:25:05","endLine":188,"groupId":"316","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/25/756fe5ef32216c762a1bc6fccfc1980b825e84.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/data/SparkAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"B"},{"authorDate":"2019-03-21 07:25:05","commitOrder":1,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2019-03-21 07:25:05","endLine":217,"groupId":"316","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/46/8af47ebbee84f1bc400837833f3d9de2bf6d6c.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/GenericAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"B"}],"commitId":"c20927801a369104e5ea510470e1cf7c8e28b808","commitMessage":"@@@Rename packages to org.apache.iceberg (#138)\n\n* Move all packages by directory (but don't change references)\n* Rename all references from com.netflix.iceberg to org.apache.iceberg\n* Reorganize all imports due to new package name.\n  Previous commit only did a string find-replace.  which made all the imports out of order. Use an IDE to auto-sort all imports.\n\n","date":"2019-03-21 07:25:05","modifiedFileCount":"0","status":"B","submitter":"mccheah"},{"authorTime":"2019-11-09 09:21:44","codes":[{"authorDate":"2019-11-09 09:21:44","commitOrder":2,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2019-11-09 09:21:44","endLine":190,"groupId":"316","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/88/977bdc6ac54b4c4046dd031428cc82ac23864a.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/data/SparkAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2019-11-09 09:21:44","commitOrder":2,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2019-11-09 09:21:44","endLine":219,"groupId":"316","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d0/4ec53ad7f7366906201e186ec624d90d532d5c.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/GenericAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"b851550621d43c4ad6d2c013a1a634b6aee18004","commitMessage":"@@@Support reading Avro enums as strings (#625)\n\n","date":"2019-11-09 09:21:44","modifiedFileCount":"4","status":"M","submitter":"Shardul Mahadik"},{"authorTime":"2019-11-09 09:21:44","codes":[{"authorDate":"2020-04-10 00:28:53","commitOrder":3,"curCode":"    public ValueReader<?> primitive(Type.PrimitiveType expected, Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-04-10 00:28:53","endLine":202,"groupId":"316","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(Type.PrimitiveTypeexpected@Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/21/5a2654ebfbff1fc9178c9d2cedac1c1e057077.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/data/SparkAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"M"},{"authorDate":"2019-11-09 09:21:44","commitOrder":3,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2019-11-09 09:21:44","endLine":219,"groupId":"316","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/d0/4ec53ad7f7366906201e186ec624d90d532d5c.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/GenericAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"N"}],"commitId":"b47e97781b82109432612a0f36ebb0d0ce270d8b","commitMessage":"@@@Avro: Support partition values using a constants map (#896)\n\n","date":"2020-04-10 00:28:53","modifiedFileCount":"9","status":"M","submitter":"Ryan Blue"},{"authorTime":"2020-05-13 08:02:18","codes":[{"authorDate":"2020-04-10 00:28:53","commitOrder":4,"curCode":"    public ValueReader<?> primitive(Type.PrimitiveType expected, Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-04-10 00:28:53","endLine":202,"groupId":"316","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(Type.PrimitiveTypeexpected@Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/21/5a2654ebfbff1fc9178c9d2cedac1c1e057077.src","preCode":"    public ValueReader<?> primitive(Type.PrimitiveType expected, Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/data/SparkAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"N"},{"authorDate":"2020-05-13 08:02:18","commitOrder":4,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"time-micros\":\n            return ValueReaders.longs();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-05-13 08:02:18","endLine":222,"groupId":"316","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f9/b51271c1859a7f290ea9e2457f19bef9c7c7d0.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/GenericAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"14433838c83ce14381241e0c8f007821c5a6bcbe","commitMessage":"@@@Support time type in Avro generics (#1015)\n\n","date":"2020-05-13 08:02:18","modifiedFileCount":"3","status":"M","submitter":"Xiang Li"},{"authorTime":"2020-07-27 03:43:05","codes":[{"authorDate":"2020-07-27 03:43:05","commitOrder":5,"curCode":"    public ValueReader<?> primitive(Type.PrimitiveType expected, Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            return SparkValueReaders.decimal(\n                ValueReaders.decimalBytesReader(primitive),\n                ((LogicalTypes.Decimal) logicalType).getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-07-27 03:43:05","endLine":190,"groupId":"10490","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"primitive","params":"(Type.PrimitiveTypeexpected@Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/ba/ecc25c9123c794aed22d65c958800a5e547047.src","preCode":"    public ValueReader<?> primitive(Type.PrimitiveType expected, Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return SparkValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return SparkValueReaders.strings();\n        case FIXED:\n          return ValueReaders.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueReaders.bytes();\n        case ENUM:\n          return SparkValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"spark/src/main/java/org/apache/iceberg/spark/data/SparkAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"M"},{"authorDate":"2020-07-27 03:43:05","commitOrder":5,"curCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"time-micros\":\n            return ValueReaders.longs();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            return ValueReaders.decimal(\n                ValueReaders.decimalBytesReader(primitive),\n                ((LogicalTypes.Decimal) logicalType).getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","date":"2020-07-27 03:43:05","endLine":210,"groupId":"10490","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"primitive","params":"(Schemaprimitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/05/e05081bc94a92e6d8cc713f5ea7674c1a1b1b9.src","preCode":"    public ValueReader<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n            \r\n            return ValueReaders.ints();\n\n          case \"time-micros\":\n            return ValueReaders.longs();\n\n          case \"timestamp-millis\":\n            \r\n            ValueReader<Long> longs = ValueReaders.longs();\n            return (ValueReader<Long>) (decoder, ignored) -> longs.read(decoder, null) * 1000L;\n\n          case \"timestamp-micros\":\n            \r\n            return ValueReaders.longs();\n\n          case \"decimal\":\n            ValueReader<byte[]> inner;\n            switch (primitive.getType()) {\n              case FIXED:\n                inner = ValueReaders.fixed(primitive.getFixedSize());\n                break;\n              case BYTES:\n                inner = ValueReaders.bytes();\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Invalid primitive type for decimal: \" + primitive.getType());\n            }\n\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return ValueReaders.decimal(inner, decimal.getScale());\n\n          case \"uuid\":\n            return ValueReaders.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unknown logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueReaders.nulls();\n        case BOOLEAN:\n          return ValueReaders.booleans();\n        case INT:\n          return ValueReaders.ints();\n        case LONG:\n          return ValueReaders.longs();\n        case FLOAT:\n          return ValueReaders.floats();\n        case DOUBLE:\n          return ValueReaders.doubles();\n        case STRING:\n          return ValueReaders.utf8s();\n        case FIXED:\n          return ValueReaders.fixed(primitive);\n        case BYTES:\n          return ValueReaders.byteBuffers();\n        case ENUM:\n          return ValueReaders.enums(primitive.getEnumSymbols());\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n","realPath":"core/src/main/java/org/apache/iceberg/avro/GenericAvroReader.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"fd45ec7b6a3c3ed5be26cdaed75dbf7ab9a29c4b","commitMessage":"@@@Avro: Extract ValueReaders.decimalBytesReader (#1233)\n\n","date":"2020-07-27 03:43:05","modifiedFileCount":"4","status":"M","submitter":"Jingsong Lee"}]
