[{"authorTime":"2019-12-28 05:07:53","codes":[{"authorDate":"2019-12-28 05:07:53","commitOrder":1,"curCode":"    public <T> Boolean notIn(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) {  \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-12-28 05:07:53","endLine":377,"groupId":"1299","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"notIn","params":"(BoundReference<T>ref@Set<T>literalSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e3/9717ca4683aa8140e9f71cd43ec2a68f45ea56.src","preCode":"    public <T> Boolean notIn(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) {  \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":348,"status":"B"},{"authorDate":"2019-12-28 05:07:53","commitOrder":1,"curCode":"    public <T> Boolean in(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(ref.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2019-12-28 05:07:53","endLine":294,"groupId":"3603","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"in","params":"(BoundReference<T>ref@Set<T>literalSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a3/bb45553264337b1a71f46ac8c42186add1caa6.src","preCode":"    public <T> Boolean in(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(ref.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":268,"status":"B"}],"commitId":"33e675331e221af0b2618815addbdb4fb29c9083","commitMessage":"@@@Implement in and notIn in multiple visitors (#600)\n\n","date":"2019-12-28 05:07:53","modifiedFileCount":"10","status":"B","submitter":"jun-he"},{"authorTime":"2020-10-29 06:57:56","codes":[{"authorDate":"2019-12-28 05:07:53","commitOrder":2,"curCode":"    public <T> Boolean notIn(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) {  \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2019-12-28 05:07:53","endLine":377,"groupId":"1299","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"notIn","params":"(BoundReference<T>ref@Set<T>literalSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/e3/9717ca4683aa8140e9f71cd43ec2a68f45ea56.src","preCode":"    public <T> Boolean notIn(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) {  \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":348,"status":"N"},{"authorDate":"2020-10-29 06:57:56","commitOrder":2,"curCode":"    public <T> Boolean in(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (literals.size() > IN_PREDICATE_LIMIT) {\n        \r\n        return ROWS_MIGHT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(ref.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2020-10-29 06:57:56","endLine":301,"groupId":"3603","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"in","params":"(BoundReference<T>ref@Set<T>literalSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/34/4a453fb5217e7b9991021429ff72aa4138ef94.src","preCode":"    public <T> Boolean in(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(ref.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":270,"status":"M"}],"commitId":"444779d86ba7fc21a1754aa21610aa7d1dc3ea23","commitMessage":"@@@Fix IN predicate performance (#1672)\n\n","date":"2020-10-29 06:57:56","modifiedFileCount":"5","status":"M","submitter":"Anton Okolnychyi"},{"authorTime":"2021-01-21 01:03:55","codes":[{"authorDate":"2021-01-21 01:03:55","commitOrder":3,"curCode":"    public <T> Boolean notIn(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id) || containsNaNsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        if (NaNUtil.isNaN(lower)) {\n          \r\n          return ROWS_MIGHT_NOT_MATCH;\n        }\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) {  \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","date":"2021-01-21 01:03:55","endLine":424,"groupId":"101511","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"notIn","params":"(BoundReference<T>ref@Set<T>literalSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/6e/a293a0b562bf42d7874b3ada59687787c298ea.src","preCode":"    public <T> Boolean notIn(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (containsNullsOnly(id)) {\n        return ROWS_MUST_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) {  \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_MUST_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_NOT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/StrictMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"M"},{"authorDate":"2021-01-21 01:03:55","commitOrder":3,"curCode":"    public <T> Boolean in(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id) || containsNaNsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (literals.size() > IN_PREDICATE_LIMIT) {\n        \r\n        return ROWS_MIGHT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n\n        if (NaNUtil.isNaN(lower)) {\n          \r\n          return ROWS_MIGHT_MATCH;\n        }\n\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(ref.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","date":"2021-01-21 01:03:55","endLine":358,"groupId":"101511","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"in","params":"(BoundReference<T>ref@Set<T>literalSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/a6/c3c65e9830f65feb26b679888b8b1ba0cd4da9.src","preCode":"    public <T> Boolean in(BoundReference<T> ref, Set<T> literalSet) {\n      Integer id = ref.fieldId();\n\n      if (containsNullsOnly(id)) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      Collection<T> literals = literalSet;\n\n      if (literals.size() > IN_PREDICATE_LIMIT) {\n        \r\n        return ROWS_MIGHT_MATCH;\n      }\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(ref.type(), lowerBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(lower, v) <= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(ref.type(), upperBounds.get(id));\n        literals = literals.stream().filter(v -> ref.comparator().compare(upper, v) >= 0).collect(Collectors.toList());\n        if (literals.isEmpty()) { \r\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n","realPath":"api/src/main/java/org/apache/iceberg/expressions/InclusiveMetricsEvaluator.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":321,"status":"M"}],"commitId":"b018e21a814808c70990c3d1f29a998d6036aa90","commitMessage":"@@@API: Handle NaN lower or upper bound in stats evaluators (#2069)\n\n","date":"2021-01-21 01:03:55","modifiedFileCount":"2","status":"M","submitter":"yyanyy"}]
