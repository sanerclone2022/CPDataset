[{"authorTime":"2020-10-08 00:35:43","codes":[{"authorDate":"2020-10-08 00:35:43","commitOrder":1,"curCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (VALIDATE_ADDED_FILES_OPERATIONS.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","date":"2020-10-08 00:35:43","endLine":277,"groupId":"3406","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"validateAddedDataFiles","params":"(TableMetadatabase@LongstartingSnapshotId@ExpressionconflictDetectionFilter@booleancaseSensitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/08/6e08991418fe66335f66c7f4fa684916a8ed41.src","preCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (VALIDATE_ADDED_FILES_OPERATIONS.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"B"},{"authorDate":"2020-10-08 00:35:43","commitOrder":1,"curCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        Set<CharSequence> requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (matchingOperations.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","date":"2020-10-08 00:35:43","endLine":328,"groupId":"3407","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"validateDataFilesExist","params":"(TableMetadatabase@LongstartingSnapshotId@Set<CharSequence>requiredDataFiles@booleanskipDeletes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/08/6e08991418fe66335f66c7f4fa684916a8ed41.src","preCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        Set<CharSequence> requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (matchingOperations.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":279,"status":"B"}],"commitId":"d4dcadb3a74d4552f85fa6c99637f86a0b763426","commitMessage":"@@@Core: Add row-level delete validations (#1469)\n\n","date":"2020-10-08 00:35:43","modifiedFileCount":"13","status":"B","submitter":"Ryan Blue"},{"authorTime":"2021-06-23 00:42:23","codes":[{"authorDate":"2020-10-08 00:35:43","commitOrder":2,"curCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (VALIDATE_ADDED_FILES_OPERATIONS.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","date":"2020-10-08 00:35:43","endLine":277,"groupId":"3406","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"validateAddedDataFiles","params":"(TableMetadatabase@LongstartingSnapshotId@ExpressionconflictDetectionFilter@booleancaseSensitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/08/6e08991418fe66335f66c7f4fa684916a8ed41.src","preCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (VALIDATE_ADDED_FILES_OPERATIONS.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"N"},{"authorDate":"2021-06-23 00:42:23","commitOrder":2,"curCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        CharSequenceSet requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (matchingOperations.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","date":"2021-06-23 00:42:23","endLine":350,"groupId":"3407","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"validateDataFilesExist","params":"(TableMetadatabase@LongstartingSnapshotId@CharSequenceSetrequiredDataFiles@booleanskipDeletes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f5/c61f550afd365d4e83a348530e31914a3740a5.src","preCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        Set<CharSequence> requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (matchingOperations.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"M"}],"commitId":"63392d95848b21b32e6619f500e87c5342824f08","commitMessage":"@@@Core: Use CharSequenceSet instead of Set<CharSequence> (#2712)\n\nThis also adds a test that makes sure a CharSequenceSet doesn't suffer\nfrom undefined equality behavior as reported by https://errorprone.info/bugpattern/CollectionUndefinedEquality","date":"2021-06-23 00:42:23","modifiedFileCount":"11","status":"M","submitter":"Eduard Tudenh?fner"},{"authorTime":"2021-07-27 23:59:53","codes":[{"authorDate":"2021-07-27 23:59:53","commitOrder":3,"curCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Pair<List<ManifestFile>, Set<Long>> history =\n        validationHistory(base, startingSnapshotId, VALIDATE_ADDED_FILES_OPERATIONS, ManifestContent.DATA);\n    List<ManifestFile> manifests = history.first();\n    Set<Long> newSnapshots = history.second();\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","date":"2021-07-27 23:59:53","endLine":284,"groupId":"3406","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"validateAddedDataFiles","params":"(TableMetadatabase@LongstartingSnapshotId@ExpressionconflictDetectionFilter@booleancaseSensitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f2/6412b27bbda5d320e22edb7f237052fb3b0f60.src","preCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (VALIDATE_ADDED_FILES_OPERATIONS.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"},{"authorDate":"2021-07-27 23:59:53","commitOrder":3,"curCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        CharSequenceSet requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    Pair<List<ManifestFile>, Set<Long>> history =\n        validationHistory(base, startingSnapshotId, matchingOperations, ManifestContent.DATA);\n    List<ManifestFile> manifests = history.first();\n    Set<Long> newSnapshots = history.second();\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","date":"2021-07-27 23:59:53","endLine":351,"groupId":"3913","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"validateDataFilesExist","params":"(TableMetadatabase@LongstartingSnapshotId@CharSequenceSetrequiredDataFiles@booleanskipDeletes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f2/6412b27bbda5d320e22edb7f237052fb3b0f60.src","preCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        CharSequenceSet requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    List<ManifestFile> manifests = Lists.newArrayList();\n    Set<Long> newSnapshots = Sets.newHashSet();\n\n    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n\n      ValidationException.check(currentSnapshot != null,\n          \"Cannot determine history between starting snapshot %s and current %s\",\n          startingSnapshotId, currentSnapshotId);\n\n      if (matchingOperations.contains(currentSnapshot.operation())) {\n        newSnapshots.add(currentSnapshotId);\n        for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n          if (manifest.snapshotId() == (long) currentSnapshotId) {\n            manifests.add(manifest);\n          }\n        }\n      }\n\n      currentSnapshotId = currentSnapshot.parentId();\n    }\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"a1bd63d56751999ecee89b871992d7bac395fd52","commitMessage":"@@@Core: Add validation for row-level deletes with rewrites (#2865)\n\n","date":"2021-07-27 23:59:53","modifiedFileCount":"10","status":"M","submitter":"Ryan Blue"},{"authorTime":"2021-09-14 05:25:49","codes":[{"authorDate":"2021-07-27 23:59:53","commitOrder":4,"curCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Pair<List<ManifestFile>, Set<Long>> history =\n        validationHistory(base, startingSnapshotId, VALIDATE_ADDED_FILES_OPERATIONS, ManifestContent.DATA);\n    List<ManifestFile> manifests = history.first();\n    Set<Long> newSnapshots = history.second();\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","date":"2021-07-27 23:59:53","endLine":284,"groupId":"102156","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"validateAddedDataFiles","params":"(TableMetadatabase@LongstartingSnapshotId@ExpressionconflictDetectionFilter@booleancaseSensitive)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f2/6412b27bbda5d320e22edb7f237052fb3b0f60.src","preCode":"  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Pair<List<ManifestFile>, Set<Long>> history =\n        validationHistory(base, startingSnapshotId, VALIDATE_ADDED_FILES_OPERATIONS, ManifestContent.DATA);\n    List<ManifestFile> manifests = history.first();\n    Set<Long> newSnapshots = history.second();\n\n    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .caseSensitive(caseSensitive)\n        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n        .filterData(conflictDetectionFilter)\n        .specsById(base.specsById())\n        .ignoreDeleted()\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> conflicts = conflictGroup.entries().iterator()) {\n      if (conflicts.hasNext()) {\n        throw new ValidationException(\"Found conflicting files that can contain records matching %s: %s\",\n            conflictDetectionFilter,\n            Iterators.toString(Iterators.transform(conflicts, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\n          String.format(\"Failed to validate no appends matching %s\", conflictDetectionFilter), e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"N"},{"authorDate":"2021-09-14 05:25:49","commitOrder":4,"curCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        CharSequenceSet requiredDataFiles, boolean skipDeletes,\n                                        Expression conflictDetectionFilter) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    Pair<List<ManifestFile>, Set<Long>> history =\n        validationHistory(base, startingSnapshotId, matchingOperations, ManifestContent.DATA);\n    List<ManifestFile> manifests = history.first();\n    Set<Long> newSnapshots = history.second();\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    if (conflictDetectionFilter != null) {\n      matchingDeletesGroup.filterData(conflictDetectionFilter);\n    }\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","date":"2021-09-14 05:25:49","endLine":356,"groupId":"102156","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"validateDataFilesExist","params":"(TableMetadatabase@LongstartingSnapshotId@CharSequenceSetrequiredDataFiles@booleanskipDeletes@ExpressionconflictDetectionFilter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-iceberg-10-0.7/blobInfo/CC_OUT/blobs/f9/07314dad694e347a10f4aa1a427532ccda799b.src","preCode":"  protected void validateDataFilesExist(TableMetadata base, Long startingSnapshotId,\n                                        CharSequenceSet requiredDataFiles, boolean skipDeletes) {\n    \r\n    if (base.currentSnapshot() == null) {\n      return;\n    }\n\n    Set<String> matchingOperations = skipDeletes ?\n        VALIDATE_DATA_FILES_EXIST_SKIP_DELETE_OPERATIONS :\n        VALIDATE_DATA_FILES_EXIST_OPERATIONS;\n\n    Pair<List<ManifestFile>, Set<Long>> history =\n        validationHistory(base, startingSnapshotId, matchingOperations, ManifestContent.DATA);\n    List<ManifestFile> manifests = history.first();\n    Set<Long> newSnapshots = history.second();\n\n    ManifestGroup matchingDeletesGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n        .filterManifestEntries(entry -> entry.status() != ManifestEntry.Status.ADDED &&\n            newSnapshots.contains(entry.snapshotId()) && requiredDataFiles.contains(entry.file().path()))\n        .specsById(base.specsById())\n        .ignoreExisting();\n\n    try (CloseableIterator<ManifestEntry<DataFile>> deletes = matchingDeletesGroup.entries().iterator()) {\n      if (deletes.hasNext()) {\n        throw new ValidationException(\"Cannot commit, missing data files: %s\",\n            Iterators.toString(Iterators.transform(deletes, entry -> entry.file().path().toString())));\n      }\n\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Failed to validate required files exist\", e);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java","repoName":"iceberg","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"838cc652273c1444155bec2e1d6029cfbdbf3ea3","commitMessage":"@@@Core: Optimize check for referenced data files in BaseRowDelta (#3071)\n\nThis change optimizes our check for referenced data files in BaseRowDelta by pushing down the conflict detection filter. Previously.  we would open manifests even though they belonged to partitions out of our interest.","date":"2021-09-14 05:25:49","modifiedFileCount":"3","status":"M","submitter":"Anton Okolnychyi"}]
