[{"authorTime":"2009-03-27 21:49:42","codes":[{"authorDate":"2009-03-27 21:49:42","commitOrder":1,"curCode":"    protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                            int alphaSize, int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            \r\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = (((weight_n1 & 0xffffff00)\n                                   + (weight_n2 & 0xffffff00))\n                                  |\n                                  (1 + (((weight_n1 & 0x000000ff)\n                                         > (weight_n2 & 0x000000ff))\n                                        ? (weight_n1 & 0x000000ff)\n                                        : (weight_n2 & 0x000000ff))\n                                   ));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            \r\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (char) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","date":"2009-03-27 21:49:42","endLine":373,"groupId":"7007","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"hbMakeCodeLengths","params":"(char[]len@int[]freq@intalphaSize@intmaxLen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/bc/84844ad1214f641d9ab463e0652a62a1584173.src","preCode":"    protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                            int alphaSize, int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            \r\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = (((weight_n1 & 0xffffff00)\n                                   + (weight_n2 & 0xffffff00))\n                                  |\n                                  (1 + (((weight_n1 & 0x000000ff)\n                                         > (weight_n2 & 0x000000ff))\n                                        ? (weight_n1 & 0x000000ff)\n                                        : (weight_n2 & 0x000000ff))\n                                   ));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            \r\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (char) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","realPath":"src/main/org/apache/tools/bzip2/CBZip2OutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"B"},{"authorDate":"2009-03-27 21:49:42","commitOrder":1,"curCode":"    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                          final Data dat, final int alphaSize,\n                                          final int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = dat.heap;\n        final int[] weight = dat.weight;\n        final int[] parent = dat.parent;\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = ((weight_n1 & 0xffffff00)\n                                  + (weight_n2 & 0xffffff00))\n                    | (1 + (((weight_n1 & 0x000000ff)\n                             > (weight_n2 & 0x000000ff))\n                            ? (weight_n1 & 0x000000ff)\n                            : (weight_n2 & 0x000000ff)));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (byte) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","date":"2009-03-27 21:49:42","endLine":524,"groupId":"7007","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"hbMakeCodeLengths","params":"(finalbyte[]len@finalint[]freq@finalDatadat@finalintalphaSize@finalintmaxLen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/bc/84844ad1214f641d9ab463e0652a62a1584173.src","preCode":"    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                          final Data dat, final int alphaSize,\n                                          final int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = dat.heap;\n        final int[] weight = dat.weight;\n        final int[] parent = dat.parent;\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = ((weight_n1 & 0xffffff00)\n                                  + (weight_n2 & 0xffffff00))\n                    | (1 + (((weight_n1 & 0x000000ff)\n                             > (weight_n2 & 0x000000ff))\n                            ? (weight_n1 & 0x000000ff)\n                            : (weight_n2 & 0x000000ff)));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (byte) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","realPath":"src/main/org/apache/tools/bzip2/CBZip2OutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"B"}],"commitId":"9922008d657c72235c402343fd88847b044014ad","commitMessage":"@@@Improve bzip2 performance.  submitted by Rodrigo Schmidt.  PR 24798\n\ngit-svn-id: https://svn.apache.org/repos/asf/ant/core/trunk@759138 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2009-03-27 21:49:42","modifiedFileCount":"1","status":"B","submitter":"Stefan Bodewig"},{"authorTime":"2009-03-27 21:49:42","codes":[{"authorDate":"2018-11-04 17:02:42","commitOrder":2,"curCode":"    protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                            int alphaSize, int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            \r\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = (weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)\n                        | 1 + ((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)\n                        ? weight_n1 & 0x000000ff : weight_n2 & 0x000000ff);\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            \r\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (char) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","date":"2018-11-04 17:03:38","endLine":370,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"hbMakeCodeLengths","params":"(char[]len@int[]freq@intalphaSize@intmaxLen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/19/eedda7b51e1ba0cf2a59e5e9d8d8b16faa730f.src","preCode":"    protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                            int alphaSize, int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            \r\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = (((weight_n1 & 0xffffff00)\n                                   + (weight_n2 & 0xffffff00))\n                                  |\n                                  (1 + (((weight_n1 & 0x000000ff)\n                                         > (weight_n2 & 0x000000ff))\n                                        ? (weight_n1 & 0x000000ff)\n                                        : (weight_n2 & 0x000000ff))\n                                   ));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            \r\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (char) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","realPath":"src/main/org/apache/tools/bzip2/CBZip2OutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"M"},{"authorDate":"2009-03-27 21:49:42","commitOrder":2,"curCode":"    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                          final Data dat, final int alphaSize,\n                                          final int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = dat.heap;\n        final int[] weight = dat.weight;\n        final int[] parent = dat.parent;\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = ((weight_n1 & 0xffffff00)\n                                  + (weight_n2 & 0xffffff00))\n                    | (1 + (((weight_n1 & 0x000000ff)\n                             > (weight_n2 & 0x000000ff))\n                            ? (weight_n1 & 0x000000ff)\n                            : (weight_n2 & 0x000000ff)));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (byte) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","date":"2009-03-27 21:49:42","endLine":524,"groupId":"7007","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"hbMakeCodeLengths","params":"(finalbyte[]len@finalint[]freq@finalDatadat@finalintalphaSize@finalintmaxLen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/bc/84844ad1214f641d9ab463e0652a62a1584173.src","preCode":"    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                          final Data dat, final int alphaSize,\n                                          final int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = dat.heap;\n        final int[] weight = dat.weight;\n        final int[] parent = dat.parent;\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = ((weight_n1 & 0xffffff00)\n                                  + (weight_n2 & 0xffffff00))\n                    | (1 + (((weight_n1 & 0x000000ff)\n                             > (weight_n2 & 0x000000ff))\n                            ? (weight_n1 & 0x000000ff)\n                            : (weight_n2 & 0x000000ff)));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (byte) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","realPath":"src/main/org/apache/tools/bzip2/CBZip2OutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"N"}],"commitId":"e2dd6ec79a083901907e35ac4f0cd3631e71ec55","commitMessage":"@@@SonarQube: unnecessary parentheses is a major code smell","date":"2018-11-04 17:03:38","modifiedFileCount":"40","status":"M","submitter":"Gintas Grigelionis"},{"authorTime":"2009-03-27 21:49:42","codes":[{"authorDate":"2018-11-05 02:45:48","commitOrder":3,"curCode":"    protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                            int alphaSize, int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            \r\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = (((weight_n1 & 0xffffff00)\n                                   + (weight_n2 & 0xffffff00))\n                                  |\n                                  (1 + (((weight_n1 & 0x000000ff)\n                                         > (weight_n2 & 0x000000ff))\n                                        ? (weight_n1 & 0x000000ff)\n                                        : (weight_n2 & 0x000000ff))\n                                   ));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            \r\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (char) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","date":"2018-11-05 02:45:48","endLine":375,"groupId":"11598","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"hbMakeCodeLengths","params":"(char[]len@int[]freq@intalphaSize@intmaxLen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/ec/438be667b5b237d909965f12180156474cd2b3.src","preCode":"    protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                            int alphaSize, int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            \r\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = (weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)\n                        | 1 + ((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)\n                        ? weight_n1 & 0x000000ff : weight_n2 & 0x000000ff);\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            \r\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (char) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","realPath":"src/main/org/apache/tools/bzip2/CBZip2OutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"M"},{"authorDate":"2009-03-27 21:49:42","commitOrder":3,"curCode":"    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                          final Data dat, final int alphaSize,\n                                          final int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = dat.heap;\n        final int[] weight = dat.weight;\n        final int[] parent = dat.parent;\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = ((weight_n1 & 0xffffff00)\n                                  + (weight_n2 & 0xffffff00))\n                    | (1 + (((weight_n1 & 0x000000ff)\n                             > (weight_n2 & 0x000000ff))\n                            ? (weight_n1 & 0x000000ff)\n                            : (weight_n2 & 0x000000ff)));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (byte) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","date":"2009-03-27 21:49:42","endLine":524,"groupId":"11598","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"hbMakeCodeLengths","params":"(finalbyte[]len@finalint[]freq@finalDatadat@finalintalphaSize@finalintmaxLen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/bc/84844ad1214f641d9ab463e0652a62a1584173.src","preCode":"    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                          final Data dat, final int alphaSize,\n                                          final int maxLen) {\n        \r\n\r\n\r\n\n        final int[] heap = dat.heap;\n        final int[] weight = dat.weight;\n        final int[] parent = dat.parent;\n\n        for (int i = alphaSize; --i >= 0;) {\n            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n        }\n\n        for (boolean tooLong = true; tooLong;) {\n            tooLong = false;\n\n            int nNodes = alphaSize;\n            int nHeap = 0;\n            heap[0] = 0;\n            weight[0] = 0;\n            parent[0] = -2;\n\n            for (int i = 1; i <= alphaSize; i++) {\n                parent[i] = -1;\n                nHeap++;\n                heap[nHeap] = i;\n\n                int zz = nHeap;\n                int tmp = heap[zz];\n                while (weight[tmp] < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n            }\n\n            while (nHeap > 1) {\n                int n1 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                int yy = 0;\n                int zz = 1;\n                int tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n\n                int n2 = heap[1];\n                heap[1] = heap[nHeap];\n                nHeap--;\n\n                yy = 0;\n                zz = 1;\n                tmp = heap[1];\n\n                while (true) {\n                    yy = zz << 1;\n\n                    if (yy > nHeap) {\n                        break;\n                    }\n\n                    if ((yy < nHeap)\n                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n                        yy++;\n                    }\n\n                    if (weight[tmp] < weight[heap[yy]]) {\n                        break;\n                    }\n\n                    heap[zz] = heap[yy];\n                    zz = yy;\n                }\n\n                heap[zz] = tmp;\n                nNodes++;\n                parent[n1] = parent[n2] = nNodes;\n\n                final int weight_n1 = weight[n1];\n                final int weight_n2 = weight[n2];\n                weight[nNodes] = ((weight_n1 & 0xffffff00)\n                                  + (weight_n2 & 0xffffff00))\n                    | (1 + (((weight_n1 & 0x000000ff)\n                             > (weight_n2 & 0x000000ff))\n                            ? (weight_n1 & 0x000000ff)\n                            : (weight_n2 & 0x000000ff)));\n\n                parent[nNodes] = -1;\n                nHeap++;\n                heap[nHeap] = nNodes;\n\n                tmp = 0;\n                zz = nHeap;\n                tmp = heap[zz];\n                final int weight_tmp = weight[tmp];\n                while (weight_tmp < weight[heap[zz >> 1]]) {\n                    heap[zz] = heap[zz >> 1];\n                    zz >>= 1;\n                }\n                heap[zz] = tmp;\n\n            }\n\n            for (int i = 1; i <= alphaSize; i++) {\n                int j = 0;\n                int k = i;\n\n                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n                    k = parent_k;\n                    j++;\n                }\n\n                len[i - 1] = (byte) j;\n                if (j > maxLen) {\n                    tooLong = true;\n                }\n            }\n\n            if (tooLong) {\n                for (int i = 1; i < alphaSize; i++) {\n                    int j = weight[i] >> 8;\n                    j = 1 + (j >> 1);\n                    weight[i] = j << 8;\n                }\n            }\n        }\n    }\n","realPath":"src/main/org/apache/tools/bzip2/CBZip2OutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"N"}],"commitId":"551cb55e328281002810714a9059f34f0502c13d","commitMessage":"@@@Revert last 5 commits","date":"2018-11-05 02:45:48","modifiedFileCount":"103","status":"M","submitter":"Gintas Grigelionis"}]
