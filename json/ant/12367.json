[{"authorTime":"2015-01-21 00:58:08","codes":[{"authorDate":"2015-01-21 00:58:08","commitOrder":1,"curCode":"    private byte[] createLocalFileHeader(ZipEntry ze, ByteBuffer name, boolean encodable)  {\n        byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        \r\n        final int zipMethod = ze.getMethod();\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)),\n                 buf, LFH_VERSION_NEEDED_OFFSET);\n\n        GeneralPurposeBit generalPurposeBit =\n            getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        \r\n        if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        \r\n        \r\n        if (hasZip64Extra(entry.entry)){\n            \r\n            \r\n            \r\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { \r\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        \r\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf,\n                         LFH_FILENAME_OFFSET, nameLen);\n\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n        return buf;\n    }\n","date":"2015-01-21 01:00:58","endLine":1088,"groupId":"876","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createLocalFileHeader","params":"(ZipEntryze@ByteBuffername@booleanencodable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/26/1c717ec8b22b796b2aa583c4c32d028b911afe.src","preCode":"    private byte[] createLocalFileHeader(ZipEntry ze, ByteBuffer name, boolean encodable)  {\n        byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        \r\n        final int zipMethod = ze.getMethod();\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)),\n                 buf, LFH_VERSION_NEEDED_OFFSET);\n\n        GeneralPurposeBit generalPurposeBit =\n            getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        \r\n        if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        \r\n        \r\n        if (hasZip64Extra(entry.entry)){\n            \r\n            \r\n            \r\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { \r\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        \r\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf,\n                         LFH_FILENAME_OFFSET, nameLen);\n\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n        return buf;\n    }\n","realPath":"src/main/org/apache/tools/zip/ZipOutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1031,"status":"B"},{"authorDate":"2015-01-21 00:58:08","commitOrder":1,"curCode":"    private byte[] createCentralFileHeader(ZipEntry ze, ByteBuffer name, long lfhOffset,\n                                           boolean needsZip64Extra) throws IOException {\n        byte[] extra = ze.getCentralDirectoryExtra();\n\n        \r\n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n\n        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n        final int nameLen = name.limit() - name.position();\n        final int commentLen = commentB.limit() - commentB.position();\n        int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n        \r\n        \r\n        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n                buf, CFH_VERSION_MADE_BY_OFFSET);\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        putShort(versionNeededToExtract(zipMethod, needsZip64Extra), buf, CFH_VERSION_NEEDED_OFFSET);\n        getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8).encode(buf, CFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n        \r\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n        \r\n        \r\n        \r\n        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n        if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC) {\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\n        putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n        \r\n        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(Math.min(lfhOffset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\n        int extraStart = CFH_FILENAME_OFFSET + nameLen;\n        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n\n        int commentStart = extraStart + commentLen;\n\n        \r\n        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n        return buf;\n    }\n","date":"2015-01-21 01:00:58","endLine":1266,"groupId":"8269","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createCentralFileHeader","params":"(ZipEntryze@ByteBuffername@longlfhOffset@booleanneedsZip64Extra)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/26/1c717ec8b22b796b2aa583c4c32d028b911afe.src","preCode":"    private byte[] createCentralFileHeader(ZipEntry ze, ByteBuffer name, long lfhOffset,\n                                           boolean needsZip64Extra) throws IOException {\n        byte[] extra = ze.getCentralDirectoryExtra();\n\n        \r\n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n\n        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n        final int nameLen = name.limit() - name.position();\n        final int commentLen = commentB.limit() - commentB.position();\n        int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n        \r\n        \r\n        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n                buf, CFH_VERSION_MADE_BY_OFFSET);\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        putShort(versionNeededToExtract(zipMethod, needsZip64Extra), buf, CFH_VERSION_NEEDED_OFFSET);\n        getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8).encode(buf, CFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n        \r\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n        \r\n        \r\n        \r\n        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n        if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC) {\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\n        putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n        \r\n        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(Math.min(lfhOffset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\n        int extraStart = CFH_FILENAME_OFFSET + nameLen;\n        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n\n        int commentStart = extraStart + commentLen;\n\n        \r\n        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n        return buf;\n    }\n","realPath":"src/main/org/apache/tools/zip/ZipOutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1188,"status":"B"}],"commitId":"2c04d7e833b4e5dab1a3c5ddfe14b572aea8c112","commitMessage":"@@@port Kristian Rosenvold's write performance improvements from Commons Compress\n","date":"2015-01-21 01:00:58","modifiedFileCount":"6","status":"B","submitter":"Stefan Bodewig"},{"authorTime":"2015-07-21 12:02:50","codes":[{"authorDate":"2015-01-21 00:58:08","commitOrder":2,"curCode":"    private byte[] createLocalFileHeader(ZipEntry ze, ByteBuffer name, boolean encodable)  {\n        byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        \r\n        final int zipMethod = ze.getMethod();\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)),\n                 buf, LFH_VERSION_NEEDED_OFFSET);\n\n        GeneralPurposeBit generalPurposeBit =\n            getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        \r\n        if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        \r\n        \r\n        if (hasZip64Extra(entry.entry)){\n            \r\n            \r\n            \r\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { \r\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        \r\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf,\n                         LFH_FILENAME_OFFSET, nameLen);\n\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n        return buf;\n    }\n","date":"2015-01-21 01:00:58","endLine":1088,"groupId":"12367","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createLocalFileHeader","params":"(ZipEntryze@ByteBuffername@booleanencodable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/26/1c717ec8b22b796b2aa583c4c32d028b911afe.src","preCode":"    private byte[] createLocalFileHeader(ZipEntry ze, ByteBuffer name, boolean encodable)  {\n        byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        \r\n        final int zipMethod = ze.getMethod();\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)),\n                 buf, LFH_VERSION_NEEDED_OFFSET);\n\n        GeneralPurposeBit generalPurposeBit =\n            getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        \r\n        if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        \r\n        \r\n        if (hasZip64Extra(entry.entry)){\n            \r\n            \r\n            \r\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || raf != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { \r\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        \r\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf,\n                         LFH_FILENAME_OFFSET, nameLen);\n\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n        return buf;\n    }\n","realPath":"src/main/org/apache/tools/zip/ZipOutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1031,"status":"N"},{"authorDate":"2015-07-21 12:02:50","commitOrder":2,"curCode":"    private byte[] createCentralFileHeader(ZipEntry ze, ByteBuffer name, long lfhOffset,\n                                           boolean needsZip64Extra) throws IOException {\n        byte[] extra = ze.getCentralDirectoryExtra();\n\n        \r\n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n\n        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n        final int nameLen = name.limit() - name.position();\n        final int commentLen = commentB.limit() - commentB.position();\n        int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n        \r\n        \r\n        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n                buf, CFH_VERSION_MADE_BY_OFFSET);\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        putShort(versionNeededToExtract(zipMethod, needsZip64Extra), buf, CFH_VERSION_NEEDED_OFFSET);\n        getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8).encode(buf, CFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n        \r\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n        \r\n        \r\n        \r\n        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n        if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC) {\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\n        putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n        \r\n        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(Math.min(lfhOffset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\n        int extraStart = CFH_FILENAME_OFFSET + nameLen;\n        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n\n        int commentStart = extraStart + extra.length;\n\n        \r\n        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n        return buf;\n    }\n","date":"2015-07-21 12:04:23","endLine":1266,"groupId":"12367","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createCentralFileHeader","params":"(ZipEntryze@ByteBuffername@longlfhOffset@booleanneedsZip64Extra)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/0b/4f5f902170f709c0d8ced67dd30abda6dde249.src","preCode":"    private byte[] createCentralFileHeader(ZipEntry ze, ByteBuffer name, long lfhOffset,\n                                           boolean needsZip64Extra) throws IOException {\n        byte[] extra = ze.getCentralDirectoryExtra();\n\n        \r\n        String comm = ze.getComment();\n        if (comm == null) {\n            comm = \"\";\n        }\n\n        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n        final int nameLen = name.limit() - name.position();\n        final int commentLen = commentB.limit() - commentB.position();\n        int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n        byte[] buf = new byte[len];\n\n        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n        \r\n        \r\n        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n                buf, CFH_VERSION_MADE_BY_OFFSET);\n\n        final int zipMethod = ze.getMethod();\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        putShort(versionNeededToExtract(zipMethod, needsZip64Extra), buf, CFH_VERSION_NEEDED_OFFSET);\n        getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8).encode(buf, CFH_GPB_OFFSET);\n\n        \r\n        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n        \r\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n        \r\n        \r\n        \r\n        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n        if (ze.getCompressedSize() >= ZIP64_MAGIC\n                || ze.getSize() >= ZIP64_MAGIC) {\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n        \r\n        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\n        putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n        \r\n        System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n        \r\n        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n        \r\n        putLong(Math.min(lfhOffset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n\n        \r\n        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\n        int extraStart = CFH_FILENAME_OFFSET + nameLen;\n        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n\n        int commentStart = extraStart + commentLen;\n\n        \r\n        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n        return buf;\n    }\n","realPath":"src/main/org/apache/tools/zip/ZipOutputStream.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1188,"status":"M"}],"commitId":"99684cfd77a3851d098824e9eb871cd6c087934f","commitMessage":"@@@yet another potential AIOBException in zip package\n\nBug found and fix provided by Earl Hood\n","date":"2015-07-21 12:04:23","modifiedFileCount":"1","status":"M","submitter":"Stefan Bodewig"}]
