[{"authorTime":"2017-12-12 19:22:26","codes":[{"authorDate":"2014-07-04 19:56:55","commitOrder":6,"curCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n                    prefix = prefix + \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","date":"2014-07-04 19:56:55","endLine":505,"groupId":"2600","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"tarResource","params":"(finalResourcer@finalTarOutputStreamtOut@StringvPath@finalTarFileSettarFileSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/26/8e660ab40d623dddb9d7a11cc6817bb30a5c1f.src","preCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n                    prefix = prefix + \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Tar.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"NB"},{"authorDate":"2017-12-12 19:22:26","commitOrder":6,"curCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","date":"2017-12-13 12:07:35","endLine":1855,"groupId":"2807","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"zipFile","params":"(finalInputStreamin@finalZipOutputStreamzOut@finalStringvPath@finallonglastModified@finalFilefromArchive@finalintmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/4f/b7365db02986f118e4f9cee0dec3cec3d04135.src","preCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Zip.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1778,"status":"B"}],"commitId":"17f06a9f0f728f8346500bbea9f7fea33c3334fb","commitMessage":"@@@BZ-19516 Use BufferedInputStream for reduced memory usage in Zip task.  in certain cases\n","date":"2017-12-13 12:07:35","modifiedFileCount":"1","status":"M","submitter":"Jaikiran Pai"},{"authorTime":"2017-12-12 19:22:26","codes":[{"authorDate":"2018-04-05 17:32:22","commitOrder":7,"curCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n                    prefix = prefix + \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getLongUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getLongGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","date":"2018-04-05 17:32:22","endLine":521,"groupId":"2600","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"tarResource","params":"(finalResourcer@finalTarOutputStreamtOut@StringvPath@finalTarFileSettarFileSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/73/7e68cfd9486f0fc4864cb84982c90e92a0a8b4.src","preCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n                    prefix = prefix + \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Tar.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"M"},{"authorDate":"2017-12-12 19:22:26","commitOrder":7,"curCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","date":"2017-12-13 12:07:35","endLine":1855,"groupId":"2807","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"zipFile","params":"(finalInputStreamin@finalZipOutputStreamzOut@finalStringvPath@finallonglastModified@finalFilefromArchive@finalintmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/4f/b7365db02986f118e4f9cee0dec3cec3d04135.src","preCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Zip.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1778,"status":"N"}],"commitId":"f2459248f23aa439e2c5ab642d9d9d7e6cffc933","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/ant\n","date":"2018-04-05 17:32:22","modifiedFileCount":"138","status":"M","submitter":"Maarten Coene"},{"authorTime":"2017-12-12 19:22:26","codes":[{"authorDate":"2018-04-06 14:32:31","commitOrder":8,"curCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (!prefix.isEmpty() && !prefix.endsWith(\"/\")) {\n                    prefix += \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getLongUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getLongGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","date":"2018-04-06 14:48:19","endLine":521,"groupId":"2600","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"tarResource","params":"(finalResourcer@finalTarOutputStreamtOut@StringvPath@finalTarFileSettarFileSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/97/8b7b54aa414f5d542e385d0032926598a08c90.src","preCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n                    prefix = prefix + \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getLongUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getLongGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Tar.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"M"},{"authorDate":"2017-12-12 19:22:26","commitOrder":8,"curCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","date":"2017-12-13 12:07:35","endLine":1855,"groupId":"2807","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"zipFile","params":"(finalInputStreamin@finalZipOutputStreamzOut@finalStringvPath@finallonglastModified@finalFilefromArchive@finalintmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/4f/b7365db02986f118e4f9cee0dec3cec3d04135.src","preCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Zip.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1778,"status":"N"}],"commitId":"4b14d85f11b9a7728dcd2d9420551fd28bf8f45e","commitMessage":"@@@Avoid repetition","date":"2018-04-06 14:48:19","modifiedFileCount":"28","status":"M","submitter":"Gintas Grigelionis"},{"authorTime":"2017-12-12 19:22:26","codes":[{"authorDate":"2018-04-06 20:50:56","commitOrder":9,"curCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.isEmpty()) {\n                \r\n                if (vPath.isEmpty()) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (!prefix.isEmpty() && !prefix.endsWith(\"/\")) {\n                    prefix += \"/\";\n                }\n                vPath = prefix + vPath;\n            } else {\n                vPath = fullpath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getLongUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getLongGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","date":"2018-04-06 20:50:56","endLine":521,"groupId":"12369","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"tarResource","params":"(finalResourcer@finalTarOutputStreamtOut@StringvPath@finalTarFileSettarFileSet)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/51/12c5ccce8d30643bfed4b4f3f37d6d17b26c5b.src","preCode":"    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n\n        if (!r.isExists()) {\n            return;\n        }\n\n        boolean preserveLeadingSlashes = false;\n\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.length() > 0) {\n                vPath = fullpath;\n            } else {\n                \r\n                if (vPath.length() <= 0) {\n                    return;\n                }\n\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                \r\n                if (!prefix.isEmpty() && !prefix.endsWith(\"/\")) {\n                    prefix += \"/\";\n                }\n                vPath = prefix + vPath;\n            }\n\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    \r\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        \r\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getLongUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getLongGid());\n            }\n        }\n\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            \r\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            \r\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n\n        if (tarFileSet != null) {\n            \r\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Tar.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"M"},{"authorDate":"2017-12-12 19:22:26","commitOrder":9,"curCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","date":"2017-12-13 12:07:35","endLine":1855,"groupId":"12369","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"zipFile","params":"(finalInputStreamin@finalZipOutputStreamzOut@finalStringvPath@finallonglastModified@finalFilefromArchive@finalintmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-ant-10-0.7/blobInfo/CC_OUT/blobs/4f/b7365db02986f118e4f9cee0dec3cec3d04135.src","preCode":"    protected void zipFile(final InputStream in, final ZipOutputStream zOut, final String vPath,\n                           final long lastModified, final File fromArchive, final int mode)\n        throws IOException {\n        \r\n\n        if (entries.containsKey(vPath)) {\n\n            if (\"preserve\".equals(duplicate)) {\n                logWhenWriting(vPath + \" already added, skipping\",\n                               Project.MSG_INFO);\n                return;\n            }\n            if (\"fail\".equals(duplicate)) {\n                throw new BuildException(\n                    \"Duplicate file %s was found and the duplicate attribute is 'fail'.\",\n                    vPath);\n            }\n            \r\n            logWhenWriting(\"duplicate file \" + vPath\n                           + \" found, adding.\", Project.MSG_VERBOSE);\n        } else {\n            logWhenWriting(\"adding entry \" + vPath, Project.MSG_VERBOSE);\n        }\n\n        entries.put(vPath, vPath);\n\n        if (!skipWriting) {\n            final ZipEntry ze = new ZipEntry(vPath);\n            ze.setTime(fixedModTime != null ? modTimeMillis : lastModified);\n            ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);\n            \r\n            \r\n            \r\n            \r\n            \r\n            final InputStream markableInputStream = in.markSupported() ? in : new BufferedInputStream(in);\n            \r\n\r\n\r\n\r\n\r\n\n            if (!zOut.isSeekable() && !doCompress) {\n                long size = 0;\n                final CRC32 cal = new CRC32();\n                markableInputStream.mark(Integer.MAX_VALUE);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    size += count;\n                    cal.update(buffer, 0, count);\n                    count = markableInputStream.read(buffer, 0, buffer.length);\n                } while (count != -1);\n                markableInputStream.reset();\n                ze.setSize(size);\n                ze.setCrc(cal.getValue());\n            }\n\n            ze.setUnixMode(mode);\n            final ZipExtraField[] extra = getCurrentExtraFields();\n            if (extra != null) {\n                ze.setExtraFields(extra);\n            }\n\n            zOut.putNextEntry(ze);\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int count = 0;\n            do {\n                if (count != 0) {\n                    zOut.write(buffer, 0, count);\n                }\n                count = markableInputStream.read(buffer, 0, buffer.length);\n            } while (count != -1);\n        }\n        addedFiles.add(vPath);\n    }\n","realPath":"src/main/org/apache/tools/ant/taskdefs/Zip.java","repoName":"ant","snippetEndLine":0,"snippetStartLine":0,"startLine":1778,"status":"N"}],"commitId":"30f52135af7a18cbf3f140089e90bdb39ceee134","commitMessage":"@@@Use null-or-empty pattern","date":"2018-04-06 20:50:56","modifiedFileCount":"80","status":"M","submitter":"Gintas Grigelionis"}]
