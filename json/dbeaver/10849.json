[{"authorTime":"2019-05-26 06:24:23","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":1,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"B"},{"authorDate":"2019-05-26 06:24:23","commitOrder":1,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (bracketsDepth > 0) {\n                            result += insertReturnAndIndent(argList, index, indent);\n                        }\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":221,"groupId":"10849","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (bracketsDepth > 0) {\n                            result += insertReturnAndIndent(argList, index, indent);\n                        }\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"B"}],"commitId":"dd15372b8eacb3ebb36774575c241eb9a86edb35","commitMessage":"@@@Refactoring: model.sql bundle extraction\n\nFormer-commit-id: 427266a339b30fd0469d58aa384d4208dd82852a","date":"2019-05-26 06:24:25","modifiedFileCount":"25","status":"B","submitter":"serge-rider"},{"authorTime":"2019-07-23 21:59:46","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":2,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"N"},{"authorDate":"2019-07-23 21:59:46","commitOrder":2,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        \r\n                        if (bracketsDepth > 0) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent);\n\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        } else {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"DECLARE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2019-07-23 21:59:46","endLine":230,"groupId":"10849","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/cd/79a4a812279478b01a679a86de9a28ea9fffa2.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (bracketsDepth > 0) {\n                            result += insertReturnAndIndent(argList, index, indent);\n                        }\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"60462edb5c675411008f21d65c267a83b33fcf71","commitMessage":"@@@#794 SQL queries formatting fix (SQL Server syntax)\n\n\nFormer-commit-id: c8b1c3402251cf2830fb0f9036d93dbcdb2d1bd3","date":"2019-07-23 21:59:46","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-07-24 18:28:50","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":3,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"N"},{"authorDate":"2019-07-24 18:28:50","commitOrder":3,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"DECLARE\":  \r\n                    if (index > 0) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2019-07-24 18:28:50","endLine":232,"groupId":"8167","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/6e/2f5617f126d1f3aaa3f34fb954dc3da145eaed.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        \r\n                        if (bracketsDepth > 0) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent);\n\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        } else {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"DECLARE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"d0b97ecaa801b94e768830b2c39ee8c512bf2706","commitMessage":"@@@#794 SQL queries formatting fix (SQL Server syntax)\n\n\nFormer-commit-id: 42b1f81b1c3c4d699a1a4ffaa991698adc70cf36","date":"2019-07-24 18:28:50","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-10-29 21:04:16","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":4,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"N"},{"authorDate":"2019-10-29 21:04:16","commitOrder":4,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent - 1);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2019-10-29 21:04:16","endLine":240,"groupId":"12280","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/df/878b44d18c076b28cbf5df6e5df0e53b676bc7.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"BEGIN\":\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"DECLARE\":  \r\n                    if (index > 0) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"END\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"f241e80d0ea9ff9c642030de91dc518fc7779bbb","commitMessage":"@@@SQL formatter: DECLARE/BEGIN/END formatting\n\n\nFormer-commit-id: 3e7a0b6293dc8baac05cc678706ccfba713231d1","date":"2019-10-29 21:04:16","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-11-12 03:43:58","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":5,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"N"},{"authorDate":"2019-11-12 03:43:58","commitOrder":5,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent - 1);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        \r\n                        \r\n                    }\n                    break;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equals(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2019-11-12 03:43:58","endLine":243,"groupId":"12280","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/c3/c8fb80858658afc328a4954a96768346d8b96c.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent - 1);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        indent++;\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"275f5800b1b2b813085ced5735867f1a664095db","commitMessage":"@@@#7181 CASE .. WHEN formatting fix\n\n\nFormer-commit-id: 01729b85965f09a11d8bccf3bec5faeacfb3ceb2","date":"2019-11-12 03:43:58","modifiedFileCount":"1","status":"M","submitter":"serge-rider"},{"authorTime":"2019-11-12 03:46:35","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":6,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"N"},{"authorDate":"2019-11-12 03:46:35","commitOrder":6,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent - 1);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (!\"WHEN\".equals(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equals(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2019-11-12 03:46:35","endLine":245,"groupId":"12280","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/c2/fcae6a161bdca002d6e56e57ddaf5e1543e6a9.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent - 1);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeyword(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeyword(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        \r\n                        \r\n                    }\n                    break;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equals(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"277c297ccb149a216f33141547f1fe5edc10ec4d","commitMessage":"@@@#7181 CASE .. WHEN formatting fix\n\n\nFormer-commit-id: 62994ba8666b3a8998b96d95d1abddddfaa6bc6d","date":"2019-11-12 03:46:35","modifiedFileCount":"1","status":"M","submitter":"serge-rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2019-05-26 06:24:23","commitOrder":7,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2019-05-26 06:24:25","endLine":85,"groupId":"12278","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/96/2760cad1235a2123232ae0bedaba111569c6bf.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                                argList,\n                                lfBeforeComma ? index : index + 1,\n                                indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":42,"status":"N"},{"authorDate":"2020-04-27 18:00:15","commitOrder":7,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent - 1);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (!\"WHEN\".equals(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equals(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"d4d19ac6ca395d91c2a221af682d70c2a834b7f9","commitMessage":"@@@Merge pull request #8547 from kai-morich/case-when-indent\n\nfix CASE ... WHEN ... END indent\n\nFormer-commit-id: d7272e52d1b1af1c76223f944adb8e23e1687ca2","date":"2020-04-27 18:00:15","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2020-05-14 15:52:19","commitOrder":8,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    if(bracketsDepth <= 0 || functionBracket.size() == 0)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2020-05-14 15:52:19","endLine":92,"groupId":"12278","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/66/94b9df57101bf6989b79e02fc81ddba3a71bd4.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"M"},{"authorDate":"2020-04-27 18:00:15","commitOrder":8,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"9ba718916e3e091f1b569a5c3b9d8fcc7f23830a","commitMessage":"@@@Merge pull request #8695 from dbeaver/formatsql#7509\n\n#7509 sql default formatting fixed\n\nFormer-commit-id: d3756429733e4ef7f9dc388d02586a840262a7fa","date":"2020-05-14 15:52:19","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2020-08-13 02:18:36","commitOrder":9,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    if(bracketsDepth <= 0 || functionBracket.size() == 0 || (\"SELECT\".equals(getPrevDMLKeyword(argList, index)) && bracketsDepth > 0 && bracketsDepth == indent))\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2020-08-13 02:18:36","endLine":93,"groupId":"12278","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/a6/ff99a06e5d603d1b4b78ad0c70aaf350965cb2.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    if(bracketsDepth <= 0 || functionBracket.size() == 0)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"},{"authorDate":"2020-04-27 18:00:15","commitOrder":9,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"94398858fb702e0b5adac7d3d1676e6cbe62c1b9","commitMessage":"@@@Merge remote-tracking branch 'origin/devel' into devel\n\n\nFormer-commit-id: c013082c666c3077318900d757f87bfef4fbbda9","date":"2020-08-13 02:18:36","modifiedFileCount":"76","status":"M","submitter":"serge-rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2020-08-17 19:06:08","commitOrder":10,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    if(bracketsDepth <= 0 || functionBracket.size() == 0 || (\"SELECT\".equalsIgnoreCase(getPrevDMLKeyword(argList, index)) && bracketsDepth > 0 && bracketsDepth == indent))\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2020-08-17 19:06:08","endLine":93,"groupId":"12278","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/53/02d57e4303e5c1240618f65d8bc6ee72612e8a.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    if(bracketsDepth <= 0 || functionBracket.size() == 0 || (\"SELECT\".equals(getPrevDMLKeyword(argList, index)) && bracketsDepth > 0 && bracketsDepth == indent))\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"},{"authorDate":"2020-04-27 18:00:15","commitOrder":10,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"c0291b282656409d7618c0d0f065869da5e46490","commitMessage":"@@@Merge pull request #9557 from dbeaver/formatingfix#9365\n\n#9365 case lowercase keywords handled\n\nFormer-commit-id: 78df582876eea6c3c1fbb3f39745338570ba3bff","date":"2020-08-17 19:06:08","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2020-11-12 17:44:06","commitOrder":11,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    if (!isInsideAFunction)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2020-11-12 17:44:06","endLine":94,"groupId":"12278","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/68/c6f66b99eb1a01cc104b98b821f1da8c4b24b7.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    if(bracketsDepth <= 0 || functionBracket.size() == 0 || (\"SELECT\".equalsIgnoreCase(getPrevDMLKeyword(argList, index)) && bracketsDepth > 0 && bracketsDepth == indent))\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"},{"authorDate":"2020-04-27 18:00:15","commitOrder":11,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"1f8a7abf918593db3d7da66d6c62da0ff778cdd5","commitMessage":"@@@Merge remote-tracking branch 'origin/devel' into devel\n\n\nFormer-commit-id: 52f6e6bf16f6719ea34624f66d332bf98d8cdda0","date":"2020-11-12 17:44:06","modifiedFileCount":"16","status":"M","submitter":"Serge Rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2021-01-12 19:23:03","commitOrder":12,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equals(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2021-01-12 19:23:03","endLine":96,"groupId":"12278","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/03/0391aaad76fe9b5311b66d2771df20626ec915.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    if (!isInsideAFunction)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"M"},{"authorDate":"2020-04-27 18:00:15","commitOrder":12,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"dcb0fb1099623a043e800273751b3e27e43e8d55","commitMessage":"@@@Merge pull request #10931 from dbeaver/informat#10618\n\n#10618 newline in arguments after the keyword IN is removed\n\nFormer-commit-id: f50557224b979ab0d92e3db1ce6d9274eacdd0e4","date":"2021-01-12 19:23:03","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2020-04-27 18:00:15","codes":[{"authorDate":"2021-01-14 10:23:46","commitOrder":13,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2021-01-14 10:23:46","endLine":96,"groupId":"12278","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/21/19b82ce98d4dc3c031be20cce71efa515f445f.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equals(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"M"},{"authorDate":"2020-04-27 18:00:15","commitOrder":13,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2020-04-27 18:00:15","endLine":251,"groupId":"11977","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/12/524d2691dbc7d26d5862dab9bda4db4bc40d37.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"N"}],"commitId":"ddc4373a632f7e4aca9414ab7492a0676f354538","commitMessage":"@@@Merge remote-tracking branch 'origin/devel' into devel\n\n\nFormer-commit-id: 9d9ace73765262fd518d1ff7589035b48cb02a34","date":"2021-01-14 10:23:46","modifiedFileCount":"1","status":"M","submitter":"serge-rider"},{"authorTime":"2021-03-24 19:01:36","codes":[{"authorDate":"2021-01-14 10:23:46","commitOrder":14,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2021-01-14 10:23:46","endLine":96,"groupId":"12278","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/21/19b82ce98d4dc3c031be20cce71efa515f445f.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"N"},{"authorDate":"2021-03-24 19:01:36","commitOrder":14,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || (SQLUtils.isBlockStartKeyword(dialect, tokenString) &&\n                            !SQLConstants.KEYWORD_SELECT.equalsIgnoreCase(getPrevDMLKeyword(argList, index)))) { \r\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2021-03-24 19:01:36","endLine":273,"groupId":"11977","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/69/362efc7c65f7b137f6202237ca0b50c805243f.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || SQLUtils.isBlockStartKeyword(dialect, tokenString)) {\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"bff9b386793158fb6da07388e638ee3969c3a813","commitMessage":"@@@Merge remote-tracking branch 'origin/devel' into devel\n\n\nFormer-commit-id: 7e555b68b5f2398599b46399e66b66fbe3b5d35f","date":"2021-03-24 19:01:36","modifiedFileCount":"2","status":"M","submitter":"Serge Rider"},{"authorTime":"2021-04-01 16:44:41","codes":[{"authorDate":"2021-04-01 16:44:41","commitOrder":15,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                conditionBracket.add(isCondition(argList, index) ? Boolean.TRUE : Boolean.FALSE);\n                isFirstConditionInBrackets = true;\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty() && !conditionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    conditionBracket.remove(conditionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2021-04-01 16:44:41","endLine":118,"groupId":"7055","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/7d/4d251fd8a4b2f8b81533c8cb632484472e5909.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"},{"authorDate":"2021-04-01 16:44:41","commitOrder":15,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || (SQLUtils.isBlockStartKeyword(dialect, tokenString) &&\n                            !SQLConstants.KEYWORD_SELECT.equalsIgnoreCase(getPrevSpecialKeyword(argList, index, false)))) { \r\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                    if (isFirstConditionInBrackets) {\n                        result = checkConditionDepth(result, argList, index);\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        \r\n                        result += insertReturnAndIndent(argList, index, indent);\n                        if (isFirstConditionInBrackets) {\n                            result = checkConditionDepth(result, argList, index);\n                        }\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2021-04-01 16:44:41","endLine":286,"groupId":"11977","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/7d/4d251fd8a4b2f8b81533c8cb632484472e5909.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || (SQLUtils.isBlockStartKeyword(dialect, tokenString) &&\n                            !SQLConstants.KEYWORD_SELECT.equalsIgnoreCase(getPrevDMLKeyword(argList, index)))) { \r\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"}],"commitId":"484e4ed13488fef5c4921382e5a30200f4a58912","commitMessage":"@@@Merge pull request #11943 from dbeaver/conditionsIndent11063\n\n#11063 add indent for condition expressions\n\nFormer-commit-id: 71192e8b1ce57949cebb5dc955c319ffaa83c194","date":"2021-04-01 16:44:41","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"},{"authorTime":"2021-04-01 18:46:11","codes":[{"authorDate":"2021-04-01 16:44:41","commitOrder":16,"curCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                conditionBracket.add(isCondition(argList, index) ? Boolean.TRUE : Boolean.FALSE);\n                isFirstConditionInBrackets = true;\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty() && !conditionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    conditionBracket.remove(conditionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","date":"2021-04-01 16:44:41","endLine":118,"groupId":"10849","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"formatSymbol","params":"(StringtokenString@List<Integer>bracketIndent@List<FormatterToken>argList@Integerindex@FormatterTokenprev)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/7d/4d251fd8a4b2f8b81533c8cb632484472e5909.src","preCode":"    private int formatSymbol(String tokenString, List<Integer> bracketIndent, List<FormatterToken> argList, Integer index, FormatterToken prev) {\n        int result = index;\n\n        switch (tokenString) {\n            case \"(\":\n                functionBracket.add(formatterCfg.isFunction(prev.getString()) ? Boolean.TRUE : Boolean.FALSE);\n                conditionBracket.add(isCondition(argList, index) ? Boolean.TRUE : Boolean.FALSE);\n                isFirstConditionInBrackets = true;\n                bracketIndent.add(indent);\n                bracketsDepth++;\n                \r\n                if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                    indent++;\n                    index += insertReturnAndIndent(argList, index + 1, indent);\n                }\n                break;\n            case \")\":\n                if (!bracketIndent.isEmpty() && !functionBracket.isEmpty() && !conditionBracket.isEmpty()) {\n                    indent = bracketIndent.remove(bracketIndent.size() - 1);\n                    if (!isCompact && formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET)) {\n                        result += insertReturnAndIndent(argList, index, indent);\n                    }\n                    functionBracket.remove(functionBracket.size() - 1);\n                    conditionBracket.remove(conditionBracket.size() - 1);\n                    bracketsDepth--;\n                }\n                break;\n            case \",\":\n                if (!isCompact) {\n                    \n                    boolean isInsideAFunction = functionBracket.size() != 0 && functionBracket.get(functionBracket.size() - 1).equals(Boolean.TRUE);\n                    boolean isAfterInKeyword = bracketsDepth > 0 && SQLConstants.KEYWORD_IN.equalsIgnoreCase(getPrevKeyword(argList, index));\n                    if (!isInsideAFunction && !isAfterInKeyword)\n                    {\n                        boolean lfBeforeComma = formatterCfg.getPreferenceStore().getBoolean(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA);\n                        result += insertReturnAndIndent(\n                            argList,\n                            lfBeforeComma ? index : index + 1,\n                            indent);\n                    }\n                }\n                break;\n            default:\n                if (statementDelimiters.contains(tokenString)) {\n                    indent = 0;\n                    result += insertReturnAndIndent(argList, index, indent);\n                }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"N"},{"authorDate":"2021-04-01 18:46:11","commitOrder":16,"curCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || (SQLUtils.isBlockStartKeyword(dialect, tokenString) &&\n                            !SQLConstants.KEYWORD_SELECT.equalsIgnoreCase(getPrevSpecialKeyword(argList, index, false)))) { \r\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    isFirstConditionInBrackets = false;\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                    if (isFirstConditionInBrackets) {\n                        result = checkConditionDepth(result, argList, index);\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        \r\n                        result += insertReturnAndIndent(argList, index, indent);\n                        if (isFirstConditionInBrackets) {\n                            result = checkConditionDepth(result, argList, index);\n                        }\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","date":"2021-04-01 18:46:11","endLine":287,"groupId":"10849","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"formatKeyword","params":"(List<FormatterToken>argList@StringtokenString@intindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/22/f46b8514590ba033033e8b77479315dc2244ab.src","preCode":"    private int formatKeyword(List<FormatterToken> argList, String tokenString, int index) {\n        int result = index;\n        if (statementDelimiters.contains(tokenString)) { \r\n            indent = 0;\n            if (index > 0) {\n                result += insertReturnAndIndent(argList, index - 1, indent);\n            }\n            result += insertReturnAndIndent(argList, index + 1, indent);\n        } else {\n            if (blockHeaderStrings != null && ArrayUtils.contains(blockHeaderStrings, tokenString) || (SQLUtils.isBlockStartKeyword(dialect, tokenString) &&\n                            !SQLConstants.KEYWORD_SELECT.equalsIgnoreCase(getPrevSpecialKeyword(argList, index, false)))) { \r\n                if (index > 0) {\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                }\n                indent++;\n                result += insertReturnAndIndent(argList, index + 1, indent);\n            } else if (SQLUtils.isBlockEndKeyword(dialect, tokenString)) {\n                indent--;\n                result += insertReturnAndIndent(argList, index, indent);\n            } else switch (tokenString) {\n                case \"CREATE\":\n                    if (!isCompact) {\n                        int nextIndex = getNextKeywordIndex(argList, index);\n                        if (nextIndex > 0 && \"OR\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                            nextIndex = getNextKeywordIndex(argList, nextIndex);\n                            if (nextIndex > 0 && \"REPLACE\".equals(argList.get(nextIndex).getString().toUpperCase(Locale.ENGLISH))) {\n                                insertReturnAndIndent(argList, nextIndex + 1, indent);\n                                break;\n                            }\n                        }\n                    }\n                case \"DROP\": \r\n                case \"ALTER\": \r\n                    break;\n                case \"DELETE\": \r\n                case \"SELECT\": \r\n                case \"UPDATE\": \r\n                case \"INSERT\": \r\n                case \"INTO\": \r\n                case \"TRUNCATE\": \r\n                case \"TABLE\": \r\n                    if (!isCompact) {\n                        if (!\"TABLE\".equals(tokenString)) {\n                            if (bracketsDepth > 0) {\n                                result += insertReturnAndIndent(argList, index, indent);\n                            } else if (index > 0) {\n                                \r\n                                indent = 0;\n                                result += insertReturnAndIndent(argList, index - 1, indent);\n                            }\n                            indent++;\n                            result += insertReturnAndIndent(argList, result + 1, indent);\n                        }\n                    }\n                    break;\n                case \"CASE\":  \r\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index - 1, indent);\n                        if (\"WHEN\".equalsIgnoreCase(getNextKeyword(argList, index))) {\n                            indent++;\n                            result += insertReturnAndIndent(argList, index + 1, indent);\n                        }\n                    }\n                    break;\n                case \"END\": \r\n                    if (!isCompact) {\n\t                    indent--;\n\t                    result += insertReturnAndIndent(argList, index, indent);\n                    }\n                \tbreak;\n                case \"FROM\":\n                case \"WHERE\":\n                case \"START WITH\":\n                case \"CONNECT BY\":\n                case \"ORDER BY\":\n                case \"GROUP BY\":\n                case \"HAVING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent - 1);\n                    if (!isCompact) {\n                        result += insertReturnAndIndent(argList, index + 1, indent);\n                    }\n                    break;\n                case \"LEFT\":\n                case \"RIGHT\":\n                case \"INNER\":\n                case \"OUTER\":\n                case \"FULL\":\n                case \"CROSS\":\n                case \"JOIN\":\n                    if (isJoinStart(argList, index)) {\n                        result += insertReturnAndIndent(argList, index, indent - 1);\n                    }\n                    if (tokenString.equals(\"JOIN\")) {\n                        \r\n                    }\n                    break;\n                case \"VALUES\":  \r\n                case \"LIMIT\":  \r\n                    indent--;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"OR\":\n                    if (\"CREATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                    if (isFirstConditionInBrackets) {\n                        result = checkConditionDepth(result, argList, index);\n                    }\n                case \"WHEN\":\n                    if (\"CASE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                        break;\n                    }\n                case \"ELSE\":  \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    break;\n                case \"SET\": {\n                    if (index > 1) {\n                        if (\"UPDATE\".equalsIgnoreCase(getPrevKeyword(argList, index))) {\n                            \r\n                            result += insertReturnAndIndent(argList, index, indent - 1);\n                        }\n                    }\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"ON\": {\n                    \r\n                    \r\n                    \r\n                    result += insertReturnAndIndent(argList, index + 1, indent);\n                    break;\n                }\n                case \"USING\":  \r\n                    result += insertReturnAndIndent(argList, index, indent + 1);\n                    break;\n                case \"TOP\":  \r\n                    \r\n                    result += insertReturnAndIndent(argList, index, indent);\n                    if (argList.size() < index + 3) {\n                        result += insertReturnAndIndent(argList, index + 3, indent);\n                    }\n                    break;\n                case \"UNION\":\n                case \"INTERSECT\":\n                case \"EXCEPT\": \r\n                    indent -= 2;\n                    result += insertReturnAndIndent(argList, index, indent);\n                    \r\n                    indent++;\n                    break;\n                case \"BETWEEN\":  \r\n                    encounterBetween = true;\n                    break;\n                case \"AND\":  \r\n                    if (!encounterBetween) {\n                        \r\n                        result += insertReturnAndIndent(argList, index, indent);\n                        if (isFirstConditionInBrackets) {\n                            result = checkConditionDepth(result, argList, index);\n                        }\n                    }\n                    encounterBetween = false;\n                    break;\n            }\n        }\n        return result;\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model.sql/src/org/jkiss/dbeaver/model/sql/format/tokenized/IndentFormatter.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"}],"commitId":"8164a85213bed96ec05ae93b2e6bd7ed08681304","commitMessage":"@@@Merge pull request #11955 from dbeaver/indentCase#11063\n\n#11063 add condition for subqueries\n\nFormer-commit-id: 78ff6a7a7d5b8f49be4fb6bbe57cd05ec369bdde","date":"2021-04-01 18:46:11","modifiedFileCount":"1","status":"M","submitter":"Serge Rider"}]
