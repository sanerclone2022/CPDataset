[{"authorTime":"2015-07-03 05:23:35","codes":[{"authorDate":"2015-07-03 05:23:35","commitOrder":1,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(JDBCTable.this);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-07-03 05:23:35","endLine":427,"groupId":"9303","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/a8/01575b121312150e044c62b32cf7a03cdbd739.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(JDBCTable.this);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":361,"status":"B"},{"authorDate":"2015-07-03 05:23:35","commitOrder":1,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(JDBCTable.this);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-07-03 05:23:35","endLine":480,"groupId":"12107","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/a8/01575b121312150e044c62b32cf7a03cdbd739.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(JDBCTable.this);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":431,"status":"B"}],"commitId":"0743792128fca9e7cb91b033f751fdbae190416d","commitMessage":"@@@Model bundle\n\nFormer-commit-id: 36a4943063ae5a5d2b114f7852f192bb5a75eb9c","date":"2015-07-03 05:23:35","modifiedFileCount":"63","status":"B","submitter":"jurgen"},{"authorTime":"2015-11-04 04:13:21","codes":[{"authorDate":"2015-11-04 04:13:21","commitOrder":2,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final Object source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-04 04:13:21","endLine":429,"groupId":"9303","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalObjectsource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/63/687a11ae8dfb14c10863367ac58018f63436fc.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(JDBCTable.this);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":363,"status":"M"},{"authorDate":"2015-11-04 04:13:21","commitOrder":2,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final Object source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-04 04:13:21","endLine":482,"groupId":"14735","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalObjectsource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/63/687a11ae8dfb14c10863367ac58018f63436fc.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(JDBCTable.this);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"M"}],"commitId":"e608e796f563ca514405775a0ae419a799165300","commitMessage":"@@@#36 SQL editor execution log tracking (update/delete/insert) fix\n\n\nFormer-commit-id: a45e90bb8edc3ea6f1354991f23733f0a0540ea6","date":"2015-11-04 04:13:21","modifiedFileCount":"13","status":"M","submitter":"Serge Rider"},{"authorTime":"2015-11-15 01:34:20","codes":[{"authorDate":"2015-11-15 01:34:20","commitOrder":3,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-15 01:34:20","endLine":425,"groupId":"9303","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/d4/6a615d85ac6b2e777b4c147a5904faf83ddffa.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final Object source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"M"},{"authorDate":"2015-11-15 01:34:20","commitOrder":3,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-15 01:34:20","endLine":478,"groupId":"14735","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/d4/6a615d85ac6b2e777b4c147a5904faf83ddffa.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final Object source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"}],"commitId":"a6bca6784e0dc1693b2f94e6832ca927e4ac0a0b","commitMessage":"@@@Execution model refactoring\n\n\nFormer-commit-id: 839cc9a5f11ca146feb2074047af2b09e3ec156f","date":"2015-11-15 01:34:20","modifiedFileCount":"23","status":"M","submitter":"Serge Rider"},{"authorTime":"2015-11-15 05:03:38","codes":[{"authorDate":"2015-11-15 05:03:38","commitOrder":4,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\"\\nWHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-15 05:03:38","endLine":425,"groupId":"9303","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/ec/55dcf2c30fa1288bdba593ac129c06f15568af.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" SET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\" WHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"M"},{"authorDate":"2015-11-15 05:03:38","commitOrder":4,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nWHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-15 05:03:38","endLine":478,"groupId":"14735","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/ec/55dcf2c30fa1288bdba593ac129c06f15568af.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\" WHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"}],"commitId":"cad2fe4a33f77e4dc4db74fcdbbabc361664f16a","commitMessage":"@@@Format query parameters (for QM).\nJDBC table queries formatted.\n\n\nFormer-commit-id: 6b6dc8e942c86c52a2e9e11a14df3fa805f8554f","date":"2015-11-15 05:03:38","modifiedFileCount":"5","status":"M","submitter":"Serge Rider"},{"authorTime":"2015-11-15 05:03:38","codes":[{"authorDate":"2016-04-23 19:10:46","commitOrder":5,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\"\\nWHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2016-04-23 19:10:46","endLine":428,"groupId":"9303","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/b0/5de8f720c52f0e4566546a5cde6c25a9ab7676.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\"\\nWHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"M"},{"authorDate":"2015-11-15 05:03:38","commitOrder":5,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nWHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2015-11-15 05:03:38","endLine":478,"groupId":"14735","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/ec/55dcf2c30fa1288bdba593ac129c06f15568af.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nWHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"N"}],"commitId":"18611acd37b00b31378bd1e7ea798ff4d5099699","commitMessage":"@@@#371 UPSERT statement support\n\n\nFormer-commit-id: 6e7b45f45ec1f880612a4f983c3507e61500ef91","date":"2016-04-23 19:10:46","modifiedFileCount":"4","status":"M","submitter":"Serge Rider"},{"authorTime":"2016-09-12 20:35:27","codes":[{"authorDate":"2016-09-12 20:35:27","commitOrder":6,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\"\\nWHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2016-09-12 20:35:30","endLine":447,"groupId":"9303","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/27/d3b6b09fe7ce3dac5bcf382832d9b5b4abcaa0.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\"\\nWHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"M"},{"authorDate":"2016-09-12 20:35:27","commitOrder":6,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nWHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2016-09-12 20:35:30","endLine":500,"groupId":"14735","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/27/d3b6b09fe7ce3dac5bcf382832d9b5b4abcaa0.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullQualifiedName());\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nWHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":451,"status":"M"}],"commitId":"a03a147e73df7aa4dae339fd4629409aaa89f113","commitMessage":"@@@Qualified objects model refactoring\n\n\nFormer-commit-id: 46d6664860ff90a574209711bf16ec16a3b6b17b","date":"2016-09-12 20:35:30","modifiedFileCount":"153","status":"M","submitter":"serge-rider"},{"authorTime":"2018-01-10 15:23:12","codes":[{"authorDate":"2018-01-10 15:23:12","commitOrder":7,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2018-01-10 15:23:12","endLine":436,"groupId":"9303","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/39/2aebbcb3af8ceb7864dfa485ea88a14da8fa74.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                query.append(\"\\nWHERE \"); \r\n                hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    DBSAttributeBase attribute = keyAttributes[i];\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":361,"status":"M"},{"authorDate":"2018-01-10 15:23:12","commitOrder":7,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2018-01-10 15:23:12","endLine":490,"groupId":"3592","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/39/2aebbcb3af8ceb7864dfa485ea88a14da8fa74.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nWHERE \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < keyAttributes.length; i++) {\n                    if (hasKey) query.append(\" AND \"); \r\n                    hasKey = true;\n                    appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":440,"status":"M"}],"commitId":"1abcf662b9e7ca52b37561b0ceea77fc5e28d95b","commitMessage":"@@@Data manipulator enhancement (batch delete/update)\n\n\nFormer-commit-id: a4325cf877b0c4ba096cd50f84f7d6912c7aa09f","date":"2018-01-10 15:23:12","modifiedFileCount":"1","status":"M","submitter":"Sergei.Rider"},{"authorTime":"2019-05-16 18:34:39","codes":[{"authorDate":"2019-05-16 18:34:39","commitOrder":8,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler) .makeQueryBind(attribute));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-05-16 18:34:39","endLine":478,"groupId":"489","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/83/a8a07b91ef317967e51e13471d5f3ad28320e2.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (DBSAttributeBase attribute : updateAttributes) {\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=?\"); \r\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"M"},{"authorDate":"2019-05-16 18:34:39","commitOrder":8,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-05-16 18:34:39","endLine":535,"groupId":"3592","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/83/a8a07b91ef317967e51e13471d5f3ad28320e2.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"M"}],"commitId":"247dd49aa00957d8a0d4eeaba49575ebf29c534a","commitMessage":"@@@Value binder model\n\n\nFormer-commit-id: a7e2deb9c2a8cb7b05d75510b0078069f816e981","date":"2019-05-16 18:34:39","modifiedFileCount":"3","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-05-16 18:34:39","codes":[{"authorDate":"2019-05-16 18:40:25","commitOrder":9,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-05-16 18:40:25","endLine":478,"groupId":"489","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/71/0e2c6e41f27332d215a427271bd467c25fde00.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler) .makeQueryBind(attribute));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"M"},{"authorDate":"2019-05-16 18:34:39","commitOrder":9,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-05-16 18:34:39","endLine":535,"groupId":"3592","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/83/a8a07b91ef317967e51e13471d5f3ad28320e2.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"N"}],"commitId":"1f78730d7eba19884e98595d568269152673884d","commitMessage":"@@@Value binder model\n\n\nFormer-commit-id: 339938cfd964d874356c4dde3061cd692edfdb72","date":"2019-05-16 18:40:25","modifiedFileCount":"2","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-07-04 04:05:05","codes":[{"authorDate":"2019-07-04 04:05:05","commitOrder":10,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\n\\tSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-07-04 04:05:05","endLine":478,"groupId":"489","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/86/b465e98e608b68bf870cd9ac5dc1d2ac504646.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\nSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"M"},{"authorDate":"2019-07-04 04:05:05","commitOrder":10,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-07-04 04:05:05","endLine":535,"groupId":"3592","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/86/b465e98e608b68bf870cd9ac5dc1d2ac504646.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\nWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"M"}],"commitId":"a19a26e574c353f94f1eaa23abc822dbeaeb5ed1","commitMessage":"@@@#5587 Preview SQL dialog redesign\n\n\nFormer-commit-id: 06eff93ace8ca80a30915d73494cd3ba5e703244","date":"2019-07-04 04:05:05","modifiedFileCount":"7","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-10-30 18:58:57","codes":[{"authorDate":"2019-10-30 18:58:57","commitOrder":11,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"UPDATE \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\n\\tSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-10-30 18:58:57","endLine":468,"groupId":"489","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/5b/c12b7153bd445d6f48ecb1c2582d53106b9966.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"UPDATE \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\n\\tSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"M"},{"authorDate":"2019-10-30 18:58:57","commitOrder":11,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"DELETE FROM \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-10-30 18:58:57","endLine":526,"groupId":"13583","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/5b/c12b7153bd445d6f48ecb1c2582d53106b9966.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                query.append(\"DELETE FROM \").append(getFullyQualifiedName(DBPEvaluationContext.DML));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":475,"status":"M"}],"commitId":"9ef62ac0463bebab59c049e477ee26f6241c00db","commitMessage":"@@@#6633 \"Use FQ names\" option in data editor scripts. Persistence model refactoring (pass options)\n\n\nFormer-commit-id: c3768a49f8a5cc280977900b40fc01d2858d70b3","date":"2019-10-30 18:58:57","modifiedFileCount":"13","status":"M","submitter":"Serge Rider"},{"authorTime":"2019-12-30 06:28:44","codes":[{"authorDate":"2019-12-30 06:28:44","commitOrder":12,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"UPDATE \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\n\\tSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-12-30 06:28:44","endLine":468,"groupId":"489","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/63/20e1a454ccd8171253436a5867d6ff5cea0452.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"UPDATE \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\n\\tSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"M"},{"authorDate":"2019-12-30 06:28:44","commitOrder":12,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"DELETE FROM \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2019-12-30 06:28:44","endLine":526,"groupId":"13583","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/63/20e1a454ccd8171253436a5867d6ff5cea0452.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = ((SQLDataSource) session.getDataSource()).getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"DELETE FROM \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":475,"status":"M"}],"commitId":"add5c6fee1280d39bc0a8973c9ebc411e832e5c1","commitMessage":"@@@SQL model refactoring (get rid of SQLDataSource)\n\n\nFormer-commit-id: 5cccfd05549661ee63098bb8efb306880579c576","date":"2019-12-30 06:28:44","modifiedFileCount":"51","status":"M","submitter":"serge-rider"},{"authorTime":"2021-03-16 02:44:13","codes":[{"authorDate":"2021-03-16 02:44:13","commitOrder":13,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(dialect.generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = dialect.generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(dialect.generateTableUpdateSet()); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-03-16 02:44:13","endLine":488,"groupId":"0","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/8f/482feceb73a7e21394ac3491ad6bf1d0d7a19b.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"UPDATE \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                query.append(\"\\n\\tSET \"); \r\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":402,"status":"M"},{"authorDate":"2021-03-16 02:44:13","commitOrder":13,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(dialect.generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-03-16 02:44:13","endLine":546,"groupId":"0","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/8f/482feceb73a7e21394ac3491ad6bf1d0d7a19b.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(\"DELETE FROM \").append(tableName);\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"M"}],"commitId":"a6d590c0635581ffa41e8f6260c363d7ad85d019","commitMessage":"@@@Merge pull request #11728 from dbeaver/clickhouseUpdateDelete#10718\n\n #10718 update and delete statements changed for Clickhouse\n\nFormer-commit-id: 3e24e39abee50d9836c81ff18f813d780fb00bc4","date":"2021-03-16 02:44:13","modifiedFileCount":"4","status":"M","submitter":"Serge Rider"},{"authorTime":"2021-03-25 04:19:05","codes":[{"authorDate":"2021-03-25 04:19:05","commitOrder":14,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(generateTableUpdateSet()); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-03-25 04:19:05","endLine":488,"groupId":"489","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/3f/8a0e136cfa044873267a755c7bc3d3d968f88d.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(dialect.generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = dialect.generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(dialect.generateTableUpdateSet()); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":402,"status":"M"},{"authorDate":"2021-03-25 04:19:05","commitOrder":14,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-03-25 04:19:05","endLine":546,"groupId":"6502","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/3f/8a0e136cfa044873267a755c7bc3d3d968f88d.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(dialect.generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"M"}],"commitId":"3fbefa3ea83eb34a5a3a93058a7a4e0f948ebdd7","commitMessage":"@@@Merge pull request #11867 from dbeaver/sqlEditorRefactoring\n\nalter table methods moved from sqldialect to jdbctable\n\nFormer-commit-id: 617a5c7b7e03194d5463f1a05d1781fa1f1a8697","date":"2021-03-25 04:19:05","modifiedFileCount":"5","status":"M","submitter":"Serge Rider"},{"authorTime":"2021-03-25 04:19:05","codes":[{"authorDate":"2021-06-22 19:56:57","commitOrder":15,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(updateSet); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-06-22 19:56:57","endLine":488,"groupId":"10251","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/f1/101d3532b694e12f29206296fc8c2819617fbd.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(generateTableUpdateSet()); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":402,"status":"M"},{"authorDate":"2021-03-25 04:19:05","commitOrder":15,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-03-25 04:19:05","endLine":546,"groupId":"6502","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/3f/8a0e136cfa044873267a755c7bc3d3d968f88d.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"N"}],"commitId":"0992cdfcca89f08440a8602f8f0b6190c4b5e56c","commitMessage":"@@@Merge pull request #12925 from dbeaver/clickHouseGenerated#12126\n\n#12126 update Generate SQL syntax depending on the database","date":"2021-06-22 19:56:57","modifiedFileCount":"5","status":"M","submitter":"Serge Rider"},{"authorTime":"2021-03-25 04:19:05","codes":[{"authorDate":"2021-07-20 14:49:29","commitOrder":16,"curCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source,\n                Collections.emptyMap());\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(updateSet); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-07-20 14:49:29","endLine":405,"groupId":"10916","id":31,"instanceNumber":1,"isCurCommit":1,"methodName":"updateData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]updateAttributes@@NotNullfinalDBSAttributeBase[]keyAttributes@@NullableDBDDataReceiverkeysReceiver@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/b2/74dba0bb7959040ae03448e33f0dd585862309.src","preCode":"    public ExecuteBatch updateData(\n        @NotNull DBCSession session,\n        @NotNull final DBSAttributeBase[] updateAttributes,\n        @NotNull final DBSAttributeBase[] keyAttributes,\n        @Nullable DBDDataReceiver keysReceiver, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        if (useUpsert(session)) {\n            return insertData(\n                session,\n                ArrayUtils.concatArrays(updateAttributes, keyAttributes),\n                keysReceiver,\n                source);\n        }\n        readRequiredMeta(session.getProgressMonitor());\n\n        DBSAttributeBase[] attributes = ArrayUtils.concatArrays(updateAttributes, keyAttributes);\n\n        return new ExecuteBatchImpl(attributes, keysReceiver, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableUpdateBegin(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                String updateSet = generateTableUpdateSet();\n                if (!CommonUtils.isEmpty(updateSet)) {\n                    query.append(\"\\n\\t\").append(updateSet); \r\n                }\n\n                boolean hasKey = false;\n                for (int i = 0; i < updateAttributes.length; i++) {\n                    DBSAttributeBase attribute = updateAttributes[i];\n                    if (hasKey) query.append(\",\"); \r\n                    hasKey = true;\n                    if (tableAlias != null) {\n                        query.append(tableAlias).append(dialect.getStructSeparator());\n                    }\n                    query.append(getAttributeName(attribute)).append(\"=\"); \r\n                    DBDValueHandler valueHandler = handlers[i];\n                    if (valueHandler instanceof DBDValueBinder) {\n                        query.append(((DBDValueBinder) valueHandler).makeQueryBind(attribute, attributeValues[i]));\n                    } else {\n                        query.append(\"?\"); \r\n                    }\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        DBSAttributeBase attribute = keyAttributes[i];\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, attribute, attributeValues[updateAttributes.length + i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, keysReceiver != null);\n\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (k >= updateAttributes.length && DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":318,"status":"M"},{"authorDate":"2021-03-25 04:19:05","commitOrder":16,"curCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","date":"2021-03-25 04:19:05","endLine":546,"groupId":"10916","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteData","params":"(@NotNullDBCSessionsession@@NotNullfinalDBSAttributeBase[]keyAttributes@@NotNullfinalDBCExecutionSourcesource)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dbeaver-10-0.7/blobInfo/CC_OUT/blobs/3f/8a0e136cfa044873267a755c7bc3d3d968f88d.src","preCode":"    public ExecuteBatch deleteData(@NotNull DBCSession session, @NotNull final DBSAttributeBase[] keyAttributes, @NotNull final DBCExecutionSource source)\n        throws DBCException\n    {\n        readRequiredMeta(session.getProgressMonitor());\n\n        return new ExecuteBatchImpl(keyAttributes, null, false) {\n            @NotNull\n            @Override\n            protected DBCStatement prepareStatement(@NotNull DBCSession session, DBDValueHandler[] handlers, Object[] attributeValues, Map<String, Object> options) throws DBCException {\n                String tableAlias = null;\n                SQLDialect dialect = session.getDataSource().getSQLDialect();\n                if (dialect.supportsAliasInUpdate()) {\n                    tableAlias = DEFAULT_TABLE_ALIAS;\n                }\n\n                \r\n                StringBuilder query = new StringBuilder();\n                String tableName = DBUtils.getEntityScriptName(JDBCTable.this, options);\n                query.append(generateTableDeleteFrom(tableName));\n                if (tableAlias != null) {\n                    query.append(' ').append(tableAlias);\n                }\n                if (keyAttributes.length > 0) {\n                    query.append(\"\\n\\tWHERE \"); \r\n                    boolean hasKey = false;\n                    for (int i = 0; i < keyAttributes.length; i++) {\n                        if (hasKey) query.append(\" AND \"); \r\n                        hasKey = true;\n                        appendAttributeCriteria(tableAlias, dialect, query, keyAttributes[i], attributeValues[i]);\n                    }\n                }\n\n                \r\n                DBCStatement dbStat = session.prepareStatement(DBCStatementType.QUERY, query.toString(), false, false, false);\n                dbStat.setStatementSource(source);\n                return dbStat;\n            }\n\n            @Override\n            protected void bindStatement(@NotNull DBDValueHandler[] handlers, @NotNull DBCStatement statement, Object[] attributeValues) throws DBCException {\n                int paramIndex = 0;\n                for (int k = 0; k < handlers.length; k++) {\n                    DBSAttributeBase attribute = attributes[k];\n                    if (DBUtils.isNullValue(attributeValues[k])) {\n                        \r\n                        continue;\n                    }\n                    handlers[k].bindValueObject(statement.getSession(), statement, attribute, paramIndex++, attributeValues[k]);\n                }\n            }\n        };\n    }\n","realPath":"plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/impl/jdbc/struct/JDBCTable.java","repoName":"dbeaver","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"N"}],"commitId":"cb8eaf29cd0a4cb6417f30eca75262d1964f789f","commitMessage":"@@@Merge remote-tracking branch 'origin/devel' into devel\n","date":"2021-07-20 14:49:29","modifiedFileCount":"15","status":"M","submitter":"Serge Rider"}]
