[{"authorTime":"2016-11-08 07:07:40","codes":[{"authorDate":"2016-11-08 07:07:40","commitOrder":1,"curCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least one protocol is enabled\", defaultProtocols.size(), greaterThan(0));\n        \n        final String protocolToDisable = defaultProtocols.iterator().next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n        assertThat(protocolToDisable + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n    }\n","date":"2016-11-08 07:07:40","endLine":531,"groupId":"8581","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"agentProtocols_multipleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8e/88f7f0e3d8b97c4bf36ba741ab4aeee73dae2f.src","preCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least one protocol is enabled\", defaultProtocols.size(), greaterThan(0));\n        \n        final String protocolToDisable = defaultProtocols.iterator().next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n        assertThat(protocolToDisable + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":511,"status":"B"},{"authorDate":"2016-11-08 07:07:40","commitOrder":1,"curCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least two protocol should be enabled\", defaultProtocols.size(), greaterThan(1));\n        \n        Iterator<String> iterator = defaultProtocols.iterator();\n        final String protocolToDisable1 = iterator.next();\n        final String protocolToDisable2 = iterator.next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable1 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertThat(protocolToDisable1 + \" must be disaabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disaabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n    }\n","date":"2016-11-08 07:07:40","endLine":594,"groupId":"8579","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"agentProtocols_singleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8e/88f7f0e3d8b97c4bf36ba741ab4aeee73dae2f.src","preCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least two protocol should be enabled\", defaultProtocols.size(), greaterThan(1));\n        \n        Iterator<String> iterator = defaultProtocols.iterator();\n        final String protocolToDisable1 = iterator.next();\n        final String protocolToDisable2 = iterator.next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable1 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertThat(protocolToDisable1 + \" must be disaabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disaabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":567,"status":"B"}],"commitId":"3e2e01717976a1f1221874bfd576429c5c48b8a6","commitMessage":"@@@[JENKINS-39465] - Fix the AgentProtocol settings persistency handling (#2621)\n\n* [JENKINS-39465] - Tweak processing of enabled and disabled protocols in Jenkins instance\n\nDue to whatever reason.  without a definition of an array recipient field the data goes to the disk in the following way:\n\n```\n<enabledAgentProtocol>JNLP3-connect</enabledAgentProtocol>\n<enabledAgentProtocol>JNLP4-connect</enabledAgentProtocol>\n```\n\nIt is supposed to processed by Implicit array correctly.  but it does not actually happen.\nWith a fix the data is being stored in another format:\n\n```\n  <enabledAgentProtocols>\n    <string>JNLP3-connect</string>\n    <string>JNLP4-connect</string>\n  </enabledAgentProtocols>\n```\n\nThis data now works correctly and gets deserialized correctly. readResolve() just adds a fallback for the case when Implicit array handling starts behaving correctly (?).\n\n* [JENKINS-39465] - Add configuration roundtrip tests\n\n* [JENKINS-39465] - Jenkins#agentProtocols cache must be invalidated when we reload the configuration\n\n* [JENKINS-39465] - Remove obsolete comment from Tests\n","date":"2016-11-08 07:07:40","modifiedFileCount":"2","status":"B","submitter":"Oleg Nenashev"},{"authorTime":"2017-02-12 18:38:30","codes":[{"authorDate":"2016-11-08 07:07:40","commitOrder":2,"curCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least one protocol is enabled\", defaultProtocols.size(), greaterThan(0));\n        \n        final String protocolToDisable = defaultProtocols.iterator().next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n        assertThat(protocolToDisable + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n    }\n","date":"2016-11-08 07:07:40","endLine":531,"groupId":"8581","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"agentProtocols_multipleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8e/88f7f0e3d8b97c4bf36ba741ab4aeee73dae2f.src","preCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least one protocol is enabled\", defaultProtocols.size(), greaterThan(0));\n        \n        final String protocolToDisable = defaultProtocols.iterator().next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n        assertThat(protocolToDisable + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":511,"status":"N"},{"authorDate":"2017-02-12 18:38:30","commitOrder":2,"curCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least two protocol should be enabled\", defaultProtocols.size(), greaterThan(1));\n        \n        Iterator<String> iterator = defaultProtocols.iterator();\n        final String protocolToDisable1 = iterator.next();\n        final String protocolToDisable2 = iterator.next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable1 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertThat(protocolToDisable1 + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n    }\n","date":"2017-02-12 18:38:30","endLine":617,"groupId":"8579","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"agentProtocols_singleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/f5/3cb81bbc93c5c0fc4e35596dbe82a7fff29bde.src","preCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least two protocol should be enabled\", defaultProtocols.size(), greaterThan(1));\n        \n        Iterator<String> iterator = defaultProtocols.iterator();\n        final String protocolToDisable1 = iterator.next();\n        final String protocolToDisable2 = iterator.next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable1 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertThat(protocolToDisable1 + \" must be disaabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disaabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":590,"status":"M"}],"commitId":"496703d0fe133445e10c7d8d07fa7afd351c8854","commitMessage":"@@@Spelling fixes in changelogs.  Javadoc.  logs and UI (#2718)\n\n* spelling: abstract\n\n* spelling: about\n\n* spelling: absolute\n\n* spelling: across\n\n* spelling: activity\n\n* spelling: actually\n\n* spelling: addition\n\n* spelling: allocating\n\n* spelling: ambiguous\n\n* spelling: analyzes\n\n* spelling: analysis\n\n* spelling: another\n\n* spelling: appear\n\n* spelling: arbitrary\n\n* spelling: artifact\n\n* spelling: assignment\n\n* spelling: associated\n\n* spelling: augment\n\n* spelling: authentication\n\n* spelling: automatically\n\n* spelling: available\n\n* spelling: availability\n\n* spelling: because\n\n* spelling: background\n\n* spelling: beginning\n\n* spelling: boolean\n\n* spelling: browsers\n\n* spelling: building\n\n* spelling: calculation\n\n* spelling: channel\n\n* spelling: column\n\n* spelling: concatenation\n\n* spelling: connect\n\n* spelling: contribute\n\n* spelling: convert\n\n* spelling: copied\n\n* spelling: couldn't\n\n* spelling: scrambled\n\n* spelling: creates-a\n\n* spelling: curr-entry\n\n* spelling: customize\n\n* spelling: diagnostic\n\n* spelling: contain\n\n* spelling: default\n\n* spelling: delimiter\n\n* spelling: descriptor\n\n* spelling: disambiguates\n\n* spelling: different\n\n* spelling: diligently\n\n* spelling: disabled\n\n* spelling: discovered\n\n* spelling: display\n\n* spelling: doesn't\n\n* spelling: dollar\n\n* spelling: downstream\n\n* spelling: dynamically\n\n* spelling: preemptively\n\n* spelling: encrypt\n\n* spelling: erroneous\n\n* spelling: examine\n\n* spelling: existence\n\n* spelling: value\n\n* spelling: february\n\n* spelling: handling\n\n* spelling: hostname\n\n* spelling: convenient\n\n* spelling: identify\n\n* spelling: implementation\n\n* spelling: incorrect\n\n* spelling: individual\n\n* spelling: initialization\n\n* spelling: initialized\n\n* spelling: inputstream\n\n* spelling: instantiated\n\n* spelling: instantiation\n\n* spelling: intended\n\n* spelling: interpreted\n\n* spelling: interrupted\n\n* spelling: invocations\n\n* spelling: kern\n\n* spelling: localization\n\n* spelling: logger\n\n* spelling: malfunctioning\n\n* spelling: methods\n\n* spelling: monitor\n\n* spelling: mutator\n\n* spelling: multiple\n\n* spelling: object\n\n* spelling: configured\n\n* spelling: optionally\n\n* spelling: option\n\n* spelling: overridden\n\n* spelling: parameterized\n\n* spelling: parent\n\n* spelling: permissions\n\n* spelling: plugin\n\n* spelling: potentially\n\n* spelling: preferable\n\n* spelling: problems like\n\n* spelling: programmatically\n\n* spelling: property\n\n* spelling: reallocate\n\n* spelling: recommended\n\n* spelling: redirected\n\n* spelling: registered\n\n* spelling: reliable\n\n* spelling: remember\n\n* spelling: recurrence\n\n* spelling: repeatable\n\n* spelling: repeated\n\n* spelling: resource\n\n* spelling: retrieve\n\n* spelling: returned\n\n* spelling: revision\n\n* spelling: sandwich\n\n* spelling: separator\n\n* spelling: serialization\n\n* spelling: settings\n\n* spelling: shadow\n\n* spelling: should\n\n* spelling: someone\n\n* spelling: source\n\n* spelling: specified\n\n* spelling: style\n\n* spelling: subversion\n\n* spelling: sufficient\n\n* spelling: supplementary\n\n* spelling: suppressing\n\n* spelling: synchronization\n\n* spelling: synchronized\n\n* spelling: this\n\n* spelling: transitioning\n\n* spelling: termination\n\n* spelling: trying\n\n* spelling: truncatable\n\n* spelling: unknown\n\n* spelling: undeployed\n\n* spelling: unnecessary\n\n* spelling: unparseable\n\n* spelling: update\n\n* spelling: upper\n\n* spelling: verify\n\n* spelling: visible\n\n* spelling: warning\n\n* spelling: we're\n\n* spelling: whitespace\n\n* spelling: wide\n\n* spelling: with\n\n* spelling: workspace\n\n* spelling: yielding\n\n* spelling: to\n\n* spelling: by\n\n* spelling: the\n\n* spelling: hours\n","date":"2017-02-12 18:38:30","modifiedFileCount":"110","status":"M","submitter":"Josh Soref"},{"authorTime":"2017-11-06 20:06:55","codes":[{"authorDate":"2017-11-06 20:06:55","commitOrder":3,"curCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        assertProtocolEnabled(MockOptOutProtocol1.NAME, \"after startup\");\n\n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(MockOptOutProtocol1.NAME);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertProtocolDisabled(MockOptOutProtocol1.NAME, \"before the roundtrip\");\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n\n        assertProtocolDisabled(MockOptOutProtocol1.NAME, \"after the roundtrip\");\n    }\n","date":"2017-11-06 20:06:55","endLine":537,"groupId":"210","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"agentProtocols_multipleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/5c/65ceffda90e015254b17fb8fbf96e5fe742cde.src","preCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least one protocol is enabled\", defaultProtocols.size(), greaterThan(0));\n        \n        final String protocolToDisable = defaultProtocols.iterator().next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n        assertThat(protocolToDisable + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable)));\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":520,"status":"M"},{"authorDate":"2017-11-06 20:06:55","commitOrder":3,"curCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        final String protocolToDisable1 = MockOptOutProtocol1.NAME;\n        final String protocolToDisable2 = MockOptOutProtocol2.NAME;\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertProtocolDisabled(protocolToDisable1, \"before the roundtrip\");\n        assertProtocolDisabled(protocolToDisable2, \"before the roundtrip\");\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertProtocolDisabled(protocolToDisable1, \"after the roundtrip\");\n        assertProtocolDisabled(protocolToDisable2, \"after the roundtrip\");\n    }\n","date":"2017-11-06 20:06:55","endLine":585,"groupId":"4167","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"agentProtocols_singleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/5c/65ceffda90e015254b17fb8fbf96e5fe742cde.src","preCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        Assume.assumeThat(\"At least two protocol should be enabled\", defaultProtocols.size(), greaterThan(1));\n        \n        Iterator<String> iterator = defaultProtocols.iterator();\n        final String protocolToDisable1 = iterator.next();\n        final String protocolToDisable2 = iterator.next();\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertThat(protocolToDisable1 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled before the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertThat(protocolToDisable1 + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable1)));\n        assertThat(protocolToDisable2 + \" must be disabled after the roundtrip\", \n                j.jenkins.getAgentProtocols(), not(hasItem(protocolToDisable2)));\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":565,"status":"M"}],"commitId":"048858daec03431edeb8cecf101bac8cc84a6685","commitMessage":"@@@Merge commit '048e313aa95844e2366a0611192415abbcf4b5ee' of git://github.com/jenkinsci/jenkins\n","date":"2017-11-06 20:06:55","modifiedFileCount":"5","status":"M","submitter":"Jesse Glick"},{"authorTime":"2021-01-03 01:20:57","codes":[{"authorDate":"2021-01-03 01:20:57","commitOrder":4,"curCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        assertProtocolEnabled(MockOptOutProtocol1.NAME, \"after startup\");\n\n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(MockOptOutProtocol1.NAME);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertProtocolDisabled(MockOptOutProtocol1.NAME, \"before the roundtrip\");\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertNotSame(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload, j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n\n        assertProtocolDisabled(MockOptOutProtocol1.NAME, \"after the roundtrip\");\n    }\n","date":"2021-01-03 01:20:57","endLine":559,"groupId":"10714","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"agentProtocols_multipleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/cbb7fa8cd421b3af28b49ed46104851e1a907a.src","preCode":"    public void agentProtocols_multipleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        assertProtocolEnabled(MockOptOutProtocol1.NAME, \"after startup\");\n\n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(MockOptOutProtocol1.NAME);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertProtocolDisabled(MockOptOutProtocol1.NAME, \"before the roundtrip\");\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really refreshed\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled one protocol\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 1));\n\n        assertProtocolDisabled(MockOptOutProtocol1.NAME, \"after the roundtrip\");\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":542,"status":"M"},{"authorDate":"2021-01-03 01:20:57","commitOrder":4,"curCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        final String protocolToDisable1 = MockOptOutProtocol1.NAME;\n        final String protocolToDisable2 = MockOptOutProtocol2.NAME;\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertProtocolDisabled(protocolToDisable1, \"before the roundtrip\");\n        assertProtocolDisabled(protocolToDisable2, \"before the roundtrip\");\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertNotSame(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload, j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertProtocolDisabled(protocolToDisable1, \"after the roundtrip\");\n        assertProtocolDisabled(protocolToDisable2, \"after the roundtrip\");\n    }\n","date":"2021-01-03 01:20:57","endLine":607,"groupId":"10714","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"agentProtocols_singleDisable_roundtrip","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/cbb7fa8cd421b3af28b49ed46104851e1a907a.src","preCode":"    public void agentProtocols_singleDisable_roundtrip() throws Exception {\n        final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols());\n        final String protocolToDisable1 = MockOptOutProtocol1.NAME;\n        final String protocolToDisable2 = MockOptOutProtocol2.NAME;\n        \n        final Set<String> newProtocols = new HashSet<>(defaultProtocols);\n        newProtocols.remove(protocolToDisable1);\n        newProtocols.remove(protocolToDisable2);\n        j.jenkins.setAgentProtocols(newProtocols);\n        j.jenkins.save();\n        assertProtocolDisabled(protocolToDisable1, \"before the roundtrip\");\n        assertProtocolDisabled(protocolToDisable2, \"before the roundtrip\");\n        final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols();\n        j.jenkins.reload();\n        \n        assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == j.jenkins.getAgentProtocols());\n        assertThat(\"We should have disabled two protocols\", \n                j.jenkins.getAgentProtocols().size(), equalTo(defaultProtocols.size() - 2));\n        assertProtocolDisabled(protocolToDisable1, \"after the roundtrip\");\n        assertProtocolDisabled(protocolToDisable2, \"after the roundtrip\");\n    }\n","realPath":"test/src/test/java/jenkins/model/JenkinsTest.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":587,"status":"M"}],"commitId":"a9ee90e7fc931445956616ffae4ea3c5ababe41d","commitMessage":"@@@Merge pull request #5134 from basil/improvements\n\nCode cleanup","date":"2021-01-03 01:20:57","modifiedFileCount":"88","status":"M","submitter":"Oleg Nenashev"}]
