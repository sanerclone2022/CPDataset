[{"authorTime":"2009-07-22 01:02:03","codes":[{"authorDate":"2009-07-22 01:02:03","commitOrder":13,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","date":"2009-07-22 01:02:03","endLine":883,"groupId":"9600","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/1f/1afd82829637d8f6b3cbe552fa36539a26d69d.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":846,"status":"MB"},{"authorDate":"2009-07-22 01:02:03","commitOrder":13,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null)    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2009-07-22 01:02:03","endLine":908,"groupId":"4589","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/1f/1afd82829637d8f6b3cbe552fa36539a26d69d.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null)    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":885,"status":"B"}],"commitId":"70db23bf56bf327b86333acc81bc423a4b28de9a","commitMessage":"@@@Merged revisions 19919. 19998. 20022 via svnmerge from \nhttps://www.dev.java.net/svn/hudson/branches/matrix-parent\n\n........\n  r19919 | kohsuke | 2009-07-18 18:45:59 -0700 (Sat.  18 Jul 2009) | 1 line\n  \n  committing the work in progress.\n........\n  r19998 | kohsuke | 2009-07-20 18:58:15 -0700 (Mon.  20 Jul 2009) | 1 line\n  \n  [HUDSON-936] I believe this should do.\n........\n  r20022 | kohsuke | 2009-07-21 09:48:03 -0700 (Tue.  21 Jul 2009) | 1 line\n  \n  adding a switch to enable this selectively.  so that we can give this feature a longer soak time.\n........\n\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@20025 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2009-07-22 01:02:03","modifiedFileCount":"5","status":"M","submitter":"kohsuke"},{"authorTime":"2009-07-22 01:02:03","codes":[{"authorDate":"2009-09-03 03:11:20","commitOrder":14,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                \r\n                if (p.task instanceof AbstractProject<?,?>) {\n                    AbstractProject<?,?> proj = (AbstractProject<?,?>) p.task;\n                    if (!proj.isConcurrentBuild() && buildables.containsKey(p.task)) {\n                        continue;\n                    }\n                }\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","date":"2009-09-03 03:11:20","endLine":905,"groupId":"4875","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/cd/27ec7dc3e1e3cdcdf48312921126bb265e3791.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"M"},{"authorDate":"2009-07-22 01:02:03","commitOrder":14,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null)    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2009-07-22 01:02:03","endLine":908,"groupId":"4589","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/1f/1afd82829637d8f6b3cbe552fa36539a26d69d.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null)    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":885,"status":"N"}],"commitId":"e9def49a05a72305a531d7f5b16661a5593c17ca","commitMessage":"@@@If a project is not set for concurrent builds and there is more than one job\nin the queue (e.g. if the build is parameterized).  then don't make more than\none of them runnable.\n\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@21365 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2009-09-03 03:11:20","modifiedFileCount":"1","status":"M","submitter":"pgweiss"},{"authorTime":"2009-11-28 08:56:25","codes":[{"authorDate":"2009-09-03 03:11:20","commitOrder":15,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                \r\n                if (p.task instanceof AbstractProject<?,?>) {\n                    AbstractProject<?,?> proj = (AbstractProject<?,?>) p.task;\n                    if (!proj.isConcurrentBuild() && buildables.containsKey(p.task)) {\n                        continue;\n                    }\n                }\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","date":"2009-09-03 03:11:20","endLine":905,"groupId":"4875","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/cd/27ec7dc3e1e3cdcdf48312921126bb265e3791.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                \r\n                if (p.task instanceof AbstractProject<?,?>) {\n                    AbstractProject<?,?> proj = (AbstractProject<?,?>) p.task;\n                    if (!proj.isConcurrentBuild() && buildables.containsKey(p.task)) {\n                        continue;\n                    }\n                }\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"},{"authorDate":"2009-11-28 08:56:25","commitOrder":15,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2009-11-28 08:56:25","endLine":916,"groupId":"4589","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/a2/d85b6ddd344b0f0c54d0edb20b63ecbec20eb4.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null)    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":893,"status":"M"}],"commitId":"53b8f8a518ef670ea6a1c2f29e4950741919c55d","commitMessage":"@@@[HUDSON-936] Applied the patch from pcc.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@24149 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2009-11-28 08:56:25","modifiedFileCount":"1","status":"M","submitter":"kohsuke"},{"authorTime":"2009-12-09 10:09:04","codes":[{"authorDate":"2009-09-03 03:11:20","commitOrder":16,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                \r\n                if (p.task instanceof AbstractProject<?,?>) {\n                    AbstractProject<?,?> proj = (AbstractProject<?,?>) p.task;\n                    if (!proj.isConcurrentBuild() && buildables.containsKey(p.task)) {\n                        continue;\n                    }\n                }\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","date":"2009-09-03 03:11:20","endLine":905,"groupId":"4875","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/cd/27ec7dc3e1e3cdcdf48312921126bb265e3791.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                \r\n                if (p.task instanceof AbstractProject<?,?>) {\n                    AbstractProject<?,?> proj = (AbstractProject<?,?>) p.task;\n                    if (!proj.isConcurrentBuild() && buildables.containsKey(p.task)) {\n                        continue;\n                    }\n                }\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"},{"authorDate":"2009-12-09 10:09:04","commitOrder":16,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2009-12-09 10:09:04","endLine":914,"groupId":"4589","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/1f/8a94af87155849c1ad0a1acefacf11bece8b97.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":891,"status":"M"}],"commitId":"6fa3acf8a9e96c385071eba594959c944150390a","commitMessage":"@@@[HUDSON-4873] follow up change to rev.23980. Since flyweight support ignores the node availability.  it bypasses the buildable state completely.  which in turn means it now ignores other checks that buildable state did.  namely to see if Hudson was quietting down.\n\nModified code so that FlyweightTask doesn't get started if Hudson is quieting down.\n\nI feel like Queue is getting too complex.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@24492 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2009-12-09 10:09:04","modifiedFileCount":"1","status":"M","submitter":"kohsuke"},{"authorTime":"2009-12-09 10:09:04","codes":[{"authorDate":"2009-12-16 03:24:11","commitOrder":17,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","date":"2009-12-16 03:24:11","endLine":888,"groupId":"5574","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/be/36cabdba3dbf31100f97b16a93a7dc3e5a96bd.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task)) {\n                \r\n                \r\n                if (p.task instanceof AbstractProject<?,?>) {\n                    AbstractProject<?,?> proj = (AbstractProject<?,?>) p.task;\n                    if (!proj.isConcurrentBuild() && buildables.containsKey(p.task)) {\n                        continue;\n                    }\n                }\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":851,"status":"M"},{"authorDate":"2009-12-09 10:09:04","commitOrder":17,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2009-12-09 10:09:04","endLine":914,"groupId":"4589","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/1f/8a94af87155849c1ad0a1acefacf11bece8b97.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":891,"status":"N"}],"commitId":"84bca061dc4f330d17999bb15ee4b40cac227fd9","commitMessage":"@@@Another fix for non-concurrent builds being built concurrently.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@24637 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2009-12-16 03:24:11","modifiedFileCount":"1","status":"M","submitter":"pgweiss"},{"authorTime":"2009-12-09 10:09:04","codes":[{"authorDate":"2010-01-28 07:54:29","commitOrder":18,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2010-01-28 07:54:29","endLine":915,"groupId":"5574","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8a/44188d787fb4934b47e9515c3821bbfdc09cc5.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n        \n        if (sortingHandler != null)\n        \tsortingHandler.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":877,"status":"M"},{"authorDate":"2009-12-09 10:09:04","commitOrder":18,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2009-12-09 10:09:04","endLine":914,"groupId":"4589","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/1f/8a94af87155849c1ad0a1acefacf11bece8b97.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":891,"status":"N"}],"commitId":"9e14a89184243394b642afc9faa817595269efee","commitMessage":"@@@[HUDSON-833] formalized the QueueSorter.\n\nThis is a binary incomatpible change from the previous QueueSortingHandler.  but given that QueueSortingHandler used one of the private classes in the method signature.  I don't see how anyone could have implemented this extension point.  so in practice this change shouldn't break any plugin (certainly not any plugins hosted in hudson-ci.org.  according to my grep.)\n\nI'll implement a plugin that shows how this extension point can be used.  and that will mark this issue as fixed.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@26610 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2010-01-28 07:54:29","modifiedFileCount":"2","status":"M","submitter":"kohsuke"},{"authorTime":"2010-05-26 00:05:05","codes":[{"authorDate":"2010-01-28 07:54:29","commitOrder":19,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2010-01-28 07:54:29","endLine":915,"groupId":"5574","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8a/44188d787fb4934b47e9515c3821bbfdc09cc5.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":877,"status":"N"},{"authorDate":"2010-05-26 00:05:05","commitOrder":19,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2010-05-26 00:05:05","endLine":943,"groupId":"5575","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/b6/01acaf9bb368a9a391ee95ddde9de28eceeb7f.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n            \n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":918,"status":"M"}],"commitId":"5c3ef69aed4cad7379ea4a8ec56f997ac8a7c405","commitMessage":"@@@[FIXED HUDSON-6180] Queue.FlyWeightTask objects now respect labels assigned to them when scheduling.  Enables Matrix Tie Parent Plugin.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@31360 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2010-05-26 00:05:05","modifiedFileCount":"1","status":"M","submitter":"kbertelson"},{"authorTime":"2010-09-10 06:24:37","codes":[{"authorDate":"2010-01-28 07:54:29","commitOrder":20,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2010-01-28 07:54:29","endLine":915,"groupId":"5574","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8a/44188d787fb4934b47e9515c3821bbfdc09cc5.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":877,"status":"N"},{"authorDate":"2010-09-10 06:24:37","commitOrder":20,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2010-09-10 06:24:37","endLine":979,"groupId":"5575","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/ca/13d0cb36a85ae9883aa90267d16408f289f8d2.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":954,"status":"M"}],"commitId":"5f3fc7076906a941ba2266eb69678262ddf30686","commitMessage":"@@@checkpoint. now it at least passes all the compilation.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@34608 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2010-09-10 06:24:37","modifiedFileCount":"7","status":"M","submitter":"kohsuke"},{"authorTime":"2010-09-10 06:24:56","codes":[{"authorDate":"2010-01-28 07:54:29","commitOrder":21,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2010-01-28 07:54:29","endLine":915,"groupId":"5574","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8a/44188d787fb4934b47e9515c3821bbfdc09cc5.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":877,"status":"N"},{"authorDate":"2010-09-10 06:24:56","commitOrder":21,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2010-09-10 06:24:56","endLine":979,"groupId":"5575","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/63/ab1ebcdcddc7f0dd043b91cd3d81437db806c5.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && (!Hudson.getInstance().isQuietingDown() || p.task instanceof NonBlockingTask)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":954,"status":"M"}],"commitId":"a41f73d102aa76625f18f543be944724ca4ef7d1","commitMessage":"@@@abstraction improvement and doc improvement.\n\ngit-svn-id: https://hudson.dev.java.net/svn/hudson/trunk/hudson/main@34609 71c3de6d-444a-0410-be80-ed276b4c234a\n","date":"2010-09-10 06:24:56","modifiedFileCount":"2","status":"M","submitter":"kohsuke"},{"authorTime":"2011-02-15 04:48:44","codes":[{"authorDate":"2011-02-15 04:48:44","commitOrder":22,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                if (makeBuildable(new BuildableItem(p))) {\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                }\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            boolean isReady = false;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                isReady = makeBuildable(new BuildableItem(top));\n            }\n            if (isReady) {\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-02-15 08:02:33","endLine":917,"groupId":"5778","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/ca/b37a93aaa20e2782ace437cd89794e5e0b5fec.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":874,"status":"M"},{"authorDate":"2011-02-15 04:48:44","commitOrder":22,"curCode":"    private boolean makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                List<OneOffExecutor> oneOffExecutors = c.getOneOffExecutors();\n                for (OneOffExecutor ooe : oneOffExecutors) {\n                    Queue.Executable exe = ooe.getCurrentExecutable();\n                    if (exe == null)\n                        return false;\n                    if (exe instanceof AbstractBuild) {\n                        AbstractBuild b = (AbstractBuild) exe;\n                        String running = b.getProject().getName();\n                        String toRun = p.task.getName();\n                        if (toRun.equals(running))\n                            return false;\n                    }\n                }\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return true;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n        return true;\n    }\n","date":"2011-02-15 08:02:33","endLine":965,"groupId":"5575","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/ca/b37a93aaa20e2782ace437cd89794e5e0b5fec.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":919,"status":"M"}],"commitId":"65689f17e873747b849f7811f3599f4c237faf9d","commitMessage":"@@@[FIXED JENKINS-8790] Build Queue Fails for Parameterized Matrix Projects.\n","date":"2011-02-15 08:02:33","modifiedFileCount":"1","status":"M","submitter":"Ken Bertelson"},{"authorTime":"2011-03-15 12:28:59","codes":[{"authorDate":"2011-03-15 12:28:59","commitOrder":23,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-03-15 13:19:19","endLine":942,"groupId":"5574","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/b0206a4fd0bf6bc5046f0da585f9510a3fb098.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                if (makeBuildable(new BuildableItem(p))) {\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                }\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            boolean isReady = false;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                isReady = makeBuildable(new BuildableItem(top));\n            }\n            if (isReady) {\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"M"},{"authorDate":"2011-03-15 12:28:59","commitOrder":23,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-03-15 13:19:19","endLine":969,"groupId":"5575","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/b0206a4fd0bf6bc5046f0da585f9510a3fb098.src","preCode":"    private boolean makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                List<OneOffExecutor> oneOffExecutors = c.getOneOffExecutors();\n                for (OneOffExecutor ooe : oneOffExecutors) {\n                    Queue.Executable exe = ooe.getCurrentExecutable();\n                    if (exe == null)\n                        return false;\n                    if (exe instanceof AbstractBuild) {\n                        AbstractBuild b = (AbstractBuild) exe;\n                        String running = b.getProject().getName();\n                        String toRun = p.task.getName();\n                        if (toRun.equals(running))\n                            return false;\n                    }\n                }\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return true;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n        return true;\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":944,"status":"M"}],"commitId":"bff971eaf9da42a6c842ca466361e6e11b0b0cfe","commitMessage":"@@@Revert \"[FIXED JENKINS-8790] Build Queue Fails for Parameterized Matrix Projects.\"\n\nThis reverts commit 65689f17e873747b849f7811f3599f4c237faf9d.\n","date":"2011-03-15 13:19:19","modifiedFileCount":"1","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-03-15 13:06:00","codes":[{"authorDate":"2011-03-15 12:28:59","commitOrder":24,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-03-15 13:19:19","endLine":942,"groupId":"5574","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/b0206a4fd0bf6bc5046f0da585f9510a3fb098.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"N"},{"authorDate":"2011-03-15 13:06:00","commitOrder":24,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-03-15 13:19:19","endLine":977,"groupId":"5575","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/0f/ecc906a4ac88459ceac5490112d570c5a66779.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":951,"status":"M"}],"commitId":"b497728418c48ed550fe7de76ae9ab6060f986d5","commitMessage":"@@@[JENKINS-8790] revisited the fix to take advantage of the atomicity between Queue.pop() and executor state change\n","date":"2011-03-15 13:19:19","modifiedFileCount":"3","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-06-08 01:44:49","codes":[{"authorDate":"2011-03-15 12:28:59","commitOrder":25,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-03-15 13:19:19","endLine":942,"groupId":"5574","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/b0206a4fd0bf6bc5046f0da585f9510a3fb098.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"N"},{"authorDate":"2011-06-08 01:44:49","commitOrder":25,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-08 01:44:49","endLine":977,"groupId":"5575","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/57/562717a60028d55dd9b576273438071c686d91.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Hudson.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Hudson h = Hudson.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":951,"status":"M"}],"commitId":"d5c24703706b5afc6f62664251d1bfb1b0e0668f","commitMessage":"@@@Merge branch 'pull-152'\n\nConflicts:\n\tcore/src/main/java/hudson/model/DependencyGraph.java\n","date":"2011-06-08 01:44:49","modifiedFileCount":"310","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-06-08 06:02:02","codes":[{"authorDate":"2011-03-15 12:28:59","commitOrder":26,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-03-15 13:19:19","endLine":942,"groupId":"5574","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/b0206a4fd0bf6bc5046f0da585f9510a3fb098.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"N"},{"authorDate":"2011-06-08 06:02:02","commitOrder":26,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-08 06:02:02","endLine":978,"groupId":"5575","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/47/149e1f6a6c6b0ca424ccd49924749e733fcdfe.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.task.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":952,"status":"M"}],"commitId":"b668a23c9d93907c21c55b7c2a16d80443b313f7","commitMessage":"@@@Merge branch 'label-parameterization'\n","date":"2011-06-08 06:02:02","modifiedFileCount":"5","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-06-15 16:40:29","codes":[{"authorDate":"2011-03-15 12:28:59","commitOrder":27,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-03-15 13:19:19","endLine":942,"groupId":"5574","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/b0206a4fd0bf6bc5046f0da585f9510a3fb098.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":903,"status":"N"},{"authorDate":"2011-06-15 16:40:29","commitOrder":27,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-15 16:40:29","endLine":979,"groupId":"5575","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/40/c837a3295ae36d436ab0760846c32e22bab710.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":952,"status":"M"}],"commitId":"20c43e51eb01dff7f48faf1c23ab34b9ba124965","commitMessage":"@@@Merge pull request #158 from vjuranek/flyweight_check\n\nJenkins should check also node properties before assigning a flyweight task","date":"2011-06-15 16:40:29","modifiedFileCount":"1","status":"M","submitter":"vjuranek"},{"authorTime":"2011-06-15 16:40:29","codes":[{"authorDate":"2011-08-12 13:41:31","commitOrder":28,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-08-12 13:45:09","endLine":969,"groupId":"0","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/dc/af248c707fd0e9815c889b1a7c67c21cbbb893.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p.task) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":930,"status":"M"},{"authorDate":"2011-06-15 16:40:29","commitOrder":28,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-15 16:40:29","endLine":979,"groupId":"5575","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/40/c837a3295ae36d436ab0760846c32e22bab710.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":952,"status":"N"}],"commitId":"eafdaa44a00d838711eb7a4cae324698342efb4c","commitMessage":"@@@QueueTaskDispatcher should participate in classifying Queue#blockedProjects and Queue#buildables.\n\nThis helps Cloud and NodeProvisioner do its work correctly.  and for many implementations this is more efficient.\n","date":"2011-08-12 13:45:09","modifiedFileCount":"2","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-06-15 16:40:29","codes":[{"authorDate":"2011-08-13 05:21:48","commitOrder":29,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","date":"2011-08-13 05:21:48","endLine":969,"groupId":"8694","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/5f/99cdaf8dd729b7cb3898981ca139f39eabf9a5.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":930,"status":"M"},{"authorDate":"2011-06-15 16:40:29","commitOrder":29,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-15 16:40:29","endLine":979,"groupId":"5575","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/40/c837a3295ae36d436ab0760846c32e22bab710.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":952,"status":"N"}],"commitId":"03f581372cedb020eb1cd04c68e50e006c29da7f","commitMessage":"@@@regression in eafdaa44a00d838711eb7a4cae324698342efb4c\n","date":"2011-08-13 05:21:48","modifiedFileCount":"1","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-06-15 16:40:29","codes":[{"authorDate":"2012-02-14 02:30:30","commitOrder":30,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null)\n                \r\n                \r\n                \r\n                continue;\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                pendings.add(p);\n        }\n    }\n","date":"2012-02-14 02:35:22","endLine":971,"groupId":"8694","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/e4/dc8f00cfab7ac4721ac18ba8d98cf7a6c013a4.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        \r\n        Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n        while (itr.hasNext()) {\n            BlockedItem p = itr.next();\n            if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                \r\n                LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                itr.remove();\n                makeBuildable(new BuildableItem(p));\n            }\n        }\n\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":896,"status":"M"},{"authorDate":"2011-06-15 16:40:29","commitOrder":30,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-15 16:40:29","endLine":979,"groupId":"5575","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/40/c837a3295ae36d436ab0760846c32e22bab710.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":952,"status":"N"}],"commitId":"1ac4872ecdc500c63c0dbfce5e4beb5ce78369e5","commitMessage":"@@@maintain() should assign buildable stuff to executors.\n\nThis came out of the conversation with Nicolas.\n\nWhen QueueTaskDispatcher vetos the assignment.  a buildable item might\nstay buildable and unexecuted. Ane he found that it doesn't get retried. \ndespite the MaintainTask class that attempts to do so.\n\nThe issue is that the maintain() method actually doesn't try to assign\nbuildable tasks to executors. That happens inside the pop() method.\nI think this goes against the original design of the maintain() method. \nwhich is a giant synchronized block that moves all the relevant actors\nfrom one state to another.\n\nSo I'm moving this code into the maintain method. In this way. \nMaintainTask will automatically reattempt to assign buildable items\nto executors.  and scheduleMaintenance() and maintain() will really\ndo the same thing.  and it solves the original problem.\n","date":"2012-02-14 02:35:22","modifiedFileCount":"1","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2011-06-15 16:40:29","codes":[{"authorDate":"2012-04-07 00:00:22","commitOrder":31,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null)\n                \r\n                \r\n                \r\n                continue;\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                pendings.add(p);\n        }\n    }\n","date":"2012-04-07 00:00:22","endLine":971,"groupId":"6995","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/7c/2d0dbc7130c815fcca014a680c580055167b0f.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                return; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null)\n                \r\n                \r\n                \r\n                continue;\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                pendings.add(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":896,"status":"M"},{"authorDate":"2011-06-15 16:40:29","commitOrder":31,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2011-06-15 16:40:29","endLine":979,"groupId":"5575","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/40/c837a3295ae36d436ab0760846c32e22bab710.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":952,"status":"N"}],"commitId":"2afdf3db7d4ed4e3839edae3f2704221087446c9","commitMessage":"@@@Merge branch 'master' of github.com:jenkinsci/jenkins\n","date":"2012-04-07 00:00:22","modifiedFileCount":"40","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2013-03-20 06:57:01","codes":[{"authorDate":"2012-04-07 00:00:22","commitOrder":32,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null)\n                \r\n                \r\n                \r\n                continue;\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                pendings.add(p);\n        }\n    }\n","date":"2012-04-07 00:00:22","endLine":971,"groupId":"6995","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/7c/2d0dbc7130c815fcca014a680c580055167b0f.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null)\n                \r\n                \r\n                \r\n                continue;\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                pendings.add(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":896,"status":"N"},{"authorDate":"2013-03-20 06:57:01","commitOrder":32,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2013-03-26 02:22:20","endLine":1081,"groupId":"2294","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/70/de750a7bef573346defffd8c1903e6bec7768c.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            hash.add(h, h.getNumExecutors()*100);\n            for (Node n : h.getNodes())\n                hash.add(n,n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1053,"status":"M"}],"commitId":"a114c693bc61c564232e78c9fffb5de1ef946ea8","commitMessage":"@@@[FIXED JENKINS-7291] Permit flyweight tasks to run on master even when it has zero configured executors.\n\nAlways adding Computer for master as a fallback\n\nThe original proposed fix for JENKINS-7291 creates a Computer object\ntransitively. This seems unwise as it violates the design of Computer\nas stated in the javadoc.  and for example we can end up creating two\nComputers for the master.\n\nI think a better fix is to create a Computer for the master all the\ntime.  even if there's no executors configured. The discrimination in\nQueue.makeBuildable would ensure that such phantom Computer is only used\nas a last resort (statistically speaking).\n\nI've also tweaked executors.jelly a bit. I simplified it somewhat\nbased on the idea that \"if there's only one computer to show.  the\ncontext is likely making it obvious\".\n\n(I must be missing the intricacy in the current code.)\n\nOriginally developed in a branch at\n2c5b57fcc1f39ed39057254e802f4183db5aa0dc then squashed for clarity.\n","date":"2013-03-26 02:22:20","modifiedFileCount":"6","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2013-04-19 06:36:02","codes":[{"authorDate":"2013-04-19 06:36:02","commitOrder":33,"curCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                LOGGER.fine(String.format(\"Catching that %s is blocked in the last minute\", p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                if (LOGGER.isLoggable(Level.FINER)) {\n                    LOGGER.finer(String.format(\"Failed to map %s to executors. candidates=%s parked=%s\",\n                            p, candidates, parked.values()));\n                }\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.fine(String.format(\"BuildableItem %s with empty work units!?\",p));\n        }\n    }\n","date":"2013-04-19 06:36:02","endLine":1064,"groupId":"6995","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8d/e7adb96072a9231ae2f5227342e3e04969ea21.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null)\n                \r\n                \r\n                \r\n                continue;\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                pendings.add(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":981,"status":"M"},{"authorDate":"2013-04-19 06:36:02","commitOrder":33,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2013-04-19 06:36:02","endLine":1094,"groupId":"2294","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8d/e7adb96072a9231ae2f5227342e3e04969ea21.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                pendings.add(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1066,"status":"M"}],"commitId":"b1f0a7be759695095ae0194d9e65b603be776e38","commitMessage":"@@@Adding more diagnostics logging\n","date":"2013-04-19 06:36:02","modifiedFileCount":"1","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2013-04-19 06:36:02","codes":[{"authorDate":"2013-05-01 04:53:27","commitOrder":34,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.log(Level.FINE, \"{0} no longer blocked\", p.task);\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.log(Level.FINE, \"{0} ready to build\", p);\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.log(Level.FINE, \"{0} is blocked\", p);\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[] {p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-05-01 04:53:27","endLine":1060,"groupId":"479","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/ab/2bbc7c17a46405b05fb27677efc41b612c03aa.src","preCode":"    public synchronized void maintain() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.fine(\"Queue maintenance started \" + this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.fine(p.task.getFullDisplayName() + \" no longer blocked\");\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" ready to build\");\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.fine(p.getFullDisplayName() + \" is blocked\");\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                LOGGER.fine(String.format(\"Catching that %s is blocked in the last minute\", p));\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                if (LOGGER.isLoggable(Level.FINER)) {\n                    LOGGER.finer(String.format(\"Failed to map %s to executors. candidates=%s parked=%s\",\n                            p, candidates, parked.values()));\n                }\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.fine(String.format(\"BuildableItem %s with empty work units!?\",p));\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":981,"status":"M"},{"authorDate":"2013-04-19 06:36:02","commitOrder":34,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","date":"2013-04-19 06:36:02","endLine":1094,"groupId":"2294","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/8d/e7adb96072a9231ae2f5227342e3e04969ea21.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1066,"status":"N"}],"commitId":"7f3096c558046edea7bcfefa480193ede429af85","commitMessage":"@@@Deferring formatting Logger messages unless and until the log formatter is run.\nNo need to call isLoggable if you are only calling simply getters and relying on toString later.","date":"2013-05-01 04:53:27","modifiedFileCount":"1","status":"M","submitter":"Jesse Glick"},{"authorTime":"2013-06-13 16:23:53","codes":[{"authorDate":"2013-06-13 16:23:53","commitOrder":35,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-06-13 20:42:00","endLine":1096,"groupId":"3825","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/52/4b670634b91b11bbfc6833afffdd331e0de948.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        {\r\n            Iterator<BlockedItem> itr = blockedProjects.values().iterator();\n            while (itr.hasNext()) {\n                BlockedItem p = itr.next();\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    LOGGER.log(Level.FINE, \"{0} no longer blocked\", p.task);\n                    itr.remove();\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            waitingList.remove(top);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                LOGGER.log(Level.FINE, \"{0} ready to build\", p);\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                LOGGER.log(Level.FINE, \"{0} is blocked\", p);\n                blockedProjects.put(p,new BlockedItem(top));\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        Iterator<BuildableItem> itr = buildables.iterator();\n        while (itr.hasNext()) {\n            BuildableItem p = itr.next();\n\n            \r\n            if (isBuildBlocked(p)) {\n                itr.remove();\n                blockedProjects.put(p.task,new BlockedItem(p));\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if(j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[] {p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            itr.remove();\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1025,"status":"M"},{"authorDate":"2013-06-13 16:23:53","commitOrder":35,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","date":"2013-06-13 20:42:00","endLine":1126,"groupId":"2294","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/52/4b670634b91b11bbfc6833afffdd331e0de948.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n        \n        buildables.put(p.task,p);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1098,"status":"M"}],"commitId":"513a45b3091b88d1ad9020099bbd1aec04a8c686","commitMessage":"@@@Added QueueListener extension point\n\nThis can track items as they go through the queue.\n","date":"2013-06-13 20:42:00","modifiedFileCount":"1","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2013-06-13 16:23:53","codes":[{"authorDate":"2013-09-05 14:11:24","commitOrder":36,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        if (!parked.containsKey(e)) {\n                            parked.put(e,new JobOffer(e));\n                        }\n                    } else {\n                        parked.remove(e);\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-09-05 14:11:24","endLine":1052,"groupId":"3825","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/84/69c4ed598cb64034a4e4e93f3dbadbd5611258.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":966,"status":"M"},{"authorDate":"2013-06-13 16:23:53","commitOrder":36,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","date":"2013-06-13 20:42:00","endLine":1126,"groupId":"2294","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/52/4b670634b91b11bbfc6833afffdd331e0de948.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1098,"status":"N"}],"commitId":"73073387c85d90bb5543a856af24bfcb5590352a","commitMessage":"@@@Still a work in progress\n","date":"2013-09-05 14:11:24","modifiedFileCount":"5","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2013-06-13 16:23:53","codes":[{"authorDate":"2013-09-15 07:04:29","commitOrder":37,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-09-15 07:04:29","endLine":1043,"groupId":"3825","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/da/7cdfb96d3f3eca3c3d6f7c0cc217ae0fc01703.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        if (!parked.containsKey(e)) {\n                            parked.put(e,new JobOffer(e));\n                        }\n                    } else {\n                        parked.remove(e);\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":958,"status":"M"},{"authorDate":"2013-06-13 16:23:53","commitOrder":37,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","date":"2013-06-13 20:42:00","endLine":1126,"groupId":"2294","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/52/4b670634b91b11bbfc6833afffdd331e0de948.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1098,"status":"N"}],"commitId":"9264f6c76159a4fe4f264926b5bef4843d8e7586","commitMessage":"@@@parked can be a local variable now\n","date":"2013-09-15 07:04:29","modifiedFileCount":"1","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2013-06-13 16:23:53","codes":[{"authorDate":"2013-10-12 03:34:53","commitOrder":38,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-10-12 03:34:53","endLine":1056,"groupId":"3825","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/60/a85fac44397ee4278dc9587437b85cca23d769.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (!top.timestamp.before(new GregorianCalendar()))\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":971,"status":"M"},{"authorDate":"2013-06-13 16:23:53","commitOrder":38,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","date":"2013-06-13 20:42:00","endLine":1126,"groupId":"2294","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/52/4b670634b91b11bbfc6833afffdd331e0de948.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1098,"status":"N"}],"commitId":"957dbdf675cdf317a8f9b7c7ecbc1f5d2f4d6f7a","commitMessage":"@@@Fixed a test failure.\n\nTurns out in the new executor on-demand code.  queue maintenance happens so quickly that even when a job is submitted with delay 0. \nit can still fail the test if the check happens when \"new GregorianCalendar()\" returns the same value as \"top.timestamp\".\n\nI'm relaxing that check\n","date":"2013-10-12 03:34:53","modifiedFileCount":"2","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2014-09-05 19:54:49","codes":[{"authorDate":"2013-10-12 03:34:53","commitOrder":39,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-10-12 03:34:53","endLine":1056,"groupId":"3825","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/60/a85fac44397ee4278dc9587437b85cca23d769.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":971,"status":"N"},{"authorDate":"2014-09-05 19:54:49","commitOrder":39,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n\n            ConsistentHash.Builder<Node> builder = new ConsistentHash.Builder<Node>(NODE_HASH);\n\n            Jenkins h = Jenkins.getInstance();\n            \r\n            builder.add(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                builder.add(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = builder.build();\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","date":"2014-09-05 19:54:49","endLine":1104,"groupId":"0","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/db/6cf5f7e743ae9dcff82173aa205a2ab85a9d15.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(new Hash<Node>() {\n                public String hash(Node node) {\n                    return node.getNodeName();\n                }\n            });\n            Jenkins h = Jenkins.getInstance();\n            \r\n            hash.add(h, Math.max(h.getNumExecutors()*100, 1));\n            for (Node n : h.getNodes())\n                hash.add(n, n.getNumExecutors()*100);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1074,"status":"M"}],"commitId":"9b7b1364c0f33bb7485ace9b49a6d964e9e9faf9","commitMessage":"@@@use a Builder to create ConsistentHash<Node> \ninvoking add(Node.  replica) for all nodes rebuild the internal Table many times. Using a builder.  Table is only created (and sorted) once\nalso avoid creating a fresh new Hash object (java 8 lambdas.  I miss you)","date":"2014-09-05 19:54:49","modifiedFileCount":"2","status":"M","submitter":"Nicolas De Loof"},{"authorTime":"2014-09-06 01:45:42","codes":[{"authorDate":"2013-10-12 03:34:53","commitOrder":40,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2013-10-12 03:34:53","endLine":1056,"groupId":"3825","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/60/a85fac44397ee4278dc9587437b85cca23d769.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":971,"status":"N"},{"authorDate":"2014-09-06 01:45:42","commitOrder":40,"curCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n\n\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","date":"2014-09-06 01:45:42","endLine":1106,"groupId":"5321","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(BuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/83/0eb851f66eb14fc79d503ea4dae4e4bbd45649.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n\n            ConsistentHash.Builder<Node> builder = new ConsistentHash.Builder<Node>(NODE_HASH);\n\n            Jenkins h = Jenkins.getInstance();\n            \r\n            builder.add(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                builder.add(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = builder.build();\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1074,"status":"M"}],"commitId":"6a2b879262436966f9348ddd6449322dc6243501","commitMessage":"@@@Revisiting 9b7b1364c0f33bb7485ace9b49a6d964e9e9faf9 a bit.\n\nSince ConsistentHash is written as a mutable class.  I think a better way to fit the existing design is to provide a bulk add operation.\nIt already has several methods to that end.  so I just added one more that's needed for our purpose.\n","date":"2014-09-06 01:45:42","modifiedFileCount":"3","status":"M","submitter":"Kohsuke Kawaguchi"},{"authorTime":"2015-01-09 20:55:26","codes":[{"authorDate":"2015-01-09 20:55:26","commitOrder":41,"curCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        r.run();\n                    }\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                Runnable r = makeBuildable(new BuildableItem(top));\n                if (r != null) {\n                    r.run();\n                } else {\n                    new BlockedItem(top).enter(this);\n                }\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1172,"groupId":"1198","id":57,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    p.leave(this);\n                    makeBuildable(new BuildableItem(p));\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                makeBuildable(new BuildableItem(top));\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1079,"status":"M"},{"authorDate":"2015-01-09 20:55:26","commitOrder":41,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1218,"groupId":"5321","id":58,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    private void makeBuildable(BuildableItem p) {\n        if(Jenkins.FLYWEIGHT_SUPPORT && p.task instanceof FlyweightTask && !ifBlockedByHudsonShutdown(p.task)) {\n\n\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                makePending(p);\n                return;\n            }\n            \r\n            \r\n        }\n\n        p.enter(this);\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1179,"status":"M"}],"commitId":"9e333bc1e60dd82b9983135276f9379d3eb4d392","commitMessage":"@@@[JENKINS-10944] [JENKINS-24519] Noting merge of #1513.\n","date":"2015-01-09 20:57:57","modifiedFileCount":"4","status":"M","submitter":"Jesse Glick"},{"authorTime":"2015-01-09 20:55:26","codes":[{"authorDate":"2015-03-26 23:13:51","commitOrder":42,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n\n            {\r\n                for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            final QueueSorter s = sorter;\n            if (s != null)\n                s.sortBuildableItems(buildables);\n\n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-03-26 23:13:51","endLine":1379,"groupId":"1198","id":59,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/41/79abb22929ebf405cb16e31caf333d4bf90319.src","preCode":"    public synchronized void maintain() {\n        LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n        \r\n        Map<Executor,JobOffer> parked = new HashMap<Executor,JobOffer>();\n\n        {\r\n            for (Computer c : Jenkins.getInstance().getComputers()) {\n                for (Executor e : c.getExecutors()) {\n                    if (e.isParking()) {\n                        parked.put(e,new JobOffer(e));\n                    }\n                }\n            }\n        }\n\n\n        {\r\n            for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        r.run();\n                    }\n                }\n            }\n        }\n\n        \r\n        while (!waitingList.isEmpty()) {\n            WaitingItem top = peek();\n\n            if (top.timestamp.compareTo(new GregorianCalendar())>0)\n                break; \r\n\n            top.leave(this);\n            Task p = top.task;\n            if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                \r\n                Runnable r = makeBuildable(new BuildableItem(top));\n                if (r != null) {\n                    r.run();\n                } else {\n                    new BlockedItem(top).enter(this);\n                }\n            } else {\n                \r\n                \r\n                new BlockedItem(top).enter(this);\n            }\n        }\n\n        final QueueSorter s = sorter;\n        if (s != null)\n        \ts.sortBuildableItems(buildables);\n\n        \r\n        for (BuildableItem p : new ArrayList<BuildableItem>(buildables)) {\r\n            \r\n            if (isBuildBlocked(p)) {\n                p.leave(this);\n                new BlockedItem(p).enter(this);\n                LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                continue;\n            }\n\n            List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n            for (JobOffer j : parked.values())\n                if (j.canTake(p))\n                    candidates.add(j);\n\n            MappingWorksheet ws = new MappingWorksheet(p, candidates);\n            Mapping m = loadBalancer.map(p.task, ws);\n            if (m == null) {\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\", new Object[]{p, candidates, parked.values()});\n                continue;\n            }\n\n            \r\n            WorkUnitContext wuc = new WorkUnitContext(p);\n            m.execute(wuc);\n\n            p.leave(this);\n            if (!wuc.getWorkUnits().isEmpty())\n                makePending(p);\n            else\n                LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1264,"status":"M"},{"authorDate":"2015-01-09 20:55:26","commitOrder":42,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1218,"groupId":"5321","id":60,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1179,"status":"N"}],"commitId":"ecac963eaff0608accf950d90d75cff8b66bdc4c","commitMessage":"@@@Merge pull request #1596 from stephenc/threadsafe-node-queue\n\n[JENKINS-27565] Fix threading issues with Nodes and Queue","date":"2015-03-26 23:13:51","modifiedFileCount":"22","status":"M","submitter":"Stephen Connolly"},{"authorTime":"2015-01-09 20:55:26","codes":[{"authorDate":"2015-04-15 23:27:47","commitOrder":43,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n\n            {\r\n                for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            final QueueSorter s = sorter;\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-04-15 23:27:47","endLine":1394,"groupId":"1198","id":61,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/92/84e95ece1dcedf9260114f8e6dce9c19133cc2.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n\n            {\r\n                for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            final QueueSorter s = sorter;\n            if (s != null)\n                s.sortBuildableItems(buildables);\n\n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1264,"status":"M"},{"authorDate":"2015-01-09 20:55:26","commitOrder":43,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1218,"groupId":"5321","id":62,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1179,"status":"N"}],"commitId":"152d00ad09931c10f02fab4ac8a42e574d622bd3","commitMessage":"@@@Merge pull request #1645 from stephenc/jenkins-27708\n\nJENKINS-27708.  JENKINS-27871  Ensure that identification of blocked tasks is using the live state.","date":"2015-04-15 23:27:47","modifiedFileCount":"2","status":"M","submitter":"Stephen Connolly"},{"authorTime":"2015-01-09 20:55:26","codes":[{"authorDate":"2015-06-16 07:02:16","commitOrder":44,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n\n            {\r\n                for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            final QueueSorter s = sorter;\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-06-16 07:02:16","endLine":1508,"groupId":"1198","id":63,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/d3/3b985fb7f997d51f72eeb696695934b4165f86.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n\n            {\r\n                for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            final QueueSorter s = sorter;\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1371,"status":"M"},{"authorDate":"2015-01-09 20:55:26","commitOrder":44,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1218,"groupId":"5321","id":64,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1179,"status":"N"}],"commitId":"71e684ad900363c48d845f73c1993f90de4417ad","commitMessage":"@@@Merge pull request #1738 from stephenc/jenkins-28840\n\n[FIXED JENKINS-28840] Deadlock between Queue.maintain and Executor.interrupt","date":"2015-06-16 07:02:16","modifiedFileCount":"4","status":"M","submitter":"Stephen Connolly"},{"authorTime":"2015-01-09 20:55:26","codes":[{"authorDate":"2015-06-17 20:51:33","commitOrder":45,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<BlockedItem>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-06-17 20:51:33","endLine":1524,"groupId":"0","id":65,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/95/1b8722a353c5151b02953bb69a1ef52892e588.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n\n            {\r\n                for (BlockedItem p : new ArrayList<BlockedItem>(blockedProjects.values())) {\r\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            final QueueSorter s = sorter;\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1371,"status":"M"},{"authorDate":"2015-01-09 20:55:26","commitOrder":45,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1218,"groupId":"5321","id":66,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1179,"status":"N"}],"commitId":"7929412037ff75f60791cfb23631521f8726c23d","commitMessage":"@@@Merge pull request #1743 from stephenc/jenkins-28926\n\n[FIXED JENKINS-28926] Block while upstream/downstream building cycles never complete","date":"2015-06-17 20:51:33","modifiedFileCount":"3","status":"M","submitter":"Stephen Connolly"},{"authorTime":"2015-01-09 20:55:26","codes":[{"authorDate":"2015-06-17 20:55:35","commitOrder":46,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-06-17 20:55:35","endLine":1523,"groupId":"4270","id":67,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/c8/603785b3a05802cfafd3818254b9ca5ababdce.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<BlockedItem>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1371,"status":"M"},{"authorDate":"2015-01-09 20:55:26","commitOrder":46,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","date":"2015-01-09 20:57:57","endLine":1218,"groupId":"5321","id":68,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/7e3fb0705dfc54591efdebab61c449dc08c30a.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1179,"status":"N"}],"commitId":"8c5b9cd008a4d0fb30dc39d9ee1bd72b95b199f2","commitMessage":"@@@[JENKINS-28926] Tidy-up TODO for the Java 7+ Jenkins versions\n","date":"2015-06-17 20:55:35","modifiedFileCount":"1","status":"M","submitter":"Stephen Connolly"},{"authorTime":"2015-10-13 04:22:10","codes":[{"authorDate":"2015-10-13 04:22:10","commitOrder":47,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values())\n                        if (j.canTake(p))\n                            candidates.add(j);\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-10-13 04:22:10","endLine":1533,"groupId":"4270","id":69,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/c2/65e477df46da5efb794f1ce4897734cfa5b7d5.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                for (JobOffer j : parked.values())\n                    if (j.canTake(p))\n                        candidates.add(j);\n\n                MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                Mapping m = loadBalancer.map(p.task, ws);\n                if (m == null) {\n                    \r\n                    \r\n                    \r\n                    LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                            new Object[]{p, candidates, parked.values()});\n                    continue;\n                }\n\n                \r\n                WorkUnitContext wuc = new WorkUnitContext(p);\n                m.execute(wuc);\n\n                p.leave(this);\n                if (!wuc.getWorkUnits().isEmpty())\n                    makePending(p);\n                else\n                    LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n                                \n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                updateSnapshot();\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1370,"status":"M"},{"authorDate":"2015-10-13 04:22:10","commitOrder":47,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                return new BuildableRunnable(p);\n            }\n            \r\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2015-10-13 04:22:10","endLine":1562,"groupId":"4727","id":70,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/c2/65e477df46da5efb794f1ce4897734cfa5b7d5.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n            Jenkins h = Jenkins.getInstance();\n            Map<Node,Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\n\n            \r\n            hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\n\n            for (Node n : h.getNodes()) {\n                hashSource.put(n, n.getNumExecutors() * 100);\n            }\n\n            ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\n            hash.addAll(hashSource);\n\n            Label lbl = p.getAssignedLabel();\n            for (Node n : hash.list(p.task.getFullDisplayName())) {\n                final Computer c = n.toComputer();\n                if (c==null || c.isOffline())    continue;\n                if (lbl!=null && !lbl.contains(n))  continue;\n                if (n.canTake(p) != null) continue;\n                return new Runnable() {\n                    @Override public void run() {\n                        c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));\n                        makePending(p);\n                    }\n                };\n            }\n            }\n            \r\n            return null;\n        } else { \r\n            return new Runnable() {\n                @Override public void run() {\n                    p.enter(Queue.this);\n                }\n            };\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1540,"status":"M"}],"commitId":"1b0ba9e1d034fe809d58f14f835f8e5347cc3bc5","commitMessage":"@@@Merge branch 'master' into security-master\n","date":"2015-10-13 04:22:10","modifiedFileCount":"32","status":"M","submitter":"Jesse Glick"},{"authorTime":"2015-12-05 06:12:26","codes":[{"authorDate":"2015-12-05 06:12:26","commitOrder":48,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        if (j.canTake(p)) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j.executor.getDisplayName(), taskDisplayName});\n                            candidates.add(j);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2015-12-05 06:12:26","endLine":1611,"groupId":"6786","id":71,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/39/76b8c69a7dd319e6c7d4d9b0bb0b5cdf7cdc95.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0)\n                    break; \r\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    if (r != null) {\n                        r.run();\n                    } else {\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values())\n                        if (j.canTake(p))\n                            candidates.add(j);\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINE, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1423,"status":"M"},{"authorDate":"2015-12-05 06:12:26","commitOrder":48,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2015-12-05 06:12:26","endLine":1643,"groupId":"6531","id":72,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/39/76b8c69a7dd319e6c7d4d9b0bb0b5cdf7cdc95.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                return new BuildableRunnable(p);\n            }\n            \r\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"M"}],"commitId":"7c9ba7011cb905adc6d39321dc68b3a202daa3de","commitMessage":"@@@Merge pull request #1863 from christ66/maintainlogs\n\n[JENKINS-30914] Add extra logging to the queue","date":"2015-12-05 06:12:26","modifiedFileCount":"1","status":"M","submitter":"Andrew Bayer"},{"authorTime":"2015-12-05 06:12:26","codes":[{"authorDate":"2016-07-09 06:51:22","commitOrder":49,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        if (j.canTake(p)) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j.executor.getDisplayName(), taskDisplayName});\n                            candidates.add(j);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2016-07-09 06:51:22","endLine":1567,"groupId":"6786","id":73,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/28/bf6e1af59d809481d6dc050ff8dc0679640772.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started {0}\", this);\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        if (j.canTake(p)) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j.executor.getDisplayName(), taskDisplayName});\n                            candidates.add(j);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1379,"status":"M"},{"authorDate":"2015-12-05 06:12:26","commitOrder":49,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2015-12-05 06:12:26","endLine":1643,"groupId":"6531","id":74,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/39/76b8c69a7dd319e6c7d4d9b0bb0b5cdf7cdc95.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"3ef1db59ea8fa617d18dc951b6de5b7d93a2c855","commitMessage":"@@@Merge pull request #2439 from jglick/nextBuildNumber-JENKINS-27530\n\n[JENKINS-27530] nextBuildNumber snafu after reload","date":"2016-07-09 06:51:22","modifiedFileCount":"9","status":"M","submitter":"Jesse Glick"},{"authorTime":"2015-12-05 06:12:26","codes":[{"authorDate":"2016-08-21 02:05:03","commitOrder":50,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        if (j.canTake(p)) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j.executor.getDisplayName(), taskDisplayName});\n                            candidates.add(j);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2016-08-21 02:05:03","endLine":1568,"groupId":"6786","id":75,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/28/2beb86211faeedc592f196581c91be474f0107.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.INFO,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p);\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        if (j.canTake(p)) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j.executor.getDisplayName(), taskDisplayName});\n                            candidates.add(j);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1380,"status":"M"},{"authorDate":"2015-12-05 06:12:26","commitOrder":50,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2015-12-05 06:12:26","endLine":1643,"groupId":"6531","id":76,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/39/76b8c69a7dd319e6c7d4d9b0bb0b5cdf7cdc95.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"30ede81c1326a750c8e258c46f57d90fc7eca45c","commitMessage":"@@@Downgrade Queue#maintain() message for dead executor from INFO to FINE. (#2510)\n\n","date":"2016-08-21 02:05:03","modifiedFileCount":"1","status":"M","submitter":"Jesse Glick"},{"authorTime":"2015-12-05 06:12:26","codes":[{"authorDate":"2016-12-09 18:04:22","commitOrder":51,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2016-12-09 18:04:22","endLine":1605,"groupId":"6786","id":77,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/66/fc9f3f9382249f0eb36537c7e397872ff0858c.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<JobOffer>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        if (j.canTake(p)) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j.executor.getDisplayName(), taskDisplayName});\n                            candidates.add(j);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1411,"status":"M"},{"authorDate":"2015-12-05 06:12:26","commitOrder":51,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2015-12-05 06:12:26","endLine":1643,"groupId":"6531","id":78,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/39/76b8c69a7dd319e6c7d4d9b0bb0b5cdf7cdc95.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"8d23041d4b785947dee1bc02f54a41d86b59bdda","commitMessage":"@@@[JENKINS-38514] Retain CauseOfBlockage from JobOffer (#2651)\n\n* Converted to JenkinsRule.\n\n* Improved messages from Node.canTake.\n\n* [FIXED JENKINS-38514] BuildableItem needs to retain information from JobOffer about why it is neither blocked nor building.\n\n* Converted to JenkinsRule.\n\n* Found an existing usage of BecauseNodeIsNotAcceptingTasks.\n\n* Original JENKINS-6598 test was checking behavior we want amended by JENKINS-38514.\n\n* Ensure that a BuildableItem which is simply waiting for a free executor reports that as its CauseOfBlockage.\n\n* Review comments from @oleg-nenashev.\n","date":"2016-12-09 18:04:22","modifiedFileCount":"5","status":"M","submitter":"Jesse Glick"},{"authorTime":"2015-12-05 06:12:26","codes":[{"authorDate":"2017-03-12 03:25:25","commitOrder":52,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2017-03-12 03:25:25","endLine":1611,"groupId":"3573","id":79,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/73/348264a45d9b27e3754ea7a80520b7b5d35fdf.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = p.task.getFullDisplayName();\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = top.task.getFullDisplayName();\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1415,"status":"M"},{"authorDate":"2015-12-05 06:12:26","commitOrder":52,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2015-12-05 06:12:26","endLine":1643,"groupId":"6531","id":80,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/39/76b8c69a7dd319e6c7d4d9b0bb0b5cdf7cdc95.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"13d85fb805161a94e45d4ac485fb3a84d2c72e1a","commitMessage":"@@@Merge pull request #2791 from jglick/Queue-logging-JENKINS-42556\n\n[JENKINS-42556] Improved logging for Queue","date":"2017-03-12 03:25:25","modifiedFileCount":"1","status":"M","submitter":"Daniel Beck"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2017-09-07 02:43:35","commitOrder":53,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1611,"groupId":"6530","id":81,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = p.task.getFullDisplayName();\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1415,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":53,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"6531","id":82,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = p.task.getFullDisplayName();\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"M"}],"commitId":"6211e8b6ec5478b9408f41a1efe53f9016378264","commitMessage":"@@@Merge branch 'master' of git://github.com/jenkinsci/jenkins\n","date":"2017-09-07 02:43:35","modifiedFileCount":"90","status":"M","submitter":"Jesse Glick"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2017-10-16 22:17:48","commitOrder":54,"curCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2017-10-16 22:17:48","endLine":1650,"groupId":"2383","id":83,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/3e/a6e8dacf09324210142ceca024079da1a1eb4a.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    if (!isBuildBlocked(p) && allowNewBuildableTask(p.task)) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                Task p = top.task;\n                if (!isBuildBlocked(top) && allowNewBuildableTask(p)) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                if (isBuildBlocked(p)) {\n                    p.leave(this);\n                    new BlockedItem(p).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1450,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":54,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"6531","id":84,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"343edd762b7df7142fe8ff6b7e0795c3f9519693","commitMessage":"@@@Merge commit '85d96df6138696ddec3f7c729f22c6d748a5df31' of git://github.com/jenkinsci/jenkins\n","date":"2017-10-16 22:17:48","modifiedFileCount":"11","status":"M","submitter":"Jesse Glick"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2018-04-10 00:31:19","commitOrder":55,"curCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2018-04-10 00:31:19","endLine":1659,"groupId":"2383","id":85,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/a7/b9dcc76243a44fac2f5ba244ffae21cf543666.src","preCode":"    public void maintain() {\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1455,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":55,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"6531","id":86,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"ed4fc8dd443186ffa1c442167256071332e1fb7b","commitMessage":"@@@Merge commit 'db48500fb8be4c4fd59c1ded088fe48025d4735d' into security-master\n","date":"2018-04-10 00:31:19","modifiedFileCount":"19","status":"M","submitter":"Daniel Beck"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2018-06-29 20:38:20","commitOrder":56,"curCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2018-06-29 20:38:20","endLine":1666,"groupId":"4501","id":87,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/7f/881e21bcf05da09f5b1a750526498cc7abed55.src","preCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null)\n                s.sortBuildableItems(buildables);\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1455,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":56,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"6531","id":88,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"0107b8fa41297ba8f1a6b88b569b23ae5152341f","commitMessage":"@@@Merge pull request #3522 from jsoref/JENKINS-52159\n\nJENKINS-52159: Queue.maintain - tolerate misbehaving sorter.sortBuild?","date":"2018-06-29 20:38:20","modifiedFileCount":"1","status":"M","submitter":"Daniel Beck"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2018-08-13 18:55:27","commitOrder":57,"curCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2018-08-13 18:55:27","endLine":1668,"groupId":"4501","id":89,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/12/1e3e6f304d7d355abce801d32845c4c81b3ac9.src","preCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1457,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":57,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"6531","id":90,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"0053851f6821d1f414d140acb87aae7600132427","commitMessage":"@@@Merge commit '817f1149781eeb3ceea7839ab3213d2d2fdc9b3d' into security-master\n","date":"2018-08-13 18:55:27","modifiedFileCount":"12","status":"M","submitter":"Daniel Beck"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2019-04-08 23:18:26","commitOrder":58,"curCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    blockedItems.sort(QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2019-04-08 23:18:26","endLine":1667,"groupId":"3100","id":91,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/a2/de43abfaf90ecfdaf327c761261ad358c38417.src","preCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<Executor, JobOffer>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<BuildableItem>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    Collections.sort(blockedItems, QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<BuildableItem>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1456,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":58,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"6531","id":92,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"6b4c6c955d10ade9b78ab02fd2733cc29e0b1ab3","commitMessage":"@@@Merge branch 'master' into security-master\n","date":"2019-04-08 23:18:26","modifiedFileCount":"242","status":"M","submitter":"Daniel Beck"},{"authorTime":"2017-09-07 02:43:35","codes":[{"authorDate":"2021-01-03 01:21:54","commitOrder":59,"curCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    blockedItems.sort(QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    Map<Node, CauseOfBlockage> reasonMap = new HashMap<>();\n                    for (JobOffer j : parked.values()) {\n                        Node offerNode = j.getNode();\n                        CauseOfBlockage reason;\n                        if (reasonMap.containsKey(offerNode)) {\n                            reason = reasonMap.get(offerNode);\n                        } else {\n                            reason = j.getCauseOfBlockage(p);\n                            reasonMap.put(offerNode, reason);\n                        }\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        List<CauseOfBlockage> reasons = reasonMap.values().stream().filter(Objects::nonNull).collect(Collectors.toList());\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","date":"2021-01-03 01:21:54","endLine":1679,"groupId":"101077","id":93,"instanceNumber":1,"isCurCommit":0,"methodName":"maintain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/ee/d63045bdce0eb26c00830c8e589cd86f8191f7.src","preCode":"    public void maintain() {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        if (jenkins == null) {\n            return;\n        }\n        lock.lock();\n        try { try {\n\n            LOGGER.log(Level.FINE, \"Queue maintenance started on {0} with {1}\", new Object[] {this, snapshot});\n\n            \r\n            Map<Executor, JobOffer> parked = new HashMap<>();\n\n            {\r\n                List<BuildableItem> lostPendings = new ArrayList<>(pendings);\n                for (Computer c : jenkins.getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        if (e.isInterrupted()) {\n                            \r\n                            \r\n                            \r\n                            lostPendings.clear(); \r\n                            LOGGER.log(Level.FINEST,\n                                    \"Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.\",\n                                    e.getDisplayName());\n                            continue;\n                        }\n                        if (e.isParking()) {\n                            LOGGER.log(Level.FINEST, \"{0} is parking and is waiting for a job to execute.\", e.getDisplayName());\n                            parked.put(e, new JobOffer(e));\n                        }\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        if (workUnit != null) {\n                            lostPendings.remove(workUnit.context.item);\n                        }\n                    }\n                }\n                \r\n                for (BuildableItem p: lostPendings) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.log(Level.FINE,\n                            \"BuildableItem {0}: pending -> buildable as the assigned executor disappeared\",\n                            p.task.getFullDisplayName());\n                    }\n                    p.isPending = false;\n                    pendings.remove(p);\n                    makeBuildable(p); \r\n                }\n            }\n\n            final QueueSorter s = sorter;\n\n            {\r\n                \r\n                List<BlockedItem> blockedItems = new ArrayList<>(blockedProjects.values());\n                \r\n                if (s != null) {\n                    s.sortBlockedItems(blockedItems);\n                } else {\n                    blockedItems.sort(QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);\n                }\n                for (BlockedItem p : blockedItems) {\n                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n                    LOGGER.log(Level.FINEST, \"Current blocked item: {0}\", taskDisplayName);\n                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                    if (causeOfBlockage == null) {\n                        LOGGER.log(Level.FINEST,\n                                \"BlockedItem {0}: blocked -> buildable as the build is not blocked and new tasks are allowed\",\n                                taskDisplayName);\n\n                        \r\n                        Runnable r = makeBuildable(new BuildableItem(p));\n                        if (r != null) {\n                            p.leave(this);\n                            r.run();\n                            \r\n                            \r\n                            \r\n                            updateSnapshot();\n                        }\n                    } else {\n                        p.setCauseOfBlockage(causeOfBlockage);\n                    }\n                }\n            }\n\n            \r\n            while (!waitingList.isEmpty()) {\n                WaitingItem top = peek();\n\n                if (top.timestamp.compareTo(new GregorianCalendar()) > 0) {\n                    LOGGER.log(Level.FINEST, \"Finished moving all ready items from queue.\");\n                    break; \r\n                }\n\n                top.leave(this);\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);\n                if (causeOfBlockage == null) {\n                    \r\n                    Runnable r = makeBuildable(new BuildableItem(top));\n                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;\n                    if (r != null) {\n                        LOGGER.log(Level.FINEST, \"Executing runnable {0}\", topTaskDisplayName);\n                        r.run();\n                    } else {\n                        LOGGER.log(Level.FINEST, \"Item {0} was unable to be made a buildable and is now a blocked item.\", topTaskDisplayName);\n                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);\n                    }\n                } else {\n                    \r\n                    \r\n                    new BlockedItem(top, causeOfBlockage).enter(this);\n                }\n            }\n\n            if (s != null) {\n                try {\n                    s.sortBuildableItems(buildables);\n                } catch (Throwable e) {\n                    \r\n                    \r\n                    LOGGER.log(Level.WARNING, \"s.sortBuildableItems() threw Throwable: {0}\", e);\n                }\n            }\n            \n            \r\n            updateSnapshot();\n            \n            \r\n            for (BuildableItem p : new ArrayList<>(\n                    buildables)) {\r\n                \r\n                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);\n                if (causeOfBlockage != null) {\n                    p.leave(this);\n                    new BlockedItem(p, causeOfBlockage).enter(this);\n                    LOGGER.log(Level.FINE, \"Catching that {0} is blocked in the last minute\", p);\n                    \r\n                    \r\n                    updateSnapshot();\n                    continue;\n                }\n\n                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n\n                if (p.task instanceof FlyweightTask) {\n                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));\n                    if (r != null) {\n                        p.leave(this);\n                        LOGGER.log(Level.FINEST, \"Executing flyweight task {0}\", taskDisplayName);\n                        r.run();\n                        updateSnapshot();\n                    }\n                } else {\n\n                    List<JobOffer> candidates = new ArrayList<>(parked.size());\n                    List<CauseOfBlockage> reasons = new ArrayList<>(parked.size());\n                    for (JobOffer j : parked.values()) {\n                        CauseOfBlockage reason = j.getCauseOfBlockage(p);\n                        if (reason == null) {\n                            LOGGER.log(Level.FINEST,\n                                    \"{0} is a potential candidate for task {1}\",\n                                    new Object[]{j, taskDisplayName});\n                            candidates.add(j);\n                        } else {\n                            LOGGER.log(Level.FINEST, \"{0} rejected {1}: {2}\", new Object[] {j, taskDisplayName, reason});\n                            reasons.add(reason);\n                        }\n                    }\n\n                    MappingWorksheet ws = new MappingWorksheet(p, candidates);\n                    Mapping m = loadBalancer.map(p.task, ws);\n                    if (m == null) {\n                        \r\n                        \r\n                        \r\n                        LOGGER.log(Level.FINER, \"Failed to map {0} to executors. candidates={1} parked={2}\",\n                                new Object[]{p, candidates, parked.values()});\n                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;\n                        continue;\n                    }\n\n                    \r\n                    WorkUnitContext wuc = new WorkUnitContext(p);\n                    LOGGER.log(Level.FINEST, \"Found a matching executor for {0}. Using it.\", taskDisplayName);\n                    m.execute(wuc);\n\n                    p.leave(this);\n                    if (!wuc.getWorkUnits().isEmpty()) {\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} marked as pending.\", taskDisplayName);\n                        makePending(p);\n                    }\n                    else\n                        LOGGER.log(Level.FINEST, \"BuildableItem {0} with empty work units!?\", p);\n\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    updateSnapshot();\n                }\n            }\n        } finally { updateSnapshot(); } } finally {\n            lock.unlock();\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1461,"status":"M"},{"authorDate":"2017-09-07 02:43:35","commitOrder":59,"curCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","date":"2017-09-07 02:43:35","endLine":1643,"groupId":"101077","id":94,"instanceNumber":2,"isCurCommit":0,"methodName":"makeBuildable","params":"(finalBuildableItemp)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/59/38360ed815e6277de270f2f430721688f55bff.src","preCode":"    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {\n        if (p.task instanceof FlyweightTask) {\n            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;\n            if (!isBlockedByShutdown(p.task)) {\n\n                Runnable runnable = makeFlyWeightTaskBuildable(p);\n                LOGGER.log(Level.FINEST, \"Converting flyweight task: {0} into a BuildableRunnable\", taskDisplayName);\n                if(runnable != null){\n                    return runnable;\n                }\n\n                \r\n                \r\n                \r\n                \r\n                LOGGER.log(Level.FINEST, \"Flyweight task {0} is entering as buildable to provision a node.\", taskDisplayName);\n                return new BuildableRunnable(p);\n            }\n            \r\n            LOGGER.log(Level.FINEST, \"Task {0} is blocked by shutdown.\", taskDisplayName);\n            return null;\n        } else {\n            \r\n            return new BuildableRunnable(p);\n        }\n    }\n","realPath":"core/src/main/java/hudson/model/Queue.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":1618,"status":"N"}],"commitId":"86f6bb31d959097113ad35c439fe2fa285d14ad3","commitMessage":"@@@Merge pull request #5082 from res0nance/JENKINS-58101\n\n[JENKINS-58101] Cache blockage reasons when considering parked executors","date":"2021-01-03 01:21:54","modifiedFileCount":"1","status":"M","submitter":"Oleg Nenashev"}]
