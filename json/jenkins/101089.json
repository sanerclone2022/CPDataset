[{"authorTime":"2017-04-15 21:22:31","codes":[{"authorDate":"2017-04-24 22:01:25","commitOrder":3,"curCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            if (item != null) {\n                                while (item != null) {\n                                    if (item == this) {\n                                        buildsInProgress.put(e, e.getCurrentExecutable());\n                                        e.interrupt(Result.ABORTED);\n                                        break;\n                                    }\n                                    if (item.getParent() instanceof Item) {\n                                        item = (Item) item.getParent();\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n    }\n","date":"2017-04-24 22:01:25","endLine":693,"groupId":"8395","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/dd/e9b636122ac3c9b8b1a7fda4186c77807b35f6.src","preCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            if (item != null) {\n                                while (item != null) {\n                                    if (item == this) {\n                                        buildsInProgress.put(e, e.getCurrentExecutable());\n                                        e.interrupt(Result.ABORTED);\n                                        break;\n                                    }\n                                    if (item.getParent() instanceof Item) {\n                                        item = (Item) item.getParent();\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n    }\n","realPath":"core/src/main/java/hudson/model/AbstractItem.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":590,"status":"MB"},{"authorDate":"2017-04-15 21:22:31","commitOrder":3,"curCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","date":"2017-04-15 21:22:31","endLine":77,"groupId":"9032","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"_contains","params":"(@NonnullItemitem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/32/d55c6023d94aaf1a69b5caebc1ab26dcf79493.src","preCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","realPath":"core/src/main/java/jenkins/model/queue/ItemDeletion.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"NB"}],"commitId":"01f8b82c04004705bd2726daba3335ca29bd45a3","commitMessage":"@@@Merge commit '4af8a599a011223a859f496276a61a28f90cf8be' into security-master\n","date":"2017-04-24 22:01:25","modifiedFileCount":"41","status":"M","submitter":"Jesse Glick"},{"authorTime":"2017-04-15 21:22:31","codes":[{"authorDate":"2019-07-03 02:02:48","commitOrder":4,"curCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.get().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            if (item != null) {\n                                while (item != null) {\n                                    if (item == this) {\n                                        buildsInProgress.put(e, e.getCurrentExecutable());\n                                        e.interrupt(Result.ABORTED);\n                                        break;\n                                    }\n                                    if (item.getParent() instanceof Item) {\n                                        item = (Item) item.getParent();\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.get().rebuildDependencyGraphAsync();\n    }\n","date":"2019-07-03 02:02:48","endLine":784,"groupId":"8395","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/4a/7524d1be3f80b445a91f84042636710481ed8d.src","preCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.getInstance().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            if (item != null) {\n                                while (item != null) {\n                                    if (item == this) {\n                                        buildsInProgress.put(e, e.getCurrentExecutable());\n                                        e.interrupt(Result.ABORTED);\n                                        break;\n                                    }\n                                    if (item.getParent() instanceof Item) {\n                                        item = (Item) item.getParent();\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.getInstance().rebuildDependencyGraphAsync();\n    }\n","realPath":"core/src/main/java/hudson/model/AbstractItem.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":681,"status":"M"},{"authorDate":"2017-04-15 21:22:31","commitOrder":4,"curCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","date":"2017-04-15 21:22:31","endLine":77,"groupId":"9032","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"_contains","params":"(@NonnullItemitem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/32/d55c6023d94aaf1a69b5caebc1ab26dcf79493.src","preCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","realPath":"core/src/main/java/jenkins/model/queue/ItemDeletion.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"N"}],"commitId":"494119294fa2f095b4a28db0dd32c0d2092d9fa1","commitMessage":"@@@Merge commit '4404c6e662befe16e8daa1ea7a412df73b370086' of github.com:jenkinsci/jenkins\n","date":"2019-07-03 02:02:48","modifiedFileCount":"292","status":"M","submitter":"Jeff Thompson"},{"authorTime":"2017-04-15 21:22:31","codes":[{"authorDate":"2020-01-20 21:55:10","commitOrder":5,"curCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.get().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            while (item != null) {\n                                if (item == this) {\n                                    buildsInProgress.put(e, e.getCurrentExecutable());\n                                    e.interrupt(Result.ABORTED);\n                                    break;\n                                }\n                                if (item.getParent() instanceof Item) {\n                                    item = (Item) item.getParent();\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.get().rebuildDependencyGraphAsync();\n    }\n","date":"2020-01-20 21:55:10","endLine":791,"groupId":"4422","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/d0/0fb66986f657fa79d9df8de6f4d3c3ab93badf.src","preCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.get().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            if (item != null) {\n                                while (item != null) {\n                                    if (item == this) {\n                                        buildsInProgress.put(e, e.getCurrentExecutable());\n                                        e.interrupt(Result.ABORTED);\n                                        break;\n                                    }\n                                    if (item.getParent() instanceof Item) {\n                                        item = (Item) item.getParent();\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.get().rebuildDependencyGraphAsync();\n    }\n","realPath":"core/src/main/java/hudson/model/AbstractItem.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":690,"status":"M"},{"authorDate":"2017-04-15 21:22:31","commitOrder":5,"curCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","date":"2017-04-15 21:22:31","endLine":77,"groupId":"9032","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"_contains","params":"(@NonnullItemitem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/32/d55c6023d94aaf1a69b5caebc1ab26dcf79493.src","preCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","realPath":"core/src/main/java/jenkins/model/queue/ItemDeletion.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"N"}],"commitId":"574ec6e5bdf2e4ac9394e290fefff5ac1c9a5c96","commitMessage":"@@@Merge branch 'master' into security-master\n","date":"2020-01-20 21:55:10","modifiedFileCount":"193","status":"M","submitter":"Wadeck Follonier"},{"authorTime":"2020-04-06 17:32:41","codes":[{"authorDate":"2020-01-20 21:55:10","commitOrder":6,"curCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.get().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            while (item != null) {\n                                if (item == this) {\n                                    buildsInProgress.put(e, e.getCurrentExecutable());\n                                    e.interrupt(Result.ABORTED);\n                                    break;\n                                }\n                                if (item.getParent() instanceof Item) {\n                                    item = (Item) item.getParent();\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.get().rebuildDependencyGraphAsync();\n    }\n","date":"2020-01-20 21:55:10","endLine":791,"groupId":"101089","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/d0/0fb66986f657fa79d9df8de6f4d3c3ab93badf.src","preCode":"    public void delete() throws IOException, InterruptedException {\n        checkPermission(DELETE);\n        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);\n        boolean ownsRegistration = ItemDeletion.register(this);\n        if (!ownsRegistration && ItemDeletion.isRegistered(this)) {\n            \r\n            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));\n        }\n        try {\n            \r\n            if (responsibleForAbortingBuilds || ownsRegistration) {\n                Queue queue = Queue.getInstance();\n                if (this instanceof Queue.Task) {\n                    \r\n                    queue.cancel((Queue.Task) this);\n                }\n                \r\n                for (Queue.Item i : queue.getItems()) {\n                    Item item = Tasks.getItemOf(i.task);\n                    while (item != null) {\n                        if (item == this) {\n                            queue.cancel(i);\n                            break;\n                        }\n                        if (item.getParent() instanceof Item) {\n                            item = (Item) item.getParent();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                \r\n                \r\n                \r\n                Map<Executor, Queue.Executable> buildsInProgress = new LinkedHashMap<>();\n                for (Computer c : Jenkins.get().getComputers()) {\n                    for (Executor e : c.getAllExecutors()) {\n                        final WorkUnit workUnit = e.getCurrentWorkUnit();\n                        final Executable executable = workUnit != null ? workUnit.getExecutable() : null;\n                        final SubTask subtask = executable != null ? getParentOf(executable) : null;\n                                \n                        if (subtask != null) {        \n                            Item item = Tasks.getItemOf(subtask);\n                            while (item != null) {\n                                if (item == this) {\n                                    buildsInProgress.put(e, e.getCurrentExecutable());\n                                    e.interrupt(Result.ABORTED);\n                                    break;\n                                }\n                                if (item.getParent() instanceof Item) {\n                                    item = (Item) item.getParent();\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!buildsInProgress.isEmpty()) {\n                    \r\n                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n                    \r\n                    \r\n                    while (!buildsInProgress.isEmpty() && expiration - System.nanoTime() > 0L) {\n                        \r\n                        \r\n                        \r\n                        \r\n                        for (Iterator<Map.Entry<Executor, Queue.Executable>> iterator =\n                             buildsInProgress.entrySet().iterator();\n                             iterator.hasNext(); ) {\n                            Map.Entry<Executor, Queue.Executable> entry = iterator.next();\n                            \r\n                            \r\n                            \r\n                            if (!entry.getKey().isAlive()\n                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {\n                                iterator.remove();\n                            }\n                            \r\n                            entry.getKey().interrupt(Result.ABORTED);\n                        }\n                        Thread.sleep(50L);\n                    }\n                    if (!buildsInProgress.isEmpty()) {\n                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(\n                                buildsInProgress.size(), getFullDisplayName()\n                        ));\n                    }\n                }\n            }\n            synchronized (this) { \r\n                performDelete();\n            } \r\n        } finally {\n            if (ownsRegistration) {\n                ItemDeletion.deregister(this);\n            }\n        }\n        getParent().onDeleted(AbstractItem.this);\n        Jenkins.get().rebuildDependencyGraphAsync();\n    }\n","realPath":"core/src/main/java/hudson/model/AbstractItem.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":690,"status":"N"},{"authorDate":"2020-04-06 17:32:41","commitOrder":6,"curCode":"    private boolean _contains(@NonNull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","date":"2020-04-06 17:32:41","endLine":77,"groupId":"101089","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"_contains","params":"(@NonNullItemitem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jenkins-10-0.7/blobInfo/CC_OUT/blobs/e8/71264fa2d72441e0da00a2a927e93647715e74.src","preCode":"    private boolean _contains(@Nonnull Item item) {\n        if (registrations.isEmpty()) {\n            \r\n            return false;\n        }\n\n        while (item != null) {\n            if (registrations.contains(item)) {\n                return true;\n            }\n            if (item.getParent() instanceof Item) {\n                item = (Item) item.getParent();\n            } else {\n                break;\n            }\n        }\n        return false;\n    }\n","realPath":"core/src/main/java/jenkins/model/queue/ItemDeletion.java","repoName":"jenkins","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"M"}],"commitId":"449c5aced523a6e66fe3d6a804e5dbfd5c5c67c6","commitMessage":"@@@Merge pull request #4604 from jtnord/kill-jsr-305\n\nKill jsr-305","date":"2020-04-06 17:32:41","modifiedFileCount":"352","status":"M","submitter":"Tim Jacomb"}]
