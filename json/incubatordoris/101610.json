[{"authorTime":"2020-07-21 12:42:42","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":1,"curCode":"    public long getAvailableCapacityB() {\n        \r\n        ImmutableMap<String, DiskInfo> disks = disksRef.get();\n        long availableCapacityB = 1L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                availableCapacityB += diskInfo.getAvailableCapacityB();\n            }\n        }\n        return availableCapacityB;\n    }\n","date":"2020-07-21 12:42:42","endLine":330,"groupId":"5900","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getAvailableCapacityB","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/31/d1c9c4aad978a37ba1469003e8b8ebc8f59adb.src","preCode":"    public long getAvailableCapacityB() {\n        \r\n        ImmutableMap<String, DiskInfo> disks = disksRef.get();\n        long availableCapacityB = 1L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                availableCapacityB += diskInfo.getAvailableCapacityB();\n            }\n        }\n        return availableCapacityB;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/system/Backend.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"B"},{"authorDate":"2020-07-21 12:42:42","commitOrder":1,"curCode":"    public long getDataUsedCapacityB() {\n        ImmutableMap<String, DiskInfo> disks = disksRef.get();\n        long dataUsedCapacityB = 0L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                dataUsedCapacityB += diskInfo.getDataUsedCapacityB();\n            }\n        }\n        return dataUsedCapacityB;\n    }\n","date":"2020-07-21 12:42:42","endLine":341,"groupId":"5900","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getDataUsedCapacityB","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/31/d1c9c4aad978a37ba1469003e8b8ebc8f59adb.src","preCode":"    public long getDataUsedCapacityB() {\n        ImmutableMap<String, DiskInfo> disks = disksRef.get();\n        long dataUsedCapacityB = 0L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                dataUsedCapacityB += diskInfo.getDataUsedCapacityB();\n            }\n        }\n        return dataUsedCapacityB;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/system/Backend.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"B"}],"commitId":"ad17afef9139a9aeedeb2e92638e95886d515f14","commitMessage":"@@@[CodeRefactor] #4098 Make FE multi module (#4099)\n\nThis PR change the FE code structure to maven multi module structure. \nSee ISSUE: #4098 for more info.  such as How to resolve conflicts.","date":"2020-07-21 12:42:42","modifiedFileCount":"0","status":"B","submitter":"Mingyu Chen"},{"authorTime":"2020-07-27 15:48:35","codes":[{"authorDate":"2020-07-27 15:48:35","commitOrder":2,"curCode":"    public long getAvailableCapacityB() {\n        \r\n        ImmutableMap<String, DiskInfo> disks = disksRef;\n        long availableCapacityB = 1L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                availableCapacityB += diskInfo.getAvailableCapacityB();\n            }\n        }\n        return availableCapacityB;\n    }\n","date":"2020-07-27 15:48:35","endLine":327,"groupId":"101610","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getAvailableCapacityB","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/44/410250ba9c9e03e34f7b5d89776a6c19ac0dbe.src","preCode":"    public long getAvailableCapacityB() {\n        \r\n        ImmutableMap<String, DiskInfo> disks = disksRef.get();\n        long availableCapacityB = 1L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                availableCapacityB += diskInfo.getAvailableCapacityB();\n            }\n        }\n        return availableCapacityB;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/system/Backend.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"M"},{"authorDate":"2020-07-27 15:48:35","commitOrder":2,"curCode":"    public long getDataUsedCapacityB() {\n        ImmutableMap<String, DiskInfo> disks = disksRef;\n        long dataUsedCapacityB = 0L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                dataUsedCapacityB += diskInfo.getDataUsedCapacityB();\n            }\n        }\n        return dataUsedCapacityB;\n    }\n","date":"2020-07-27 15:48:35","endLine":338,"groupId":"101610","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getDataUsedCapacityB","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/44/410250ba9c9e03e34f7b5d89776a6c19ac0dbe.src","preCode":"    public long getDataUsedCapacityB() {\n        ImmutableMap<String, DiskInfo> disks = disksRef.get();\n        long dataUsedCapacityB = 0L;\n        for (DiskInfo diskInfo : disks.values()) {\n            if (diskInfo.getState() == DiskState.ONLINE) {\n                dataUsedCapacityB += diskInfo.getDataUsedCapacityB();\n            }\n        }\n        return dataUsedCapacityB;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/system/Backend.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":329,"status":"M"}],"commitId":"94ac0f43dcd4688262a822c22d46fab529f87bf6","commitMessage":"@@@Use LongAdder or volatile long to replace AtomicLong in some scenarios (#4131)\n\nThis PR is to use LongAdder or volatile long to replace AtomicLong in some scenarios.\nIn the statistical summation scenario.  LongAdder(introduced by jdk1.8) has better performance than AtomicLong in high concurrency update scenario. And if we just want to keep get and set operation for variable to be atomic.  just add volatile at the front of the variable is enough.  use AtomicLong is a little heavy.\nNOTE: LongAdder is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics.  not for fine-grained synchronization control.  such as auto-incremental ids.","date":"2020-07-27 15:48:35","modifiedFileCount":"16","status":"M","submitter":"caiconghui"}]
