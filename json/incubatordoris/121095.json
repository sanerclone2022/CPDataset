[{"authorTime":"2020-12-31 09:47:06","codes":[{"authorDate":"2020-12-31 09:47:06","commitOrder":7,"curCode":"    private void getExecHostPortForFragmentIDAndBucketSeq(TScanRangeLocations seqLocation, PlanFragmentId fragmentId, Integer bucketSeq,\n                                                          HashMap<TNetworkAddress, Long> assignedBytesPerHost) throws Exception {\n        Reference<Long> backendIdRef = new Reference<Long>();\n        selectBackendsByRoundRobin(seqLocation, assignedBytesPerHost, backendIdRef);\n        Backend backend = this.idToBackend.get(backendIdRef.getRef());\n        TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n        this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n        this.fragmentIdToSeqToAddressMap.get(fragmentId).put(bucketSeq, execHostPort);\n    }\n","date":"2020-12-31 09:47:06","endLine":1286,"groupId":"6306","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getExecHostPortForFragmentIDAndBucketSeq","params":"(TScanRangeLocationsseqLocation@PlanFragmentIdfragmentId@IntegerbucketSeq@HashMap<TNetworkAddress@Long>assignedBytesPerHost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ff/05413d56243d0902d85aaaf0a72a00e2bb18cc.src","preCode":"    private void getExecHostPortForFragmentIDAndBucketSeq(TScanRangeLocations seqLocation, PlanFragmentId fragmentId, Integer bucketSeq,\n                                                          HashMap<TNetworkAddress, Long> assignedBytesPerHost) throws Exception {\n        Reference<Long> backendIdRef = new Reference<Long>();\n        selectBackendsByRoundRobin(seqLocation, assignedBytesPerHost, backendIdRef);\n        Backend backend = this.idToBackend.get(backendIdRef.getRef());\n        TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n        this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n        this.fragmentIdToSeqToAddressMap.get(fragmentId).put(bucketSeq, execHostPort);\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1278,"status":"B"},{"authorDate":"2020-12-31 09:47:06","commitOrder":7,"curCode":"    private void computeScanRangeAssignmentByScheduler(\n            final ScanNode scanNode,\n            final List<TScanRangeLocations> locations,\n            FragmentScanRangeAssignment assignment) throws Exception {\n\n        HashMap<TNetworkAddress, Long> assignedBytesPerHost = Maps.newHashMap();\n        for (TScanRangeLocations scanRangeLocations : locations) {\n            Reference<Long> backendIdRef = new Reference<Long>();\n            TScanRangeLocation minLocation = selectBackendsByRoundRobin(scanRangeLocations, assignedBytesPerHost, backendIdRef);\n            Backend backend = this.idToBackend.get(backendIdRef.getRef());\n            TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n            this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n\n            Map<Integer, List<TScanRangeParams>> scanRanges = findOrInsert(assignment, execHostPort,\n                    new HashMap<Integer, List<TScanRangeParams>>());\n            List<TScanRangeParams> scanRangeParamsList = findOrInsert(scanRanges, scanNode.getId().asInt(),\n                    new ArrayList<TScanRangeParams>());\n            \r\n            TScanRangeParams scanRangeParams = new TScanRangeParams();\n            scanRangeParams.scan_range = scanRangeLocations.scan_range;\n            \r\n            scanRangeParams.setVolumeId(minLocation.volume_id);\n            scanRangeParamsList.add(scanRangeParams);\n        }\n    }\n","date":"2020-12-31 09:47:06","endLine":1335,"groupId":"6306","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeScanRangeAssignmentByScheduler","params":"(finalScanNodescanNode@finalList<TScanRangeLocations>locations@FragmentScanRangeAssignmentassignment)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ff/05413d56243d0902d85aaaf0a72a00e2bb18cc.src","preCode":"    private void computeScanRangeAssignmentByScheduler(\n            final ScanNode scanNode,\n            final List<TScanRangeLocations> locations,\n            FragmentScanRangeAssignment assignment) throws Exception {\n\n        HashMap<TNetworkAddress, Long> assignedBytesPerHost = Maps.newHashMap();\n        for (TScanRangeLocations scanRangeLocations : locations) {\n            Reference<Long> backendIdRef = new Reference<Long>();\n            TScanRangeLocation minLocation = selectBackendsByRoundRobin(scanRangeLocations, assignedBytesPerHost, backendIdRef);\n            Backend backend = this.idToBackend.get(backendIdRef.getRef());\n            TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n            this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n\n            Map<Integer, List<TScanRangeParams>> scanRanges = findOrInsert(assignment, execHostPort,\n                    new HashMap<Integer, List<TScanRangeParams>>());\n            List<TScanRangeParams> scanRangeParamsList = findOrInsert(scanRanges, scanNode.getId().asInt(),\n                    new ArrayList<TScanRangeParams>());\n            \r\n            TScanRangeParams scanRangeParams = new TScanRangeParams();\n            scanRangeParams.scan_range = scanRangeLocations.scan_range;\n            \r\n            scanRangeParams.setVolumeId(minLocation.volume_id);\n            scanRangeParamsList.add(scanRangeParams);\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1311,"status":"MB"}],"commitId":"2e95b1c38935f53ed5a16720771d9d45efd91d9e","commitMessage":"@@@[Enhancement]Make Cholocate table join more load balance (#5104)\n\nWhen two colocate tables make join operation.  to make join operation locally. \nthe tablet belongs to the same bucket sequence will be distributed to the same host.\nWhen choosing which host for a bucket sequence.  it takes random strategy.\nRandom strategy can not make query task load balance logically for one query.\n\nTherefore.  this patch takes round-robin strategy.  make buckets distributed evenly.\nFor example.  if there are 6 bucket sequences and 3 hosts. \nit is better to distributed 2 buckets sequence for every host.","date":"2020-12-31 09:47:06","modifiedFileCount":"3","status":"M","submitter":"xinghuayu007"},{"authorTime":"2021-01-15 11:18:57","codes":[{"authorDate":"2020-12-31 09:47:06","commitOrder":8,"curCode":"    private void getExecHostPortForFragmentIDAndBucketSeq(TScanRangeLocations seqLocation, PlanFragmentId fragmentId, Integer bucketSeq,\n                                                          HashMap<TNetworkAddress, Long> assignedBytesPerHost) throws Exception {\n        Reference<Long> backendIdRef = new Reference<Long>();\n        selectBackendsByRoundRobin(seqLocation, assignedBytesPerHost, backendIdRef);\n        Backend backend = this.idToBackend.get(backendIdRef.getRef());\n        TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n        this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n        this.fragmentIdToSeqToAddressMap.get(fragmentId).put(bucketSeq, execHostPort);\n    }\n","date":"2020-12-31 09:47:06","endLine":1286,"groupId":"121095","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getExecHostPortForFragmentIDAndBucketSeq","params":"(TScanRangeLocationsseqLocation@PlanFragmentIdfragmentId@IntegerbucketSeq@HashMap<TNetworkAddress@Long>assignedBytesPerHost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ff/05413d56243d0902d85aaaf0a72a00e2bb18cc.src","preCode":"    private void getExecHostPortForFragmentIDAndBucketSeq(TScanRangeLocations seqLocation, PlanFragmentId fragmentId, Integer bucketSeq,\n                                                          HashMap<TNetworkAddress, Long> assignedBytesPerHost) throws Exception {\n        Reference<Long> backendIdRef = new Reference<Long>();\n        selectBackendsByRoundRobin(seqLocation, assignedBytesPerHost, backendIdRef);\n        Backend backend = this.idToBackend.get(backendIdRef.getRef());\n        TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n        this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n        this.fragmentIdToSeqToAddressMap.get(fragmentId).put(bucketSeq, execHostPort);\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1278,"status":"N"},{"authorDate":"2021-01-15 11:18:57","commitOrder":8,"curCode":"    private void computeScanRangeAssignmentByScheduler(\n            final ScanNode scanNode,\n            final List<TScanRangeLocations> locations,\n            FragmentScanRangeAssignment assignment,\n            HashMap<TNetworkAddress, Long> assignedBytesPerHost) throws Exception {\n        for (TScanRangeLocations scanRangeLocations : locations) {\n            Reference<Long> backendIdRef = new Reference<Long>();\n            TScanRangeLocation minLocation = selectBackendsByRoundRobin(scanRangeLocations, assignedBytesPerHost, backendIdRef);\n            Backend backend = this.idToBackend.get(backendIdRef.getRef());\n            TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n            this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n\n            Map<Integer, List<TScanRangeParams>> scanRanges = findOrInsert(assignment, execHostPort,\n                    new HashMap<Integer, List<TScanRangeParams>>());\n            List<TScanRangeParams> scanRangeParamsList = findOrInsert(scanRanges, scanNode.getId().asInt(),\n                    new ArrayList<TScanRangeParams>());\n            \r\n            TScanRangeParams scanRangeParams = new TScanRangeParams();\n            scanRangeParams.scan_range = scanRangeLocations.scan_range;\n            \r\n            scanRangeParams.setVolumeId(minLocation.volume_id);\n            scanRangeParamsList.add(scanRangeParams);\n        }\n    }\n","date":"2021-01-15 11:18:57","endLine":1335,"groupId":"121095","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeScanRangeAssignmentByScheduler","params":"(finalScanNodescanNode@finalList<TScanRangeLocations>locations@FragmentScanRangeAssignmentassignment@HashMap<TNetworkAddress@Long>assignedBytesPerHost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/55/8af53c0779b7095907ea9c14319b7f937415fe.src","preCode":"    private void computeScanRangeAssignmentByScheduler(\n            final ScanNode scanNode,\n            final List<TScanRangeLocations> locations,\n            FragmentScanRangeAssignment assignment) throws Exception {\n\n        HashMap<TNetworkAddress, Long> assignedBytesPerHost = Maps.newHashMap();\n        for (TScanRangeLocations scanRangeLocations : locations) {\n            Reference<Long> backendIdRef = new Reference<Long>();\n            TScanRangeLocation minLocation = selectBackendsByRoundRobin(scanRangeLocations, assignedBytesPerHost, backendIdRef);\n            Backend backend = this.idToBackend.get(backendIdRef.getRef());\n            TNetworkAddress execHostPort = new TNetworkAddress(backend.getHost(), backend.getBePort());\n            this.addressToBackendID.put(execHostPort, backendIdRef.getRef());\n\n            Map<Integer, List<TScanRangeParams>> scanRanges = findOrInsert(assignment, execHostPort,\n                    new HashMap<Integer, List<TScanRangeParams>>());\n            List<TScanRangeParams> scanRangeParamsList = findOrInsert(scanRanges, scanNode.getId().asInt(),\n                    new ArrayList<TScanRangeParams>());\n            \r\n            TScanRangeParams scanRangeParams = new TScanRangeParams();\n            scanRangeParams.scan_range = scanRangeLocations.scan_range;\n            \r\n            scanRangeParams.setVolumeId(minLocation.volume_id);\n            scanRangeParamsList.add(scanRangeParams);\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1312,"status":"M"}],"commitId":"d692764934bf3a073112a9180236d72e94ce181a","commitMessage":"@@@[Optimize]Take all scan nodes of one sql into consideration when select host for a tablet (#4984)\n\nCurrently when a scan node scans many tablets.  Doris will assure it load balance when choosing which replica for scan task to be executed. But it does not take other scan nodes into consideration to implement a global load balance. This patch tries to make all tables of all scan nodes to be load balance.\n\nCo-authored-by: wangxixu <wangxixu@xiaomi.com>","date":"2021-01-15 11:18:57","modifiedFileCount":"2","status":"M","submitter":"xinghuayu007"}]
