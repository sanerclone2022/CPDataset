[{"authorTime":"2020-08-21 22:57:16","codes":[{"authorDate":"2020-08-21 22:57:16","commitOrder":2,"curCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","date":"2020-08-21 22:57:16","endLine":169,"groupId":"5657","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNormal","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ac/6c12c9dece7858cab3fc8df1cd1a79456db625.src","preCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"MB"},{"authorDate":"2020-08-21 22:57:16","commitOrder":2,"curCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr);\n        desc.analyze(\"testDb\");\n    }\n","date":"2020-08-21 22:57:16","endLine":185,"groupId":"2185","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNegMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ac/6c12c9dece7858cab3fc8df1cd1a79456db625.src","preCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr);\n        desc.analyze(\"testDb\");\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"B"}],"commitId":"d61c10b76108fdbd04f7d86f89c646708a3934ea","commitMessage":"@@@[Delete] Support batch delete [part 1] (#4310)\n\n* Implements the grammar of the batch delete #4051 \n* Process create.  alter table when table has delete sign column\n* Support the syntax for enabling the delete column\n* Automatically filtered deleted data in the select statement.\n* Automatically add delete sign when create  rollup table\nTODO:\n * Optimize the reading and compaction logic on the be side.  so that the data marked as deleted will be completely deleted during base compaction","date":"2020-08-21 22:57:16","modifiedFileCount":"44","status":"M","submitter":"Zhengguo Yang"},{"authorTime":"2020-09-04 10:10:17","codes":[{"authorDate":"2020-09-04 10:10:17","commitOrder":3,"curCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","date":"2020-09-04 10:10:17","endLine":209,"groupId":"5657","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNormal","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/f2/5464d3ee9782dc9f7b8773616314e96724e203.src","preCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2020-09-04 10:10:17","commitOrder":3,"curCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n    }\n","date":"2020-09-04 10:10:17","endLine":225,"groupId":"2185","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNegMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/f2/5464d3ee9782dc9f7b8773616314e96724e203.src","preCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr);\n        desc.analyze(\"testDb\");\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"}],"commitId":"068707484d16bbb26a7944baf89244ced07c2471","commitMessage":"@@@Support sequence column for UNIQUE_KEYS Table (#4256)\n\n* add sequence  col\n\nCo-authored-by: yangwenbo6 <yangwenbo3@jd.com>","date":"2020-09-04 10:10:17","modifiedFileCount":"24","status":"M","submitter":"Youngwb"},{"authorTime":"2021-02-07 22:37:48","codes":[{"authorDate":"2021-02-07 22:37:48","commitOrder":4,"curCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","date":"2021-02-07 22:37:48","endLine":209,"groupId":"5657","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNormal","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/91/97c6b563abab7914a42c283734f5a6051185e3.src","preCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2021-02-07 22:37:48","commitOrder":4,"curCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n    }\n","date":"2021-02-07 22:37:48","endLine":225,"groupId":"2185","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNegMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/91/97c6b563abab7914a42c283734f5a6051185e3.src","preCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"}],"commitId":"780900ac9ca7ef7ee91595557ca4a80c1e36b206","commitMessage":"@@@[Feature] Support preceding filter original data when loading (#5338)\n\nSupport conditional filtering of original data in broker load and routine load\neg:\n\n```\nLOAD LABEL `label1`\n(\nDATA INFILE ('bos://cmy-repo/1.csv')\nINTO TABLE tbl2\nCOLUMNS TERMINATED BY '\\t'\n(event_day.  product_id.  ocpc_stage.  user_id)\nSET (\n\tocpc_stage = ocpc_stage + 100\n)\nPRECEDING FILTER user_id = 1381035\nWHERE ocpc_stage > 30\n)\n...\n```","date":"2021-02-07 22:37:48","modifiedFileCount":"18","status":"M","submitter":"Mingyu Chen"},{"authorTime":"2021-03-09 09:35:39","codes":[{"authorDate":"2021-03-09 09:35:39","commitOrder":5,"curCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"csv\", null, false, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new Separator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new Separator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","date":"2021-03-09 09:35:39","endLine":209,"groupId":"5657","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNormal","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/03/f21cc59f5eaebdab6aa585b83b43ae8aa8d149.src","preCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, false, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2021-03-09 09:35:39","commitOrder":5,"curCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"csv\", null, true, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n    }\n","date":"2021-03-09 09:35:39","endLine":225,"groupId":"2185","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNegMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/03/f21cc59f5eaebdab6aa585b83b43ae8aa8d149.src","preCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new ColumnSeparator(\",\"), \"csv\", null, true, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"}],"commitId":"e023ef5404493fa0b1aece6b72d1c2202f190dc2","commitMessage":"@@@[Load] Support multi bytes LineDelimiter and ColumnSeparator (#5462)\n\n* [Internal][Support Multibytes Separator] doris-1079\nsupport multi bytes LineDelimiter and ColumnSeparator","date":"2021-03-09 09:35:39","modifiedFileCount":"15","status":"M","submitter":"Zhengguo Yang"},{"authorTime":"2021-06-09 14:59:55","codes":[{"authorDate":"2021-06-09 14:59:55","commitOrder":6,"curCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"csv\", null, false, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new Separator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new Separator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n\n        Map<String, String> properties = Maps.newHashMap();\n        properties.put(\"line_delimiter\", \"abc\");\n        properties.put(\"fuzzy_parse\", \"true\");\n        properties.put(\"strip_outer_array\", \"true\");\n        properties.put(\"jsonpaths\",  \"[\\\"$.h1.h2.k1\\\",\\\"$.h1.h2.v1\\\",\\\"$.h1.h2.v2\\\"]\");\n        properties.put(\"json_root\", \"$.RECORDS\");\n        properties.put(\"read_json_by_line\", \"true\");\n        properties.put(\"num_as_string\",\"true\");\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"json\", null, false, null,\n                null, null, LoadTask.MergeType.APPEND, null, null, properties);\n\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"abc\", desc.getLineDelimiter());\n        Assert.assertTrue(desc.isFuzzyParse());\n        Assert.assertTrue(desc.isStripOuterArray());\n        Assert.assertEquals(\"[\\\"$.h1.h2.k1\\\",\\\"$.h1.h2.v1\\\",\\\"$.h1.h2.v2\\\"]\", desc.getJsonPaths());\n        Assert.assertEquals(\"$.RECORDS\", desc.getJsonRoot());\n        Assert.assertTrue(desc.isNumAsString());\n    }\n","date":"2021-06-09 14:59:55","endLine":231,"groupId":"1019","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testNormal","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/85/395ebcf2debdf5dedcf40424af1bfdc6b670ec.src","preCode":"    public void testNormal() throws AnalysisException {\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                   null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"), null, null, null,\n                                                  true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"), null,\n                                                  null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\", desc.toString());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), null, null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') NEGATIVE INTO TABLE testTable (col1, col2)\", desc.toString());\n        Assert.assertEquals(\"testTable\", desc.getTableName());\n        Assert.assertEquals(\"[col1, col2]\", desc.getFileFieldNames().toString());\n        Assert.assertEquals(\"[abc.txt]\", desc.getFilePaths().toString());\n        Assert.assertTrue(desc.isNegative());\n        Assert.assertNull(desc.getColumnSeparator());\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"csv\", null, false, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"MERGE DATA INFILE ('abc.txt') INTO TABLE testTable COLUMNS TERMINATED BY ',' (col1, col2) WHERE 1 = 1 DELETE ON 1 = 1\", desc.toString());\n        Assert.assertEquals(\"1 = 1\", desc.getWhereExpr().toSql());\n        Assert.assertEquals(\"1 = 1\", desc.getDeleteCondition().toSql());\n        Assert.assertEquals(\",\", desc.getColumnSeparator());\n\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new Separator(\"\\t\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\t' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\", \"bcd.txt\"),\n                                                  Lists.newArrayList(\"col1\", \"col2\"), new Separator(\"\\\\x01\"),\n                                                  null, true, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt', 'bcd.txt') NEGATIVE INTO TABLE testTable\"\n                        +  \" COLUMNS TERMINATED BY '\\\\x01' (col1, col2)\",\n                desc.toString());\n\n        \r\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  null, null, null, false, null);\n        desc.analyze(\"testDb\");\n        Assert.assertEquals(\"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2)\", desc.toString());\n        \n        \r\n        List<Expr> params = Lists.newArrayList();\n        params.add(new StringLiteral(\"day\"));\n        params.add(new SlotRef(null, \"k2\"));\n        BinaryPredicate predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"), \n                new FunctionCallExpr(\"alignment_timestamp\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        String sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = alignment_timestamp('day', `k2`))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"-\"));\n        params.add(new StringLiteral(\"10\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null,\n                                                  false, Lists.newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('-', '10'))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new StringLiteral(\"\"));\n        params.add(new NullLiteral());\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                new FunctionCallExpr(\"replace_value\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                                  Lists.newArrayList(\"abc.txt\"),\n                                                  Lists.newArrayList(\"k2\", \"k3\"), null, null, false, Lists\n                                                          .newArrayList((Expr) predicate));\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA INFILE ('abc.txt') INTO TABLE testTable PARTITIONS (p1, p2) (k2, k3)\"\n                + \" SET (`k1` = replace_value('', NULL))\";\n        Assert.assertEquals(sql, desc.toString());\n\n        \r\n        params.clear();\n        params.add(new SlotRef(null, \"k2\"));\n        predicate = new BinaryPredicate(Operator.EQ, new SlotRef(null, \"k1\"),\n                                        new FunctionCallExpr(\"bitmap_dict\", params));\n        desc = new DataDescription(\"testTable\", new PartitionNames(false, Lists.newArrayList(\"p1\", \"p2\")),\n                                   \"testHiveTable\", false, Lists.newArrayList(predicate),\n                null, LoadTask.MergeType.APPEND, null);\n        desc.analyze(\"testDb\");\n        sql = \"APPEND DATA FROM TABLE testHiveTable INTO TABLE testTable PARTITIONS (p1, p2) SET (`k1` = bitmap_dict(`k2`))\";\n        Assert.assertEquals(sql, desc.toSql());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"},{"authorDate":"2021-06-09 14:59:55","commitOrder":6,"curCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"csv\", null, true, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null, null);\n        desc.analyze(\"testDb\");\n    }\n","date":"2021-06-09 14:59:55","endLine":247,"groupId":"1019","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testNegMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/85/395ebcf2debdf5dedcf40424af1bfdc6b670ec.src","preCode":"    public void testNegMerge() throws AnalysisException {\n        Expr whereExpr = new BinaryPredicate(BinaryPredicate.Operator.EQ, new IntLiteral(1),  new IntLiteral(1));\n\n        DataDescription desc = new DataDescription(\"testTable\", null, Lists.newArrayList(\"abc.txt\"),\n                Lists.newArrayList(\"col1\", \"col2\"), new Separator(\",\"), \"csv\", null, true, null, null, whereExpr, LoadTask.MergeType.MERGE, whereExpr, null);\n        desc.analyze(\"testDb\");\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/analysis/DataDescriptionTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"}],"commitId":"d9c128b7444f6066f0095894f39f8c70f8355419","commitMessage":"@@@[BrokerLoad] Support read properties for broker load when read data (#5845)\n\n* [BrokerLoad] support read properties for broker load when read data\n\nCo-authored-by: caiconghui <caiconghui@xiaomi.com>","date":"2021-06-09 14:59:55","modifiedFileCount":"6","status":"M","submitter":"caiconghui"}]
