[{"authorTime":"2020-10-11 15:37:32","codes":[{"authorDate":"2020-09-12 11:16:31","commitOrder":2,"curCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(nodeScanRanges);\n        }\n\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","date":"2020-09-12 11:16:31","endLine":1139,"groupId":"2168","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"computeColocateJoinInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/a6/9d4ff22622d5e0fd77fc32cbc05ecf9da95de7.src","preCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(nodeScanRanges);\n        }\n\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1096,"status":"NB"},{"authorDate":"2020-10-11 15:37:32","commitOrder":2,"curCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(scanRanges);\n            }\n\n            for (Map.Entry<TNetworkAddress, List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.getKey());\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.getValue().entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","date":"2020-10-11 15:37:32","endLine":1596,"groupId":"6949","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/0f/c2680b081daa7df3dacfe4df7a1b6dcf060692.src","preCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(scanRanges);\n            }\n\n            for (Map.Entry<TNetworkAddress, List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.getKey());\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.getValue().entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1551,"status":"B"}],"commitId":"04f26e4b7f9b929c9c713fb01e513f5c80b494c0","commitMessage":"@@@[SQL] Support Bucket Shuffle Join (#4677)\n\nSupport Bucket Shuffle Join\nissue:#4394","date":"2020-10-11 15:37:32","modifiedFileCount":"7","status":"M","submitter":"HappenLee"},{"authorTime":"2020-11-05 20:57:11","codes":[{"authorDate":"2020-11-05 20:57:11","commitOrder":3,"curCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredNodeScanRanges);\n        }\n\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","date":"2020-11-05 20:57:11","endLine":1194,"groupId":"2168","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"computeColocateJoinInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/4d/4f851aa5e2b687e66548eb664083da01753656.src","preCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(nodeScanRanges);\n        }\n\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1142,"status":"M"},{"authorDate":"2020-11-05 20:57:11","commitOrder":3,"curCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","date":"2020-11-05 20:57:11","endLine":1632,"groupId":"6308","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/4d/4f851aa5e2b687e66548eb664083da01753656.src","preCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(scanRanges);\n            }\n\n            for (Map.Entry<TNetworkAddress, List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.getKey());\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.getValue().entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1577,"status":"M"}],"commitId":"bde84e4ae5d0597343e9dfb52a27e00c2d520137","commitMessage":"@@@[Bug][SQL] Fix bug that query failed when SQL contains Union and Colocate join (#4842)\n\nSQL like:\n`select a join b union select c join d`;\n\nif a b is colocate join.  and c d is also colocate join.  the query may failed\nwith error like:\n\n`failed to get tablet. tablet_id=26846.  with schema_hash=398972982.  reason=tablet does not exist`","date":"2020-11-05 20:57:11","modifiedFileCount":"2","status":"M","submitter":"Mingyu Chen"},{"authorTime":"2021-01-16 21:37:33","codes":[{"authorDate":"2021-01-16 21:37:33","commitOrder":4,"curCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredNodeScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","date":"2021-01-16 21:37:33","endLine":1220,"groupId":"2168","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"computeColocateJoinInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/0c/d3f0ca101f0793fc2f9ed100a89c56401588f4.src","preCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredNodeScanRanges);\n        }\n\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1163,"status":"M"},{"authorDate":"2021-01-16 21:37:33","commitOrder":4,"curCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","date":"2021-01-16 21:37:33","endLine":1679,"groupId":"6581","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computeInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/0c/d3f0ca101f0793fc2f9ed100a89c56401588f4.src","preCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1622,"status":"M"}],"commitId":"3dcbbbea956c80a91b5e0708aeedc938dd2d2d1d","commitMessage":"@@@[Enhancement] Fill assignment param of bucket shuffle and colocate shuffle for debug  (#5167)\n\nWhen Doris is in debug mode.  function `Coordinator#traceInstance` is used to print\nthe physical execute plan of a fragment instance for debug.\nFunction  `Coordinator#traceInstance` uses param `scanRangeAssignment` to print\nthe detail of a fragment. But bucket shuffle join and colocate shuffle join do not fill the param.\nThat will cause debug not work well.\nThis path fill assignment param of bucket shuffle and colocate shuffle for debug.","date":"2021-01-16 21:37:33","modifiedFileCount":"2","status":"M","submitter":"xinghuayu007"},{"authorTime":"2021-01-20 21:42:04","codes":[{"authorDate":"2021-01-20 21:42:04","commitOrder":5,"curCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredNodeScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                        }\n                        range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","date":"2021-01-20 21:42:04","endLine":1218,"groupId":"2168","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"computeColocateJoinInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/c0/fba828b7413a7c9529c851b33ce56666698b77.src","preCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredNodeScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                        } else {\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1163,"status":"M"},{"authorDate":"2021-01-20 21:42:04","commitOrder":5,"curCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            }\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","date":"2021-01-20 21:42:04","endLine":1676,"groupId":"6581","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computeInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/c0/fba828b7413a7c9529c851b33ce56666698b77.src","preCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), nodeScanRange.getValue());\n                            } else {\n                                range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                                instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            }\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1620,"status":"M"}],"commitId":"50ba5d336d7bbfdafb73f6b2be6e3532a21a1632","commitMessage":"@@@[Bug] Colocate Join and Bucket shuffle join may scan some tablet twice time. (#5256)\n\nFix issue #5255","date":"2021-01-20 21:42:04","modifiedFileCount":"2","status":"M","submitter":"HappenLee"},{"authorTime":"2021-01-20 21:42:04","codes":[{"authorDate":"2021-03-09 14:47:59","commitOrder":6,"curCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n\n                for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                    instanceParam.bucketSeqSet.add(nodeScanRangeMap.first);\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                        }\n                        range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","date":"2021-03-09 14:47:59","endLine":1228,"groupId":"6581","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"computeColocateJoinInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/10/81ebc268b406b683a2778a354f930b359f9271.src","preCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredNodeScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Map<Integer, List<TScanRangeParams>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Map<Integer, List<TScanRangeParams>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Map<Integer, List<TScanRangeParams>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Map<Integer, List<TScanRangeParams>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n\n                for (Map<Integer, List<TScanRangeParams>> nodeScanRangeMap : perInstanceScanRange) {\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                        }\n                        range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1165,"status":"M"},{"authorDate":"2021-01-20 21:42:04","commitOrder":6,"curCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            }\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","date":"2021-01-20 21:42:04","endLine":1676,"groupId":"6581","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"computeInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/c0/fba828b7413a7c9529c851b33ce56666698b77.src","preCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            }\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1620,"status":"N"}],"commitId":"bd53f407aadd136a2b3b949efc78970c21a11b3d","commitMessage":"@@@[Bucket Shuffle Join] Support the some featrue of Bucket Shuffle Join (#5459)\n\n1.Support Bucket Shuffle Join when left table is colocate table or Colocate/Bucket Bucket Shuffle Join\n2.Enable Local Rumtime Filter when there is Bucket Shuffle Join and Colocate Join\n3.Add Doc for Bucket Shuffle Join","date":"2021-03-09 14:47:59","modifiedFileCount":"4","status":"M","submitter":"HappenLee"},{"authorTime":"2021-01-20 21:42:04","codes":[{"authorDate":"2021-06-04 10:19:58","commitOrder":7,"curCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        BucketSeqToScanRange bucketSeqToScanRange = fragmentIdTobucketSeqToScanRangeMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                    instanceParam.bucketSeqSet.add(nodeScanRangeMap.first);\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                        }\n                        range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","date":"2021-06-04 10:19:58","endLine":1240,"groupId":"101093","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"computeColocateJoinInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/cb/93a094b20e928c14e7faecac92777c27858cd2.src","preCode":"    private void computeColocateJoinInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n        Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n        Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n        \r\n        Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n        for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n            TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n            Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n\n            \r\n            Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n            for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                if (scanNodeIds.contains(scanNodeId)) {\n                    filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                }\n            }\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n            if (!addressToScanRanges.containsKey(address)) {\n                addressToScanRanges.put(address, Lists.newArrayList());\n            }\n            addressToScanRanges.get(address).add(filteredScanRanges);\n        }\n        FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n        for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n            List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n            Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n            int expectedInstanceNum = 1;\n            if (parallelExecInstanceNum > 1) {\n                \r\n                expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n            }\n\n            \r\n            List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                    expectedInstanceNum);\n\n            \r\n            for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                    instanceParam.bucketSeqSet.add(nodeScanRangeMap.first);\n                    for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                        if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                            range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                        }\n                        range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                    }\n                }\n                params.instanceExecParams.add(instanceParam);\n            }\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1177,"status":"M"},{"authorDate":"2021-01-20 21:42:04","commitOrder":7,"curCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            }\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","date":"2021-01-20 21:42:04","endLine":1676,"groupId":"101093","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"computeInstanceParam","params":"(PlanFragmentIdfragmentId@intparallelExecInstanceNum@FragmentExecParamsparams)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/c0/fba828b7413a7c9529c851b33ce56666698b77.src","preCode":"        private void computeInstanceParam(PlanFragmentId fragmentId, int parallelExecInstanceNum, FragmentExecParams params) {\n            Map<Integer, TNetworkAddress> bucketSeqToAddress = fragmentIdToSeqToAddressMap.get(fragmentId);\n            BucketSeqToScanRange bucketSeqToScanRange = fragmentIdBucketSeqToScanRangeMap.get(fragmentId);\n            Set<Integer> scanNodeIds = fragmentIdToScanNodeIds.get(fragmentId);\n\n            \r\n            Map<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressToScanRanges = Maps.newHashMap();\n            for (Map.Entry<Integer, Map<Integer, List<TScanRangeParams>>> scanRanges : bucketSeqToScanRange.entrySet()) {\n                TNetworkAddress address = bucketSeqToAddress.get(scanRanges.getKey());\n                Map<Integer, List<TScanRangeParams>> nodeScanRanges = scanRanges.getValue();\n                \r\n                Map<Integer, List<TScanRangeParams>> filteredNodeScanRanges = Maps.newHashMap();\n                for (Integer scanNodeId : nodeScanRanges.keySet()) {\n                    if (scanNodeIds.contains(scanNodeId)) {\n                        filteredNodeScanRanges.put(scanNodeId, nodeScanRanges.get(scanNodeId));\n                    }\n                }\n                Pair<Integer, Map<Integer, List<TScanRangeParams>>> filteredScanRanges = Pair.create(scanRanges.getKey(), filteredNodeScanRanges);\n\n                if (!addressToScanRanges.containsKey(address)) {\n                    addressToScanRanges.put(address, Lists.newArrayList());\n                }\n                addressToScanRanges.get(address).add(filteredScanRanges);\n            }\n            FragmentScanRangeAssignment assignment = params.scanRangeAssignment;\n            for (Map.Entry<TNetworkAddress, List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> addressScanRange : addressToScanRanges.entrySet()) {\n                List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> scanRange = addressScanRange.getValue();\n                Map<Integer, List<TScanRangeParams>> range = findOrInsert(assignment, addressScanRange.getKey(), new HashMap<Integer, List<TScanRangeParams>>());\n                int expectedInstanceNum = 1;\n                if (parallelExecInstanceNum > 1) {\n                    \r\n                    expectedInstanceNum = Math.min(scanRange.size(), parallelExecInstanceNum);\n                }\n\n                \r\n                List<List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>>> perInstanceScanRanges = ListUtil.splitBySize(scanRange,\n                        expectedInstanceNum);\n\n                \r\n                for (List<Pair<Integer, Map<Integer, List<TScanRangeParams>>>> perInstanceScanRange : perInstanceScanRanges) {\n                    FInstanceExecParam instanceParam = new FInstanceExecParam(null, addressScanRange.getKey(), 0, params);\n\n                    for (Pair<Integer, Map<Integer, List<TScanRangeParams>>> nodeScanRangeMap : perInstanceScanRange) {\n                        instanceParam.addBucketSeq(nodeScanRangeMap.first);\n                        for (Map.Entry<Integer, List<TScanRangeParams>> nodeScanRange : nodeScanRangeMap.second.entrySet()) {\n                            if (!instanceParam.perNodeScanRanges.containsKey(nodeScanRange.getKey())) {\n                                range.put(nodeScanRange.getKey(), Lists.newArrayList());\n                                instanceParam.perNodeScanRanges.put(nodeScanRange.getKey(), Lists.newArrayList());\n                            }\n                            range.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                            instanceParam.perNodeScanRanges.get(nodeScanRange.getKey()).addAll(nodeScanRange.getValue());\n                        }\n                    }\n                    params.instanceExecParams.add(instanceParam);\n                }\n            }\n        }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/qe/Coordinator.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":1620,"status":"N"}],"commitId":"a5c35eb20f3a10834f2920bf45515b2f4e411edf","commitMessage":"@@@[Bug] Fix the bug of null pointer exception of colocate join (#5961)\n\n","date":"2021-06-04 10:19:58","modifiedFileCount":"2","status":"M","submitter":"HappenLee"}]
