[{"authorTime":"2021-04-11 22:02:03","codes":[{"authorDate":"2021-04-11 22:02:03","commitOrder":1,"curCode":"    public void testBalance(@Mocked SystemInfoService infoService,\n                            @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                infoService.getBackend(1L);\n                result = backend1;\n                minTimes = 0;\n                infoService.getBackend(2L);\n                result = backend2;\n                minTimes = 0;\n                infoService.getBackend(3L);\n                result = backend3;\n                minTimes = 0;\n                infoService.getBackend(4L);\n                result = backend4;\n                minTimes = 0;\n                infoService.getBackend(5L);\n                result = backend5;\n                minTimes = 0;\n                infoService.getBackend(6L);\n                result = backend6;\n                minTimes = 0;\n                infoService.getBackend(7L);\n                result = backend7;\n                minTimes = 0;\n                infoService.getBackend(8L);\n                result = backend8;\n                minTimes = 0;\n                infoService.getBackend(9L);\n                result = backend9;\n                minTimes = 0;\n\n                statistic.getBackendLoadStatistic(anyLong);\n                result = null;\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        distributionCols.add(new Column(\"k1\", PrimitiveType.INT));\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, (short) 3);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        \r\n        \r\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        List<Long> allAvailBackendIds = Lists.newArrayList(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        List<List<Long>> expected = Lists.partition(\n                Lists.newArrayList(9L, 5L, 3L, 4L, 6L, 8L, 7L, 6L, 1L, 2L, 9L, 4L, 1L, 2L, 3L), 3);\n        Assert.assertTrue(changed);\n        Assert.assertEquals(expected, balancedBackendsPerBucketSeq);\n\n        \r\n        colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(9L, 8L, 7L, 8L, 6L, 5L, 9L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n        balancedBackendsPerBucketSeq.clear();\n        changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        System.out.println(balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n        Assert.assertTrue(balancedBackendsPerBucketSeq.isEmpty());\n    }\n","date":"2021-04-11 22:02:03","endLine":166,"groupId":"6115","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testBalance","params":"(@MockedSystemInfoServiceinfoService@@MockedClusterLoadStatisticstatistic)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/3b/5695affd328ef94774036a57da659d21595780.src","preCode":"    public void testBalance(@Mocked SystemInfoService infoService,\n                            @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                infoService.getBackend(1L);\n                result = backend1;\n                minTimes = 0;\n                infoService.getBackend(2L);\n                result = backend2;\n                minTimes = 0;\n                infoService.getBackend(3L);\n                result = backend3;\n                minTimes = 0;\n                infoService.getBackend(4L);\n                result = backend4;\n                minTimes = 0;\n                infoService.getBackend(5L);\n                result = backend5;\n                minTimes = 0;\n                infoService.getBackend(6L);\n                result = backend6;\n                minTimes = 0;\n                infoService.getBackend(7L);\n                result = backend7;\n                minTimes = 0;\n                infoService.getBackend(8L);\n                result = backend8;\n                minTimes = 0;\n                infoService.getBackend(9L);\n                result = backend9;\n                minTimes = 0;\n\n                statistic.getBackendLoadStatistic(anyLong);\n                result = null;\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        distributionCols.add(new Column(\"k1\", PrimitiveType.INT));\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, (short) 3);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        \r\n        \r\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        List<Long> allAvailBackendIds = Lists.newArrayList(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        List<List<Long>> expected = Lists.partition(\n                Lists.newArrayList(9L, 5L, 3L, 4L, 6L, 8L, 7L, 6L, 1L, 2L, 9L, 4L, 1L, 2L, 3L), 3);\n        Assert.assertTrue(changed);\n        Assert.assertEquals(expected, balancedBackendsPerBucketSeq);\n\n        \r\n        colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(9L, 8L, 7L, 8L, 6L, 5L, 9L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n        balancedBackendsPerBucketSeq.clear();\n        changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        System.out.println(balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n        Assert.assertTrue(balancedBackendsPerBucketSeq.isEmpty());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/clone/ColocateTableCheckerAndBalancerTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"B"},{"authorDate":"2021-04-11 22:02:03","commitOrder":1,"curCode":"    public void testFixBalanceEndlessLoop2(@Mocked SystemInfoService infoService,\n                                           @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                statistic.getBackendLoadStatistic(anyLong);\n                result = new Delegate<BackendLoadStatistic>() {\n                    BackendLoadStatistic delegate(Long beId) {\n                        return new FakeBackendLoadStatistic(beId, null, null, null);\n                    }\n                };\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, (short) 1);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId, Lists.newArrayList(7L, 7L, 7L, 7L, 7L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        Set<Long> unAvailBackendIds = Sets.newHashSet(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        List<Long> availBackendIds = Lists.newArrayList();\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, unAvailBackendIds, availBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n    }\n","date":"2021-04-11 22:02:03","endLine":265,"groupId":"6146","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFixBalanceEndlessLoop2","params":"(@MockedSystemInfoServiceinfoService@@MockedClusterLoadStatisticstatistic)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/3b/5695affd328ef94774036a57da659d21595780.src","preCode":"    public void testFixBalanceEndlessLoop2(@Mocked SystemInfoService infoService,\n                                           @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                statistic.getBackendLoadStatistic(anyLong);\n                result = new Delegate<BackendLoadStatistic>() {\n                    BackendLoadStatistic delegate(Long beId) {\n                        return new FakeBackendLoadStatistic(beId, null, null, null);\n                    }\n                };\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, (short) 1);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId, Lists.newArrayList(7L, 7L, 7L, 7L, 7L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        Set<Long> unAvailBackendIds = Sets.newHashSet(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        List<Long> availBackendIds = Lists.newArrayList();\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, unAvailBackendIds, availBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/clone/ColocateTableCheckerAndBalancerTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"B"}],"commitId":"a25e3afa5b43051a3f2ca9faae679b01481b0c0b","commitMessage":"@@@[Colocate plan][Step1] Colocate join covers more situations (#5521)\n\nThe old colocate join can only cover the case where the child is hash or scan.\nIn fact.  as long as the child's data distribution meets the requirements. \nno matter what the plan node on the child node is.  a colocate join can be performed.","date":"2021-04-11 22:02:03","modifiedFileCount":"15","status":"B","submitter":"EmmyMiao87"},{"authorTime":"2021-09-04 10:59:35","codes":[{"authorDate":"2021-09-04 10:59:35","commitOrder":2,"curCode":"    public void testBalance(@Mocked SystemInfoService infoService,\n                            @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                infoService.getBackend(1L);\n                result = backend1;\n                minTimes = 0;\n                infoService.getBackend(2L);\n                result = backend2;\n                minTimes = 0;\n                infoService.getBackend(3L);\n                result = backend3;\n                minTimes = 0;\n                infoService.getBackend(4L);\n                result = backend4;\n                minTimes = 0;\n                infoService.getBackend(5L);\n                result = backend5;\n                minTimes = 0;\n                infoService.getBackend(6L);\n                result = backend6;\n                minTimes = 0;\n                infoService.getBackend(7L);\n                result = backend7;\n                minTimes = 0;\n                infoService.getBackend(8L);\n                result = backend8;\n                minTimes = 0;\n                infoService.getBackend(9L);\n                result = backend9;\n                minTimes = 0;\n\n                statistic.getBackendLoadStatistic(anyLong);\n                result = null;\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        distributionCols.add(new Column(\"k1\", PrimitiveType.INT));\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5,\n                ReplicaAllocation.DEFAULT_ALLOCATION);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        \r\n        \r\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        List<Long> allAvailBackendIds = Lists.newArrayList(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId,\n                Tag.DEFAULT_BACKEND_TAG, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        List<List<Long>> expected = Lists.partition(\n                Lists.newArrayList(9L, 5L, 3L, 4L, 6L, 8L, 7L, 6L, 1L, 2L, 9L, 4L, 1L, 2L, 3L), 3);\n        Assert.assertTrue(changed);\n        Assert.assertEquals(expected, balancedBackendsPerBucketSeq);\n\n        \r\n        colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(9L, 8L, 7L, 8L, 6L, 5L, 9L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n        balancedBackendsPerBucketSeq.clear();\n        changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId,\n                Tag.DEFAULT_BACKEND_TAG, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        System.out.println(balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n        Assert.assertTrue(balancedBackendsPerBucketSeq.isEmpty());\n    }\n","date":"2021-09-04 10:59:35","endLine":174,"groupId":"10281","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testBalance","params":"(@MockedSystemInfoServiceinfoService@@MockedClusterLoadStatisticstatistic)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/8b/525ea042e252c29f9b6ac9c1ba1b6905dacf68.src","preCode":"    public void testBalance(@Mocked SystemInfoService infoService,\n                            @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                infoService.getBackend(1L);\n                result = backend1;\n                minTimes = 0;\n                infoService.getBackend(2L);\n                result = backend2;\n                minTimes = 0;\n                infoService.getBackend(3L);\n                result = backend3;\n                minTimes = 0;\n                infoService.getBackend(4L);\n                result = backend4;\n                minTimes = 0;\n                infoService.getBackend(5L);\n                result = backend5;\n                minTimes = 0;\n                infoService.getBackend(6L);\n                result = backend6;\n                minTimes = 0;\n                infoService.getBackend(7L);\n                result = backend7;\n                minTimes = 0;\n                infoService.getBackend(8L);\n                result = backend8;\n                minTimes = 0;\n                infoService.getBackend(9L);\n                result = backend9;\n                minTimes = 0;\n\n                statistic.getBackendLoadStatistic(anyLong);\n                result = null;\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        distributionCols.add(new Column(\"k1\", PrimitiveType.INT));\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, (short) 3);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        \r\n        \r\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        List<Long> allAvailBackendIds = Lists.newArrayList(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        List<List<Long>> expected = Lists.partition(\n                Lists.newArrayList(9L, 5L, 3L, 4L, 6L, 8L, 7L, 6L, 1L, 2L, 9L, 4L, 1L, 2L, 3L), 3);\n        Assert.assertTrue(changed);\n        Assert.assertEquals(expected, balancedBackendsPerBucketSeq);\n\n        \r\n        colocateTableIndex = createColocateIndex(groupId,\n                Lists.newArrayList(9L, 8L, 7L, 8L, 6L, 5L, 9L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n        balancedBackendsPerBucketSeq.clear();\n        changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, new HashSet<Long>(), allAvailBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        System.out.println(balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n        Assert.assertTrue(balancedBackendsPerBucketSeq.isEmpty());\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/clone/ColocateTableCheckerAndBalancerTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"},{"authorDate":"2021-09-04 10:59:35","commitOrder":2,"curCode":"    public void testFixBalanceEndlessLoop2(@Mocked SystemInfoService infoService,\n                                           @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                statistic.getBackendLoadStatistic(anyLong);\n                result = new Delegate<BackendLoadStatistic>() {\n                    BackendLoadStatistic delegate(Long beId) {\n                        return new FakeBackendLoadStatistic(beId, null, null, null);\n                    }\n                };\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, new ReplicaAllocation((short) 1));\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId, Lists.newArrayList(7L, 7L, 7L, 7L, 7L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        Set<Long> unAvailBackendIds = Sets.newHashSet(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        List<Long> availBackendIds = Lists.newArrayList();\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, Tag.DEFAULT_BACKEND_TAG,\n                unAvailBackendIds, availBackendIds, colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n    }\n","date":"2021-09-04 10:59:35","endLine":274,"groupId":"10281","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testFixBalanceEndlessLoop2","params":"(@MockedSystemInfoServiceinfoService@@MockedClusterLoadStatisticstatistic)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/8b/525ea042e252c29f9b6ac9c1ba1b6905dacf68.src","preCode":"    public void testFixBalanceEndlessLoop2(@Mocked SystemInfoService infoService,\n                                           @Mocked ClusterLoadStatistic statistic) {\n        new Expectations() {\n            {\n                statistic.getBackendLoadStatistic(anyLong);\n                result = new Delegate<BackendLoadStatistic>() {\n                    BackendLoadStatistic delegate(Long beId) {\n                        return new FakeBackendLoadStatistic(beId, null, null, null);\n                    }\n                };\n                minTimes = 0;\n            }\n        };\n        GroupId groupId = new GroupId(10000, 10001);\n        List<Column> distributionCols = Lists.newArrayList();\n        ColocateGroupSchema groupSchema = new ColocateGroupSchema(groupId, distributionCols, 5, (short) 1);\n        Map<GroupId, ColocateGroupSchema> group2Schema = Maps.newHashMap();\n        group2Schema.put(groupId, groupSchema);\n\n        ColocateTableIndex colocateTableIndex = createColocateIndex(groupId, Lists.newArrayList(7L, 7L, 7L, 7L, 7L));\n        Deencapsulation.setField(colocateTableIndex, \"group2Schema\", group2Schema);\n\n        List<List<Long>> balancedBackendsPerBucketSeq = Lists.newArrayList();\n        Set<Long> unAvailBackendIds = Sets.newHashSet(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L);\n        List<Long> availBackendIds = Lists.newArrayList();\n        boolean changed = (Boolean) Deencapsulation.invoke(balancer, \"relocateAndBalance\", groupId, unAvailBackendIds, availBackendIds,\n                colocateTableIndex, infoService, statistic, balancedBackendsPerBucketSeq);\n        Assert.assertFalse(changed);\n    }\n","realPath":"fe/fe-core/src/test/java/org/apache/doris/clone/ColocateTableCheckerAndBalancerTest.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"}],"commitId":"7db8841ae264012f37bb929b0f7ba6ffefe703c8","commitMessage":"@@@[Feature][ResourceTag] Support Resource Tag (#6203)\n\n#5902 \nThis CL mainly changes:\n\n1. Support setting tags for BE nodes:\n\n    ```\n    alter system add backend \"1272:9050.  1212:9050\" properties(\"tag.location\": \"zoneA\");\n    alter system modify backend \"1272:9050.  1212:9050\" set (\"tag.location\": \"zoneB\");\n    ```\n    And for compatibility.  all BE nodes will be set a \"default\" tag when upgrading: `\"tag.location\": \"default\"`.\n\n2. Create a new class `ReplicaAllocation` to replace the previous `replication_num`.\n\n    `ReplicaAllocation` represents the allocation of the replicas of a tablet. It contains a map from \n    Tag to number of replicas.\n    For example.  if user set a table's replication num to 3.  it will be converted to a ReplicaAllocation\n    like: `\"tag.location.default\" : \"3\"`.  which means the tablet will have 3 replicas and all of them will be\n    allocated in BE nodes with tag \"default\";\n\n3. Support create table with replication allocation:\n\n    ```\n    CREATE TABLE example_db.table_hash\n    (\n    k1 TINYINT\n    )\n    DISTRIBUTED BY HASH(k1) BUCKETS 32\n    PROPERTIES (\n        \"replication_allocation\"=\"tag.location.zone1:1.  tag.location.zone2:2\"\n    );\n    ```\n    \n    Also support set replica allocation for dynamic tables.  and modify replica allocation at runtime.\n\n    For compatibility.  user can still set \"replication_num\" = \"3\".  and it will be automatically converted to:\n    ` \"replication_allocation\"=\"tag.location.default:3\"`\n\n4. Support tablet repair and balance based on Tag\n\n    1. For tablets of non-colocate table.  most of the logic is the same as before. \n       but when selecting the destination node for clone.  the tag of the node will be considered.\n       If the required tag does not exist.  it cannot be repaired.\n       Similarly.  under the condition of ensuring that the replicas are complete.  the tablet will be\n       reallocated according to the tag or the replicas will be balanced.\n\n       Balancing is performed separately within each resource group.\n\n    2. For tablets of colocate table.  the backends sequence of buckets will be splitted by tag.\n       For example.  if replica allocation is \"tag.location.zone1:1.  tag.location.zone2:2\". \n\n       And zone1 has 2 BE: A.  B; zone2 has 3 BE: C.  D.  F\n\n       there will be 2 backend sequences: one is for zone1.  and the other is for zone2.\n       And one posible seqeunces will be:\n\n\n       zone1: [A]   [B]   [A]   [B]\n       zone2: [C.  D][D.  F][F.  C][C.  D]\n\n5. Support setting tags for user and restrict execution node with tags:\n\n\n    ```\n    set property for 'cmy' 'resource_tags.location' : 'zone1.  zone2';\n    ```\n\n    After setting.  the user 'cmy' can only query data stored on backends with tag zone1 and zone2. \n    And query can only be executed on backends with tag zone1 and zone2\n\n\n    For compatibility.  after upgrading.  the property `resource_tags.location` will be empty. \n    so that user can still query data stored on any backends.\n\n6. Modify the Unit test frame of FE so that we can created multi backends with different mocked IP in unit test.\n\n    This help us to easily test some distributed cases like query.  tablet repair and balance\n\nThe document will be added in another PR.\n\nAlso fix a bug described in #6194 ","date":"2021-09-04 10:59:35","modifiedFileCount":"161","status":"M","submitter":"Mingyu Chen"}]
