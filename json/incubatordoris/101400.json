[{"authorTime":"2020-07-21 12:42:42","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":1,"curCode":"    public synchronized void recoverPartition(long dbId, OlapTable table, String partitionName) throws DdlException {\n        \r\n        RecyclePartitionInfo recoverPartitionInfo = null;\n\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n\n            if (partitionInfo.getTableId() != table.getId()) {\n                continue;\n            }\n\n            if (!partitionInfo.getPartition().getName().equalsIgnoreCase(partitionName)) {\n                continue;\n            }\n\n            recoverPartitionInfo = partitionInfo;\n            break;\n        }\n\n        if (recoverPartitionInfo == null) {\n            throw new DdlException(\"No partition named \" + partitionName + \" in table \" + table.getName());\n        }\n        \n        \r\n        Range<PartitionKey> recoverRange = recoverPartitionInfo.getRange();\n        RangePartitionInfo partitionInfo = (RangePartitionInfo) table.getPartitionInfo();\n        if (partitionInfo.getAnyIntersectRange(recoverRange, false) != null) {\n            throw new DdlException(\"Can not recover partition[\" + partitionName + \"]. Range conflict.\");\n        }\n\n        \r\n        Partition recoverPartition = recoverPartitionInfo.getPartition();\n        Preconditions.checkState(recoverPartition.getName().equalsIgnoreCase(partitionName));\n        table.addPartition(recoverPartition);\n        \n        \r\n        long partitionId = recoverPartition.getId();\n        partitionInfo.setRange(partitionId, false, recoverRange);\n        partitionInfo.setDataProperty(partitionId, recoverPartitionInfo.getDataProperty());\n        partitionInfo.setReplicationNum(partitionId, recoverPartitionInfo.getReplicationNum());\n        partitionInfo.setIsInMemory(partitionId, recoverPartitionInfo.isInMemory());\n\n        \r\n        idToPartition.remove(partitionId);\n        idToRecycleTime.remove(partitionId);\n\n        \r\n        RecoverInfo recoverInfo = new RecoverInfo(dbId, table.getId(), partitionId);\n        Catalog.getCurrentCatalog().getEditLog().logRecoverPartition(recoverInfo);\n        LOG.info(\"recover partition[{}]\", partitionId);\n    }\n","date":"2020-07-21 12:42:42","endLine":552,"groupId":"1633","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"recoverPartition","params":"(longdbId@OlapTabletable@StringpartitionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ed/993b54a656543c5c8a8d812fbc3a68ea3cfb55.src","preCode":"    public synchronized void recoverPartition(long dbId, OlapTable table, String partitionName) throws DdlException {\n        \r\n        RecyclePartitionInfo recoverPartitionInfo = null;\n\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n\n            if (partitionInfo.getTableId() != table.getId()) {\n                continue;\n            }\n\n            if (!partitionInfo.getPartition().getName().equalsIgnoreCase(partitionName)) {\n                continue;\n            }\n\n            recoverPartitionInfo = partitionInfo;\n            break;\n        }\n\n        if (recoverPartitionInfo == null) {\n            throw new DdlException(\"No partition named \" + partitionName + \" in table \" + table.getName());\n        }\n        \n        \r\n        Range<PartitionKey> recoverRange = recoverPartitionInfo.getRange();\n        RangePartitionInfo partitionInfo = (RangePartitionInfo) table.getPartitionInfo();\n        if (partitionInfo.getAnyIntersectRange(recoverRange, false) != null) {\n            throw new DdlException(\"Can not recover partition[\" + partitionName + \"]. Range conflict.\");\n        }\n\n        \r\n        Partition recoverPartition = recoverPartitionInfo.getPartition();\n        Preconditions.checkState(recoverPartition.getName().equalsIgnoreCase(partitionName));\n        table.addPartition(recoverPartition);\n        \n        \r\n        long partitionId = recoverPartition.getId();\n        partitionInfo.setRange(partitionId, false, recoverRange);\n        partitionInfo.setDataProperty(partitionId, recoverPartitionInfo.getDataProperty());\n        partitionInfo.setReplicationNum(partitionId, recoverPartitionInfo.getReplicationNum());\n        partitionInfo.setIsInMemory(partitionId, recoverPartitionInfo.isInMemory());\n\n        \r\n        idToPartition.remove(partitionId);\n        idToRecycleTime.remove(partitionId);\n\n        \r\n        RecoverInfo recoverInfo = new RecoverInfo(dbId, table.getId(), partitionId);\n        Catalog.getCurrentCatalog().getEditLog().logRecoverPartition(recoverInfo);\n        LOG.info(\"recover partition[{}]\", partitionId);\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/catalog/CatalogRecycleBin.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":500,"status":"B"},{"authorDate":"2020-07-21 12:42:42","commitOrder":1,"curCode":"    public synchronized void replayRecoverPartition(OlapTable table, long partitionId) {\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n            if (partitionInfo.getPartition().getId() != partitionId) {\n                continue;\n            }\n\n            Preconditions.checkState(partitionInfo.getTableId() == table.getId());\n\n            table.addPartition(partitionInfo.getPartition());\n            RangePartitionInfo rangePartitionInfo = (RangePartitionInfo) table.getPartitionInfo();\n            rangePartitionInfo.setRange(partitionId, false, partitionInfo.getRange());\n            rangePartitionInfo.setDataProperty(partitionId, partitionInfo.getDataProperty());\n            rangePartitionInfo.setReplicationNum(partitionId, partitionInfo.getReplicationNum());\n            rangePartitionInfo.setIsInMemory(partitionId, partitionInfo.isInMemory());\n\n            iterator.remove();\n            idToRecycleTime.remove(partitionId);\n\n            LOG.info(\"replay recover partition[{}]\", partitionId);\n            break;\n        }\n    }\n","date":"2020-07-21 12:42:42","endLine":579,"groupId":"1240","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"replayRecoverPartition","params":"(OlapTabletable@longpartitionId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/ed/993b54a656543c5c8a8d812fbc3a68ea3cfb55.src","preCode":"    public synchronized void replayRecoverPartition(OlapTable table, long partitionId) {\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n            if (partitionInfo.getPartition().getId() != partitionId) {\n                continue;\n            }\n\n            Preconditions.checkState(partitionInfo.getTableId() == table.getId());\n\n            table.addPartition(partitionInfo.getPartition());\n            RangePartitionInfo rangePartitionInfo = (RangePartitionInfo) table.getPartitionInfo();\n            rangePartitionInfo.setRange(partitionId, false, partitionInfo.getRange());\n            rangePartitionInfo.setDataProperty(partitionId, partitionInfo.getDataProperty());\n            rangePartitionInfo.setReplicationNum(partitionId, partitionInfo.getReplicationNum());\n            rangePartitionInfo.setIsInMemory(partitionId, partitionInfo.isInMemory());\n\n            iterator.remove();\n            idToRecycleTime.remove(partitionId);\n\n            LOG.info(\"replay recover partition[{}]\", partitionId);\n            break;\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/catalog/CatalogRecycleBin.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":555,"status":"B"}],"commitId":"ad17afef9139a9aeedeb2e92638e95886d515f14","commitMessage":"@@@[CodeRefactor] #4098 Make FE multi module (#4099)\n\nThis PR change the FE code structure to maven multi module structure. \nSee ISSUE: #4098 for more info.  such as How to resolve conflicts.","date":"2020-07-21 12:42:42","modifiedFileCount":"0","status":"B","submitter":"Mingyu Chen"},{"authorTime":"2021-04-24 17:42:27","codes":[{"authorDate":"2021-04-24 17:42:27","commitOrder":2,"curCode":"    public synchronized void recoverPartition(long dbId, OlapTable table, String partitionName) throws DdlException {\n        \r\n        RecyclePartitionInfo recoverPartitionInfo = null;\n\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n\n            if (partitionInfo.getTableId() != table.getId()) {\n                continue;\n            }\n\n            if (!partitionInfo.getPartition().getName().equalsIgnoreCase(partitionName)) {\n                continue;\n            }\n\n            recoverPartitionInfo = partitionInfo;\n            break;\n        }\n\n        if (recoverPartitionInfo == null) {\n            throw new DdlException(\"No partition named \" + partitionName + \" in table \" + table.getName());\n        }\n\n        PartitionInfo partitionInfo = table.getPartitionInfo();\n        Range<PartitionKey> recoverRange = recoverPartitionInfo.getRange();\n        PartitionItem recoverItem = null;\n        if (partitionInfo.getType() == PartitionType.RANGE) {\n            recoverItem = new RangePartitionItem(recoverRange);\n        } else if (partitionInfo.getType() == PartitionType.LIST) {\n            recoverItem = recoverPartitionInfo.getListPartitionItem();;\n        }\n        \r\n        if (partitionInfo.getAnyIntersectItem(recoverItem, false) != null) {\n            throw new DdlException(\"Can not recover partition[\" + partitionName + \"]. Partition item conflict.\");\n        }\n\n        \r\n        Partition recoverPartition = recoverPartitionInfo.getPartition();\n        Preconditions.checkState(recoverPartition.getName().equalsIgnoreCase(partitionName));\n        table.addPartition(recoverPartition);\n\n        \r\n        long partitionId = recoverPartition.getId();\n        partitionInfo.setItem(partitionId, false, recoverItem);\n        partitionInfo.setDataProperty(partitionId, recoverPartitionInfo.getDataProperty());\n        partitionInfo.setReplicationNum(partitionId, recoverPartitionInfo.getReplicationNum());\n        partitionInfo.setIsInMemory(partitionId, recoverPartitionInfo.isInMemory());\n\n        \r\n        idToPartition.remove(partitionId);\n        idToRecycleTime.remove(partitionId);\n\n        \r\n        RecoverInfo recoverInfo = new RecoverInfo(dbId, table.getId(), partitionId);\n        Catalog.getCurrentCatalog().getEditLog().logRecoverPartition(recoverInfo);\n        LOG.info(\"recover partition[{}]\", partitionId);\n    }\n","date":"2021-04-24 17:42:27","endLine":464,"groupId":"557","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"recoverPartition","params":"(longdbId@OlapTabletable@StringpartitionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/bd/ee43118b9d219ec309723c24bd479eed03c097.src","preCode":"    public synchronized void recoverPartition(long dbId, OlapTable table, String partitionName) throws DdlException {\n        \r\n        RecyclePartitionInfo recoverPartitionInfo = null;\n\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n\n            if (partitionInfo.getTableId() != table.getId()) {\n                continue;\n            }\n\n            if (!partitionInfo.getPartition().getName().equalsIgnoreCase(partitionName)) {\n                continue;\n            }\n\n            recoverPartitionInfo = partitionInfo;\n            break;\n        }\n\n        if (recoverPartitionInfo == null) {\n            throw new DdlException(\"No partition named \" + partitionName + \" in table \" + table.getName());\n        }\n        \n        \r\n        Range<PartitionKey> recoverRange = recoverPartitionInfo.getRange();\n        RangePartitionInfo partitionInfo = (RangePartitionInfo) table.getPartitionInfo();\n        if (partitionInfo.getAnyIntersectRange(recoverRange, false) != null) {\n            throw new DdlException(\"Can not recover partition[\" + partitionName + \"]. Range conflict.\");\n        }\n\n        \r\n        Partition recoverPartition = recoverPartitionInfo.getPartition();\n        Preconditions.checkState(recoverPartition.getName().equalsIgnoreCase(partitionName));\n        table.addPartition(recoverPartition);\n        \n        \r\n        long partitionId = recoverPartition.getId();\n        partitionInfo.setRange(partitionId, false, recoverRange);\n        partitionInfo.setDataProperty(partitionId, recoverPartitionInfo.getDataProperty());\n        partitionInfo.setReplicationNum(partitionId, recoverPartitionInfo.getReplicationNum());\n        partitionInfo.setIsInMemory(partitionId, recoverPartitionInfo.isInMemory());\n\n        \r\n        idToPartition.remove(partitionId);\n        idToRecycleTime.remove(partitionId);\n\n        \r\n        RecoverInfo recoverInfo = new RecoverInfo(dbId, table.getId(), partitionId);\n        Catalog.getCurrentCatalog().getEditLog().logRecoverPartition(recoverInfo);\n        LOG.info(\"recover partition[{}]\", partitionId);\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/catalog/CatalogRecycleBin.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":406,"status":"M"},{"authorDate":"2021-04-24 17:42:27","commitOrder":2,"curCode":"    public synchronized void replayRecoverPartition(OlapTable table, long partitionId) {\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo recyclePartitionInfo = entry.getValue();\n            if (recyclePartitionInfo.getPartition().getId() != partitionId) {\n                continue;\n            }\n\n            Preconditions.checkState(recyclePartitionInfo.getTableId() == table.getId());\n\n            table.addPartition(recyclePartitionInfo.getPartition());\n            PartitionInfo partitionInfo = table.getPartitionInfo();\n            PartitionItem recoverItem = null;\n            if (partitionInfo.getType() == PartitionType.RANGE) {\n                recoverItem = new RangePartitionItem(recyclePartitionInfo.getRange());\n            } else if (partitionInfo.getType() == PartitionType.LIST) {\n                recoverItem = recyclePartitionInfo.getListPartitionItem();\n            }\n            partitionInfo.setItem(partitionId, false, recoverItem);\n            partitionInfo.setDataProperty(partitionId, recyclePartitionInfo.getDataProperty());\n            partitionInfo.setReplicationNum(partitionId, recyclePartitionInfo.getReplicationNum());\n            partitionInfo.setIsInMemory(partitionId, recyclePartitionInfo.isInMemory());\n\n            iterator.remove();\n            idToRecycleTime.remove(partitionId);\n\n            LOG.info(\"replay recover partition[{}]\", partitionId);\n            break;\n        }\n    }\n","date":"2021-04-24 17:42:27","endLine":497,"groupId":"560","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"replayRecoverPartition","params":"(OlapTabletable@longpartitionId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/bd/ee43118b9d219ec309723c24bd479eed03c097.src","preCode":"    public synchronized void replayRecoverPartition(OlapTable table, long partitionId) {\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n            if (partitionInfo.getPartition().getId() != partitionId) {\n                continue;\n            }\n\n            Preconditions.checkState(partitionInfo.getTableId() == table.getId());\n\n            table.addPartition(partitionInfo.getPartition());\n            RangePartitionInfo rangePartitionInfo = (RangePartitionInfo) table.getPartitionInfo();\n            rangePartitionInfo.setRange(partitionId, false, partitionInfo.getRange());\n            rangePartitionInfo.setDataProperty(partitionId, partitionInfo.getDataProperty());\n            rangePartitionInfo.setReplicationNum(partitionId, partitionInfo.getReplicationNum());\n            rangePartitionInfo.setIsInMemory(partitionId, partitionInfo.isInMemory());\n\n            iterator.remove();\n            idToRecycleTime.remove(partitionId);\n\n            LOG.info(\"replay recover partition[{}]\", partitionId);\n            break;\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/catalog/CatalogRecycleBin.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":467,"status":"M"}],"commitId":"de87f4ae840c1a527379c046d7f01afb2e2d7dcc","commitMessage":"@@@[Feature] Add list partition support (#5529)\n\nAdd list partition support","date":"2021-04-24 17:42:27","modifiedFileCount":"48","status":"M","submitter":"qiye"},{"authorTime":"2021-09-04 10:59:35","codes":[{"authorDate":"2021-09-04 10:59:35","commitOrder":3,"curCode":"    public synchronized void recoverPartition(long dbId, OlapTable table, String partitionName) throws DdlException {\n        \r\n        RecyclePartitionInfo recoverPartitionInfo = null;\n\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n\n            if (partitionInfo.getTableId() != table.getId()) {\n                continue;\n            }\n\n            if (!partitionInfo.getPartition().getName().equalsIgnoreCase(partitionName)) {\n                continue;\n            }\n\n            recoverPartitionInfo = partitionInfo;\n            break;\n        }\n\n        if (recoverPartitionInfo == null) {\n            throw new DdlException(\"No partition named \" + partitionName + \" in table \" + table.getName());\n        }\n\n        PartitionInfo partitionInfo = table.getPartitionInfo();\n        Range<PartitionKey> recoverRange = recoverPartitionInfo.getRange();\n        PartitionItem recoverItem = null;\n        if (partitionInfo.getType() == PartitionType.RANGE) {\n            recoverItem = new RangePartitionItem(recoverRange);\n        } else if (partitionInfo.getType() == PartitionType.LIST) {\n            recoverItem = recoverPartitionInfo.getListPartitionItem();;\n        }\n        \r\n        if (partitionInfo.getAnyIntersectItem(recoverItem, false) != null) {\n            throw new DdlException(\"Can not recover partition[\" + partitionName + \"]. Partition item conflict.\");\n        }\n\n        \r\n        Partition recoverPartition = recoverPartitionInfo.getPartition();\n        Preconditions.checkState(recoverPartition.getName().equalsIgnoreCase(partitionName));\n        table.addPartition(recoverPartition);\n\n        \r\n        long partitionId = recoverPartition.getId();\n        partitionInfo.setItem(partitionId, false, recoverItem);\n        partitionInfo.setDataProperty(partitionId, recoverPartitionInfo.getDataProperty());\n        partitionInfo.setReplicaAllocation(partitionId, recoverPartitionInfo.getReplicaAlloc());\n        partitionInfo.setIsInMemory(partitionId, recoverPartitionInfo.isInMemory());\n\n        \r\n        idToPartition.remove(partitionId);\n        idToRecycleTime.remove(partitionId);\n\n        \r\n        RecoverInfo recoverInfo = new RecoverInfo(dbId, table.getId(), partitionId);\n        Catalog.getCurrentCatalog().getEditLog().logRecoverPartition(recoverInfo);\n        LOG.info(\"recover partition[{}]\", partitionId);\n    }\n","date":"2021-09-04 10:59:35","endLine":463,"groupId":"101400","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"recoverPartition","params":"(longdbId@OlapTabletable@StringpartitionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/5d/5e90306a07dcacb4f8121e503e452623ec33ca.src","preCode":"    public synchronized void recoverPartition(long dbId, OlapTable table, String partitionName) throws DdlException {\n        \r\n        RecyclePartitionInfo recoverPartitionInfo = null;\n\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo partitionInfo = entry.getValue();\n\n            if (partitionInfo.getTableId() != table.getId()) {\n                continue;\n            }\n\n            if (!partitionInfo.getPartition().getName().equalsIgnoreCase(partitionName)) {\n                continue;\n            }\n\n            recoverPartitionInfo = partitionInfo;\n            break;\n        }\n\n        if (recoverPartitionInfo == null) {\n            throw new DdlException(\"No partition named \" + partitionName + \" in table \" + table.getName());\n        }\n\n        PartitionInfo partitionInfo = table.getPartitionInfo();\n        Range<PartitionKey> recoverRange = recoverPartitionInfo.getRange();\n        PartitionItem recoverItem = null;\n        if (partitionInfo.getType() == PartitionType.RANGE) {\n            recoverItem = new RangePartitionItem(recoverRange);\n        } else if (partitionInfo.getType() == PartitionType.LIST) {\n            recoverItem = recoverPartitionInfo.getListPartitionItem();;\n        }\n        \r\n        if (partitionInfo.getAnyIntersectItem(recoverItem, false) != null) {\n            throw new DdlException(\"Can not recover partition[\" + partitionName + \"]. Partition item conflict.\");\n        }\n\n        \r\n        Partition recoverPartition = recoverPartitionInfo.getPartition();\n        Preconditions.checkState(recoverPartition.getName().equalsIgnoreCase(partitionName));\n        table.addPartition(recoverPartition);\n\n        \r\n        long partitionId = recoverPartition.getId();\n        partitionInfo.setItem(partitionId, false, recoverItem);\n        partitionInfo.setDataProperty(partitionId, recoverPartitionInfo.getDataProperty());\n        partitionInfo.setReplicationNum(partitionId, recoverPartitionInfo.getReplicationNum());\n        partitionInfo.setIsInMemory(partitionId, recoverPartitionInfo.isInMemory());\n\n        \r\n        idToPartition.remove(partitionId);\n        idToRecycleTime.remove(partitionId);\n\n        \r\n        RecoverInfo recoverInfo = new RecoverInfo(dbId, table.getId(), partitionId);\n        Catalog.getCurrentCatalog().getEditLog().logRecoverPartition(recoverInfo);\n        LOG.info(\"recover partition[{}]\", partitionId);\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/catalog/CatalogRecycleBin.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":405,"status":"M"},{"authorDate":"2021-09-04 10:59:35","commitOrder":3,"curCode":"    public synchronized void replayRecoverPartition(OlapTable table, long partitionId) {\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo recyclePartitionInfo = entry.getValue();\n            if (recyclePartitionInfo.getPartition().getId() != partitionId) {\n                continue;\n            }\n\n            Preconditions.checkState(recyclePartitionInfo.getTableId() == table.getId());\n\n            table.addPartition(recyclePartitionInfo.getPartition());\n            PartitionInfo partitionInfo = table.getPartitionInfo();\n            PartitionItem recoverItem = null;\n            if (partitionInfo.getType() == PartitionType.RANGE) {\n                recoverItem = new RangePartitionItem(recyclePartitionInfo.getRange());\n            } else if (partitionInfo.getType() == PartitionType.LIST) {\n                recoverItem = recyclePartitionInfo.getListPartitionItem();\n            }\n            partitionInfo.setItem(partitionId, false, recoverItem);\n            partitionInfo.setDataProperty(partitionId, recyclePartitionInfo.getDataProperty());\n            partitionInfo.setReplicaAllocation(partitionId, recyclePartitionInfo.getReplicaAlloc());\n            partitionInfo.setIsInMemory(partitionId, recyclePartitionInfo.isInMemory());\n\n            iterator.remove();\n            idToRecycleTime.remove(partitionId);\n\n            LOG.info(\"replay recover partition[{}]\", partitionId);\n            break;\n        }\n    }\n","date":"2021-09-04 10:59:35","endLine":496,"groupId":"101400","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"replayRecoverPartition","params":"(OlapTabletable@longpartitionId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/5d/5e90306a07dcacb4f8121e503e452623ec33ca.src","preCode":"    public synchronized void replayRecoverPartition(OlapTable table, long partitionId) {\n        Iterator<Map.Entry<Long, RecyclePartitionInfo>> iterator = idToPartition.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<Long, RecyclePartitionInfo> entry = iterator.next();\n            RecyclePartitionInfo recyclePartitionInfo = entry.getValue();\n            if (recyclePartitionInfo.getPartition().getId() != partitionId) {\n                continue;\n            }\n\n            Preconditions.checkState(recyclePartitionInfo.getTableId() == table.getId());\n\n            table.addPartition(recyclePartitionInfo.getPartition());\n            PartitionInfo partitionInfo = table.getPartitionInfo();\n            PartitionItem recoverItem = null;\n            if (partitionInfo.getType() == PartitionType.RANGE) {\n                recoverItem = new RangePartitionItem(recyclePartitionInfo.getRange());\n            } else if (partitionInfo.getType() == PartitionType.LIST) {\n                recoverItem = recyclePartitionInfo.getListPartitionItem();\n            }\n            partitionInfo.setItem(partitionId, false, recoverItem);\n            partitionInfo.setDataProperty(partitionId, recyclePartitionInfo.getDataProperty());\n            partitionInfo.setReplicationNum(partitionId, recyclePartitionInfo.getReplicationNum());\n            partitionInfo.setIsInMemory(partitionId, recyclePartitionInfo.isInMemory());\n\n            iterator.remove();\n            idToRecycleTime.remove(partitionId);\n\n            LOG.info(\"replay recover partition[{}]\", partitionId);\n            break;\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/catalog/CatalogRecycleBin.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":466,"status":"M"}],"commitId":"7db8841ae264012f37bb929b0f7ba6ffefe703c8","commitMessage":"@@@[Feature][ResourceTag] Support Resource Tag (#6203)\n\n#5902 \nThis CL mainly changes:\n\n1. Support setting tags for BE nodes:\n\n    ```\n    alter system add backend \"1272:9050.  1212:9050\" properties(\"tag.location\": \"zoneA\");\n    alter system modify backend \"1272:9050.  1212:9050\" set (\"tag.location\": \"zoneB\");\n    ```\n    And for compatibility.  all BE nodes will be set a \"default\" tag when upgrading: `\"tag.location\": \"default\"`.\n\n2. Create a new class `ReplicaAllocation` to replace the previous `replication_num`.\n\n    `ReplicaAllocation` represents the allocation of the replicas of a tablet. It contains a map from \n    Tag to number of replicas.\n    For example.  if user set a table's replication num to 3.  it will be converted to a ReplicaAllocation\n    like: `\"tag.location.default\" : \"3\"`.  which means the tablet will have 3 replicas and all of them will be\n    allocated in BE nodes with tag \"default\";\n\n3. Support create table with replication allocation:\n\n    ```\n    CREATE TABLE example_db.table_hash\n    (\n    k1 TINYINT\n    )\n    DISTRIBUTED BY HASH(k1) BUCKETS 32\n    PROPERTIES (\n        \"replication_allocation\"=\"tag.location.zone1:1.  tag.location.zone2:2\"\n    );\n    ```\n    \n    Also support set replica allocation for dynamic tables.  and modify replica allocation at runtime.\n\n    For compatibility.  user can still set \"replication_num\" = \"3\".  and it will be automatically converted to:\n    ` \"replication_allocation\"=\"tag.location.default:3\"`\n\n4. Support tablet repair and balance based on Tag\n\n    1. For tablets of non-colocate table.  most of the logic is the same as before. \n       but when selecting the destination node for clone.  the tag of the node will be considered.\n       If the required tag does not exist.  it cannot be repaired.\n       Similarly.  under the condition of ensuring that the replicas are complete.  the tablet will be\n       reallocated according to the tag or the replicas will be balanced.\n\n       Balancing is performed separately within each resource group.\n\n    2. For tablets of colocate table.  the backends sequence of buckets will be splitted by tag.\n       For example.  if replica allocation is \"tag.location.zone1:1.  tag.location.zone2:2\". \n\n       And zone1 has 2 BE: A.  B; zone2 has 3 BE: C.  D.  F\n\n       there will be 2 backend sequences: one is for zone1.  and the other is for zone2.\n       And one posible seqeunces will be:\n\n\n       zone1: [A]   [B]   [A]   [B]\n       zone2: [C.  D][D.  F][F.  C][C.  D]\n\n5. Support setting tags for user and restrict execution node with tags:\n\n\n    ```\n    set property for 'cmy' 'resource_tags.location' : 'zone1.  zone2';\n    ```\n\n    After setting.  the user 'cmy' can only query data stored on backends with tag zone1 and zone2. \n    And query can only be executed on backends with tag zone1 and zone2\n\n\n    For compatibility.  after upgrading.  the property `resource_tags.location` will be empty. \n    so that user can still query data stored on any backends.\n\n6. Modify the Unit test frame of FE so that we can created multi backends with different mocked IP in unit test.\n\n    This help us to easily test some distributed cases like query.  tablet repair and balance\n\nThe document will be added in another PR.\n\nAlso fix a bug described in #6194 ","date":"2021-09-04 10:59:35","modifiedFileCount":"161","status":"M","submitter":"Mingyu Chen"}]
