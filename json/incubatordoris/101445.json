[{"authorTime":"2020-07-21 12:42:42","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":1,"curCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","date":"2020-07-21 12:42:42","endLine":121,"groupId":"4005","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"sendResponsePacket","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"B"},{"authorDate":"2020-07-21 12:42:42","commitOrder":1,"curCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","date":"2020-07-21 12:42:42","endLine":189,"groupId":"2096","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"negotiate","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"B"}],"commitId":"ad17afef9139a9aeedeb2e92638e95886d515f14","commitMessage":"@@@[CodeRefactor] #4098 Make FE multi module (#4099)\n\nThis PR change the FE code structure to maven multi module structure. \nSee ISSUE: #4098 for more info.  such as How to resolve conflicts.","date":"2020-07-21 12:42:42","modifiedFileCount":"0","status":"B","submitter":"Mingyu Chen"},{"authorTime":"2021-02-06 23:14:26","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":2,"curCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","date":"2020-07-21 12:42:42","endLine":121,"groupId":"4005","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"sendResponsePacket","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"},{"authorDate":"2021-02-06 23:14:26","commitOrder":2,"curCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.warn(\"Send and flush channel exception, ignore. Exception: \" + e.toString());\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","date":"2021-02-06 23:14:26","endLine":194,"groupId":"2096","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"negotiate","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/7c/6c1a42693855983faab42e908ede3238cec18d.src","preCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"4ce6f49c0f6df9326d207e4a80da6680fcdaae29","commitMessage":"@@@[LOG] Reduce verbose exception log by catch exceptions (#5229)\n\nIn our product environment.  we use LVS to dispatch requests to FEs. \nhowever.  LVS will send probes to check whether FE is alive.  and will\nclose the connection immediately. It will cause much verbose log. \nthis patch aim to reduce these log by catch related exceptions.","date":"2021-02-06 23:14:26","modifiedFileCount":"3","status":"M","submitter":"Yingchun Lai"},{"authorTime":"2021-02-16 22:47:53","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":3,"curCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","date":"2020-07-21 12:42:42","endLine":121,"groupId":"4005","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"sendResponsePacket","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"},{"authorDate":"2021-02-16 22:47:53","commitOrder":3,"curCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.warn(\"Send and flush channel exception, ignore. Exception: \" + e.toString());\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n            \r\n            serializer.reset();\n            \r\n            handshakePacket.buildAuthSwitchRequest(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                \r\n                return false;\n            }\n            \r\n            \r\n            authPacket.setAuthResponse(readEofString(authSwitchResponse));\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","date":"2021-02-16 22:47:53","endLine":219,"groupId":"2096","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"negotiate","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/c6/08948d10a54c7979b0c3dbabf382a50bbecbaa.src","preCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.warn(\"Send and flush channel exception, ignore. Exception: \" + e.toString());\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"a7d16acaac3e1baf227c801110863c07b7f0223d","commitMessage":"@@@[MySQL] Support for AuthSwitchRequest In HandShakePacket to better support MySQL 8.0 clients (#5386)\n\nissue:5348","date":"2021-02-16 22:47:53","modifiedFileCount":"3","status":"M","submitter":"HappenLee"},{"authorTime":"2021-03-30 19:50:42","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":4,"curCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","date":"2020-07-21 12:42:42","endLine":121,"groupId":"4005","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"sendResponsePacket","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"},{"authorDate":"2021-03-30 19:50:42","commitOrder":4,"curCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.debug(\"Send and flush channel exception, ignore.\", e);\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n            \r\n            serializer.reset();\n            \r\n            handshakePacket.buildAuthSwitchRequest(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                \r\n                return false;\n            }\n            \r\n            \r\n            authPacket.setAuthResponse(readEofString(authSwitchResponse));\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","date":"2021-03-30 19:50:42","endLine":219,"groupId":"2096","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"negotiate","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/31/20eab64860473f4f5824b027888b0a64b36a7b.src","preCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.warn(\"Send and flush channel exception, ignore. Exception: \" + e.toString());\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n            \r\n            serializer.reset();\n            \r\n            handshakePacket.buildAuthSwitchRequest(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                \r\n                return false;\n            }\n            \r\n            \r\n            authPacket.setAuthResponse(readEofString(authSwitchResponse));\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"0490b156c862963bb1dfb05ba5e976ac59b31132","commitMessage":"@@@[Bug] Fix bug that call frontend service failed when rpc_timeout is equal with publish_timeout (#5564)\n\n* [Bug] Fix bug that call frontend service failed when rpc_timeout is equal with publish_timeout\n\n*This PR is to fix bug that call frontend service failed when rpc_timeout is equal with publish_timeout and fix some small issues with log\n\nCo-authored-by: caiconghui [???] <caiconghui@xiaomi.com>","date":"2021-03-30 19:50:42","modifiedFileCount":"5","status":"M","submitter":"caiconghui"},{"authorTime":"2021-05-05 10:19:50","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":5,"curCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","date":"2020-07-21 12:42:42","endLine":121,"groupId":"4005","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"sendResponsePacket","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"},{"authorDate":"2021-05-05 10:19:50","commitOrder":5,"curCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.debug(\"Send and flush channel exception, ignore.\", e);\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (authPacket.getCapability().isPluginAuth() &&\n                !handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n            \r\n            serializer.reset();\n            \r\n            handshakePacket.buildAuthSwitchRequest(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                \r\n                return false;\n            }\n            \r\n            \r\n            authPacket.setAuthResponse(readEofString(authSwitchResponse));\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","date":"2021-05-05 10:19:50","endLine":222,"groupId":"0","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"negotiate","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/5a/a9eb234c903dd65261c7a80ff350b1e04ef8b8.src","preCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.debug(\"Send and flush channel exception, ignore.\", e);\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n            \r\n            serializer.reset();\n            \r\n            handshakePacket.buildAuthSwitchRequest(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                \r\n                return false;\n            }\n            \r\n            \r\n            authPacket.setAuthResponse(readEofString(authSwitchResponse));\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"04d12fbb003297424d3ad9ad98afdfdbb37fe18f","commitMessage":"@@@[Bug] Optimize querying from PostgreSQL and MySQL compatibility (#5741)\n\n1. Use the param `UseDeclareFetch` to fix the memory consumption of PostgreSQL Driver\n2. Fix the bug of mysql client 5.1 query failed Doris","date":"2021-05-05 10:19:50","modifiedFileCount":"2","status":"M","submitter":"HappenLee"},{"authorTime":"2021-07-30 09:24:50","codes":[{"authorDate":"2020-07-21 12:42:42","commitOrder":6,"curCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","date":"2020-07-21 12:42:42","endLine":121,"groupId":"101445","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"sendResponsePacket","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/11/b67d63ad28dadbeaeffb94d468e9e79a066fe9.src","preCode":"    public static void sendResponsePacket(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        MysqlPacket packet = context.getState().toResponsePacket();\n\n        \r\n        serializer.reset();\n        packet.writeTo(serializer);\n        channel.sendAndFlush(serializer.toByteBuffer());\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"},{"authorDate":"2021-07-30 09:24:50","commitOrder":6,"curCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.debug(\"Send and flush channel exception, ignore.\", e);\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        String qualifiedUser = parseUser(context, authPacket.getAuthResponse(), authPacket.getUser());\n        if (qualifiedUser == null) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        boolean useLdapAuthenticate;\n        try {\n            useLdapAuthenticate = useLdapAuthenticate(qualifiedUser);\n        } catch (Exception e) {\n            LOG.debug(\"Check if user exists in ldap error.\", e);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        if (useLdapAuthenticate) {\n            LOG.debug(\"user:{} start to ldap authenticate.\", qualifiedUser);\n            \r\n            \r\n            serializer.reset();\n            MysqlAuthSwitchPacket mysqlAuthSwitchPacket = new MysqlAuthSwitchPacket();\n            mysqlAuthSwitchPacket.writeTo(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                return false;\n            }\n            MysqlClearTextPacket clearTextPacket = new MysqlClearTextPacket();\n            if (!clearTextPacket.readFrom(authSwitchResponse)) {\n                ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n                sendResponsePacket(context);\n                return false;\n            }\n            if (!LdapAuthenticate.authenticate(context, clearTextPacket.getPassword(), qualifiedUser)) {\n                sendResponsePacket(context);\n                return false;\n            }\n        } else {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (authPacket.getCapability().isPluginAuth() &&\n                    !handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n                \r\n                serializer.reset();\n                \r\n                handshakePacket.buildAuthSwitchRequest(serializer);\n                channel.sendAndFlush(serializer.toByteBuffer());\n                \r\n                ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n                if (authSwitchResponse == null) {\n                    \r\n                    return false;\n                }\n                \r\n                \r\n                authPacket.setAuthResponse(readEofString(authSwitchResponse));\n            }\n\n            \r\n            byte[] randomString = handshakePacket.getAuthPluginData();\n            if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n                randomString = authPacket.getRandomString();\n            }\n            \r\n            if (!authenticate(context, authPacket.getAuthResponse(), randomString, qualifiedUser)) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","date":"2021-07-30 09:24:50","endLine":290,"groupId":"101445","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"negotiate","params":"(ConnectContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/12/f53c35f168637dc4b3c4f5496761bd36606f2c.src","preCode":"    public static boolean negotiate(ConnectContext context) throws IOException {\n        MysqlSerializer serializer = context.getSerializer();\n        MysqlChannel channel = context.getMysqlChannel();\n        context.getState().setOk();\n\n        \r\n        serializer.reset();\n        MysqlHandshakePacket handshakePacket = new MysqlHandshakePacket(context.getConnectionId());\n        handshakePacket.writeTo(serializer);\n        try {\n            channel.sendAndFlush(serializer.toByteBuffer());\n        } catch (IOException e) {\n            LOG.debug(\"Send and flush channel exception, ignore.\", e);\n            return false;\n        }\n        \r\n        ByteBuffer handshakeResponse = channel.fetchOnePacket();\n        if (handshakeResponse == null) {\n            \r\n            return false;\n        }\n        MysqlAuthPacket authPacket = new MysqlAuthPacket();\n        if (!authPacket.readFrom(handshakeResponse)) {\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        if (!MysqlCapability.isCompatible(context.getServerCapability(), authPacket.getCapability())) {\n            \r\n            ErrorReport.report(ErrorCode.ERR_NOT_SUPPORTED_AUTH_MODE);\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (authPacket.getCapability().isPluginAuth() &&\n                !handshakePacket.checkAuthPluginSameAsDoris(authPacket.getPluginName())) {\n            \r\n            serializer.reset();\n            \r\n            handshakePacket.buildAuthSwitchRequest(serializer);\n            channel.sendAndFlush(serializer.toByteBuffer());\n            \r\n            ByteBuffer authSwitchResponse = channel.fetchOnePacket();\n            if (authSwitchResponse == null) {\n                \r\n                return false;\n            }\n            \r\n            \r\n            authPacket.setAuthResponse(readEofString(authSwitchResponse));\n        }\n\n        \r\n        context.setCapability(context.getServerCapability());\n        serializer.setCapability(context.getCapability());\n\n        \r\n        byte[] randomString = handshakePacket.getAuthPluginData();\n        if (Config.proxy_auth_enable && authPacket.getRandomString() != null) {\n            randomString = authPacket.getRandomString();\n        }\n        \r\n        if (!authenticate(context, authPacket.getAuthResponse(), randomString, authPacket.getUser())) {\n            sendResponsePacket(context);\n            return false;\n        }\n\n        \r\n        String db = authPacket.getDb();\n        if (!Strings.isNullOrEmpty(db)) {\n            try {\n                String dbFullName = ClusterNamespace.getFullName(context.getClusterName(), db);\n                Catalog.getCurrentCatalog().changeDb(context, dbFullName);\n            } catch (DdlException e) {\n                sendResponsePacket(context);\n                return false;\n            }\n        }\n        return true;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/mysql/MysqlProto.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"}],"commitId":"9ca369aa58ef6215e2c79b14fc1b4edfc2e2d720","commitMessage":"@@@[Feature][LDAP] Add LDAP authentication login and LDAP group authorization support. (#6333)\n\n* [Feature][LDAP] Add LDAP authentication login and LDAP group authorization support.\n\n* Update docs/.vuepress/sidebar/en.js\n\nCo-authored-by: Mingyu Chen <morningman.cmy@gmail.com>\n\nCo-authored-by: Mingyu Chen <morningman.cmy@gmail.com>","date":"2021-07-30 09:24:50","modifiedFileCount":"14","status":"M","submitter":"luozenglin"}]
