[{"authorTime":"2020-10-25 17:17:56","codes":[{"authorDate":"2021-01-13 10:27:58","commitOrder":2,"curCode":"    private boolean processAlterOlapTable(AlterTableStmt stmt, OlapTable olapTable, List<AlterClause> alterClauses,\n                                         final String clusterName, Database db) throws UserException {\n        stmt.rewriteAlterClause(olapTable);\n\n        \r\n        alterClauses.addAll(stmt.getOps());\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        \r\n        if (currentAlterOps.needCheckCapacity()) {\n            Catalog.getCurrentSystemInfo().checkClusterCapacity(clusterName);\n            db.checkQuota();\n        }\n\n        if (olapTable.getState() != OlapTableState.NORMAL) {\n            throw new DdlException(\n                    \"Table[\" + olapTable.getName() + \"]'s state is not NORMAL. Do not allow doing ALTER ops\");\n        }\n\n        boolean needProcessOutsideTableLock = false;\n        if (currentAlterOps.hasSchemaChangeOp()) {\n            \r\n            schemaChangeHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasRollupOp()) {\n            materializedViewHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasPartitionOp()) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            olapTable.writeLock();\n            try {\n                if (alterClause instanceof DropPartitionClause) {\n                    if (!((DropPartitionClause) alterClause).isTempPartition()) {\n                        DynamicPartitionUtil.checkAlterAllowed(olapTable);\n                    }\n                    Catalog.getCurrentCatalog().dropPartition(db, olapTable, ((DropPartitionClause) alterClause));\n                } else if (alterClause instanceof ReplacePartitionClause) {\n                    Catalog.getCurrentCatalog().replaceTempPartition(db, olapTable, (ReplacePartitionClause) alterClause);\n                } else if (alterClause instanceof ModifyPartitionClause) {\n                    ModifyPartitionClause clause = ((ModifyPartitionClause) alterClause);\n                    \r\n                    if (clause.isNeedExpand()) {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        partitionNames.clear();\n                        for (Partition partition : olapTable.getPartitions()) {\n                            partitionNames.add(partition.getName());\n                        }\n                    }\n                    Map<String, String> properties = clause.getProperties();\n                    if (properties.containsKey(PropertyAnalyzer.PROPERTIES_INMEMORY)) {\n                        needProcessOutsideTableLock = true;\n                    } else {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        modifyPartitionsProperty(db, olapTable, partitionNames, properties);\n                    }\n                } else if (alterClause instanceof AddPartitionClause) {\n                    needProcessOutsideTableLock = true;\n                } else {\n                    throw new DdlException(\"Invalid alter operation: \" + alterClause.getOpType());\n                }\n            } finally {\n                olapTable.writeUnlock();\n            }\n        } else if (currentAlterOps.hasRenameOp()) {\n            processRename(db, olapTable, alterClauses);\n        } else if (currentAlterOps.hasReplaceTableOp()) {\n            processReplaceTable(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_PROPERTY_SYNC)) {\n            needProcessOutsideTableLock = true;\n        } else {\n            throw new DdlException(\"Invalid alter operations: \" + currentAlterOps);\n        }\n\n        return needProcessOutsideTableLock;\n    }\n","date":"2021-01-13 10:27:58","endLine":200,"groupId":"1028","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"processAlterOlapTable","params":"(AlterTableStmtstmt@OlapTableolapTable@List<AlterClause>alterClauses@finalStringclusterName@Databasedb)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/0c/b6ab58d17577be3a6187ecf2ff39339c6856e9.src","preCode":"    private boolean processAlterOlapTable(AlterTableStmt stmt, OlapTable olapTable, List<AlterClause> alterClauses,\n                                         final String clusterName, Database db) throws UserException {\n        stmt.rewriteAlterClause(olapTable);\n\n        \r\n        alterClauses.addAll(stmt.getOps());\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        \r\n        if (currentAlterOps.needCheckCapacity()) {\n            Catalog.getCurrentSystemInfo().checkClusterCapacity(clusterName);\n            db.checkQuota();\n        }\n\n        if (olapTable.getState() != OlapTableState.NORMAL) {\n            throw new DdlException(\n                    \"Table[\" + olapTable.getName() + \"]'s state is not NORMAL. Do not allow doing ALTER ops\");\n        }\n\n        boolean needProcessOutsideTableLock = false;\n        if (currentAlterOps.hasSchemaChangeOp()) {\n            \r\n            schemaChangeHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasRollupOp()) {\n            materializedViewHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasPartitionOp()) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            olapTable.writeLock();\n            try {\n                if (alterClause instanceof DropPartitionClause) {\n                    if (!((DropPartitionClause) alterClause).isTempPartition()) {\n                        DynamicPartitionUtil.checkAlterAllowed(olapTable);\n                    }\n                    Catalog.getCurrentCatalog().dropPartition(db, olapTable, ((DropPartitionClause) alterClause));\n                } else if (alterClause instanceof ReplacePartitionClause) {\n                    Catalog.getCurrentCatalog().replaceTempPartition(db, olapTable, (ReplacePartitionClause) alterClause);\n                } else if (alterClause instanceof ModifyPartitionClause) {\n                    ModifyPartitionClause clause = ((ModifyPartitionClause) alterClause);\n                    \r\n                    if (clause.isNeedExpand()) {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        partitionNames.clear();\n                        for (Partition partition : olapTable.getPartitions()) {\n                            partitionNames.add(partition.getName());\n                        }\n                    }\n                    Map<String, String> properties = clause.getProperties();\n                    if (properties.containsKey(PropertyAnalyzer.PROPERTIES_INMEMORY)) {\n                        needProcessOutsideTableLock = true;\n                    } else {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        modifyPartitionsProperty(db, olapTable, partitionNames, properties);\n                    }\n                } else if (alterClause instanceof AddPartitionClause) {\n                    needProcessOutsideTableLock = true;\n                } else {\n                    throw new DdlException(\"Invalid alter operation: \" + alterClause.getOpType());\n                }\n            } finally {\n                olapTable.writeUnlock();\n            }\n        } else if (currentAlterOps.hasRenameOp()) {\n            processRename(db, olapTable, alterClauses);\n        } else if (currentAlterOps.hasReplaceTableOp()) {\n            processReplaceTable(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_PROPERTY_SYNC)) {\n            needProcessOutsideTableLock = true;\n        } else {\n            throw new DdlException(\"Invalid alter operations: \" + currentAlterOps);\n        }\n\n        return needProcessOutsideTableLock;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/alter/Alter.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"MB"},{"authorDate":"2020-10-25 17:17:56","commitOrder":2,"curCode":"    private void processAlterExternalTable(AlterTableStmt stmt, Table externalTable, Database db) throws UserException {\n        stmt.rewriteAlterClause(externalTable);\n\n        \r\n        List<AlterClause> alterClauses = stmt.getOps();\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        if (currentAlterOps.hasRenameOp()) {\n            processRename(db, externalTable, alterClauses);\n        } else if (currentAlterOps.hasSchemaChangeOp()) {\n            schemaChangeHandler.processExternalTable(alterClauses, db, externalTable);\n        }\n    }\n","date":"2020-10-25 17:17:56","endLine":241,"groupId":"7169","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"processAlterExternalTable","params":"(AlterTableStmtstmt@TableexternalTable@Databasedb)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/94/d1bb2fe031e545d4072750f71b60d503b5034a.src","preCode":"    private void processAlterExternalTable(AlterTableStmt stmt, Table externalTable, Database db) throws UserException {\n        stmt.rewriteAlterClause(externalTable);\n\n        \r\n        List<AlterClause> alterClauses = stmt.getOps();\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        if (currentAlterOps.hasRenameOp()) {\n            processRename(db, externalTable, alterClauses);\n        } else if (currentAlterOps.hasSchemaChangeOp()) {\n            schemaChangeHandler.processExternalTable(alterClauses, db, externalTable);\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/alter/Alter.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"NB"}],"commitId":"f7730031b8eca90c150c400c8d67e008290a6f70","commitMessage":"@@@Support read and write lock in table level to reduce lock competition (#3775)\n\nThis PR is to reduce lock competition by supporting read and write lock in table level. When we modify or read table's meta.  we don't need to get database lock.  just get table write or read lock. And when we get database lock.  that means meta directly in db cannot be modified by other thread. Database lock only protect meta in Database class.  while table lock protect meta in Table class.\n\nCo-authored-by: caiconghui [???] <caiconghui@xiaomi.com>","date":"2021-01-13 10:27:58","modifiedFileCount":"108","status":"M","submitter":"caiconghui"},{"authorTime":"2020-10-25 17:17:56","codes":[{"authorDate":"2021-07-12 20:28:40","commitOrder":3,"curCode":"    private boolean processAlterOlapTable(AlterTableStmt stmt, OlapTable olapTable, List<AlterClause> alterClauses,\n                                         final String clusterName, Database db) throws UserException {\n        stmt.rewriteAlterClause(olapTable);\n\n        \r\n        alterClauses.addAll(stmt.getOps());\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        \r\n        if (currentAlterOps.needCheckCapacity()) {\n            Catalog.getCurrentSystemInfo().checkClusterCapacity(clusterName);\n            db.checkQuota();\n        }\n\n        if (olapTable.getState() != OlapTableState.NORMAL) {\n            throw new DdlException(\n                    \"Table[\" + olapTable.getName() + \"]'s state is not NORMAL. Do not allow doing ALTER ops\");\n        }\n\n        boolean needProcessOutsideTableLock = false;\n        if (currentAlterOps.hasSchemaChangeOp()) {\n            \r\n            schemaChangeHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasRollupOp()) {\n            materializedViewHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasPartitionOp()) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            olapTable.writeLock();\n            try {\n                if (alterClause instanceof DropPartitionClause) {\n                    if (!((DropPartitionClause) alterClause).isTempPartition()) {\n                        DynamicPartitionUtil.checkAlterAllowed(olapTable);\n                    }\n                    Catalog.getCurrentCatalog().dropPartition(db, olapTable, ((DropPartitionClause) alterClause));\n                } else if (alterClause instanceof ReplacePartitionClause) {\n                    Catalog.getCurrentCatalog().replaceTempPartition(db, olapTable, (ReplacePartitionClause) alterClause);\n                } else if (alterClause instanceof ModifyPartitionClause) {\n                    ModifyPartitionClause clause = ((ModifyPartitionClause) alterClause);\n                    \r\n                    if (clause.isNeedExpand()) {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        partitionNames.clear();\n                        for (Partition partition : olapTable.getPartitions()) {\n                            partitionNames.add(partition.getName());\n                        }\n                    }\n                    Map<String, String> properties = clause.getProperties();\n                    if (properties.containsKey(PropertyAnalyzer.PROPERTIES_INMEMORY)) {\n                        needProcessOutsideTableLock = true;\n                    } else {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        modifyPartitionsProperty(db, olapTable, partitionNames, properties);\n                    }\n                } else if (alterClause instanceof AddPartitionClause) {\n                    needProcessOutsideTableLock = true;\n                } else {\n                    throw new DdlException(\"Invalid alter operation: \" + alterClause.getOpType());\n                }\n            } finally {\n                olapTable.writeUnlock();\n            }\n        } else if (currentAlterOps.hasRenameOp()) {\n            processRename(db, olapTable, alterClauses);\n        } else if (currentAlterOps.hasReplaceTableOp()) {\n            processReplaceTable(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_PROPERTY_SYNC)) {\n            needProcessOutsideTableLock = true;\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_DISTRIBUTION)) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            Catalog.getCurrentCatalog().modifyDefaultDistributionBucketNum(db, olapTable, (ModifyDistributionClause) alterClause);\n        } else {\n            throw new DdlException(\"Invalid alter operations: \" + currentAlterOps);\n        }\n\n        return needProcessOutsideTableLock;\n    }\n","date":"2021-07-12 20:28:40","endLine":204,"groupId":"1028","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"processAlterOlapTable","params":"(AlterTableStmtstmt@OlapTableolapTable@List<AlterClause>alterClauses@finalStringclusterName@Databasedb)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/a7/391a9547bc256475a1f034ba3b93e31e89886c.src","preCode":"    private boolean processAlterOlapTable(AlterTableStmt stmt, OlapTable olapTable, List<AlterClause> alterClauses,\n                                         final String clusterName, Database db) throws UserException {\n        stmt.rewriteAlterClause(olapTable);\n\n        \r\n        alterClauses.addAll(stmt.getOps());\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        \r\n        if (currentAlterOps.needCheckCapacity()) {\n            Catalog.getCurrentSystemInfo().checkClusterCapacity(clusterName);\n            db.checkQuota();\n        }\n\n        if (olapTable.getState() != OlapTableState.NORMAL) {\n            throw new DdlException(\n                    \"Table[\" + olapTable.getName() + \"]'s state is not NORMAL. Do not allow doing ALTER ops\");\n        }\n\n        boolean needProcessOutsideTableLock = false;\n        if (currentAlterOps.hasSchemaChangeOp()) {\n            \r\n            schemaChangeHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasRollupOp()) {\n            materializedViewHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasPartitionOp()) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            olapTable.writeLock();\n            try {\n                if (alterClause instanceof DropPartitionClause) {\n                    if (!((DropPartitionClause) alterClause).isTempPartition()) {\n                        DynamicPartitionUtil.checkAlterAllowed(olapTable);\n                    }\n                    Catalog.getCurrentCatalog().dropPartition(db, olapTable, ((DropPartitionClause) alterClause));\n                } else if (alterClause instanceof ReplacePartitionClause) {\n                    Catalog.getCurrentCatalog().replaceTempPartition(db, olapTable, (ReplacePartitionClause) alterClause);\n                } else if (alterClause instanceof ModifyPartitionClause) {\n                    ModifyPartitionClause clause = ((ModifyPartitionClause) alterClause);\n                    \r\n                    if (clause.isNeedExpand()) {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        partitionNames.clear();\n                        for (Partition partition : olapTable.getPartitions()) {\n                            partitionNames.add(partition.getName());\n                        }\n                    }\n                    Map<String, String> properties = clause.getProperties();\n                    if (properties.containsKey(PropertyAnalyzer.PROPERTIES_INMEMORY)) {\n                        needProcessOutsideTableLock = true;\n                    } else {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        modifyPartitionsProperty(db, olapTable, partitionNames, properties);\n                    }\n                } else if (alterClause instanceof AddPartitionClause) {\n                    needProcessOutsideTableLock = true;\n                } else {\n                    throw new DdlException(\"Invalid alter operation: \" + alterClause.getOpType());\n                }\n            } finally {\n                olapTable.writeUnlock();\n            }\n        } else if (currentAlterOps.hasRenameOp()) {\n            processRename(db, olapTable, alterClauses);\n        } else if (currentAlterOps.hasReplaceTableOp()) {\n            processReplaceTable(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_PROPERTY_SYNC)) {\n            needProcessOutsideTableLock = true;\n        } else {\n            throw new DdlException(\"Invalid alter operations: \" + currentAlterOps);\n        }\n\n        return needProcessOutsideTableLock;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/alter/Alter.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2020-10-25 17:17:56","commitOrder":3,"curCode":"    private void processAlterExternalTable(AlterTableStmt stmt, Table externalTable, Database db) throws UserException {\n        stmt.rewriteAlterClause(externalTable);\n\n        \r\n        List<AlterClause> alterClauses = stmt.getOps();\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        if (currentAlterOps.hasRenameOp()) {\n            processRename(db, externalTable, alterClauses);\n        } else if (currentAlterOps.hasSchemaChangeOp()) {\n            schemaChangeHandler.processExternalTable(alterClauses, db, externalTable);\n        }\n    }\n","date":"2020-10-25 17:17:56","endLine":241,"groupId":"7169","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"processAlterExternalTable","params":"(AlterTableStmtstmt@TableexternalTable@Databasedb)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/94/d1bb2fe031e545d4072750f71b60d503b5034a.src","preCode":"    private void processAlterExternalTable(AlterTableStmt stmt, Table externalTable, Database db) throws UserException {\n        stmt.rewriteAlterClause(externalTable);\n\n        \r\n        List<AlterClause> alterClauses = stmt.getOps();\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        if (currentAlterOps.hasRenameOp()) {\n            processRename(db, externalTable, alterClauses);\n        } else if (currentAlterOps.hasSchemaChangeOp()) {\n            schemaChangeHandler.processExternalTable(alterClauses, db, externalTable);\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/alter/Alter.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"N"}],"commitId":"76e148988ac201829cee796c444aa8c671897e36","commitMessage":"@@@Support alter default bucket_num of partitioned olap table (#6023)\n\n* Support modify partitioned olap table's bucket num\n\nCo-authored-by: EmmyMiao87 <522274284@qq.com>","date":"2021-07-12 20:28:40","modifiedFileCount":"10","status":"M","submitter":"flynn"},{"authorTime":"2020-10-25 17:17:56","codes":[{"authorDate":"2021-08-11 16:37:42","commitOrder":4,"curCode":"    private boolean processAlterOlapTable(AlterTableStmt stmt, OlapTable olapTable, List<AlterClause> alterClauses,\n                                         final String clusterName, Database db) throws UserException {\n        stmt.rewriteAlterClause(olapTable);\n\n        \r\n        alterClauses.addAll(stmt.getOps());\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        \r\n        if (currentAlterOps.needCheckCapacity()) {\n            Catalog.getCurrentSystemInfo().checkClusterCapacity(clusterName);\n            db.checkQuota();\n        }\n\n        if (olapTable.getState() != OlapTableState.NORMAL) {\n            throw new DdlException(\n                    \"Table[\" + olapTable.getName() + \"]'s state is not NORMAL. Do not allow doing ALTER ops\");\n        }\n\n        boolean needProcessOutsideTableLock = false;\n        if (currentAlterOps.hasSchemaChangeOp()) {\n            \r\n            schemaChangeHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasRollupOp()) {\n            materializedViewHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasPartitionOp()) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            olapTable.writeLock();\n            try {\n                if (alterClause instanceof DropPartitionClause) {\n                    if (!((DropPartitionClause) alterClause).isTempPartition()) {\n                        DynamicPartitionUtil.checkAlterAllowed(olapTable);\n                    }\n                    Catalog.getCurrentCatalog().dropPartition(db, olapTable, ((DropPartitionClause) alterClause));\n                } else if (alterClause instanceof ReplacePartitionClause) {\n                    Catalog.getCurrentCatalog().replaceTempPartition(db, olapTable, (ReplacePartitionClause) alterClause);\n                } else if (alterClause instanceof ModifyPartitionClause) {\n                    ModifyPartitionClause clause = ((ModifyPartitionClause) alterClause);\n                    \r\n                    if (clause.isNeedExpand()) {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        partitionNames.clear();\n                        for (Partition partition : olapTable.getPartitions()) {\n                            partitionNames.add(partition.getName());\n                        }\n                    }\n                    Map<String, String> properties = clause.getProperties();\n                    if (properties.containsKey(PropertyAnalyzer.PROPERTIES_INMEMORY)) {\n                        needProcessOutsideTableLock = true;\n                    } else {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        modifyPartitionsProperty(db, olapTable, partitionNames, properties);\n                    }\n                } else if (alterClause instanceof AddPartitionClause) {\n                    needProcessOutsideTableLock = true;\n                } else {\n                    throw new DdlException(\"Invalid alter operation: \" + alterClause.getOpType());\n                }\n            } finally {\n                olapTable.writeUnlock();\n            }\n        } else if (currentAlterOps.hasRenameOp()) {\n            processRename(db, olapTable, alterClauses);\n        } else if (currentAlterOps.hasReplaceTableOp()) {\n            processReplaceTable(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_PROPERTY_SYNC)) {\n            needProcessOutsideTableLock = true;\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_DISTRIBUTION)) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            Catalog.getCurrentCatalog().modifyDefaultDistributionBucketNum(db, olapTable, (ModifyDistributionClause) alterClause);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_COLUMN_COMMENT)) {\n            processModifyColumnComment(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_COMMENT)) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            processModifyTableComment(db, olapTable, alterClause);\n        } else {\n            throw new DdlException(\"Invalid alter operations: \" + currentAlterOps);\n        }\n\n        return needProcessOutsideTableLock;\n    }\n","date":"2021-08-11 16:37:42","endLine":214,"groupId":"101199","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"processAlterOlapTable","params":"(AlterTableStmtstmt@OlapTableolapTable@List<AlterClause>alterClauses@finalStringclusterName@Databasedb)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/93/3855256b13dd34e32282924fc21fbd0bee74c2.src","preCode":"    private boolean processAlterOlapTable(AlterTableStmt stmt, OlapTable olapTable, List<AlterClause> alterClauses,\n                                         final String clusterName, Database db) throws UserException {\n        stmt.rewriteAlterClause(olapTable);\n\n        \r\n        alterClauses.addAll(stmt.getOps());\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        \r\n        if (currentAlterOps.needCheckCapacity()) {\n            Catalog.getCurrentSystemInfo().checkClusterCapacity(clusterName);\n            db.checkQuota();\n        }\n\n        if (olapTable.getState() != OlapTableState.NORMAL) {\n            throw new DdlException(\n                    \"Table[\" + olapTable.getName() + \"]'s state is not NORMAL. Do not allow doing ALTER ops\");\n        }\n\n        boolean needProcessOutsideTableLock = false;\n        if (currentAlterOps.hasSchemaChangeOp()) {\n            \r\n            schemaChangeHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasRollupOp()) {\n            materializedViewHandler.process(alterClauses, clusterName, db, olapTable);\n        } else if (currentAlterOps.hasPartitionOp()) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            olapTable.writeLock();\n            try {\n                if (alterClause instanceof DropPartitionClause) {\n                    if (!((DropPartitionClause) alterClause).isTempPartition()) {\n                        DynamicPartitionUtil.checkAlterAllowed(olapTable);\n                    }\n                    Catalog.getCurrentCatalog().dropPartition(db, olapTable, ((DropPartitionClause) alterClause));\n                } else if (alterClause instanceof ReplacePartitionClause) {\n                    Catalog.getCurrentCatalog().replaceTempPartition(db, olapTable, (ReplacePartitionClause) alterClause);\n                } else if (alterClause instanceof ModifyPartitionClause) {\n                    ModifyPartitionClause clause = ((ModifyPartitionClause) alterClause);\n                    \r\n                    if (clause.isNeedExpand()) {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        partitionNames.clear();\n                        for (Partition partition : olapTable.getPartitions()) {\n                            partitionNames.add(partition.getName());\n                        }\n                    }\n                    Map<String, String> properties = clause.getProperties();\n                    if (properties.containsKey(PropertyAnalyzer.PROPERTIES_INMEMORY)) {\n                        needProcessOutsideTableLock = true;\n                    } else {\n                        List<String> partitionNames = clause.getPartitionNames();\n                        modifyPartitionsProperty(db, olapTable, partitionNames, properties);\n                    }\n                } else if (alterClause instanceof AddPartitionClause) {\n                    needProcessOutsideTableLock = true;\n                } else {\n                    throw new DdlException(\"Invalid alter operation: \" + alterClause.getOpType());\n                }\n            } finally {\n                olapTable.writeUnlock();\n            }\n        } else if (currentAlterOps.hasRenameOp()) {\n            processRename(db, olapTable, alterClauses);\n        } else if (currentAlterOps.hasReplaceTableOp()) {\n            processReplaceTable(db, olapTable, alterClauses);\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_TABLE_PROPERTY_SYNC)) {\n            needProcessOutsideTableLock = true;\n        } else if (currentAlterOps.contains(AlterOpType.MODIFY_DISTRIBUTION)) {\n            Preconditions.checkState(alterClauses.size() == 1);\n            AlterClause alterClause = alterClauses.get(0);\n            Catalog.getCurrentCatalog().modifyDefaultDistributionBucketNum(db, olapTable, (ModifyDistributionClause) alterClause);\n        } else {\n            throw new DdlException(\"Invalid alter operations: \" + currentAlterOps);\n        }\n\n        return needProcessOutsideTableLock;\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/alter/Alter.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"},{"authorDate":"2020-10-25 17:17:56","commitOrder":4,"curCode":"    private void processAlterExternalTable(AlterTableStmt stmt, Table externalTable, Database db) throws UserException {\n        stmt.rewriteAlterClause(externalTable);\n\n        \r\n        List<AlterClause> alterClauses = stmt.getOps();\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        if (currentAlterOps.hasRenameOp()) {\n            processRename(db, externalTable, alterClauses);\n        } else if (currentAlterOps.hasSchemaChangeOp()) {\n            schemaChangeHandler.processExternalTable(alterClauses, db, externalTable);\n        }\n    }\n","date":"2020-10-25 17:17:56","endLine":241,"groupId":"101199","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"processAlterExternalTable","params":"(AlterTableStmtstmt@TableexternalTable@Databasedb)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-incubatordoris-10-0.7/blobInfo/CC_OUT/blobs/94/d1bb2fe031e545d4072750f71b60d503b5034a.src","preCode":"    private void processAlterExternalTable(AlterTableStmt stmt, Table externalTable, Database db) throws UserException {\n        stmt.rewriteAlterClause(externalTable);\n\n        \r\n        List<AlterClause> alterClauses = stmt.getOps();\n        AlterOperations currentAlterOps = new AlterOperations();\n        currentAlterOps.checkConflict(alterClauses);\n\n        if (currentAlterOps.hasRenameOp()) {\n            processRename(db, externalTable, alterClauses);\n        } else if (currentAlterOps.hasSchemaChangeOp()) {\n            schemaChangeHandler.processExternalTable(alterClauses, db, externalTable);\n        }\n    }\n","realPath":"fe/fe-core/src/main/java/org/apache/doris/alter/Alter.java","repoName":"incubatordoris","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"N"}],"commitId":"7e93405df39ddc3f230ffafb09156bcb0264f972","commitMessage":"@@@[Alter] Support alter table and column's comment (#6387)\n\n1. alter table tbl1 modify comment \"new comment\";\n2. alter table tbl1 modify column k1 comment \"k1\".  modify column v1 comment \"v1\";","date":"2021-08-11 16:37:42","modifiedFileCount":"7","status":"M","submitter":"Mingyu Chen"}]
