[{"authorTime":"2019-10-23 11:19:11","codes":[{"authorDate":"2019-10-23 11:19:11","commitOrder":1,"curCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieCleanMetadata cleanMetadata = AvroUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant),\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2019-10-23 11:19:11","endLine":423,"groupId":"1079","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(SyncableFileSystemViewview@Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/09/50f2cebc25d23b01c3510101f0764ccc6dde48.src","preCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieCleanMetadata cleanMetadata = AvroUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant),\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":412,"status":"B"},{"authorDate":"2019-10-23 11:19:11","commitOrder":1,"curCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant),\n          AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2019-10-23 11:19:11","endLine":464,"groupId":"4359","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(SyncableFileSystemViewview@Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/09/50f2cebc25d23b01c3510101f0764ccc6dde48.src","preCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant),\n          AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"B"}],"commitId":"e4c91ed13f16e1d0d55d9d690395bb62ab2b4fa0","commitMessage":"@@@[HUDI-290] Normalize test class name of all test classes (#951)\n\n","date":"2019-10-23 11:19:11","modifiedFileCount":"1","status":"B","submitter":"vinoth chandar"},{"authorTime":"2019-10-23 11:19:11","codes":[{"authorDate":"2019-12-04 02:11:03","commitOrder":2,"curCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant),\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2019-12-04 02:11:03","endLine":425,"groupId":"1079","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(SyncableFileSystemViewview@Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e4/7b834a9a3a1cfb1bd6c775ad4eb6e876479789.src","preCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieCleanMetadata cleanMetadata = AvroUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant),\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":413,"status":"M"},{"authorDate":"2019-10-23 11:19:11","commitOrder":2,"curCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant),\n          AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2019-10-23 11:19:11","endLine":464,"groupId":"4359","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(SyncableFileSystemViewview@Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/09/50f2cebc25d23b01c3510101f0764ccc6dde48.src","preCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant),\n          AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"N"}],"commitId":"98ab33bb6e1637d18c8fab7a9ddd50daeaf56962","commitMessage":"@@@[HUDI-294] Delete Paths written in Cleaner plan needs to be relative to partition-path (#1062)\n\n[HUDI-294] Delete Paths written in Cleaner plan needs to be relative to partition-path","date":"2019-12-04 02:11:03","modifiedFileCount":"7","status":"M","submitter":"leesf"},{"authorTime":"2019-12-04 17:02:17","codes":[{"authorDate":"2019-12-04 17:02:17","commitOrder":3,"curCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2019-12-16 13:26:30","endLine":432,"groupId":"0","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(SyncableFileSystemViewview@Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/89/81d8ef1081cf52da011a0e28687e75bad123a8.src","preCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant),\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"},{"authorDate":"2019-12-04 17:02:17","commitOrder":3,"curCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2019-12-16 13:26:30","endLine":475,"groupId":"4359","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(SyncableFileSystemViewview@Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/89/81d8ef1081cf52da011a0e28687e75bad123a8.src","preCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant),\n          AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":442,"status":"M"}],"commitId":"9a1f698eef1044443adadbf7a1bf7b5eb94fb84e","commitMessage":"@@@[HUDI-308] Avoid Renames for tracking state transitions of all actions on dataset\n","date":"2019-12-16 13:26:30","modifiedFileCount":"42","status":"M","submitter":"Balaji Varadarajan"},{"authorTime":"2019-12-29 17:30:06","codes":[{"authorDate":"2019-12-29 17:30:06","commitOrder":4,"curCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2020-01-01 03:10:49","endLine":416,"groupId":"2483","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e1/e6b9f36bc597405b6efc551507ee0fc839abba.src","preCode":"  private void performClean(SyncableFileSystemView view, String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n          new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1));\n    }).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":403,"status":"M"},{"authorDate":"2019-12-29 17:30:06","commitOrder":4,"curCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2020-01-01 03:10:49","endLine":458,"groupId":"4359","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e1/e6b9f36bc597405b6efc551507ee0fc839abba.src","preCode":"  private void performRestore(SyncableFileSystemView view, String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e -> {\n      return new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>());\n    }).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":425,"status":"M"}],"commitId":"dde21e7315739c108567307813f4b816dd9f1920","commitMessage":"@@@[HUDI-402]: code clean up in test cases\n","date":"2020-01-01 03:10:49","modifiedFileCount":"62","status":"M","submitter":"Pratyaksh Sharma"},{"authorTime":"2020-03-28 15:11:32","codes":[{"authorDate":"2019-12-29 17:30:06","commitOrder":5,"curCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2020-01-01 03:10:49","endLine":416,"groupId":"2483","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e1/e6b9f36bc597405b6efc551507ee0fc839abba.src","preCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":403,"status":"N"},{"authorDate":"2020-03-28 15:11:32","commitOrder":5,"curCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2020-03-28 15:11:32","endLine":464,"groupId":"1460","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/08/f31746ed71d8b7258765a208890b9af21bfc14.src","preCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(new ImmutableMap.Builder().put(rollbackInstant, rollbackM).build());\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":431,"status":"M"}],"commitId":"8c3001363d80b29733470221c192a72f541381c5","commitMessage":"@@@HUDI-479: Eliminate or Minimize use of Guava if possible (#1159)\n\n","date":"2020-03-28 15:11:32","modifiedFileCount":"43","status":"M","submitter":"Suneel Marthi"},{"authorTime":"2020-03-30 01:58:49","codes":[{"authorDate":"2020-03-30 01:58:49","commitOrder":6,"curCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2020-03-30 01:58:49","endLine":421,"groupId":"2483","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/90/51cc18b28b51655ba030905a71b500fa96af85.src","preCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        AvroUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"M"},{"authorDate":"2020-03-30 01:58:49","commitOrder":6,"curCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2020-03-30 01:58:49","endLine":463,"groupId":"1460","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/90/51cc18b28b51655ba030905a71b500fa96af85.src","preCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        AvroUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, AvroUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"M"}],"commitId":"e057c27603301d8b49e9b50b78a3ffce247b1059","commitMessage":"@@@[HUDI-744] Restructure hudi-common and clean up files under util packages (#1462)\n\n - Brings more order and cohesion to the classes in hudi-common\n - Utils classes related to a particular concept (avro.  timeline. ...) are placed near to the package\n - common.fs package now contains all the filesystem level classes including wrapper filesystem\n - bloom.filter package renamed to just bloom\n - config package contains classes that help store properties\n - common.fs.inline package contains all the inline filesystem classes/impl\n - common.table.timeline now consolidates all timeline related classes\n - common.table.view consolidates all the classes related to filesystem view metadata\n - common.table.timeline.versioning contains all classes related to versioning of timeline\n - Fix few unit tests as a result\n - Moved the test packages around to match the source file move\n - Rename AvroUtils to TimelineMetadataUtils & minor fixes/typos","date":"2020-03-30 01:58:49","modifiedFileCount":"206","status":"M","submitter":"vinoth chandar"},{"authorTime":"2020-03-30 01:58:49","codes":[{"authorDate":"2020-04-04 15:07:34","commitOrder":7,"curCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2020-04-04 15:07:34","endLine":420,"groupId":"2483","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e6/c45a24874a80302af61e3301cf654952a9d7eb.src","preCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils\n        .convertCleanMetadata(metaClient, cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"M"},{"authorDate":"2020-03-30 01:58:49","commitOrder":7,"curCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","date":"2020-03-30 01:58:49","endLine":463,"groupId":"1460","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(Stringinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/90/51cc18b28b51655ba030905a71b500fa96af85.src","preCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"N"}],"commitId":"eaf6cc2d90bf27c0d9414a4ea18dbd1b61f58e50","commitMessage":"@@@[HUDI-756] Organize Cleaning Action execution into a single package in hudi-client (#1485)\n\n- Introduced a thin abstraction ActionExecutor.  that all actions will implement\n- Pulled cleaning code from table.  writeclient into a single package\n- CleanHelper is now CleanPlanner.  HoodieCleanClient is no longer around\n- Minor refactor of HoodieTable factory method\n- HoodieTable.create() methods with and without metaclient passed in\n- HoodieTable constructor now does not do a redundant instantiation\n- Fixed existing unit tests to work at the HoodieWriteClient level","date":"2020-04-04 15:07:34","modifiedFileCount":"25","status":"M","submitter":"vinoth chandar"},{"authorTime":"2020-09-30 08:04:25","codes":[{"authorDate":"2020-04-04 15:07:34","commitOrder":8,"curCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2020-04-04 15:07:34","endLine":420,"groupId":"2483","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e6/c45a24874a80302af61e3301cf654952a9d7eb.src","preCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"N"},{"authorDate":"2020-09-30 08:04:25","commitOrder":8,"curCode":"  private void performRestore(HoodieInstant instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<HoodieInstant> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      HoodieRestoreMetadata metadata = TimelineMetadataUtils.convertRestoreMetadata(rollbackInstant,\n          100, Collections.singletonList(instant), CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n    boolean deleted = metaClient.getFs().delete(new Path(metaClient.getMetaPath(), instant.getFileName()), false);\n    assertTrue(deleted);\n  }\n","date":"2020-09-30 08:04:25","endLine":583,"groupId":"1460","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(HoodieInstantinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e4/933cf4e983bd5f05eb66fbc4aa924593a8e50e.src","preCode":"  private void performRestore(String instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<String> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      HoodieRestoreMetadata metadata = new HoodieRestoreMetadata();\n\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      metadata.setHoodieRestoreMetadata(CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n      List<String> rollbackInstants = new ArrayList<>();\n      rollbackInstants.add(rollbackInstant);\n      metadata.setInstantsToRollback(rollbackInstants);\n      metadata.setStartRestoreTime(rollbackInstant);\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":553,"status":"M"}],"commitId":"a99e93bed542c8ae30a641d1df616cc2cd5798e1","commitMessage":"@@@[HUDI-1072] Introduce REPLACE top level action. Implement insert_overwrite operation on top of replace action (#2048)\n\n","date":"2020-09-30 08:04:25","modifiedFileCount":"45","status":"M","submitter":"satishkotha"},{"authorTime":"2021-01-12 05:23:13","codes":[{"authorDate":"2020-04-04 15:07:34","commitOrder":9,"curCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","date":"2020-04-04 15:07:34","endLine":420,"groupId":"10885","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"performClean","params":"(Stringinstant@List<String>files@StringcleanInstant)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e6/c45a24874a80302af61e3301cf654952a9d7eb.src","preCode":"  private void performClean(String instant, List<String> files, String cleanInstant)\n      throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieCleanStat> cleanStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieCleanStat(HoodieCleaningPolicy.KEEP_LATEST_COMMITS, e.getKey(), e.getValue(), e.getValue(),\n        new ArrayList<>(), Integer.toString(Integer.parseInt(instant) + 1))).collect(Collectors.toList());\n\n    HoodieInstant cleanInflightInstant = new HoodieInstant(true, HoodieTimeline.CLEAN_ACTION, cleanInstant);\n    metaClient.getActiveTimeline().createNewInstant(cleanInflightInstant);\n    HoodieCleanMetadata cleanMetadata = CleanerUtils.convertCleanMetadata(cleanInstant, Option.empty(), cleanStats);\n    metaClient.getActiveTimeline().saveAsComplete(cleanInflightInstant,\n        TimelineMetadataUtils.serializeCleanMetadata(cleanMetadata));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"N"},{"authorDate":"2021-01-12 05:23:13","commitOrder":9,"curCode":"  private void performRestore(HoodieInstant instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<HoodieInstant> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      HoodieRestoreMetadata metadata = TimelineMetadataUtils.convertRestoreMetadata(rollbackInstant,\n          100, Collections.singletonList(instant), CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n    boolean deleted = metaClient.getFs().delete(new Path(metaClient.getMetaPath(), instant.getFileName()), false);\n    assertTrue(deleted);\n  }\n","date":"2021-01-12 05:23:13","endLine":585,"groupId":"10885","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"performRestore","params":"(HoodieInstantinstant@List<String>files@StringrollbackInstant@booleanisRestore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/14/6e0bb85b53d1241075b2519a5e6fccf4080ebf.src","preCode":"  private void performRestore(HoodieInstant instant, List<String> files, String rollbackInstant,\n      boolean isRestore) throws IOException {\n    Map<String, List<String>> partititonToFiles = deleteFiles(files);\n    List<HoodieRollbackStat> rollbackStats = partititonToFiles.entrySet().stream().map(e ->\n        new HoodieRollbackStat(e.getKey(), e.getValue(), new ArrayList<>(), new HashMap<>())\n    ).collect(Collectors.toList());\n\n    List<HoodieInstant> rollbacks = new ArrayList<>();\n    rollbacks.add(instant);\n\n    HoodieRollbackMetadata rollbackMetadata =\n        TimelineMetadataUtils.convertRollbackMetadata(rollbackInstant, Option.empty(), rollbacks, rollbackStats);\n    if (isRestore) {\n      List<HoodieRollbackMetadata> rollbackM = new ArrayList<>();\n      rollbackM.add(rollbackMetadata);\n      HoodieRestoreMetadata metadata = TimelineMetadataUtils.convertRestoreMetadata(rollbackInstant,\n          100, Collections.singletonList(instant), CollectionUtils.createImmutableMap(rollbackInstant, rollbackM));\n\n      HoodieInstant restoreInstant = new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, rollbackInstant);\n      metaClient.getActiveTimeline().createNewInstant(restoreInstant);\n      metaClient.getActiveTimeline().saveAsComplete(restoreInstant, TimelineMetadataUtils.serializeRestoreMetadata(metadata));\n    } else {\n      metaClient.getActiveTimeline().createNewInstant(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant));\n      metaClient.getActiveTimeline().saveAsComplete(\n          new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, rollbackInstant),\n          TimelineMetadataUtils.serializeRollbackMetadata(rollbackMetadata));\n    }\n    boolean deleted = metaClient.getFs().delete(new Path(metaClient.getMetaPath(), instant.getFileName()), false);\n    assertTrue(deleted);\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestIncrementalFSViewSync.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":555,"status":"M"}],"commitId":"e3d3677b7e7899705b624925666317f0c074f7c7","commitMessage":"@@@[HUDI-1502] MOR rollback and restore support for metadata sync (#2421)\n\n- Adds field to RollbackMetadata that capture the logs written for rollback blocks\n- Adds field to RollbackMetadata that capture new logs files written by unsynced deltacommits\n\nCo-authored-by: Vinoth Chandar <vinoth@apache.org>","date":"2021-01-12 05:23:13","modifiedFileCount":"14","status":"M","submitter":"Sivabalan Narayanan"}]
