[{"authorTime":"2020-10-21 14:20:19","codes":[{"authorDate":"2021-03-05 13:01:51","commitOrder":7,"curCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(JavaSparkContext sparkContext,\n                                                                             Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    \r\n    LOG.info(\n        \"Root path => \"\n            + props.getString(ROOT_INPUT_PATH_PROP)\n            + \" source limit => \"\n            + sourceLimit\n            + \" depth of day partition => \"\n            + datePartitionDepth\n            + \" num prev days to list => \"\n            + numPrevDaysToList\n            + \" from current date => \"\n            + currentDate);\n    long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n    HoodieSparkEngineContext context = new HoodieSparkEngineContext(sparkContext);\n    SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n    List<String> prunedParitionPaths = pruneDatePartitionPaths(context, fs, props.getString(ROOT_INPUT_PATH_PROP));\n\n    List<FileStatus> eligibleFiles = context.flatMap(prunedParitionPaths,\n        path -> {\n          FileSystem fs = new Path(path).getFileSystem(serializedConf.get());\n          return listEligibleFiles(fs, new Path(path), lastCheckpointTime).stream();\n        }, partitionsListParallelism);\n    \r\n    List<FileStatus> sortedEligibleFiles = eligibleFiles.stream()\n        .sorted(Comparator.comparingLong(FileStatus::getModificationTime)).collect(Collectors.toList());\n\n    \r\n    long currentBytes = 0;\n    List<FileStatus> filteredFiles = new ArrayList<>();\n    for (FileStatus f : sortedEligibleFiles) {\n      if (currentBytes + f.getLen() >= sourceLimit) {\n        \r\n        break;\n      }\n\n      currentBytes += f.getLen();\n      filteredFiles.add(f);\n    }\n\n    \r\n    if (filteredFiles.isEmpty()) {\n      return new ImmutablePair<>(\n          Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n    }\n\n    \r\n    String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n    long maxModificationTime = filteredFiles.get(filteredFiles.size() - 1).getModificationTime();\n    return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n  }\n","date":"2021-03-05 13:01:51","endLine":170,"groupId":"5015","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getNextFilePathsAndMaxModificationTime","params":"(JavaSparkContextsparkContext@Option<String>lastCheckpointStr@longsourceLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/c2/2657f5815c49385cda85f42996f4d42fa13bda.src","preCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(JavaSparkContext sparkContext,\n                                                                             Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    \r\n    LOG.info(\n        \"Root path => \"\n            + props.getString(ROOT_INPUT_PATH_PROP)\n            + \" source limit => \"\n            + sourceLimit\n            + \" depth of day partition => \"\n            + datePartitionDepth\n            + \" num prev days to list => \"\n            + numPrevDaysToList\n            + \" from current date => \"\n            + currentDate);\n    long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n    HoodieSparkEngineContext context = new HoodieSparkEngineContext(sparkContext);\n    SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n    List<String> prunedParitionPaths = pruneDatePartitionPaths(context, fs, props.getString(ROOT_INPUT_PATH_PROP));\n\n    List<FileStatus> eligibleFiles = context.flatMap(prunedParitionPaths,\n        path -> {\n          FileSystem fs = new Path(path).getFileSystem(serializedConf.get());\n          return listEligibleFiles(fs, new Path(path), lastCheckpointTime).stream();\n        }, partitionsListParallelism);\n    \r\n    List<FileStatus> sortedEligibleFiles = eligibleFiles.stream()\n        .sorted(Comparator.comparingLong(FileStatus::getModificationTime)).collect(Collectors.toList());\n\n    \r\n    long currentBytes = 0;\n    List<FileStatus> filteredFiles = new ArrayList<>();\n    for (FileStatus f : sortedEligibleFiles) {\n      if (currentBytes + f.getLen() >= sourceLimit) {\n        \r\n        break;\n      }\n\n      currentBytes += f.getLen();\n      filteredFiles.add(f);\n    }\n\n    \r\n    if (filteredFiles.isEmpty()) {\n      return new ImmutablePair<>(\n          Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n    }\n\n    \r\n    String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n    long maxModificationTime = filteredFiles.get(filteredFiles.size() - 1).getModificationTime();\n    return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n  }\n","realPath":"hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/helpers/DatePartitionPathSelector.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"MB"},{"authorDate":"2020-10-21 14:20:19","commitOrder":7,"curCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(Option<String> lastCheckpointStr,\n      long sourceLimit) {\n\n    try {\n      \r\n      log.info(\"Root path => \" + props.getString(Config.ROOT_INPUT_PATH_PROP) + \" source limit => \" + sourceLimit);\n      long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n      List<FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(props.getString(Config.ROOT_INPUT_PATH_PROP)), lastCheckpointTime);\n      \r\n      eligibleFiles.sort(Comparator.comparingLong(FileStatus::getModificationTime));\n      \r\n      long currentBytes = 0;\n      long maxModificationTime = Long.MIN_VALUE;\n      List<FileStatus> filteredFiles = new ArrayList<>();\n      for (FileStatus f : eligibleFiles) {\n        if (currentBytes + f.getLen() >= sourceLimit) {\n          \r\n          break;\n        }\n\n        maxModificationTime = f.getModificationTime();\n        currentBytes += f.getLen();\n        filteredFiles.add(f);\n      }\n\n      \r\n      if (filteredFiles.isEmpty()) {\n        return new ImmutablePair<>(Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n      }\n\n      \r\n      String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n      return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n    } catch (IOException ioe) {\n      throw new HoodieIOException(\"Unable to read from source from checkpoint: \" + lastCheckpointStr, ioe);\n    }\n  }\n","date":"2020-10-21 14:20:19","endLine":134,"groupId":"3554","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getNextFilePathsAndMaxModificationTime","params":"(Option<String>lastCheckpointStr@longsourceLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/47/419e0297550618e6b8d574bc66fade57d165bd.src","preCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(Option<String> lastCheckpointStr,\n      long sourceLimit) {\n\n    try {\n      \r\n      log.info(\"Root path => \" + props.getString(Config.ROOT_INPUT_PATH_PROP) + \" source limit => \" + sourceLimit);\n      long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n      List<FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(props.getString(Config.ROOT_INPUT_PATH_PROP)), lastCheckpointTime);\n      \r\n      eligibleFiles.sort(Comparator.comparingLong(FileStatus::getModificationTime));\n      \r\n      long currentBytes = 0;\n      long maxModificationTime = Long.MIN_VALUE;\n      List<FileStatus> filteredFiles = new ArrayList<>();\n      for (FileStatus f : eligibleFiles) {\n        if (currentBytes + f.getLen() >= sourceLimit) {\n          \r\n          break;\n        }\n\n        maxModificationTime = f.getModificationTime();\n        currentBytes += f.getLen();\n        filteredFiles.add(f);\n      }\n\n      \r\n      if (filteredFiles.isEmpty()) {\n        return new ImmutablePair<>(Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n      }\n\n      \r\n      String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n      return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n    } catch (IOException ioe) {\n      throw new HoodieIOException(\"Unable to read from source from checkpoint: \" + lastCheckpointStr, ioe);\n    }\n  }\n","realPath":"hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/helpers/DFSPathSelector.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"NB"}],"commitId":"f53bca404f1482e0e99ad683dd29bfaff8bfb8ab","commitMessage":"@@@[HUDI-1655] Support custom date format and fix unsupported exception in DatePartitionPathSelector (#2621)\n\n- Add a config to allow parsing custom date format in `DatePartitionPathSelector`. Currently it assumes date partition string in the format of `yyyy-MM-dd`.\n- Fix a bug where `UnsupportedOperationException` was thrown when sort `eligibleFiles` in-place. Changed to sort it and store in a new list.","date":"2021-03-05 13:01:51","modifiedFileCount":"2","status":"M","submitter":"Raymond Xu"},{"authorTime":"2020-10-21 14:20:19","codes":[{"authorDate":"2021-03-13 07:53:01","commitOrder":8,"curCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(JavaSparkContext sparkContext,\n                                                                             Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    \r\n    LocalDate currentDate = LocalDate.parse(props.getString(Config.CURRENT_DATE, LocalDate.now().toString()));\n\n    \r\n    LOG.info(\n        \"Root path => \"\n            + props.getString(ROOT_INPUT_PATH_PROP)\n            + \" source limit => \"\n            + sourceLimit\n            + \" depth of day partition => \"\n            + datePartitionDepth\n            + \" num prev days to list => \"\n            + numPrevDaysToList\n            + \" from current date => \"\n            + currentDate);\n    long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n    HoodieSparkEngineContext context = new HoodieSparkEngineContext(sparkContext);\n    SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n    List<String> prunedParitionPaths = pruneDatePartitionPaths(context, fs, props.getString(ROOT_INPUT_PATH_PROP), currentDate);\n\n    List<FileStatus> eligibleFiles = context.flatMap(prunedParitionPaths,\n        path -> {\n          FileSystem fs = new Path(path).getFileSystem(serializedConf.get());\n          return listEligibleFiles(fs, new Path(path), lastCheckpointTime).stream();\n        }, partitionsListParallelism);\n    \r\n    List<FileStatus> sortedEligibleFiles = eligibleFiles.stream()\n        .sorted(Comparator.comparingLong(FileStatus::getModificationTime)).collect(Collectors.toList());\n\n    \r\n    long currentBytes = 0;\n    List<FileStatus> filteredFiles = new ArrayList<>();\n    for (FileStatus f : sortedEligibleFiles) {\n      if (currentBytes + f.getLen() >= sourceLimit) {\n        \r\n        break;\n      }\n\n      currentBytes += f.getLen();\n      filteredFiles.add(f);\n    }\n\n    \r\n    if (filteredFiles.isEmpty()) {\n      return new ImmutablePair<>(\n          Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n    }\n\n    \r\n    String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n    long maxModificationTime = filteredFiles.get(filteredFiles.size() - 1).getModificationTime();\n    return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n  }\n","date":"2021-03-13 07:53:01","endLine":168,"groupId":"5015","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getNextFilePathsAndMaxModificationTime","params":"(JavaSparkContextsparkContext@Option<String>lastCheckpointStr@longsourceLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/97/106ded9bcb8b3dd3f0ece09ce6e5f88fc1d0cb.src","preCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(JavaSparkContext sparkContext,\n                                                                             Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    \r\n    LOG.info(\n        \"Root path => \"\n            + props.getString(ROOT_INPUT_PATH_PROP)\n            + \" source limit => \"\n            + sourceLimit\n            + \" depth of day partition => \"\n            + datePartitionDepth\n            + \" num prev days to list => \"\n            + numPrevDaysToList\n            + \" from current date => \"\n            + currentDate);\n    long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n    HoodieSparkEngineContext context = new HoodieSparkEngineContext(sparkContext);\n    SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n    List<String> prunedParitionPaths = pruneDatePartitionPaths(context, fs, props.getString(ROOT_INPUT_PATH_PROP));\n\n    List<FileStatus> eligibleFiles = context.flatMap(prunedParitionPaths,\n        path -> {\n          FileSystem fs = new Path(path).getFileSystem(serializedConf.get());\n          return listEligibleFiles(fs, new Path(path), lastCheckpointTime).stream();\n        }, partitionsListParallelism);\n    \r\n    List<FileStatus> sortedEligibleFiles = eligibleFiles.stream()\n        .sorted(Comparator.comparingLong(FileStatus::getModificationTime)).collect(Collectors.toList());\n\n    \r\n    long currentBytes = 0;\n    List<FileStatus> filteredFiles = new ArrayList<>();\n    for (FileStatus f : sortedEligibleFiles) {\n      if (currentBytes + f.getLen() >= sourceLimit) {\n        \r\n        break;\n      }\n\n      currentBytes += f.getLen();\n      filteredFiles.add(f);\n    }\n\n    \r\n    if (filteredFiles.isEmpty()) {\n      return new ImmutablePair<>(\n          Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n    }\n\n    \r\n    String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n    long maxModificationTime = filteredFiles.get(filteredFiles.size() - 1).getModificationTime();\n    return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n  }\n","realPath":"hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/helpers/DatePartitionPathSelector.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2020-10-21 14:20:19","commitOrder":8,"curCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(Option<String> lastCheckpointStr,\n      long sourceLimit) {\n\n    try {\n      \r\n      log.info(\"Root path => \" + props.getString(Config.ROOT_INPUT_PATH_PROP) + \" source limit => \" + sourceLimit);\n      long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n      List<FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(props.getString(Config.ROOT_INPUT_PATH_PROP)), lastCheckpointTime);\n      \r\n      eligibleFiles.sort(Comparator.comparingLong(FileStatus::getModificationTime));\n      \r\n      long currentBytes = 0;\n      long maxModificationTime = Long.MIN_VALUE;\n      List<FileStatus> filteredFiles = new ArrayList<>();\n      for (FileStatus f : eligibleFiles) {\n        if (currentBytes + f.getLen() >= sourceLimit) {\n          \r\n          break;\n        }\n\n        maxModificationTime = f.getModificationTime();\n        currentBytes += f.getLen();\n        filteredFiles.add(f);\n      }\n\n      \r\n      if (filteredFiles.isEmpty()) {\n        return new ImmutablePair<>(Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n      }\n\n      \r\n      String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n      return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n    } catch (IOException ioe) {\n      throw new HoodieIOException(\"Unable to read from source from checkpoint: \" + lastCheckpointStr, ioe);\n    }\n  }\n","date":"2020-10-21 14:20:19","endLine":134,"groupId":"3554","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getNextFilePathsAndMaxModificationTime","params":"(Option<String>lastCheckpointStr@longsourceLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/47/419e0297550618e6b8d574bc66fade57d165bd.src","preCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(Option<String> lastCheckpointStr,\n      long sourceLimit) {\n\n    try {\n      \r\n      log.info(\"Root path => \" + props.getString(Config.ROOT_INPUT_PATH_PROP) + \" source limit => \" + sourceLimit);\n      long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n      List<FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(props.getString(Config.ROOT_INPUT_PATH_PROP)), lastCheckpointTime);\n      \r\n      eligibleFiles.sort(Comparator.comparingLong(FileStatus::getModificationTime));\n      \r\n      long currentBytes = 0;\n      long maxModificationTime = Long.MIN_VALUE;\n      List<FileStatus> filteredFiles = new ArrayList<>();\n      for (FileStatus f : eligibleFiles) {\n        if (currentBytes + f.getLen() >= sourceLimit) {\n          \r\n          break;\n        }\n\n        maxModificationTime = f.getModificationTime();\n        currentBytes += f.getLen();\n        filteredFiles.add(f);\n      }\n\n      \r\n      if (filteredFiles.isEmpty()) {\n        return new ImmutablePair<>(Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n      }\n\n      \r\n      String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n      return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n    } catch (IOException ioe) {\n      throw new HoodieIOException(\"Unable to read from source from checkpoint: \" + lastCheckpointStr, ioe);\n    }\n  }\n","realPath":"hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/helpers/DFSPathSelector.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"N"}],"commitId":"f5e31be0866848940510b91dd4e9cdc7500a9086","commitMessage":"@@@[HUDI-1685] keep updating current date for every batch (#2671)\n\n","date":"2021-03-13 07:53:01","modifiedFileCount":"2","status":"M","submitter":"Ankush Kanungo"},{"authorTime":"2021-05-25 22:19:10","codes":[{"authorDate":"2021-05-25 22:19:10","commitOrder":9,"curCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(JavaSparkContext sparkContext,\n                                                                             Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    \r\n    LocalDate currentDate = LocalDate.parse(props.getString(Config.CURRENT_DATE, LocalDate.now().toString()));\n\n    \r\n    LOG.info(\n        \"Root path => \"\n            + props.getString(ROOT_INPUT_PATH_PROP)\n            + \" source limit => \"\n            + sourceLimit\n            + \" depth of day partition => \"\n            + datePartitionDepth\n            + \" num prev days to list => \"\n            + numPrevDaysToList\n            + \" from current date => \"\n            + currentDate);\n    long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n    HoodieSparkEngineContext context = new HoodieSparkEngineContext(sparkContext);\n    SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n    List<String> prunedParitionPaths = pruneDatePartitionPaths(context, fs, props.getString(ROOT_INPUT_PATH_PROP), currentDate);\n\n    List<FileStatus> eligibleFiles = context.flatMap(prunedParitionPaths,\n        path -> {\n          FileSystem fs = new Path(path).getFileSystem(serializedConf.get());\n          return listEligibleFiles(fs, new Path(path), lastCheckpointTime).stream();\n        }, partitionsListParallelism);\n    \r\n    List<FileStatus> sortedEligibleFiles = eligibleFiles.stream()\n        .sorted(Comparator.comparingLong(FileStatus::getModificationTime)).collect(Collectors.toList());\n\n    \r\n    long currentBytes = 0;\n    long newCheckpointTime = lastCheckpointTime;\n    List<FileStatus> filteredFiles = new ArrayList<>();\n    for (FileStatus f : sortedEligibleFiles) {\n      if (currentBytes + f.getLen() >= sourceLimit && f.getModificationTime() > newCheckpointTime) {\n        \r\n        \r\n        \r\n        break;\n      }\n\n      newCheckpointTime = f.getModificationTime();\n      currentBytes += f.getLen();\n      filteredFiles.add(f);\n    }\n\n    \r\n    if (filteredFiles.isEmpty()) {\n      return new ImmutablePair<>(Option.empty(), String.valueOf(newCheckpointTime));\n    }\n\n    \r\n    String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n    return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(newCheckpointTime));\n  }\n","date":"2021-05-25 22:19:10","endLine":171,"groupId":"10304","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"getNextFilePathsAndMaxModificationTime","params":"(JavaSparkContextsparkContext@Option<String>lastCheckpointStr@longsourceLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/71/e6a57dbe4994f12e84644e24c964d3e811ae47.src","preCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(JavaSparkContext sparkContext,\n                                                                             Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    \r\n    LocalDate currentDate = LocalDate.parse(props.getString(Config.CURRENT_DATE, LocalDate.now().toString()));\n\n    \r\n    LOG.info(\n        \"Root path => \"\n            + props.getString(ROOT_INPUT_PATH_PROP)\n            + \" source limit => \"\n            + sourceLimit\n            + \" depth of day partition => \"\n            + datePartitionDepth\n            + \" num prev days to list => \"\n            + numPrevDaysToList\n            + \" from current date => \"\n            + currentDate);\n    long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n    HoodieSparkEngineContext context = new HoodieSparkEngineContext(sparkContext);\n    SerializableConfiguration serializedConf = new SerializableConfiguration(fs.getConf());\n    List<String> prunedParitionPaths = pruneDatePartitionPaths(context, fs, props.getString(ROOT_INPUT_PATH_PROP), currentDate);\n\n    List<FileStatus> eligibleFiles = context.flatMap(prunedParitionPaths,\n        path -> {\n          FileSystem fs = new Path(path).getFileSystem(serializedConf.get());\n          return listEligibleFiles(fs, new Path(path), lastCheckpointTime).stream();\n        }, partitionsListParallelism);\n    \r\n    List<FileStatus> sortedEligibleFiles = eligibleFiles.stream()\n        .sorted(Comparator.comparingLong(FileStatus::getModificationTime)).collect(Collectors.toList());\n\n    \r\n    long currentBytes = 0;\n    List<FileStatus> filteredFiles = new ArrayList<>();\n    for (FileStatus f : sortedEligibleFiles) {\n      if (currentBytes + f.getLen() >= sourceLimit) {\n        \r\n        break;\n      }\n\n      currentBytes += f.getLen();\n      filteredFiles.add(f);\n    }\n\n    \r\n    if (filteredFiles.isEmpty()) {\n      return new ImmutablePair<>(\n          Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n    }\n\n    \r\n    String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n    long maxModificationTime = filteredFiles.get(filteredFiles.size() - 1).getModificationTime();\n    return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n  }\n","realPath":"hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/helpers/DatePartitionPathSelector.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2021-05-25 22:19:10","commitOrder":9,"curCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    try {\n      \r\n      log.info(\"Root path => \" + props.getString(Config.ROOT_INPUT_PATH_PROP) + \" source limit => \" + sourceLimit);\n      long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n      List<FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(props.getString(Config.ROOT_INPUT_PATH_PROP)), lastCheckpointTime);\n      \r\n      eligibleFiles.sort(Comparator.comparingLong(FileStatus::getModificationTime));\n      \r\n      long currentBytes = 0;\n      long newCheckpointTime = lastCheckpointTime;\n      List<FileStatus> filteredFiles = new ArrayList<>();\n      for (FileStatus f : eligibleFiles) {\n        if (currentBytes + f.getLen() >= sourceLimit && f.getModificationTime() > newCheckpointTime) {\n          \r\n          \r\n          \r\n          break;\n        }\n\n        newCheckpointTime = f.getModificationTime();\n        currentBytes += f.getLen();\n        filteredFiles.add(f);\n      }\n\n      \r\n      if (filteredFiles.isEmpty()) {\n        return new ImmutablePair<>(Option.empty(), String.valueOf(newCheckpointTime));\n      }\n\n      \r\n      String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n      return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(newCheckpointTime));\n    } catch (IOException ioe) {\n      throw new HoodieIOException(\"Unable to read from source from checkpoint: \" + lastCheckpointStr, ioe);\n    }\n  }\n","date":"2021-05-25 22:19:10","endLine":151,"groupId":"10304","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"getNextFilePathsAndMaxModificationTime","params":"(Option<String>lastCheckpointStr@longsourceLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/93/01bf31d7fc064940380bf62d900a9af1643efd.src","preCode":"  public Pair<Option<String>, String> getNextFilePathsAndMaxModificationTime(Option<String> lastCheckpointStr,\n                                                                             long sourceLimit) {\n    try {\n      \r\n      log.info(\"Root path => \" + props.getString(Config.ROOT_INPUT_PATH_PROP) + \" source limit => \" + sourceLimit);\n      long lastCheckpointTime = lastCheckpointStr.map(Long::parseLong).orElse(Long.MIN_VALUE);\n      List<FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(props.getString(Config.ROOT_INPUT_PATH_PROP)), lastCheckpointTime);\n      \r\n      eligibleFiles.sort(Comparator.comparingLong(FileStatus::getModificationTime));\n      \r\n      long currentBytes = 0;\n      long maxModificationTime = Long.MIN_VALUE;\n      List<FileStatus> filteredFiles = new ArrayList<>();\n      for (FileStatus f : eligibleFiles) {\n        if (currentBytes + f.getLen() >= sourceLimit) {\n          \r\n          break;\n        }\n\n        maxModificationTime = f.getModificationTime();\n        currentBytes += f.getLen();\n        filteredFiles.add(f);\n      }\n\n      \r\n      if (filteredFiles.isEmpty()) {\n        return new ImmutablePair<>(Option.empty(), lastCheckpointStr.orElseGet(() -> String.valueOf(Long.MIN_VALUE)));\n      }\n\n      \r\n      String pathStr = filteredFiles.stream().map(f -> f.getPath().toString()).collect(Collectors.joining(\",\"));\n\n      return new ImmutablePair<>(Option.ofNullable(pathStr), String.valueOf(maxModificationTime));\n    } catch (IOException ioe) {\n      throw new HoodieIOException(\"Unable to read from source from checkpoint: \" + lastCheckpointStr, ioe);\n    }\n  }\n","realPath":"hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/helpers/DFSPathSelector.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"afa6bc0b100450b5d80a27bf5b87cbd4a0fbb3a5","commitMessage":"@@@[HUDI-1723] Fix path selector listing files with the same mod date (#2845)\n\n","date":"2021-05-25 22:19:10","modifiedFileCount":"3","status":"M","submitter":"Raymond Xu"}]
