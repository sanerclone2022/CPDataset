[{"authorTime":"2020-11-03 05:12:51","codes":[{"authorDate":"2020-11-03 05:12:51","commitOrder":1,"curCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.getSplitRegex());\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\");\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2020-11-03 05:12:51","endLine":127,"groupId":"4797","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getPartitionPath","params":"(Option<GenericRecord>record@Option<Row>row)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/67/27b79d7847747da01dba7cc080ef9502bba207.src","preCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.getSplitRegex());\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\");\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"B"},{"authorDate":"2020-11-03 05:12:51","commitOrder":1,"curCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\");\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2020-11-03 05:12:51","endLine":101,"groupId":"2970","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getPartitionPath","params":"(GenericRecordrecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/62/66fd15c6b849d23f11e5455fa40d464dafec81.src","preCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\");\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CustomAvroKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"B"}],"commitId":"d160abb43740e0bcdf40458c345ecd2d74e6698c","commitMessage":"@@@[HUDI-912] Refactor and relocate KeyGenerator to support more engines (#2200)\n\n* [HUDI-912] Refactor and relocate KeyGenerator to support more engines\n\n* Rename KeyGenerators","date":"2020-11-03 05:12:51","modifiedFileCount":"1","status":"B","submitter":"wangxianghu"},{"authorTime":"2020-12-22 09:02:23","codes":[{"authorDate":"2020-12-22 09:02:23","commitOrder":2,"curCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.getSplitRegex());\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", ioe);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2020-12-22 09:02:23","endLine":127,"groupId":"4797","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getPartitionPath","params":"(Option<GenericRecord>record@Option<Row>row)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/77/896d2e88a06c722abfb45b6adff7bc48a7b5da.src","preCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.getSplitRegex());\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\");\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2020-12-22 09:02:23","commitOrder":2,"curCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", e);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2020-12-22 09:02:23","endLine":101,"groupId":"2970","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getPartitionPath","params":"(GenericRecordrecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/72/4cabdc73964e5b44607056a1cacf0bc2f9b00f.src","preCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\");\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CustomAvroKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"}],"commitId":"0c821fecc2140683de24d9b350c8142b4b8b8c47","commitMessage":"@@@[MINOR] Pass root exception to HoodieKeyGeneratorException for more information (#2354)\n\nCo-authored-by: Xi Chen <chenxi07@qiyi.com>","date":"2020-12-22 09:02:23","modifiedFileCount":"2","status":"M","submitter":"jshmchenxi"},{"authorTime":"2020-12-22 09:02:23","codes":[{"authorDate":"2021-04-02 02:12:28","commitOrder":3,"curCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", ioe);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2021-04-02 02:12:28","endLine":127,"groupId":"4797","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getPartitionPath","params":"(Option<GenericRecord>record@Option<Row>row)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/a2/a3012908e4602fc17c3c4cdc4322deb2fcd2c8.src","preCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.getSplitRegex());\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", ioe);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2020-12-22 09:02:23","commitOrder":3,"curCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", e);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2020-12-22 09:02:23","endLine":101,"groupId":"2970","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getPartitionPath","params":"(GenericRecordrecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/72/4cabdc73964e5b44607056a1cacf0bc2f9b00f.src","preCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", e);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CustomAvroKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"N"}],"commitId":"684622c7c9fa6df9eb177b51cb1e7bd6dd16f78d","commitMessage":"@@@[HUDI-1591] Implement Spark's FileIndex for Hudi to support queries via Hudi DataSource using non-globbed table path and partition pruning (#2651)\n\n","date":"2021-04-02 02:12:28","modifiedFileCount":"6","status":"M","submitter":"pengzhiwei"},{"authorTime":"2020-12-22 09:02:23","codes":[{"authorDate":"2021-07-20 08:43:48","commitOrder":4,"curCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row, Option<Pair<InternalRow, StructType>> internalRowStructTypePair) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else if (row.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(internalRowStructTypePair.get().getKey(),\n                internalRowStructTypePair.get().getValue()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else if (row.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(internalRowStructTypePair.get().getKey(),\n                  internalRowStructTypePair.get().getValue()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", ioe);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2021-07-20 08:43:48","endLine":142,"groupId":"10771","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getPartitionPath","params":"(Option<GenericRecord>record@Option<Row>row@Option<Pair<InternalRow@StructType>>internalRowStructTypePair)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/14/a1c1677726aab9fb72ec6caf0122704dd9875b.src","preCode":"  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(customAvroKeyGenerator.SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyGeneratorException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      CustomAvroKeyGenerator.PartitionKeyType keyType = CustomAvroKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          if (record.isPresent()) {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n          } else {\n            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n          }\n          break;\n        case TIMESTAMP:\n          try {\n            if (record.isPresent()) {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n            } else {\n              partitionPath.append(new TimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n            }\n          } catch (IOException ioe) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", ioe);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n\n      partitionPath.append(customAvroKeyGenerator.getDefaultPartitionPathSeparator());\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"M"},{"authorDate":"2020-12-22 09:02:23","commitOrder":4,"curCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", e);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","date":"2020-12-22 09:02:23","endLine":101,"groupId":"10771","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getPartitionPath","params":"(GenericRecordrecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/72/4cabdc73964e5b44607056a1cacf0bc2f9b00f.src","preCode":"  public String getPartitionPath(GenericRecord record) {\n    if (getPartitionPathFields() == null) {\n      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n    }\n\n    String partitionPathField;\n    StringBuilder partitionPath = new StringBuilder();\n\n    \r\n    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n      return \"\";\n    }\n    for (String field : getPartitionPathFields()) {\n      String[] fieldWithType = field.split(SPLIT_REGEX);\n      if (fieldWithType.length != 2) {\n        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n      }\n\n      partitionPathField = fieldWithType[0];\n      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n      switch (keyType) {\n        case SIMPLE:\n          partitionPath.append(new SimpleAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          break;\n        case TIMESTAMP:\n          try {\n            partitionPath.append(new TimestampBasedAvroKeyGenerator(config, partitionPathField).getPartitionPath(record));\n          } catch (IOException e) {\n            throw new HoodieKeyGeneratorException(\"Unable to initialise TimestampBasedKeyGenerator class\", e);\n          }\n          break;\n        default:\n          throw new HoodieKeyGeneratorException(\"Please provide valid PartitionKeyType with fields! You provided: \" + keyType);\n      }\n      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n    }\n    partitionPath.deleteCharAt(partitionPath.length() - 1);\n    return partitionPath.toString();\n  }\n","realPath":"hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CustomAvroKeyGenerator.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"N"}],"commitId":"d5026e9a24850bdcce9f6df3686bf2235d7d01c4","commitMessage":"@@@[HUDI-2161] Adding support to disable meta columns with bulk insert operation (#3247)\n\n","date":"2021-07-20 08:43:48","modifiedFileCount":"39","status":"M","submitter":"Sivabalan Narayanan"}]
