[{"authorTime":"2020-11-06 00:49:58","codes":[{"authorDate":"2020-09-30 08:04:25","commitOrder":2,"curCode":"  public void testReplaceWithTimeTravel() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n\n    \r\n    String fileId3 = UUID.randomUUID().toString();\n    String fileId4 = UUID.randomUUID().toString();\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    String fileName4 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId4);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName4).createNewFile();\n\n    String commitTime2 = \"2\";\n    Map<String, List<String>> partitionToReplaceFileIds = new HashMap<>();\n    List<String> replacedFileIds = new ArrayList<>();\n    replacedFileIds.add(fileId1);\n    partitionToReplaceFileIds.put(partitionPath1, replacedFileIds);\n    HoodieCommitMetadata commitMetadata =\n        CommitUtils.buildMetadata(Collections.emptyList(), partitionToReplaceFileIds, Option.empty(), WriteOperationType.INSERT_OVERWRITE, \"\", HoodieTimeline.REPLACE_COMMIT_ACTION);\n    commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant2 = new HoodieInstant(true, HoodieTimeline.REPLACE_COMMIT_ACTION, commitTime2);\n    saveAsComplete(commitTimeline, instant2, Option.of(commitMetadata.toJsonString().getBytes(StandardCharsets.UTF_8)));\n\n    \r\n    refreshFsView();\n    assertEquals(0, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    SyncableFileSystemView filteredView = getFileSystemView(metaClient.getActiveTimeline().findInstantsBefore(\"2\"), false);\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    List<HoodieFileGroup> replacedOnInstant1 = fsView.getReplacedFileGroupsBeforeOrOn(\"1\", partitionPath1).collect(Collectors.toList());\n    assertEquals(0, replacedOnInstant1.size());\n\n    List<HoodieFileGroup> allReplaced = fsView.getReplacedFileGroupsBeforeOrOn(\"2\", partitionPath1).collect(Collectors.toList());\n    assertEquals(1, allReplaced.size());\n    assertEquals(fileId1, allReplaced.get(0).getFileGroupId().getFileId());\n  }\n","date":"2020-09-30 08:04:25","endLine":1356,"groupId":"1082","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testReplaceWithTimeTravel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/c5/8df38c0a8e936ca03959d272d09b7a4f0e7440.src","preCode":"  public void testReplaceWithTimeTravel() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n\n    \r\n    String fileId3 = UUID.randomUUID().toString();\n    String fileId4 = UUID.randomUUID().toString();\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    String fileName4 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId4);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName4).createNewFile();\n\n    String commitTime2 = \"2\";\n    Map<String, List<String>> partitionToReplaceFileIds = new HashMap<>();\n    List<String> replacedFileIds = new ArrayList<>();\n    replacedFileIds.add(fileId1);\n    partitionToReplaceFileIds.put(partitionPath1, replacedFileIds);\n    HoodieCommitMetadata commitMetadata =\n        CommitUtils.buildMetadata(Collections.emptyList(), partitionToReplaceFileIds, Option.empty(), WriteOperationType.INSERT_OVERWRITE, \"\", HoodieTimeline.REPLACE_COMMIT_ACTION);\n    commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant2 = new HoodieInstant(true, HoodieTimeline.REPLACE_COMMIT_ACTION, commitTime2);\n    saveAsComplete(commitTimeline, instant2, Option.of(commitMetadata.toJsonString().getBytes(StandardCharsets.UTF_8)));\n\n    \r\n    refreshFsView();\n    assertEquals(0, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    SyncableFileSystemView filteredView = getFileSystemView(metaClient.getActiveTimeline().findInstantsBefore(\"2\"), false);\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    List<HoodieFileGroup> replacedOnInstant1 = fsView.getReplacedFileGroupsBeforeOrOn(\"1\", partitionPath1).collect(Collectors.toList());\n    assertEquals(0, replacedOnInstant1.size());\n\n    List<HoodieFileGroup> allReplaced = fsView.getReplacedFileGroupsBeforeOrOn(\"2\", partitionPath1).collect(Collectors.toList());\n    assertEquals(1, allReplaced.size());\n    assertEquals(fileId1, allReplaced.get(0).getFileGroupId().getFileId());\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestHoodieTableFileSystemView.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":1281,"status":"NB"},{"authorDate":"2020-11-06 00:49:58","commitOrder":2,"curCode":"  public void testPendingClusteringOperations() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n    String fileId3 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2) || dfile.getFileId().equals(fileId3)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n\n    List<FileSlice>[] fileSliceGroups = new List[] {\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId1).get()),\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId2).get())\n    };\n\n    \r\n    HoodieClusteringPlan plan = ClusteringUtils.createClusteringPlan(\"strategy\", new HashMap<>(),\n        fileSliceGroups, Collections.emptyMap());\n\n    String clusterTime = \"2\";\n    HoodieInstant instant2 = new HoodieInstant(State.REQUESTED, HoodieTimeline.REPLACE_COMMIT_ACTION, clusterTime);\n    HoodieRequestedReplaceMetadata requestedReplaceMetadata = HoodieRequestedReplaceMetadata.newBuilder()\n        .setClusteringPlan(plan).setOperationType(WriteOperationType.CLUSTER.name()).build();\n    metaClient.getActiveTimeline().saveToPendingReplaceCommit(instant2, TimelineMetadataUtils.serializeRequestedReplaceMetadata(requestedReplaceMetadata));\n\n    \r\n    refreshFsView();\n    Set<String> fileIds =\n        fsView.getFileGroupsInPendingClustering().map(e -> e.getLeft().getFileId()).collect(Collectors.toSet());\n    assertTrue(fileIds.contains(fileId1));\n    assertTrue(fileIds.contains(fileId2));\n    assertFalse(fileIds.contains(fileId3));\n  }\n","date":"2020-11-06 00:49:58","endLine":1485,"groupId":"585","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPendingClusteringOperations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/3f/ceee3bb40c1f7065e8e68217c7584ddde85cbb.src","preCode":"  public void testPendingClusteringOperations() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n    String fileId3 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2) || dfile.getFileId().equals(fileId3)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n\n    List<FileSlice>[] fileSliceGroups = new List[] {\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId1).get()),\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId2).get())\n    };\n\n    \r\n    HoodieClusteringPlan plan = ClusteringUtils.createClusteringPlan(\"strategy\", new HashMap<>(),\n        fileSliceGroups, Collections.emptyMap());\n\n    String clusterTime = \"2\";\n    HoodieInstant instant2 = new HoodieInstant(State.REQUESTED, HoodieTimeline.REPLACE_COMMIT_ACTION, clusterTime);\n    HoodieRequestedReplaceMetadata requestedReplaceMetadata = HoodieRequestedReplaceMetadata.newBuilder()\n        .setClusteringPlan(plan).setOperationType(WriteOperationType.CLUSTER.name()).build();\n    metaClient.getActiveTimeline().saveToPendingReplaceCommit(instant2, TimelineMetadataUtils.serializeRequestedReplaceMetadata(requestedReplaceMetadata));\n\n    \r\n    refreshFsView();\n    Set<String> fileIds =\n        fsView.getFileGroupsInPendingClustering().map(e -> e.getLeft().getFileId()).collect(Collectors.toSet());\n    assertTrue(fileIds.contains(fileId1));\n    assertTrue(fileIds.contains(fileId2));\n    assertFalse(fileIds.contains(fileId3));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestHoodieTableFileSystemView.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"B"}],"commitId":"33ec88fc3840c47a54b5862e4d276889c4121231","commitMessage":"@@@[HUDI-1352] Add FileSystemView APIs to query pending clustering operations (#2202)\n\n","date":"2020-11-06 00:49:58","modifiedFileCount":"17","status":"M","submitter":"satishkotha"},{"authorTime":"2020-11-06 00:49:58","codes":[{"authorDate":"2021-01-10 08:53:34","commitOrder":3,"curCode":"  public void testReplaceWithTimeTravel() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n\n    \r\n    String fileId3 = UUID.randomUUID().toString();\n    String fileId4 = UUID.randomUUID().toString();\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    String fileName4 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId4);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName4).createNewFile();\n\n    String commitTime2 = \"2\";\n    Map<String, List<String>> partitionToReplaceFileIds = new HashMap<>();\n    List<String> replacedFileIds = new ArrayList<>();\n    replacedFileIds.add(fileId1);\n    partitionToReplaceFileIds.put(partitionPath1, replacedFileIds);\n    HoodieCommitMetadata commitMetadata =\n        CommitUtils.buildMetadata(Collections.emptyList(), partitionToReplaceFileIds, Option.empty(), WriteOperationType.INSERT_OVERWRITE, \"\", HoodieTimeline.REPLACE_COMMIT_ACTION);\n    commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant2 = new HoodieInstant(true, HoodieTimeline.REPLACE_COMMIT_ACTION, commitTime2);\n    saveAsComplete(commitTimeline, instant2, Option.of(commitMetadata.toJsonString().getBytes(StandardCharsets.UTF_8)));\n\n    \r\n    refreshFsView();\n    assertEquals(0, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    SyncableFileSystemView filteredView = getFileSystemView(metaClient.getActiveTimeline().findInstantsBefore(\"2\"), false);\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    List<HoodieFileGroup> replacedOnInstant1 = fsView.getReplacedFileGroupsBeforeOrOn(\"1\", partitionPath1).collect(Collectors.toList());\n    assertEquals(0, replacedOnInstant1.size());\n\n    List<HoodieFileGroup> allReplaced = fsView.getReplacedFileGroupsBeforeOrOn(\"2\", partitionPath1).collect(Collectors.toList());\n    assertEquals(1, allReplaced.size());\n    assertEquals(fileId1, allReplaced.get(0).getFileGroupId().getFileId());\n\n    allReplaced = fsView.getReplacedFileGroupsBefore(\"2\", partitionPath1).collect(Collectors.toList());\n    assertEquals(0, allReplaced.size());\n\n    allReplaced = fsView.getAllReplacedFileGroups(partitionPath1).collect(Collectors.toList());\n    assertEquals(1, allReplaced.size());\n    assertEquals(fileId1, allReplaced.get(0).getFileGroupId().getFileId());\n  }\n","date":"2021-01-10 08:53:34","endLine":1366,"groupId":"10893","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testReplaceWithTimeTravel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/e1/03427d40728b722ff032cf8de3b5ba3410880f.src","preCode":"  public void testReplaceWithTimeTravel() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n\n    \r\n    String fileId3 = UUID.randomUUID().toString();\n    String fileId4 = UUID.randomUUID().toString();\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    String fileName4 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId4);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName4).createNewFile();\n\n    String commitTime2 = \"2\";\n    Map<String, List<String>> partitionToReplaceFileIds = new HashMap<>();\n    List<String> replacedFileIds = new ArrayList<>();\n    replacedFileIds.add(fileId1);\n    partitionToReplaceFileIds.put(partitionPath1, replacedFileIds);\n    HoodieCommitMetadata commitMetadata =\n        CommitUtils.buildMetadata(Collections.emptyList(), partitionToReplaceFileIds, Option.empty(), WriteOperationType.INSERT_OVERWRITE, \"\", HoodieTimeline.REPLACE_COMMIT_ACTION);\n    commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant2 = new HoodieInstant(true, HoodieTimeline.REPLACE_COMMIT_ACTION, commitTime2);\n    saveAsComplete(commitTimeline, instant2, Option.of(commitMetadata.toJsonString().getBytes(StandardCharsets.UTF_8)));\n\n    \r\n    refreshFsView();\n    assertEquals(0, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    SyncableFileSystemView filteredView = getFileSystemView(metaClient.getActiveTimeline().findInstantsBefore(\"2\"), false);\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n    assertEquals(1, filteredView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId4)).count());\n\n    \r\n    List<HoodieFileGroup> replacedOnInstant1 = fsView.getReplacedFileGroupsBeforeOrOn(\"1\", partitionPath1).collect(Collectors.toList());\n    assertEquals(0, replacedOnInstant1.size());\n\n    List<HoodieFileGroup> allReplaced = fsView.getReplacedFileGroupsBeforeOrOn(\"2\", partitionPath1).collect(Collectors.toList());\n    assertEquals(1, allReplaced.size());\n    assertEquals(fileId1, allReplaced.get(0).getFileGroupId().getFileId());\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestHoodieTableFileSystemView.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":1284,"status":"M"},{"authorDate":"2020-11-06 00:49:58","commitOrder":3,"curCode":"  public void testPendingClusteringOperations() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n    String fileId3 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2) || dfile.getFileId().equals(fileId3)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n\n    List<FileSlice>[] fileSliceGroups = new List[] {\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId1).get()),\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId2).get())\n    };\n\n    \r\n    HoodieClusteringPlan plan = ClusteringUtils.createClusteringPlan(\"strategy\", new HashMap<>(),\n        fileSliceGroups, Collections.emptyMap());\n\n    String clusterTime = \"2\";\n    HoodieInstant instant2 = new HoodieInstant(State.REQUESTED, HoodieTimeline.REPLACE_COMMIT_ACTION, clusterTime);\n    HoodieRequestedReplaceMetadata requestedReplaceMetadata = HoodieRequestedReplaceMetadata.newBuilder()\n        .setClusteringPlan(plan).setOperationType(WriteOperationType.CLUSTER.name()).build();\n    metaClient.getActiveTimeline().saveToPendingReplaceCommit(instant2, TimelineMetadataUtils.serializeRequestedReplaceMetadata(requestedReplaceMetadata));\n\n    \r\n    refreshFsView();\n    Set<String> fileIds =\n        fsView.getFileGroupsInPendingClustering().map(e -> e.getLeft().getFileId()).collect(Collectors.toSet());\n    assertTrue(fileIds.contains(fileId1));\n    assertTrue(fileIds.contains(fileId2));\n    assertFalse(fileIds.contains(fileId3));\n  }\n","date":"2020-11-06 00:49:58","endLine":1485,"groupId":"10893","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPendingClusteringOperations","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-hudi-10-0.7/blobInfo/CC_OUT/blobs/3f/ceee3bb40c1f7065e8e68217c7584ddde85cbb.src","preCode":"  public void testPendingClusteringOperations() throws IOException {\n    String partitionPath1 = \"2020/06/27\";\n    new File(basePath + \"/\" + partitionPath1).mkdirs();\n\n    \r\n    String fileId1 = UUID.randomUUID().toString();\n    String fileId2 = UUID.randomUUID().toString();\n    String fileId3 = UUID.randomUUID().toString();\n\n    assertFalse(roView.getLatestBaseFiles(partitionPath1)\n            .anyMatch(dfile -> dfile.getFileId().equals(fileId1) || dfile.getFileId().equals(fileId2) || dfile.getFileId().equals(fileId3)),\n        \"No commit, should not find any data file\");\n    \r\n    String commitTime1 = \"1\";\n    String fileName1 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId1);\n    String fileName2 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId2);\n    String fileName3 = FSUtils.makeDataFileName(commitTime1, TEST_WRITE_TOKEN, fileId3);\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName1).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName2).createNewFile();\n    new File(basePath + \"/\" + partitionPath1 + \"/\" + fileName3).createNewFile();\n\n    HoodieActiveTimeline commitTimeline = metaClient.getActiveTimeline();\n    HoodieInstant instant1 = new HoodieInstant(true, HoodieTimeline.COMMIT_ACTION, commitTime1);\n    saveAsComplete(commitTimeline, instant1, Option.empty());\n    refreshFsView();\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId1)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId2)).count());\n    assertEquals(1, roView.getLatestBaseFiles(partitionPath1)\n        .filter(dfile -> dfile.getFileId().equals(fileId3)).count());\n\n    List<FileSlice>[] fileSliceGroups = new List[] {\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId1).get()),\n        Collections.singletonList(fsView.getLatestFileSlice(partitionPath1, fileId2).get())\n    };\n\n    \r\n    HoodieClusteringPlan plan = ClusteringUtils.createClusteringPlan(\"strategy\", new HashMap<>(),\n        fileSliceGroups, Collections.emptyMap());\n\n    String clusterTime = \"2\";\n    HoodieInstant instant2 = new HoodieInstant(State.REQUESTED, HoodieTimeline.REPLACE_COMMIT_ACTION, clusterTime);\n    HoodieRequestedReplaceMetadata requestedReplaceMetadata = HoodieRequestedReplaceMetadata.newBuilder()\n        .setClusteringPlan(plan).setOperationType(WriteOperationType.CLUSTER.name()).build();\n    metaClient.getActiveTimeline().saveToPendingReplaceCommit(instant2, TimelineMetadataUtils.serializeRequestedReplaceMetadata(requestedReplaceMetadata));\n\n    \r\n    refreshFsView();\n    Set<String> fileIds =\n        fsView.getFileGroupsInPendingClustering().map(e -> e.getLeft().getFileId()).collect(Collectors.toSet());\n    assertTrue(fileIds.contains(fileId1));\n    assertTrue(fileIds.contains(fileId2));\n    assertFalse(fileIds.contains(fileId3));\n  }\n","realPath":"hudi-common/src/test/java/org/apache/hudi/common/table/view/TestHoodieTableFileSystemView.java","repoName":"hudi","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"}],"commitId":"65866c45ec04820b01ab701e7de5cf6a406d2a8e","commitMessage":"@@@[HUDI-1276] [HUDI-1459] Make Clustering/ReplaceCommit and Metadata table be compatible (#2422)\n\n* [HUDI-1276] [HUDI-1459] Make Clustering/ReplaceCommit and Metadata table be compatible\n\n* Use filesystemview and json format from metadata. Add tests\n\nCo-authored-by: Satish Kotha <satishkotha@uber.com>","date":"2021-01-10 08:53:34","modifiedFileCount":"17","status":"M","submitter":"vinoth chandar"}]
