[{"authorTime":"2015-12-03 11:23:54","codes":[{"authorDate":"2015-12-03 11:23:54","commitOrder":1,"curCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-01-24 11:35:29","endLine":1348,"groupId":"20444","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testChinesePrefixSearch","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cb/5ec73780d95c217a07a36dfb7bf84ee929528a.src","preCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1294,"status":"B"},{"authorDate":"2015-12-03 11:23:54","commitOrder":1,"curCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-01-24 11:35:29","endLine":1489,"groupId":"10385","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPrefixSSTableLookup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cb/5ec73780d95c217a07a36dfb7bf84ee929528a.src","preCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1423,"status":"B"}],"commitId":"72790dc8e34826b39ac696b03025ae6b7b6beb2b","commitMessage":"@@@Integrate SASI index into Cassandra\n\npatch by xedin; reviewed by beobal for CASSANDRA-10661\n","date":"2016-01-24 11:35:29","modifiedFileCount":"17","status":"B","submitter":"Pavel Yaskevich"},{"authorTime":"2016-01-26 11:13:36","codes":[{"authorDate":"2016-01-26 11:13:36","commitOrder":2,"curCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-06 03:56:23","endLine":1358,"groupId":"20444","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testChinesePrefixSearch","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b3/2bfc55205929c7bc45439ad848da8e9fd21b83.src","preCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1304,"status":"M"},{"authorDate":"2016-01-26 11:13:36","commitOrder":2,"curCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n    }\n","date":"2016-02-06 03:56:23","endLine":1505,"groupId":"10385","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPrefixSSTableLookup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b3/2bfc55205929c7bc45439ad848da8e9fd21b83.src","preCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1433,"status":"M"}],"commitId":"392866546e6377aafd018c3fcb2e124674a318dc","commitMessage":"@@@add LIKE support to CQL3\npatch by xedin; reviewed by beobal for CASSANDRA-11067\n","date":"2016-02-06 03:56:23","modifiedFileCount":"28","status":"M","submitter":"Pavel Yaskevich"},{"authorTime":"2016-02-08 09:15:21","codes":[{"authorDate":"2016-01-26 11:13:36","commitOrder":3,"curCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-06 03:56:23","endLine":1358,"groupId":"20444","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testChinesePrefixSearch","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b3/2bfc55205929c7bc45439ad848da8e9fd21b83.src","preCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1304,"status":"N"},{"authorDate":"2016-02-08 09:15:21","commitOrder":3,"curCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\")); \r\n        update(rm, name, UTF8Type.instance.decompose(\"Jean-Claude\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\"}, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"JeAn\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"claUde\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean-Claude\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-12 03:24:40","endLine":1525,"groupId":"25875","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testPrefixSSTableLookup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/a8/8e5940f8dc20287822e7c5aeb174cbab1c67af.src","preCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1433,"status":"M"}],"commitId":"479e8aff1346d41ebc05e1a113996a803228284d","commitMessage":"@@@fix EQ semantics of analyzed SASI indexes\n\npatch by xedin; reviewed by beobal for CASSANDRA-11130\n","date":"2016-02-12 03:24:40","modifiedFileCount":"13","status":"M","submitter":"Pavel Yaskevich"},{"authorTime":"2017-09-13 21:57:50","codes":[{"authorDate":"2017-09-13 21:57:50","commitOrder":4,"curCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2018-01-09 15:10:23","endLine":1403,"groupId":"20444","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testChinesePrefixSearch","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/07/1f84d05f620db46530bd7aab58b09331bd9d26.src","preCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1349,"status":"M"},{"authorDate":"2017-09-13 21:57:50","commitOrder":4,"curCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation.PartitionUpdateCollector rm;\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key8\")); \r\n        update(rm, name, UTF8Type.instance.decompose(\"Jean-Claude\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\"}, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"JeAn\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"claUde\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean-Claude\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2018-01-09 15:10:23","endLine":1570,"groupId":"17226","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testPrefixSSTableLookup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/07/1f84d05f620db46530bd7aab58b09331bd9d26.src","preCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation rm;\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key8\")); \r\n        update(rm, name, UTF8Type.instance.decompose(\"Jean-Claude\"), System.currentTimeMillis());\n        rm.apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\"}, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"JeAn\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"claUde\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean-Claude\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1478,"status":"M"}],"commitId":"de7c24b395265ff619c622ed6be8d88453f158ac","commitMessage":"@@@Make PartitionUpdate and Mutation immutable\n\nPatch by marcuse; reviewed by Aleksey Yeschenko for CASSANDRA-13867\n","date":"2018-01-09 15:10:23","modifiedFileCount":"33","status":"M","submitter":"Marcus Eriksson"},{"authorTime":"2021-03-08 18:31:12","codes":[{"authorDate":"2021-03-08 18:31:12","commitOrder":5,"curCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 1000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 2000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 3000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 4000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 5000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 6000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 7000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), 8000);\n        rm.build().apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        assertRows(rows, \"key3\");\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        assertRows(rows, \"key7\");\n    }\n","date":"2021-03-08 18:31:59","endLine":1469,"groupId":"101072","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testChinesePrefixSearch","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/33/96e3d86732343cf4348530977ce2e41af0605a.src","preCode":"    public void testChinesePrefixSearch()\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer fullName = UTF8Type.instance.decompose(\"/output/full-name/\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key8\"));\n        update(rm, fullName, UTF8Type.instance.decompose(\"������������������ ������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        store.forceBlockingFlush();\n\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.EQ, UTF8Type.instance.decompose(\"������������������ ������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(fullName, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1415,"status":"M"},{"authorDate":"2021-03-08 18:31:12","commitOrder":5,"curCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation.PartitionUpdateCollector rm;\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), 1000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), 2000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), 3000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), 4000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), 5000);\n        rm.build().apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), 6000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), 7000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key8\")); \r\n        update(rm, name, UTF8Type.instance.decompose(\"Jean-Claude\"), 8000);\n        rm.build().apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        assertRows(rows, \"key2\", \"key5\", \"key6\", \"key8\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        assertRows(rows, \"key2\", \"key5\", \"key6\", \"key8\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        assertRows(rows, \"key3\", \"key4\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        assertRows(rows, \"key7\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        assertRows(rows, \"key2\", \"key6\", \"key8\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"pavel\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pavel\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"JeAn\")));\n        assertRows(rows, \"key8\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"claUde\")));\n        assertRows(rows, \"key8\");\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean-Claude\")));\n        assertRows(rows, \"key8\");\n    }\n","date":"2021-03-08 18:31:59","endLine":1636,"groupId":"101072","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testPrefixSSTableLookup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/33/96e3d86732343cf4348530977ce2e41af0605a.src","preCode":"    public void testPrefixSSTableLookup()\n    {\n        \r\n        \r\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer name = UTF8Type.instance.decompose(\"first_name_prefix\");\n\n        Mutation.PartitionUpdateCollector rm;\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Pavel\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jordan\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Mikhail\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Michael\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Johnny\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key6\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Jason\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key7\"));\n        update(rm, name, UTF8Type.instance.decompose(\"Vijay\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key8\")); \r\n        update(rm, name, UTF8Type.instance.decompose(\"Jean-Claude\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        \r\n        store.forceBlockingFlush();\n\n        \r\n        \r\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"J\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\"}, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key5\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"m\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"v\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key7\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"p\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_PREFIX, UTF8Type.instance.decompose(\"j\")),\n                                     buildExpression(name, Operator.NEQ, UTF8Type.instance.decompose(\"joh\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key6\", \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pave\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Pavel\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"JeAn\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"claUde\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean\")));\n        Assert.assertTrue(rows.isEmpty());\n\n        rows = getIndexed(store, 10, buildExpression(name, Operator.EQ, UTF8Type.instance.decompose(\"Jean-Claude\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key8\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1544,"status":"M"}],"commitId":"2aa22ba99dcc1dacb07b7af31b2664e7db839063","commitMessage":"@@@Merge branch cassandra-3.11 into trunk\n","date":"2021-03-08 18:31:59","modifiedFileCount":"1","status":"M","submitter":"Benjamin Lerer"}]
