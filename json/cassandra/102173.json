[{"authorTime":"2016-09-01 06:48:43","codes":[{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public ListenableFuture<Boolean> prepare(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Sending PrepareConsistentRequest message to {}\", participants);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return prepareFuture;\n    }\n","date":"2017-02-07 11:11:18","endLine":148,"groupId":"3846","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"prepare","params":"(Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ef/3eacda4ff0a5679ec05b441c1888da9f425138.src","preCode":"    public ListenableFuture<Boolean> prepare(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Sending PrepareConsistentRequest message to {}\", participants);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return prepareFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"B"},{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Sending FinalizePropose message to {}\", participants);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","date":"2017-02-07 11:11:18","endLine":188,"groupId":"3846","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizePropose","params":"(Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ef/3eacda4ff0a5679ec05b441c1888da9f425138.src","preCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Sending FinalizePropose message to {}\", participants);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"B"}],"commitId":"98d74ed998706e9e047dc0f7886a1e9b18df3ce9","commitMessage":"@@@Fix consistency of incrementally repaired data\n\npatch by Blake Eggleston.  reviewed by Marcus Eriksson for CASSANDRA-9143\n","date":"2017-02-07 11:11:18","modifiedFileCount":"81","status":"B","submitter":"Blake Eggleston"},{"authorTime":"2017-04-21 04:24:14","codes":[{"authorDate":"2017-04-21 04:24:14","commitOrder":2,"curCode":"    public ListenableFuture<Boolean> prepare(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return prepareFuture;\n    }\n","date":"2017-05-03 00:19:27","endLine":149,"groupId":"21389","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"prepare","params":"(Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cd/4844b0146ceb27cd4de1ec0046872950aa8c02.src","preCode":"    public ListenableFuture<Boolean> prepare(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Sending PrepareConsistentRequest message to {}\", participants);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return prepareFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":138,"status":"M"},{"authorDate":"2017-04-21 04:24:14","commitOrder":2,"curCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","date":"2017-05-03 00:19:27","endLine":190,"groupId":"31661","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizePropose","params":"(Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cd/4844b0146ceb27cd4de1ec0046872950aa8c02.src","preCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Sending FinalizePropose message to {}\", participants);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"}],"commitId":"4ef0bf8861ee12f5c7e826298c42fe3ddb29c198","commitMessage":"@@@Improve incremental repair logging\n\nPatch by Blake Eggleston; reviewed by Marcus Eriksson for CASSANDRA-13468\n","date":"2017-05-03 00:19:27","modifiedFileCount":"3","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-04-21 04:24:14","codes":[{"authorDate":"2017-07-06 04:20:32","commitOrder":3,"curCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","date":"2017-07-07 01:31:37","endLine":151,"groupId":"21389","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"prepare","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/83/0ed2c92c425945f49c9f844a24eb15b80200e0.src","preCode":"    public ListenableFuture<Boolean> prepare(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return prepareFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"},{"authorDate":"2017-04-21 04:24:14","commitOrder":3,"curCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","date":"2017-05-03 00:19:27","endLine":190,"groupId":"31661","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizePropose","params":"(Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cd/4844b0146ceb27cd4de1ec0046872950aa8c02.src","preCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"N"}],"commitId":"3234c0704a4fef08dedc4ff78f4ded3b9226fe80","commitMessage":"@@@Send IR coordinator messages synchronously\n\nPatch by Blake Eggleston; Reviewed by Marcus Eriksson for CASSANDRA-13673\n","date":"2017-07-07 01:31:37","modifiedFileCount":"5","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-04-21 04:24:14","codes":[{"authorDate":"2017-11-10 00:33:48","commitOrder":4,"curCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","date":"2018-01-26 03:32:24","endLine":152,"groupId":"21389","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"prepare","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f5/2a28de31ff87c0fdbeba4c654fe65bf3e0e55a.src","preCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddress participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"M"},{"authorDate":"2017-04-21 04:24:14","commitOrder":4,"curCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","date":"2017-05-03 00:19:27","endLine":190,"groupId":"31661","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizePropose","params":"(Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cd/4844b0146ceb27cd4de1ec0046872950aa8c02.src","preCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"N"}],"commitId":"59b5b6bef0fa76bf5740b688fcd4d9cf525760d0","commitMessage":"@@@Allow storage port to be configurable per node\n\nPatch by Ariel Weisberg; Reviewed by Jason Brown for CASSANDRA-7544\n","date":"2018-01-26 03:32:24","modifiedFileCount":"308","status":"M","submitter":"Ariel Weisberg"},{"authorTime":"2019-06-14 21:49:46","codes":[{"authorDate":"2019-06-14 21:49:46","commitOrder":5,"curCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        Message<RepairMessage> message =\n            Message.out(Verb.PREPARE_CONSISTENT_REQ, new PrepareConsistentRequest(sessionID, coordinator, participants));\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","date":"2019-09-21 06:52:19","endLine":160,"groupId":"24190","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"prepare","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/8f/1759afd12572552fe457fe274a15230f2a0890.src","preCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        PrepareConsistentRequest message = new PrepareConsistentRequest(sessionID, coordinator, participants);\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"},{"authorDate":"2019-06-14 21:49:46","commitOrder":5,"curCode":"    public synchronized ListenableFuture<Boolean> finalizePropose()\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        Message<RepairMessage> message = Message.out(Verb.FINALIZE_PROPOSE_MSG, new FinalizePropose(sessionID));\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return finalizeProposeFuture;\n    }\n","date":"2019-09-21 06:52:19","endLine":207,"groupId":"26091","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizePropose","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/8f/1759afd12572552fe457fe274a15230f2a0890.src","preCode":"    public synchronized ListenableFuture<Boolean> finalizePropose(Executor executor)\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        FinalizePropose message = new FinalizePropose(sessionID);\n        for (final InetAddress participant : participants)\n        {\n            executor.execute(() -> sendMessage(participant, message));\n        }\n        return finalizeProposeFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"}],"commitId":"f9ff88437742675db5c53f5834884b43f8937e00","commitMessage":"@@@Untangle RepairMessage sub-hierarchy of messages.  use new messaging (more) correctly\n\npatch by Aleksey Yeschenko; reviewed by Blake Eggleston for\nCASSANDRA-15163\n","date":"2019-09-21 06:52:19","modifiedFileCount":"35","status":"M","submitter":"Aleksey Yeschenko"},{"authorTime":"2020-03-25 04:44:17","codes":[{"authorDate":"2020-03-25 04:44:17","commitOrder":6,"curCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.info(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        Message<RepairMessage> message =\n            Message.out(Verb.PREPARE_CONSISTENT_REQ, new PrepareConsistentRequest(sessionID, coordinator, participants));\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","date":"2020-04-01 23:15:41","endLine":161,"groupId":"102173","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"prepare","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9d/440c2cc093ff4c71291804d09151bf415d4b2c.src","preCode":"    public ListenableFuture<Boolean> prepare()\n    {\n        Preconditions.checkArgument(allStates(State.PREPARING));\n\n        logger.debug(\"Beginning prepare phase of incremental repair session {}\", sessionID);\n        Message<RepairMessage> message =\n            Message.out(Verb.PREPARE_CONSISTENT_REQ, new PrepareConsistentRequest(sessionID, coordinator, participants));\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return prepareFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"},{"authorDate":"2020-03-25 04:44:17","commitOrder":6,"curCode":"    public synchronized ListenableFuture<Boolean> finalizePropose()\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.info(\"Proposing finalization of repair session {}\", sessionID);\n        Message<RepairMessage> message = Message.out(Verb.FINALIZE_PROPOSE_MSG, new FinalizePropose(sessionID));\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return finalizeProposeFuture;\n    }\n","date":"2020-04-01 23:15:41","endLine":208,"groupId":"102173","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizePropose","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9d/440c2cc093ff4c71291804d09151bf415d4b2c.src","preCode":"    public synchronized ListenableFuture<Boolean> finalizePropose()\n    {\n        Preconditions.checkArgument(allStates(State.REPAIRING));\n        logger.debug(\"Proposing finalization of repair session {}\", sessionID);\n        Message<RepairMessage> message = Message.out(Verb.FINALIZE_PROPOSE_MSG, new FinalizePropose(sessionID));\n        for (final InetAddressAndPort participant : participants)\n        {\n            sendMessage(participant, message);\n        }\n        return finalizeProposeFuture;\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"}],"commitId":"dd9a6e0a8a691bdee357eb6559f1b2b92b076925","commitMessage":"@@@Use more appropriate logging levels.\n\nThe following logging was changed:\n\n* When the Commit log reader finishes logging each segment.  from debug to info\n* When starting a new compaction.  logging details of the compaction task.  from debug -> info\n* When finishing a compaction.  logging details of how many sstables.  sizes.  etc.  from debug -> info\n* When performing a validation compaction.  adding helpful logging\n* When flushing memtables.  log details. debug -> info\n* When flushing largest memtable to free up room.  logging more details at INFO\n* Various logging messages for incremental repair moved to INFO from debug\n* When failing incremental repair phase.  log a warning instead of debug message\n\nPatch by Jon Haddad; Reviewed by Alexander Dejanovski for CASSANDRA-15661\n","date":"2020-04-01 23:15:41","modifiedFileCount":"11","status":"M","submitter":"Jon Haddad jon@jonhaddad.com"}]
