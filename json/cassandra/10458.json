[{"authorTime":"2020-03-12 00:36:02","codes":[{"authorDate":"2020-03-12 00:36:02","commitOrder":1,"curCode":"    public void testPartitionDeletionRowDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_row_deletion (k int, c int, v int, primary key (k, c))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_row_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_row_deletion(k,c,v) VALUES(1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_row_deletion where k=1 and c=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected no row deletion, but got \" + u.toString(metadata, true), ((Row) u).deletion().isLive()));\n    }\n","date":"2020-11-03 02:27:29","endLine":384,"groupId":"28530","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testPartitionDeletionRowDeletionTie","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/12/168ec9bb4bb70d0987bca5864354e699911d0f.src","preCode":"    public void testPartitionDeletionRowDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_row_deletion (k int, c int, v int, primary key (k, c))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_row_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_row_deletion(k,c,v) VALUES(1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_row_deletion where k=1 and c=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected no row deletion, but got \" + u.toString(metadata, true), ((Row) u).deletion().isLive()));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":336,"status":"B"},{"authorDate":"2020-03-12 00:36:02","commitOrder":1,"curCode":"    public void testPartitionDeletionRangeDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_range_deletion (k int, c1 int, c2 int, v int, primary key (k, c1, c2))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_range_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable) ->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1 and c1=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_range_deletion(k,c1,c2,v) VALUES(1,1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_range_deletion where k=1 and c1=1 and c2=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected row, but got \" + u.toString(metadata, true), u.isRow()));\n    }\n","date":"2020-11-03 02:27:29","endLine":438,"groupId":"28530","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPartitionDeletionRangeDeletionTie","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/12/168ec9bb4bb70d0987bca5864354e699911d0f.src","preCode":"    public void testPartitionDeletionRangeDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_range_deletion (k int, c1 int, c2 int, v int, primary key (k, c1, c2))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_range_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable) ->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1 and c1=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_range_deletion(k,c1,c2,v) VALUES(1,1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_range_deletion where k=1 and c1=1 and c2=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected row, but got \" + u.toString(metadata, true), u.isRow()));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"B"}],"commitId":"56e697dc124e9d94581052cca1ba97ad9b1044c5","commitMessage":"@@@Produce consistent tombstone to avoid digest mistmatch:\n\n* fix memtable read creates row deletion while sstable read creates range tombstone marker.\n* return range tombstone marker for memtable read instead of row deletion\n* remove range-tombstome-marker or row deletion when they don't supersede partition deletion\n\npatch by Zhao Yang; reviewed by Andres de la Pe?a and Marcus Eriksson\nfor CASSANDRA-15369\n","date":"2020-11-03 02:27:29","modifiedFileCount":"11","status":"B","submitter":"Zhao Yang"},{"authorTime":"2020-03-12 00:36:02","codes":[{"authorDate":"2021-02-20 01:00:13","commitOrder":2,"curCode":"    public void testPartitionDeletionRowDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_row_deletion (k int, c int, v int, primary key (k, c))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_row_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->\n        {\n            cfs.truncateBlocking();\n\n            final long timestamp = FBUtilities.timestampMicros();\n            final int nowInSec = FBUtilities.nowInSeconds();\n\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_row_deletion(k,c,v) VALUES(1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_row_deletion where k=1 and c=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected no row deletion, but got \" + u.toString(metadata, true), ((Row) u).deletion().isLive()));\n    }\n","date":"2021-02-24 07:02:35","endLine":392,"groupId":"28530","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testPartitionDeletionRowDeletionTie","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/10/2eb9037cff028eea576d0804388495db3fdf59.src","preCode":"    public void testPartitionDeletionRowDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_row_deletion (k int, c int, v int, primary key (k, c))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_row_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_row_deletion(k,c,v) VALUES(1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_row_deletion where k=1 and c=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected no row deletion, but got \" + u.toString(metadata, true), ((Row) u).deletion().isLive()));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":336,"status":"M"},{"authorDate":"2020-03-12 00:36:02","commitOrder":2,"curCode":"    public void testPartitionDeletionRangeDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_range_deletion (k int, c1 int, c2 int, v int, primary key (k, c1, c2))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_range_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable) ->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1 and c1=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_range_deletion(k,c1,c2,v) VALUES(1,1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_range_deletion where k=1 and c1=1 and c2=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected row, but got \" + u.toString(metadata, true), u.isRow()));\n    }\n","date":"2020-11-03 02:27:29","endLine":438,"groupId":"28530","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPartitionDeletionRangeDeletionTie","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/12/168ec9bb4bb70d0987bca5864354e699911d0f.src","preCode":"    public void testPartitionDeletionRangeDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_range_deletion (k int, c1 int, c2 int, v int, primary key (k, c1, c2))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_range_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable) ->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1 and c1=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_range_deletion(k,c1,c2,v) VALUES(1,1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_range_deletion where k=1 and c1=1 and c2=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected row, but got \" + u.toString(metadata, true), u.isRow()));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"}],"commitId":"0b60c8f37694d44482768ebc327989f7a42c8c08","commitMessage":"@@@Fix timestamp issue in SinglePartitionSliceCommandTest testPartitionDeletionRowDeletionTie\n\nPatch by Benjamin Lerer; reviewed by Ekaterina Dimitrova and Berenguer Blasi for CASSANDRA-16443\n","date":"2021-02-24 07:02:35","modifiedFileCount":"2","status":"M","submitter":"Benjamin Lerer"},{"authorTime":"2021-03-12 05:02:42","codes":[{"authorDate":"2021-02-20 01:00:13","commitOrder":3,"curCode":"    public void testPartitionDeletionRowDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_row_deletion (k int, c int, v int, primary key (k, c))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_row_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->\n        {\n            cfs.truncateBlocking();\n\n            final long timestamp = FBUtilities.timestampMicros();\n            final int nowInSec = FBUtilities.nowInSeconds();\n\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_row_deletion(k,c,v) VALUES(1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_row_deletion where k=1 and c=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected no row deletion, but got \" + u.toString(metadata, true), ((Row) u).deletion().isLive()));\n    }\n","date":"2021-02-24 07:02:35","endLine":392,"groupId":"10458","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testPartitionDeletionRowDeletionTie","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/10/2eb9037cff028eea576d0804388495db3fdf59.src","preCode":"    public void testPartitionDeletionRowDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_row_deletion (k int, c int, v int, primary key (k, c))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_row_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->\n        {\n            cfs.truncateBlocking();\n\n            final long timestamp = FBUtilities.timestampMicros();\n            final int nowInSec = FBUtilities.nowInSeconds();\n\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_row_deletion(k,c,v) VALUES(1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_row_deletion where k=1 and c=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected no row deletion, but got \" + u.toString(metadata, true), ((Row) u).deletion().isLive()));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":336,"status":"N"},{"authorDate":"2021-03-12 05:02:42","commitOrder":3,"curCode":"    public void testPartitionDeletionRangeDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_range_deletion (k int, c1 int, c2 int, v int, primary key (k, c1, c2))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_range_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable) ->\n        {\n            cfs.truncateBlocking();\n\n            \r\n            \r\n            \r\n            \r\n            \r\n\n            final long timestamp = FBUtilities.timestampMicros();\n            final int nowInSec = FBUtilities.nowInSeconds();\n\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,\n                                                                  timestamp,\n                                                                  \"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1 and c1=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_range_deletion(k,c1,c2,v) VALUES(1,1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_range_deletion where k=1 and c1=1 and c2=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected row, but got \" + u.toString(metadata, true), u.isRow()));\n    }\n","date":"2021-03-16 07:41:58","endLine":465,"groupId":"10458","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testPartitionDeletionRangeDeletionTie","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/95/72f28f0066cff625697394ae3f9f96ecbb6601.src","preCode":"    public void testPartitionDeletionRangeDeletionTie()\n    {\n        QueryProcessor.executeOnceInternal(\"CREATE TABLE ks.partition_range_deletion (k int, c1 int, c2 int, v int, primary key (k, c1, c2))\");\n        TableMetadata metadata = Schema.instance.getTableMetadata(\"ks\", \"partition_range_deletion\");\n        ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);\n        cfs.disableAutoCompaction();\n\n        BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable) ->\n        {\n            cfs.truncateBlocking();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1\");\n            if (flush && multiSSTable)\n                cfs.forceBlockingFlush();\n            QueryProcessor.executeOnceInternal(\"DELETE FROM ks.partition_range_deletion USING TIMESTAMP 10 WHERE k=1 and c1=1\");\n            if (flush)\n                cfs.forceBlockingFlush();\n\n            QueryProcessor.executeOnceInternal(\"INSERT INTO ks.partition_range_deletion(k,c1,c2,v) VALUES(1,1,1,1) using timestamp 11\");\n            if (flush)\n            {\n                cfs.forceBlockingFlush();\n                try\n                {\n                    cfs.forceMajorCompaction();\n                }\n                catch (Throwable e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            try (UnfilteredRowIterator partition = getIteratorFromSinglePartition(\"SELECT * FROM ks.partition_range_deletion where k=1 and c1=1 and c2=1\"))\n            {\n                assertEquals(10, partition.partitionLevelDeletion().markedForDeleteAt());\n                return toUnfiltereds(partition);\n            }\n        };\n\n        List<Unfiltered> memtableUnfiltereds = tester.apply(false, false);\n        List<Unfiltered> singleSSTableUnfiltereds = tester.apply(true, false);\n        List<Unfiltered> multiSSTableUnfiltereds = tester.apply(true, true);\n\n        assertEquals(1, singleSSTableUnfiltereds.size());\n        String errorMessage = String.format(\"Expected %s but got %s\", toString(memtableUnfiltereds, metadata), toString(singleSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, memtableUnfiltereds, singleSSTableUnfiltereds);\n        errorMessage = String.format(\"Expected %s but got %s\", toString(singleSSTableUnfiltereds, metadata), toString(multiSSTableUnfiltereds, metadata));\n        assertEquals(errorMessage, singleSSTableUnfiltereds, multiSSTableUnfiltereds);\n        memtableUnfiltereds.forEach(u -> assertTrue(\"Expected row, but got \" + u.toString(metadata, true), u.isRow()));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":403,"status":"M"}],"commitId":"0a4b997337aafcc81396d27ac5de2a682283152f","commitMessage":"@@@Fix testPartitionDeletionRangeDeletionTie\nauthored by Ekaterina Dimitrova based on solution provided by Benjamin Lerer; reviewed by Jacek Lewandowski.  Benjamin Lerer and Berenguer Blasi for CASSANDRA-16512\n","date":"2021-03-16 07:41:58","modifiedFileCount":"1","status":"M","submitter":"Ekaterina Dimitrova"}]
