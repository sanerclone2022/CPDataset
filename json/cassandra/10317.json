[{"authorTime":"2019-06-12 23:26:54","codes":[{"authorDate":"2019-02-15 17:03:47","commitOrder":2,"curCode":"    private void testMockedMessagingPrepareFailure() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2019-02-23 02:55:08","endLine":221,"groupId":"29876","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingPrepareFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b5/32abdcd5737781f7a6a3b0ccf289b8f2a495bc.src","preCode":"    private void testMockedMessagingPrepareFailure() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"NB"},{"authorDate":"2019-06-12 23:26:54","commitOrder":2,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2019-06-12 23:26:54","endLine":266,"groupId":"14498","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/23/7e9a86df710739d3b4fe157c21092217264d64.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"MB"}],"commitId":"310a48efcfdc0fb77fbd5fd6e734bf17667f617d","commitMessage":"@@@Rewrite the internode messaging subsystem\n\npatch by Aleksey Yeschenko and Benedict Elliott Smith; reviewed by Alex\nPetrov.  Aleksey Yeschenko.  and Benedict Elliott Smith for CASSANDRA-15066\n\nCo-authored-by: Aleksey Yeschenko <aleksey@apache.org>\nCo-authored-by: Benedict Elliott Smith <benedict@apache.org>\n","date":"2019-06-12 23:26:54","modifiedFileCount":"253","status":"M","submitter":"Benedict Elliott Smith"},{"authorTime":"2020-03-31 21:53:51","codes":[{"authorDate":"2020-03-31 21:53:51","commitOrder":3,"curCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":227,"groupId":"29876","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingPrepareFailure","params":"(CountDownLatchprepareLatch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    private void testMockedMessagingPrepareFailure() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"},{"authorDate":"2020-03-31 21:53:51","commitOrder":3,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":271,"groupId":"14498","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"b4e640a96e76f8d4a45937b1312b64ddc1aeb8ac","commitMessage":"@@@Fix flaky CoordinatorMessagingTest and docstring in OutboundSink and ConsistentSession\n\npatch by Aleksandr Sorokoumov; reviewed by Stefania Alborghetti for CASSANDRA-15672\n","date":"2020-04-06 20:28:53","modifiedFileCount":"3","status":"M","submitter":"Aleksandr Sorokoumov"},{"authorTime":"2020-03-31 21:53:51","codes":[{"authorDate":"2020-02-25 21:10:22","commitOrder":4,"curCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-14 21:57:50","endLine":226,"groupId":"8706","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingPrepareFailure","params":"(CountDownLatchprepareLatch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/42/0cd546a3fcbf4db4f757a3ac56e0b841854c6c.src","preCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"},{"authorDate":"2020-03-31 21:53:51","commitOrder":4,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":271,"groupId":"14498","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"N"}],"commitId":"78c785367f2836960ae26e5e5ef258162ef30ec3","commitMessage":"@@@Improve logging around incremental repairs\n\nPatch by marcuse; reviewed by Sam Tunnicliffe for CASSANDRA-15599\n","date":"2020-04-14 21:57:50","modifiedFileCount":"8","status":"M","submitter":"Marcus Eriksson"},{"authorTime":"2021-03-17 22:28:05","codes":[{"authorDate":"2021-03-17 22:28:05","commitOrder":5,"curCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException, NoSuchRepairSessionException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2021-07-22 05:21:23","endLine":227,"groupId":"10317","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testMockedMessagingPrepareFailure","params":"(CountDownLatchprepareLatch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3c/288b0ef5a547b9bff3065e3757620a36dfe4c9.src","preCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"},{"authorDate":"2021-03-17 22:28:05","commitOrder":5,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException, NoSuchRepairSessionException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2021-07-22 05:21:23","endLine":271,"groupId":"10317","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3c/288b0ef5a547b9bff3065e3757620a36dfe4c9.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"f49c29ee8c7374a05e32be01cb0046236d5309e6","commitMessage":"@@@Reduce the log level on \"expected\" repair exceptions\n\npatch by Caleb Rackliffe and Marcus Eriksson; reviewed by Josh McKenzie for CASSANDRA-16775\n","date":"2021-07-22 05:21:23","modifiedFileCount":"30","status":"M","submitter":"Marcus Eriksson"}]
