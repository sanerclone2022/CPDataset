[{"authorTime":"2014-11-25 05:25:55","codes":[{"authorDate":"2014-11-25 05:25:55","commitOrder":1,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating \" + address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating \" + nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2014-11-25 05:25:55","endLine":232,"groupId":"27289","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/34/b421710a57596504955e6d1e13a9d840a39a31.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating \" + address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating \" + nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"B"},{"authorDate":"2014-11-25 05:25:55","commitOrder":1,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating \" + address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating \" + nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2014-11-25 05:25:55","endLine":287,"groupId":"27289","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/34/b421710a57596504955e6d1e13a9d840a39a31.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating \" + address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating \" + nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"B"}],"commitId":"c023d4922863bd4e7d3c959035a8634cd370a829","commitMessage":"@@@Merge branch 'cassandra-2.1' into trunk\n\nConflicts:\n\tsrc/java/org/apache/cassandra/repair/RepairJob.java\n\tsrc/java/org/apache/cassandra/repair/RepairSession.java\n\tsrc/java/org/apache/cassandra/service/ActiveRepairService.java\n\tsrc/java/org/apache/cassandra/service/StorageService.java\n\tsrc/java/org/apache/cassandra/service/StorageServiceMBean.java\n\tsrc/java/org/apache/cassandra/tools/NodeProbe.java\n\tsrc/java/org/apache/cassandra/tools/NodeTool.java\n","date":"2014-11-25 05:25:55","modifiedFileCount":"10","status":"B","submitter":"Yuki Morishita"},{"authorTime":"2014-11-29 10:53:29","codes":[{"authorDate":"2014-11-29 10:53:29","commitOrder":2,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2014-11-29 10:53:29","endLine":232,"groupId":"27289","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/70/8ee7087f990fa4bf61ac742fe23c57dc826d0c.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating \" + address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating \" + nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2014-11-29 10:53:29","commitOrder":2,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2014-11-29 10:53:29","endLine":287,"groupId":"27289","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/70/8ee7087f990fa4bf61ac742fe23c57dc826d0c.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating \" + address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating \" + nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"M"}],"commitId":"630e47ba4cd7fe7264f7373b3432ca96a38a6610","commitMessage":"@@@use parameterized logging\n","date":"2014-11-29 10:53:29","modifiedFileCount":"1","status":"M","submitter":"Dave Brosius"},{"authorTime":"2014-09-02 00:54:46","codes":[{"authorDate":"2014-09-02 00:54:46","commitOrder":3,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2015-06-30 18:47:01","endLine":232,"groupId":"27289","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ac/20428c3d880f09af44b4a4e6ee471385c22578.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2014-09-02 00:54:46","commitOrder":3,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2015-06-30 18:47:01","endLine":287,"groupId":"27289","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ac/20428c3d880f09af44b4a4e6ee471385c22578.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(System.currentTimeMillis());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"M"}],"commitId":"a991b64811f4d6adb6c7b31c0df52288eb06cf19","commitMessage":"@@@Storage engine refactor.  a.k.a CASSANDRA-8099\n\nInitial patch.  see ticket for details\n","date":"2015-06-30 18:47:01","modifiedFileCount":"374","status":"M","submitter":"Sylvain Lebresne"},{"authorTime":"2016-04-04 20:04:09","codes":[{"authorDate":"2016-04-04 20:04:09","commitOrder":4,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"[repair #{}] {}\", desc.sessionId, message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2016-04-04 20:04:09","endLine":226,"groupId":"27289","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cb/a176c632df3bf5db103a6391ee6a6ed3998b7a.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"},{"authorDate":"2016-04-04 20:04:09","commitOrder":4,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"[repair #{}] {}\", desc.sessionId, message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2016-04-04 20:04:09","endLine":284,"groupId":"27289","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cb/a176c632df3bf5db103a6391ee6a6ed3998b7a.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"}],"commitId":"0fe80fb42390753625bebdafc6241172cb05b0a5","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2016-04-04 20:04:09","modifiedFileCount":"1","status":"M","submitter":"Marcus Eriksson"},{"authorTime":"2017-02-24 01:35:04","codes":[{"authorDate":"2017-02-24 01:35:04","commitOrder":5,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore, previewKind);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore, previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2017-04-25 00:21:33","endLine":245,"groupId":"19988","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d6/c11769075a8c6588d3723d92f578ec9914ee63.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"[repair #{}] {}\", desc.sessionId, message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2017-02-24 01:35:04","commitOrder":5,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore, previewKind);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore, previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2017-04-25 00:21:33","endLine":303,"groupId":"19988","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d6/c11769075a8c6588d3723d92f578ec9914ee63.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"[repair #{}] {}\", desc.sessionId, message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"M"}],"commitId":"4cfaf855c404256a9dd281d5066cc076232d72ff","commitMessage":"@@@Add repair streaming preview\n\nPatch by Blake Eggleston; Reviewed by Marcus Eriksson for CASSANDRA-13257\n","date":"2017-04-25 00:21:33","modifiedFileCount":"49","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-07-06 02:18:21","codes":[{"authorDate":"2017-07-06 02:18:21","commitOrder":6,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2017-07-07 01:41:31","endLine":251,"groupId":"21035","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/06/15681511a981e29d1120677cc7254aa4bec612.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, gcBefore, previewKind);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore, previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":214,"status":"M"},{"authorDate":"2017-07-06 02:18:21","commitOrder":6,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2017-07-07 01:41:31","endLine":309,"groupId":"21039","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddress>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/06/15681511a981e29d1120677cc7254aa4bec612.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int gcBefore = Keyspace.open(desc.keyspace).getColumnFamilyStore(desc.columnFamily).gcBefore(FBUtilities.nowInSeconds());\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, gcBefore, previewKind);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, gcBefore, previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"M"}],"commitId":"9fdec0a82851f5c35cd21d02e8c4da8fc685edb2","commitMessage":"@@@Use common nowInSec for validation compactions\n\nPatch by Blake Eggleston; Reviewed by Marcus Eriksson for CASSANDRA-13671\n","date":"2017-07-07 01:41:31","modifiedFileCount":"7","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-11-10 00:33:48","codes":[{"authorDate":"2017-11-10 00:33:48","commitOrder":7,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2018-01-26 03:32:24","endLine":317,"groupId":"29125","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/48/973d21cf02dc334e0bf2d8d4ae0994595599e2.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddress> requests = new LinkedList<>(endpoints);\n        InetAddress address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddress nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"M"},{"authorDate":"2017-11-10 00:33:48","commitOrder":7,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2018-01-26 03:32:24","endLine":375,"groupId":"29131","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/48/973d21cf02dc334e0bf2d8d4ae0994595599e2.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddress> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddress>> requestsByDatacenter = new HashMap<>();\n        for (InetAddress endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddress> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddress>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddress> requests = entry.getValue();\n            InetAddress address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddress nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":322,"status":"M"}],"commitId":"59b5b6bef0fa76bf5740b688fcd4d9cf525760d0","commitMessage":"@@@Allow storage port to be configurable per node\n\nPatch by Ariel Weisberg; Reviewed by Jason Brown for CASSANDRA-7544\n","date":"2018-01-26 03:32:24","modifiedFileCount":"308","status":"M","submitter":"Ariel Weisberg"},{"authorTime":"2018-10-01 21:30:58","codes":[{"authorDate":"2018-10-01 21:30:58","commitOrder":8,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"Validating {}\", address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2018-10-10 05:33:31","endLine":395,"groupId":"6253","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/eb/eb1f9de650f2421ac5ac3424c77cc3dc21f817.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n        logger.info(\"Validating {}\", address);\n        session.waitForValidation(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":358,"status":"M"},{"authorDate":"2018-10-01 21:30:58","commitOrder":8,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"Validating {}\", address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2018-10-10 05:33:31","endLine":453,"groupId":"6254","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/eb/eb1f9de650f2421ac5ac3424c77cc3dc21f817.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, previewKind);\n            logger.info(\"Validating {}\", address);\n            session.waitForValidation(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.waitForValidation(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":400,"status":"M"}],"commitId":"a05785d82c621c9cd04d8a064c38fd2012ef981c","commitMessage":"@@@Add tests for RepairJob\n\nPatch by Alex Petrov; reviewed by Marcus Eriksson for CASSANDRA-14717","date":"2018-10-10 05:33:31","modifiedFileCount":"7","status":"M","submitter":"Alex Petrov"},{"authorTime":"2018-04-11 06:01:48","codes":[{"authorDate":"2018-04-11 06:01:48","commitOrder":9,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"Validating {}\", address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2019-10-08 03:19:42","endLine":400,"groupId":"6253","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/37/40070d1314573be7d8935131edc987e13f9d3a.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"Validating {}\", address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            });\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":363,"status":"M"},{"authorDate":"2018-04-11 06:01:48","commitOrder":9,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"Validating {}\", address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2019-10-08 03:19:42","endLine":458,"groupId":"6254","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/37/40070d1314573be7d8935131edc987e13f9d3a.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"Validating {}\", address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                });\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":405,"status":"M"}],"commitId":"38b49904dd1c71fcb16abfbc205edfd6ce008b76","commitMessage":"@@@Upgrading Guava to 27.  and to java-driver 3.6.0 (from 3.4.0-SNAPSHOT).  plus refactoring to remove nativePort argument for NativeSSTableLoaderClient constructor\n\nPatch by Sumanth Pasupuleti; reviewed by Michael Semb Wever for CASSANDRA-14655\n","date":"2019-10-08 03:19:42","modifiedFileCount":"23","status":"M","submitter":"Sumanth Pasupuleti"},{"authorTime":"2020-03-17 23:47:50","codes":[{"authorDate":"2020-03-17 23:47:50","commitOrder":10,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"Validating {}\", address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2020-04-03 18:48:38","endLine":413,"groupId":"6253","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/e6/09f0d7d4475087862d10f1cbcecd1471df003e.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"Validating {}\", address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":376,"status":"M"},{"authorDate":"2020-03-17 23:47:50","commitOrder":10,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"Validating {}\", address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2020-04-03 18:48:38","endLine":471,"groupId":"6254","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/e6/09f0d7d4475087862d10f1cbcecd1471df003e.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = FBUtilities.nowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"Validating {}\", address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"}],"commitId":"6a302f734a1dede4b4bdee5e5f67c5ada6f0115d","commitMessage":"@@@Set now in seconds in the future for validation repairs\n\nPatch by Blake Eggleston; reviewed by Ekaterina Dimitrova for CASSANDRA-15655\n","date":"2020-04-03 18:48:38","modifiedFileCount":"3","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2020-02-25 21:10:22","codes":[{"authorDate":"2020-02-25 21:10:22","commitOrder":11,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"{} Validating {}\", session.previewKind.logPrefix(desc.sessionId), address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"{} Validating {}\", session.previewKind.logPrefix(desc.sessionId), nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2020-04-14 21:57:50","endLine":418,"groupId":"28469","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/16/eb32550936450b3d1b18aef9bb59d3d5103d1c.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"Validating {}\", address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"Validating {}\", nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":381,"status":"M"},{"authorDate":"2020-02-25 21:10:22","commitOrder":11,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"{} Validating {}\", session.previewKind.logPrefix(session.getId()), address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"{} Validating {}\", session.previewKind.logPrefix(session.getId()), nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2020-04-14 21:57:50","endLine":476,"groupId":"28472","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/16/eb32550936450b3d1b18aef9bb59d3d5103d1c.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"Validating {}\", address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"Validating {}\", nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":423,"status":"M"}],"commitId":"78c785367f2836960ae26e5e5ef258162ef30ec3","commitMessage":"@@@Improve logging around incremental repairs\n\nPatch by marcuse; reviewed by Sam Tunnicliffe for CASSANDRA-15599\n","date":"2020-04-14 21:57:50","modifiedFileCount":"8","status":"M","submitter":"Marcus Eriksson"},{"authorTime":"2021-03-17 22:28:05","codes":[{"authorDate":"2021-03-17 22:28:05","commitOrder":12,"curCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = newValidationTask(address, nowInSec);\n        logger.info(\"{} Validating {}\", session.previewKind.logPrefix(desc.sessionId), address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = newValidationTask(nextAddress, nowInSec);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"{} Validating {}\", session.previewKind.logPrefix(desc.sessionId), nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","date":"2021-07-22 05:21:23","endLine":429,"groupId":"102165","id":23,"instanceNumber":1,"isCurCommit":1,"methodName":"sendSequentialValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/fb/66be7738e8a5ea04db06cdfc136d4197bd3ecb.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendSequentialValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Queue<InetAddressAndPort> requests = new LinkedList<>(endpoints);\n        InetAddressAndPort address = requests.poll();\n        ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n        logger.info(\"{} Validating {}\", session.previewKind.logPrefix(desc.sessionId), address);\n        session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n        tasks.add(firstTask);\n        ValidationTask currentTask = firstTask;\n        while (requests.size() > 0)\n        {\n            final InetAddressAndPort nextAddress = requests.poll();\n            final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n            tasks.add(nextTask);\n            Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n            {\n                public void onSuccess(TreeResponse result)\n                {\n                    logger.info(\"{} Validating {}\", session.previewKind.logPrefix(desc.sessionId), nextAddress);\n                    session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                    taskExecutor.execute(nextTask);\n                }\n\n                \r\n                public void onFailure(Throwable t) {}\n            }, MoreExecutors.directExecutor());\n            currentTask = nextTask;\n        }\n        \r\n        taskExecutor.execute(firstTask);\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":392,"status":"M"},{"authorDate":"2021-03-17 22:28:05","commitOrder":12,"curCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = newValidationTask(address, nowInSec);\n            logger.info(\"{} Validating {}\", session.previewKind.logPrefix(session.getId()), address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = newValidationTask(nextAddress, nowInSec);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"{} Validating {}\", session.previewKind.logPrefix(session.getId()), nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","date":"2021-07-22 05:21:23","endLine":487,"groupId":"102165","id":24,"instanceNumber":2,"isCurCommit":1,"methodName":"sendDCAwareValidationRequest","params":"(Collection<InetAddressAndPort>endpoints)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/fb/66be7738e8a5ea04db06cdfc136d4197bd3ecb.src","preCode":"    private ListenableFuture<List<TreeResponse>> sendDCAwareValidationRequest(Collection<InetAddressAndPort> endpoints)\n    {\n        String message = String.format(\"Requesting merkle trees for %s (to %s)\", desc.columnFamily, endpoints);\n        logger.info(\"{} {}\", session.previewKind.logPrefix(desc.sessionId), message);\n        Tracing.traceRepair(message);\n        int nowInSec = getNowInSeconds();\n        List<ListenableFuture<TreeResponse>> tasks = new ArrayList<>(endpoints.size());\n\n        Map<String, Queue<InetAddressAndPort>> requestsByDatacenter = new HashMap<>();\n        for (InetAddressAndPort endpoint : endpoints)\n        {\n            String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);\n            Queue<InetAddressAndPort> queue = requestsByDatacenter.get(dc);\n            if (queue == null)\n            {\n                queue = new LinkedList<>();\n                requestsByDatacenter.put(dc, queue);\n            }\n            queue.add(endpoint);\n        }\n\n        for (Map.Entry<String, Queue<InetAddressAndPort>> entry : requestsByDatacenter.entrySet())\n        {\n            Queue<InetAddressAndPort> requests = entry.getValue();\n            InetAddressAndPort address = requests.poll();\n            ValidationTask firstTask = new ValidationTask(desc, address, nowInSec, session.previewKind);\n            logger.info(\"{} Validating {}\", session.previewKind.logPrefix(session.getId()), address);\n            session.trackValidationCompletion(Pair.create(desc, address), firstTask);\n            tasks.add(firstTask);\n            ValidationTask currentTask = firstTask;\n            while (requests.size() > 0)\n            {\n                final InetAddressAndPort nextAddress = requests.poll();\n                final ValidationTask nextTask = new ValidationTask(desc, nextAddress, nowInSec, session.previewKind);\n                tasks.add(nextTask);\n                Futures.addCallback(currentTask, new FutureCallback<TreeResponse>()\n                {\n                    public void onSuccess(TreeResponse result)\n                    {\n                        logger.info(\"{} Validating {}\", session.previewKind.logPrefix(session.getId()), nextAddress);\n                        session.trackValidationCompletion(Pair.create(desc, nextAddress), nextTask);\n                        taskExecutor.execute(nextTask);\n                    }\n\n                    \r\n                    public void onFailure(Throwable t) {}\n                }, MoreExecutors.directExecutor());\n                currentTask = nextTask;\n            }\n            \r\n            taskExecutor.execute(firstTask);\n        }\n        return Futures.allAsList(tasks);\n    }\n","realPath":"src/java/org/apache/cassandra/repair/RepairJob.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":434,"status":"M"}],"commitId":"f49c29ee8c7374a05e32be01cb0046236d5309e6","commitMessage":"@@@Reduce the log level on \"expected\" repair exceptions\n\npatch by Caleb Rackliffe and Marcus Eriksson; reviewed by Josh McKenzie for CASSANDRA-16775\n","date":"2021-07-22 05:21:23","modifiedFileCount":"30","status":"M","submitter":"Marcus Eriksson"}]
