[{"authorTime":"2017-11-15 09:38:10","codes":[{"authorDate":"2017-11-15 09:38:10","commitOrder":1,"curCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-03-02 09:52:54","endLine":764,"groupId":"28331","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testResolveComplexDelete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/4d/4d39867784affffc5d86fd7ad82487ad2b932e.src","preCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":715,"status":"B"},{"authorDate":"2017-11-15 09:38:10","commitOrder":1,"curCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-03-02 09:52:54","endLine":904,"groupId":"16064","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testResolveNewCollectionOverwritingDeleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/4d/4d39867784affffc5d86fd7ad82487ad2b932e.src","preCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":859,"status":"B"}],"commitId":"39807ba48ed2e02223014fbf47dce21d4124b380","commitMessage":"@@@Refactor read executor and response resolver.  abstract read repair\n\nPatch by Blake Eggleston; Reviewed by Marcus Eriksson for CASSANDRA-14058\n","date":"2018-03-02 09:52:54","modifiedFileCount":"5","status":"B","submitter":"Blake Eggleston"},{"authorTime":"2018-05-15 05:24:03","codes":[{"authorDate":"2018-05-15 05:24:03","commitOrder":2,"curCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-08-22 02:01:10","endLine":758,"groupId":"28331","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testResolveComplexDelete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1a/5aa7a9cd18f33c78f8d471fca8a89668ccf27e.src","preCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":709,"status":"M"},{"authorDate":"2018-05-15 05:24:03","commitOrder":2,"curCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-08-22 02:01:10","endLine":898,"groupId":"16064","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testResolveNewCollectionOverwritingDeleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1a/5aa7a9cd18f33c78f8d471fca8a89668ccf27e.src","preCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":853,"status":"M"}],"commitId":"644676b088be5177ef1d0cdaf450306ea28d8a12","commitMessage":"@@@Improve read repair blocking behavior\n\nPatch by Blake Eggleston; reviewed by Marcus Eriksson and Alex Petrov\nfor CASSANDRA-10726\n","date":"2018-08-22 02:01:10","modifiedFileCount":"15","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2018-07-27 02:11:17","codes":[{"authorDate":"2018-07-27 02:11:17","commitOrder":3,"curCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-08-23 21:14:07","endLine":758,"groupId":"28331","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testResolveComplexDelete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ac/8ed0b9d5c7452d4b9d4efc493078e332a6dee1.src","preCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":709,"status":"M"},{"authorDate":"2018-07-27 02:11:17","commitOrder":3,"curCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-08-23 21:14:07","endLine":898,"groupId":"16064","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testResolveNewCollectionOverwritingDeleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ac/8ed0b9d5c7452d4b9d4efc493078e332a6dee1.src","preCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder(nowInSec);\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":853,"status":"M"}],"commitId":"e225c88a65f2e8091f8ea6212c291416674882a1","commitMessage":"@@@Cell reconciliation should not depend on nowInSec\n\npatch by Benedict; reviewed by Aleksey for CASSANDRA-14592\n","date":"2018-08-23 21:14:07","modifiedFileCount":"28","status":"M","submitter":"Benedict Elliott Smith"},{"authorTime":"2018-07-06 06:10:40","codes":[{"authorDate":"2018-07-06 06:10:40","commitOrder":4,"curCode":"    public void testResolveComplexDelete()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-09-01 09:34:22","endLine":756,"groupId":"16064","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testResolveComplexDelete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ab/ec25d8a4919ec7e93638094a3ebe4f769a1a94.src","preCode":"    public void testResolveComplexDelete()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":707,"status":"M"},{"authorDate":"2018-07-06 06:10:40","commitOrder":4,"curCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-09-01 09:34:22","endLine":899,"groupId":"22529","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testResolveNewCollectionOverwritingDeleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ab/ec25d8a4919ec7e93638094a3ebe4f769a1a94.src","preCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(ks, cmd, ConsistencyLevel.ALL, 2, System.nanoTime(), readRepair);\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = peer();\n        resolver.preprocess(readResponseMessage(peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = peer();\n        resolver.preprocess(readResponseMessage(peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build())), cmd));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":853,"status":"M"}],"commitId":"f7431b432875e334170ccdb19934d05545d2cebd","commitMessage":"@@@Transient Replication and Cheap Quorums\n\nPatch by Blake Eggleston.  Benedict Elliott Smith.  Marcus Eriksson.  Alex Petrov.  Ariel Weisberg; Reviewed by Blake Eggleston.  Marcus Eriksson.  Benedict Elliott Smith.  Alex Petrov.  Ariel Weisberg for CASSANDRA-14404\n\nCo-authored-by: Blake Eggleston <bdeggleston@gmail.com>\nCo-authored-by: Benedict Elliott Smith <benedict@apache.org>\nCo-authored-by: Marcus Eriksson <marcuse@apache.org>\nCo-authored-by: Alex Petrov <oleksandr.petrov@gmail.com>\n","date":"2018-09-01 09:34:22","modifiedFileCount":"230","status":"M","submitter":"Ariel Weisberg"},{"authorTime":"2018-09-07 18:41:28","codes":[{"authorDate":"2018-09-07 18:41:28","commitOrder":5,"curCode":"    public void testResolveComplexDelete()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-09-14 17:14:37","endLine":764,"groupId":"16064","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testResolveComplexDelete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/c4/9bf3a83bdebcb1cfa47eaeb99f10cc67a4a892.src","preCode":"    public void testResolveComplexDelete()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":715,"status":"M"},{"authorDate":"2018-09-07 18:41:28","commitOrder":5,"curCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2018-09-14 17:14:37","endLine":907,"groupId":"22529","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testResolveNewCollectionOverwritingDeleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/c4/9bf3a83bdebcb1cfa47eaeb99f10cc67a4a892.src","preCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd, ConsistencyLevel.QUORUM);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":861,"status":"M"}],"commitId":"047bcd7ad171d6a4aa89128c5e6c6ed5f012b1c0","commitMessage":"@@@ReplicaPlan/Layout refactor follow-up/completion\n\nFinish much of the work to clarify endpoint selection\nthat was begun in Transient Replication (CASSANDRA-14404)\n\nAlso fixes:\n  - commitPaxos was incorrectly selecting only live nodes. \n    when needed to include down\n  - We were not writing to pending transient replicas\n  - On write.  we were not hinting to full nodes with transient\n    replication\n  - rr.maybeSendAdditional{Reads. Writes} would only consult the\n    same node we may have speculated a read to\n  - transient->full movements mishandled consistency level upgrade by\n    retaining the 'full' pending variant.  which increased CL requirement;\n    instead.  the 'natural' replica is upgraded to 'full' for writes\n\npatch by Benedict; reviewed by Alex Petrov and Ariel Weisberg for CASSANDRA-14705\n","date":"2018-09-14 17:14:37","modifiedFileCount":"53","status":"M","submitter":"Benedict Elliott Smith"},{"authorTime":"2019-10-16 04:04:26","codes":[{"authorDate":"2019-10-16 04:04:26","commitOrder":6,"curCode":"    public void testResolveComplexDelete()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell<?> expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2020-09-14 23:32:44","endLine":784,"groupId":"101378","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testResolveComplexDelete","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/36/d792e1053ba4a097b8d61a95ab4ab006fedc71.src","preCode":"    public void testResolveComplexDelete()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n        builder.addCell(mapCell(0, 0, ts[0]));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                Assert.assertNull(row.getCell(m, CellPath.create(bb(0))));\n                Assert.assertNotNull(row.getCell(m, CellPath.create(bb(1))));\n            }\n        }\n\n        Mutation mutation = readRepair.getForEndpoint(peer1);\n        Iterator<Row> rowIter = mutation.getPartitionUpdate(cfm2).iterator();\n        assertTrue(rowIter.hasNext());\n        Row row = rowIter.next();\n        assertFalse(rowIter.hasNext());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":735,"status":"M"},{"authorDate":"2019-10-16 04:04:26","commitOrder":6,"curCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell<?> expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","date":"2020-09-14 23:32:44","endLine":927,"groupId":"101378","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testResolveNewCollectionOverwritingDeleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/36/d792e1053ba4a097b8d61a95ab4ab006fedc71.src","preCode":"    public void testResolveNewCollectionOverwritingDeleted()\n    {\n        EndpointsForRange replicas = makeReplicas(2);\n        ReadCommand cmd = Util.cmd(cfs2, dk).withNowInSeconds(nowInSec).build();\n        TestableReadRepair readRepair = new TestableReadRepair(cmd);\n        DataResolver resolver = new DataResolver(cmd, plan(replicas, ConsistencyLevel.ALL), readRepair, System.nanoTime());\n\n        long[] ts = {100, 200};\n\n        \r\n        Row.Builder builder = BTreeRow.unsortedBuilder();\n        builder.newRow(Clustering.EMPTY);\n        builder.addComplexDeletion(m, new DeletionTime(ts[0] - 1, nowInSec));\n\n        InetAddressAndPort peer1 = replicas.get(0).endpoint();\n        resolver.preprocess(response(cmd, peer1, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        \r\n        builder.newRow(Clustering.EMPTY);\n        DeletionTime expectedCmplxDelete = new DeletionTime(ts[1] - 1, nowInSec);\n        builder.addComplexDeletion(m, expectedCmplxDelete);\n        Cell expectedCell = mapCell(1, 1, ts[1]);\n        builder.addCell(expectedCell);\n\n        InetAddressAndPort peer2 = replicas.get(1).endpoint();\n        resolver.preprocess(response(cmd, peer2, iter(PartitionUpdate.singleRowUpdate(cfm2, dk, builder.build()))));\n\n        try(PartitionIterator data = resolver.resolve())\n        {\n            try (RowIterator rows = Iterators.getOnlyElement(data))\n            {\n                Row row = Iterators.getOnlyElement(rows);\n                assertColumns(row, \"m\");\n                ComplexColumnData cd = row.getComplexColumnData(m);\n                assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n            }\n        }\n\n        Row row = Iterators.getOnlyElement(readRepair.getForEndpoint(peer1).getPartitionUpdate(cfm2).iterator());\n\n        ComplexColumnData cd = row.getComplexColumnData(m);\n\n        assertEquals(Collections.singleton(expectedCell), Sets.newHashSet(cd));\n        assertEquals(expectedCmplxDelete, cd.complexDeletion());\n\n        Assert.assertNull(readRepair.sent.get(peer2));\n    }\n","realPath":"test/unit/org/apache/cassandra/service/reads/DataResolverTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":881,"status":"M"}],"commitId":"ccab496d2d37c86341d364dea6c27513fda27331","commitMessage":"@@@Add byte array backed cells\n\nPatch by Blake Eggleston; reviewed by Caleb Rackliffe and Marcus Eriksson for CASSANDRA-15393\n","date":"2020-09-14 23:32:44","modifiedFileCount":"278","status":"M","submitter":"Blake Eggleston"}]
