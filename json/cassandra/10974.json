[{"authorTime":"2015-08-22 07:44:46","codes":[{"authorDate":"2015-08-26 16:33:17","commitOrder":2,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final DeletionTime deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion, opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-08-26 16:33:17","endLine":426,"groupId":"7740","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/33/26b3fbead859d727a39e0a1499b1727db09c13.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final DeletionTime deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion, opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"B"},{"authorDate":"2015-08-22 07:44:46","commitOrder":2,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final DeletionTime deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion, opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-08-22 07:44:46","endLine":443,"groupId":"7740","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b1/7ab4e6d4e89ba8dc77849030f57693e6433334.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final DeletionTime deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion, opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":304,"status":"NB"}],"commitId":"32817b21ad0ba82cec328cfd0ea096fe6acff69b","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2015-08-26 16:33:17","modifiedFileCount":"2","status":"M","submitter":"Sam Tunnicliffe"},{"authorTime":"2015-09-11 23:26:04","codes":[{"authorDate":"2015-09-11 23:26:04","commitOrder":3,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-09-11 23:26:04","endLine":426,"groupId":"7740","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9d/9c0b3d394c671799a4c14518eb6252f3594236.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final DeletionTime deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion, opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"M"},{"authorDate":"2015-09-11 23:26:04","commitOrder":3,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-09-11 23:26:04","endLine":442,"groupId":"7740","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1e/2deeeab3431ca2a3333129bf267f890c3bb504.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final DeletionTime deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion, opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":303,"status":"M"}],"commitId":"43e13d9086786eeecffa2eb39b3fefa7dd3636d8","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2015-09-11 23:26:04","modifiedFileCount":"22","status":"M","submitter":"T Jake Luciani"},{"authorTime":"2015-12-03 22:02:25","codes":[{"authorDate":"2015-12-03 22:02:25","commitOrder":4,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-12-03 22:02:25","endLine":410,"groupId":"7740","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/40/45b6ac3121e954b5ab9599c03c302079bb1844.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"M"},{"authorDate":"2015-12-03 22:02:25","commitOrder":4,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-12-03 22:02:25","endLine":462,"groupId":"7740","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/45/9832632c797c8c9e547433cfdf8a45584b8297.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"M"}],"commitId":"4f5845eb5a08b8dd38b02f42d980b50837ba62e8","commitMessage":"@@@Merge branch 'cassandra-3.1' into trunk\n","date":"2015-12-03 22:02:25","modifiedFileCount":"5","status":"M","submitter":"Sylvain Lebresne"},{"authorTime":"2016-01-19 17:02:21","codes":[{"authorDate":"2015-12-03 22:02:25","commitOrder":5,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2015-12-03 22:02:25","endLine":410,"groupId":"7740","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/40/45b6ac3121e954b5ab9599c03c302079bb1844.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"N"},{"authorDate":"2016-01-19 17:02:21","commitOrder":5,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2016-01-19 17:02:21","endLine":469,"groupId":"7740","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ef/813b849fe5486d8db64fe0d7d0a09d8cbbca7b.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"M"}],"commitId":"e13ea8db6e0fca9001c2524716176a46b5894412","commitMessage":"@@@Merge branch 'cassandra-3.3' into trunk\n","date":"2016-01-19 17:02:21","modifiedFileCount":"2","status":"M","submitter":"Sam Tunnicliffe"},{"authorTime":"2016-03-07 22:01:17","codes":[{"authorDate":"2016-03-07 22:01:17","commitOrder":6,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2016-03-07 22:01:17","endLine":410,"groupId":"4360","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/457c9359a3eabc9f99d0550c1802141ca8f375.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"M"},{"authorDate":"2016-03-07 22:01:17","commitOrder":6,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2016-03-07 22:01:17","endLine":478,"groupId":"13938","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/15/03f0ba649d712341e9710c8067a439df1bb1f5.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"e017f9494844234fa73848890347f59c622cea40","commitMessage":"@@@Allow to remove TTLs on table with default_time_to_live\n\npatch by Benjamin Lerer; reviewed by Tyler Hobbs for CASSANDRA-11207\n","date":"2016-03-07 22:01:17","modifiedFileCount":"30","status":"M","submitter":"Benjamin Lerer"},{"authorTime":"2016-04-06 22:50:22","codes":[{"authorDate":"2016-03-07 22:01:17","commitOrder":7,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2016-03-07 22:01:17","endLine":410,"groupId":"4360","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/457c9359a3eabc9f99d0550c1802141ca8f375.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"N"},{"authorDate":"2016-04-06 22:50:22","commitOrder":7,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2016-04-06 22:50:22","endLine":478,"groupId":"13938","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalPartitionColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/184c337aeec6c7e0b143ab7f7e8e0222d76be6.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"b680ddd61038d41344bcb6e1c63948bcfe922413","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2016-04-06 22:50:22","modifiedFileCount":"3","status":"M","submitter":"Sam Tunnicliffe"},{"authorTime":"2016-11-10 09:16:59","codes":[{"authorDate":"2016-11-10 09:16:59","commitOrder":8,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2017-01-28 06:17:46","endLine":431,"groupId":"4360","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1f/1d8b9de296f776737423948d70eb7e63f5d4d6.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"M"},{"authorDate":"2016-11-10 09:16:59","commitOrder":8,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2017-01-28 06:17:46","endLine":498,"groupId":"13938","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/af/759060cc32210aff299c84aab0f2e5b00c2549.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final PartitionColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"}],"commitId":"af3fe39dcabd9ef77a00309ce6741268423206df","commitMessage":"@@@Make TableMetadata immutable.  optimize Schema\n\npatch by Aleksey Yeschenko; reviewed by Sylvain Lebresne for\nCASSANDRA-9425\n","date":"2017-01-28 06:17:46","modifiedFileCount":"511","status":"M","submitter":"Aleksey Yeschenko"},{"authorTime":"2017-04-07 18:00:21","codes":[{"authorDate":"2016-11-10 09:16:59","commitOrder":9,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2017-01-28 06:17:46","endLine":431,"groupId":"4360","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1f/1d8b9de296f776737423948d70eb7e63f5d4d6.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"N"},{"authorDate":"2017-04-07 18:00:21","commitOrder":9,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2017-04-07 18:00:29","endLine":498,"groupId":"13938","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalOpOrder.GroupopGroup@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/c6/f7d98f3343cf4367d5875a7276d31e9de1f867.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"}],"commitId":"94aa57e27240316373c5b9218d2848baebf45a71","commitMessage":"@@@Merge branch cassandra-3.11 into trunk\n","date":"2017-04-07 18:00:29","modifiedFileCount":"2","status":"M","submitter":"Benjamin Lerer"},{"authorTime":"2018-03-21 08:36:30","codes":[{"authorDate":"2018-03-21 08:36:30","commitOrder":10,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2018-04-16 08:39:58","endLine":430,"groupId":"14938","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalWriteContextctx@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f0/07c09d2c8425d29822b22607bb66a55f74dc2b.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"M"},{"authorDate":"2018-03-21 08:36:30","commitOrder":10,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2018-04-16 08:39:58","endLine":498,"groupId":"27576","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalWriteContextctx@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9a/29c0264a125487568138c16ed800e8b2c23bfd.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final OpOrder.Group opGroup,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       opGroup);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, opGroup, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, opGroup);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), opGroup);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"}],"commitId":"d31ed0f51b23d8fce892695ecd82d4f843f31f4c","commitMessage":"@@@Abstract write path for pluggable storage\n\nPatch by Blake Eggleston; Reviewed by Aleksey Yeschenko for CASSANDRA-14118\n","date":"2018-04-16 08:39:58","modifiedFileCount":"12","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2019-10-16 04:04:26","codes":[{"authorDate":"2019-10-16 04:04:26","commitOrder":11,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering<?> clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell<?> cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2020-09-14 23:32:44","endLine":431,"groupId":"15154","id":19,"instanceNumber":1,"isCurCommit":1,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalWriteContextctx@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/bb6bbf6a7d7cb6508265380365a7c002c066e9.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"M"},{"authorDate":"2019-10-16 04:04:26","commitOrder":11,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering<?> clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell<?> cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2020-09-14 23:32:44","endLine":497,"groupId":"15154","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalWriteContextctx@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ea/5f8e2f613c050a3fad86dbf8a7d108d745c3c8.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering clustering, Iterable<Cell> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering clustering, Cell cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":339,"status":"M"}],"commitId":"ccab496d2d37c86341d364dea6c27513fda27331","commitMessage":"@@@Add byte array backed cells\n\nPatch by Blake Eggleston; reviewed by Caleb Rackliffe and Marcus Eriksson for CASSANDRA-15393\n","date":"2020-09-14 23:32:44","modifiedFileCount":"278","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2021-08-25 01:11:16","codes":[{"authorDate":"2019-10-16 04:04:26","commitOrder":12,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering<?> clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell<?> cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2020-09-14 23:32:44","endLine":431,"groupId":"10974","id":21,"instanceNumber":1,"isCurCommit":1,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalWriteContextctx@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/bb6bbf6a7d7cb6508265380365a7c002c066e9.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(row.clustering(), row.primaryKeyLivenessInfo(), row.deletion());\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering<?> clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell<?> cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"N"},{"authorDate":"2021-08-25 01:11:16","commitOrder":12,"curCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    getPrimaryKeyIndexLiveness(newRow),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering<?> clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell<?> cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                            timestamp = cellTimestamp;\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","date":"2021-08-25 01:11:16","endLine":494,"groupId":"10974","id":22,"instanceNumber":2,"isCurCommit":1,"methodName":"indexerFor","params":"(finalDecoratedKeykey@finalRegularAndStaticColumnscolumns@finalintnowInSec@finalWriteContextctx@finalIndexTransaction.TypetransactionType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/25/61040577696baaac4430da3caee2670f0f9afa.src","preCode":"    public Indexer indexerFor(final DecoratedKey key,\n                              final RegularAndStaticColumns columns,\n                              final int nowInSec,\n                              final WriteContext ctx,\n                              final IndexTransaction.Type transactionType)\n    {\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        if (!isPrimaryKeyIndex() && !columns.contains(indexedColumn))\n            return null;\n\n        return new Indexer()\n        {\n            public void begin()\n            {\n            }\n\n            public void partitionDelete(DeletionTime deletionTime)\n            {\n            }\n\n            public void rangeTombstone(RangeTombstone tombstone)\n            {\n            }\n\n            public void insertRow(Row row)\n            {\n                if (row.isStatic() && !indexedColumn.isStatic() && !indexedColumn.isPartitionKey())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                {\n                    indexPrimaryKey(row.clustering(),\n                                    getPrimaryKeyIndexLiveness(row),\n                                    row.deletion());\n                }\n                else\n                {\n                    if (indexedColumn.isComplex())\n                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                    else\n                        indexCell(row.clustering(), row.getCell(indexedColumn));\n                }\n            }\n\n            public void removeRow(Row row)\n            {\n                if (isPrimaryKeyIndex())\n                    return;\n\n                if (indexedColumn.isComplex())\n                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));\n                else\n                    removeCell(row.clustering(), row.getCell(indexedColumn));\n            }\n\n            public void updateRow(Row oldRow, Row newRow)\n            {\n                assert oldRow.isStatic() == newRow.isStatic();\n                if (newRow.isStatic() != indexedColumn.isStatic())\n                    return;\n\n                if (isPrimaryKeyIndex())\n                    indexPrimaryKey(newRow.clustering(),\n                                    newRow.primaryKeyLivenessInfo(),\n                                    newRow.deletion());\n\n                if (indexedColumn.isComplex())\n                {\n                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));\n                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));\n                }\n                else\n                {\n                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));\n                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));\n                }\n            }\n\n            public void finish()\n            {\n            }\n\n            private void indexCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    indexCell(clustering, cell);\n            }\n\n            private void indexCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                insert(key.getKey(),\n                       clustering,\n                       cell,\n                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),\n                       ctx);\n            }\n\n            private void removeCells(Clustering<?> clustering, Iterable<Cell<?>> cells)\n            {\n                if (cells == null)\n                    return;\n\n                for (Cell<?> cell : cells)\n                    removeCell(clustering, cell);\n            }\n\n            private void removeCell(Clustering<?> clustering, Cell<?> cell)\n            {\n                if (cell == null || !cell.isLive(nowInSec))\n                    return;\n\n                delete(key.getKey(), clustering, cell, ctx, nowInSec);\n            }\n\n            private void indexPrimaryKey(final Clustering<?> clustering,\n                                         final LivenessInfo liveness,\n                                         final Row.Deletion deletion)\n            {\n                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)\n                    insert(key.getKey(), clustering, null, liveness, ctx);\n\n                if (!deletion.isLive())\n                    delete(key.getKey(), clustering, deletion.time(), ctx);\n            }\n\n            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)\n            {\n                long timestamp = row.primaryKeyLivenessInfo().timestamp();\n                int ttl = row.primaryKeyLivenessInfo().ttl();\n                for (Cell<?> cell : row.cells())\n                {\n                    long cellTimestamp = cell.timestamp();\n                    if (cell.isLive(nowInSec))\n                    {\n                        if (cellTimestamp > timestamp)\n                        {\n                            timestamp = cellTimestamp;\n                            ttl = cell.ttl();\n                        }\n                    }\n                }\n                return LivenessInfo.create(timestamp, ttl, nowInSec);\n            }\n        };\n    }\n","realPath":"src/java/org/apache/cassandra/index/internal/CassandraIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":339,"status":"M"}],"commitId":"5dd472e943f237fa86a06d077a27d704c09996db","commitMessage":"@@@Merge branch 'cassandra-4.0' into trunk\n","date":"2021-08-25 01:11:16","modifiedFileCount":"2","status":"M","submitter":"Andr?s de la Pe?a"}]
