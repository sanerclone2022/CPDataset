[{"authorTime":"2016-04-06 16:47:23","codes":[{"authorDate":"2015-12-23 18:50:58","commitOrder":3,"curCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound b = (ClusteringBound) prev.clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(\n                        b.isInclusive() ? ClusteringBound.Kind.INCL_END_EXCL_START_BOUNDARY : ClusteringBound.Kind.EXCL_END_INCL_START_BOUNDARY,\n                        b.getRawValues());\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","date":"2016-08-01 20:20:50","endLine":273,"groupId":"19471","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"attachBoundaries","params":"(List<Unfiltered>content)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/7c/dccdbc6db80f685d03c13737862d2215f9fddb.src","preCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound b = (ClusteringBound) prev.clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(\n                        b.isInclusive() ? ClusteringBound.Kind.INCL_END_EXCL_START_BOUNDARY : ClusteringBound.Kind.EXCL_END_INCL_START_BOUNDARY,\n                        b.getRawValues());\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/rows/UnfilteredRowsGenerator.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"B"},{"authorDate":"2016-04-06 16:47:23","commitOrder":3,"curCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound b = ((RangeTombstoneBoundMarker) prev).clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(b.isInclusive()\n                                                                            ? ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY\n                                                                            : ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,\n                                                                        b.getRawValues());\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","date":"2016-04-28 20:32:36","endLine":246,"groupId":"26359","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"attachBoundaries","params":"(List<Unfiltered>content)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/0e/eb3790fde99bf87460d32595dc3e22fbdec9e8.src","preCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound b = ((RangeTombstoneBoundMarker) prev).clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(b.isInclusive()\n                                                                            ? ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY\n                                                                            : ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,\n                                                                        b.getRawValues());\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/rows/UnfilteredRowIteratorsMergeTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"NB"}],"commitId":"d40ac784d3a8ddaf71a2df8b21745827392294cc","commitMessage":"@@@Garbage-collecting compaction operation and schema option.\n\npatch by Branimir Lambov; reviewed by Marcus Eriksson for CASSANDRA-7019\n","date":"2016-08-01 20:20:50","modifiedFileCount":"28","status":"M","submitter":"Branimir Lambov"},{"authorTime":"2019-10-16 04:04:26","codes":[{"authorDate":"2019-10-16 04:04:26","commitOrder":4,"curCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound<?> b = (ClusteringBound) prev.clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(\n                        b.isInclusive() ? ClusteringBound.Kind.INCL_END_EXCL_START_BOUNDARY : ClusteringBound.Kind.EXCL_END_INCL_START_BOUNDARY,\n                        b);\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","date":"2020-09-14 23:32:44","endLine":273,"groupId":"10443","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"attachBoundaries","params":"(List<Unfiltered>content)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/28/04733e3f54b1b46304966170d70b41ec4d530b.src","preCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound b = (ClusteringBound) prev.clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(\n                        b.isInclusive() ? ClusteringBound.Kind.INCL_END_EXCL_START_BOUNDARY : ClusteringBound.Kind.EXCL_END_INCL_START_BOUNDARY,\n                        b.getRawValues());\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/rows/UnfilteredRowsGenerator.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-10-16 04:04:26","commitOrder":4,"curCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound<?> b = ((RangeTombstoneBoundMarker) prev).clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(b.isInclusive()\n                                                                        ? ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY\n                                                                        : ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,\n                                                                        b);\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","date":"2020-09-14 23:32:44","endLine":256,"groupId":"10443","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"attachBoundaries","params":"(List<Unfiltered>content)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ed/8e2944dd217459dd8cd2733f59d8f5b7d6d00b.src","preCode":"    static void attachBoundaries(List<Unfiltered> content)\n    {\n        int di = 0;\n        RangeTombstoneMarker prev = null;\n        for (int si = 0; si < content.size(); ++si)\n        {\n            Unfiltered currUnfiltered = content.get(si);\n            RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?\n                                        (RangeTombstoneMarker) currUnfiltered :\n                                        null;\n            if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))\n            {\n                \r\n                ClusteringBound b = ((RangeTombstoneBoundMarker) prev).clustering();\n                ClusteringBoundary boundary = ClusteringBoundary.create(b.isInclusive()\n                                                                            ? ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY\n                                                                            : ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,\n                                                                        b.getRawValues());\n                prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));\n                currUnfiltered = prev;\n                --di;\n            }\n            content.set(di++, currUnfiltered);\n            prev = curr;\n        }\n        for (int pos = content.size() - 1; pos >= di; --pos)\n            content.remove(pos);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/rows/UnfilteredRowIteratorsMergeTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"}],"commitId":"ccab496d2d37c86341d364dea6c27513fda27331","commitMessage":"@@@Add byte array backed cells\n\nPatch by Blake Eggleston; reviewed by Caleb Rackliffe and Marcus Eriksson for CASSANDRA-15393\n","date":"2020-09-14 23:32:44","modifiedFileCount":"278","status":"M","submitter":"Blake Eggleston"}]
