[{"authorTime":"2019-06-12 23:26:54","codes":[{"authorDate":"2019-02-15 17:03:47","commitOrder":2,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2019-02-23 02:55:08","endLine":147,"groupId":"29878","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b5/32abdcd5737781f7a6a3b0ccf289b8f2a495bc.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"NB"},{"authorDate":"2019-06-12 23:26:54","commitOrder":2,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2019-06-12 23:26:54","endLine":266,"groupId":"14498","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/23/7e9a86df710739d3b4fe157c21092217264d64.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"MB"}],"commitId":"310a48efcfdc0fb77fbd5fd6e734bf17667f617d","commitMessage":"@@@Rewrite the internode messaging subsystem\n\npatch by Aleksey Yeschenko and Benedict Elliott Smith; reviewed by Alex\nPetrov.  Aleksey Yeschenko.  and Benedict Elliott Smith for CASSANDRA-15066\n\nCo-authored-by: Aleksey Yeschenko <aleksey@apache.org>\nCo-authored-by: Benedict Elliott Smith <benedict@apache.org>\n","date":"2019-06-12 23:26:54","modifiedFileCount":"253","status":"M","submitter":"Benedict Elliott Smith"},{"authorTime":"2020-03-31 21:53:51","codes":[{"authorDate":"2020-03-31 21:53:51","commitOrder":3,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":147,"groupId":"8704","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"},{"authorDate":"2020-03-31 21:53:51","commitOrder":3,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":271,"groupId":"14498","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"b4e640a96e76f8d4a45937b1312b64ddc1aeb8ac","commitMessage":"@@@Fix flaky CoordinatorMessagingTest and docstring in OutboundSink and ConsistentSession\n\npatch by Aleksandr Sorokoumov; reviewed by Stefania Alborghetti for CASSANDRA-15672\n","date":"2020-04-06 20:28:53","modifiedFileCount":"3","status":"M","submitter":"Aleksandr Sorokoumov"},{"authorTime":"2021-03-17 22:28:05","codes":[{"authorDate":"2021-03-17 22:28:05","commitOrder":4,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException, NoSuchRepairSessionException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2021-07-22 05:21:23","endLine":148,"groupId":"10316","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3c/288b0ef5a547b9bff3065e3757620a36dfe4c9.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"},{"authorDate":"2021-03-17 22:28:05","commitOrder":4,"curCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException, NoSuchRepairSessionException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2021-07-22 05:21:23","endLine":271,"groupId":"10316","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testMockedMessagingPrepareTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3c/288b0ef5a547b9bff3065e3757620a36dfe4c9.src","preCode":"    public void testMockedMessagingPrepareTimeout() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.singleton(PARTICIPANT3), new CountDownLatch(0));\n        MockMessagingSpy sendFailSessionUnexpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n            fail(\"Failed session in prepare failed during timeout from participant\");\n        }\n        catch (TimeoutException e)\n        {\n            \r\n        }\n        \r\n        spyPrepare.expectMockedMessage(2).get(100, TimeUnit.MILLISECONDS);\n        sendFailSessionUnexpectedSpy.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertFalse(hasFailures.get());\n        Assert.assertEquals(ConsistentSession.State.PREPARING, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"f49c29ee8c7374a05e32be01cb0046236d5309e6","commitMessage":"@@@Reduce the log level on \"expected\" repair exceptions\n\npatch by Caleb Rackliffe and Marcus Eriksson; reviewed by Josh McKenzie for CASSANDRA-16775\n","date":"2021-07-22 05:21:23","modifiedFileCount":"30","status":"M","submitter":"Marcus Eriksson"}]
