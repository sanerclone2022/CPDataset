[{"authorTime":"2015-12-03 11:23:54","codes":[{"authorDate":"2016-04-21 22:48:26","commitOrder":18,"curCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","date":"2016-04-21 22:48:26","endLine":383,"groupId":"13557","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/eb/acf34c6efaee0248208c9cf93277d6d9f9a47c.src","preCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","realPath":"test/unit/org/apache/cassandra/db/RowIndexEntryTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":352,"status":"B"},{"authorDate":"2015-12-03 11:23:54","commitOrder":18,"curCode":"        private void add(Unfiltered unfiltered) throws IOException\n        {\n            long pos = currentPosition();\n\n            if (firstClustering == null)\n            {\n                \r\n                firstClustering = unfiltered.clustering();\n                startPosition = pos;\n            }\n\n            UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n            \r\n            if (!observers.isEmpty())\n                observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n            lastClustering = unfiltered.clustering();\n            previousRowStart = pos;\n            ++written;\n\n            if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n            {\n                RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n            }\n\n            \r\n            if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                addIndexBlock();\n\n        }\n","date":"2016-01-24 11:35:29","endLine":173,"groupId":"13557","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/93/0fc052a42110b79a3bc1d06ce0b154b64cab6b.src","preCode":"        private void add(Unfiltered unfiltered) throws IOException\n        {\n            long pos = currentPosition();\n\n            if (firstClustering == null)\n            {\n                \r\n                firstClustering = unfiltered.clustering();\n                startPosition = pos;\n            }\n\n            UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n            \r\n            if (!observers.isEmpty())\n                observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n            lastClustering = unfiltered.clustering();\n            previousRowStart = pos;\n            ++written;\n\n            if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n            {\n                RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n            }\n\n            \r\n            if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                addIndexBlock();\n\n        }\n","realPath":"src/java/org/apache/cassandra/db/ColumnIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"NB"}],"commitId":"ef5bbedd687d75923e9a20fde9d2f78b4535241d","commitMessage":"@@@Support large partitions on the 3.0 sstable format\n\npatch by Robert Stupp; reviewed by T Jake Luciani for CASSANDRA-11206\n","date":"2016-04-21 22:48:26","modifiedFileCount":"31","status":"M","submitter":"Robert Stupp"},{"authorTime":"2016-06-27 00:21:08","codes":[{"authorDate":"2016-04-21 22:48:26","commitOrder":19,"curCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","date":"2016-04-21 22:48:26","endLine":383,"groupId":"13557","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/eb/acf34c6efaee0248208c9cf93277d6d9f9a47c.src","preCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","realPath":"test/unit/org/apache/cassandra/db/RowIndexEntryTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":352,"status":"N"},{"authorDate":"2016-06-27 00:21:08","commitOrder":19,"curCode":"    private void add(Unfiltered unfiltered) throws IOException\n    {\n        final long origPos = writer.position();\n        long pos = currentPosition();\n\n        if (firstClustering == null)\n        {\n            \r\n            firstClustering = unfiltered.clustering();\n            startPosition = pos;\n        }\n\n        UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n        \r\n        if (!observers.isEmpty())\n            observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered, origPos));\n\n        lastClustering = unfiltered.clustering();\n        previousRowStart = pos;\n        ++written;\n\n        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n        {\n            RangeTombstoneMarker marker = (RangeTombstoneMarker) unfiltered;\n            openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n        }\n\n        \r\n        if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n            addIndexBlock();\n    }\n","date":"2016-09-06 13:17:11","endLine":265,"groupId":"2966","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1f/399275e35fed1230d55631bc0476b18809fbfe.src","preCode":"    private void add(Unfiltered unfiltered) throws IOException\n    {\n        long pos = currentPosition();\n\n        if (firstClustering == null)\n        {\n            \r\n            firstClustering = unfiltered.clustering();\n            startPosition = pos;\n        }\n\n        UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n        \r\n        if (!observers.isEmpty())\n            observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n        lastClustering = unfiltered.clustering();\n        previousRowStart = pos;\n        ++written;\n\n        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n        {\n            RangeTombstoneMarker marker = (RangeTombstoneMarker) unfiltered;\n            openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n        }\n\n        \r\n        if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n            addIndexBlock();\n    }\n","realPath":"src/java/org/apache/cassandra/db/ColumnIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"}],"commitId":"7d857b46fb070548bf5e5f6ff81db588f08ec22a","commitMessage":"@@@Add row offset support to SASI\n\nPatch by Alex Petrov; reviewed by Pavel Yaskevich for CASSANDRA-11990\n","date":"2016-09-06 13:17:11","modifiedFileCount":"34","status":"M","submitter":"Alex Petrov"},{"authorTime":"2016-11-18 07:27:14","codes":[{"authorDate":"2016-04-21 22:48:26","commitOrder":20,"curCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","date":"2016-04-21 22:48:26","endLine":383,"groupId":"13557","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/eb/acf34c6efaee0248208c9cf93277d6d9f9a47c.src","preCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","realPath":"test/unit/org/apache/cassandra/db/RowIndexEntryTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":352,"status":"N"},{"authorDate":"2016-11-18 07:27:14","commitOrder":20,"curCode":"    private void add(Unfiltered unfiltered) throws IOException\n    {\n        long pos = currentPosition();\n\n        if (firstClustering == null)\n        {\n            \r\n            firstClustering = unfiltered.clustering();\n            startPosition = pos;\n        }\n\n        UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n        \r\n        if (!observers.isEmpty())\n            observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n        lastClustering = unfiltered.clustering();\n        previousRowStart = pos;\n        ++written;\n\n        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n        {\n            RangeTombstoneMarker marker = (RangeTombstoneMarker) unfiltered;\n            openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n        }\n\n        \r\n        if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n            addIndexBlock();\n    }\n","date":"2016-11-18 07:27:14","endLine":265,"groupId":"13557","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/de/1b1dfe9ea0b04900dbb716a82e89220dc6f6a3.src","preCode":"    private void add(Unfiltered unfiltered) throws IOException\n    {\n        final long origPos = writer.position();\n        long pos = currentPosition();\n\n        if (firstClustering == null)\n        {\n            \r\n            firstClustering = unfiltered.clustering();\n            startPosition = pos;\n        }\n\n        UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n        \r\n        if (!observers.isEmpty())\n            observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered, origPos));\n\n        lastClustering = unfiltered.clustering();\n        previousRowStart = pos;\n        ++written;\n\n        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n        {\n            RangeTombstoneMarker marker = (RangeTombstoneMarker) unfiltered;\n            openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n        }\n\n        \r\n        if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n            addIndexBlock();\n    }\n","realPath":"src/java/org/apache/cassandra/db/ColumnIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"}],"commitId":"f55d1b9f02a0c5b10fd1527440dd2b0371f91fe0","commitMessage":"@@@Merge branch 'cassandra-3.X' into trunk\n","date":"2016-11-18 07:27:14","modifiedFileCount":"34","status":"M","submitter":"Pavel Yaskevich"},{"authorTime":"2019-10-16 11:10:42","codes":[{"authorDate":"2019-10-16 11:10:42","commitOrder":21,"curCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, helper, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","date":"2020-04-11 08:38:41","endLine":384,"groupId":"10496","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/39/2a1a041d3e58ac845f74011cf8e5746133a9be.src","preCode":"            private void add(Unfiltered unfiltered) throws IOException\n            {\n                long pos = currentPosition();\n\n                if (firstClustering == null)\n                {\n                    \r\n                    firstClustering = unfiltered.clustering();\n                    startPosition = pos;\n                }\n\n                UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n                \r\n                if (!observers.isEmpty())\n                    observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n                lastClustering = unfiltered.clustering();\n                previousRowStart = pos;\n                ++written;\n\n                if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n                {\n                    RangeTombstoneMarker marker = (RangeTombstoneMarker)unfiltered;\n                    openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n                }\n\n                \r\n                if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n                    addIndexBlock();\n\n            }\n","realPath":"test/unit/org/apache/cassandra/db/RowIndexEntryTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":353,"status":"M"},{"authorDate":"2019-10-16 11:10:42","commitOrder":21,"curCode":"    private void add(Unfiltered unfiltered) throws IOException\n    {\n        long pos = currentPosition();\n\n        if (firstClustering == null)\n        {\n            \r\n            firstClustering = unfiltered.clustering();\n            startPosition = pos;\n        }\n\n        UnfilteredSerializer.serializer.serialize(unfiltered, helper, writer, pos - previousRowStart, version);\n\n        \r\n        if (!observers.isEmpty())\n            observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n        lastClustering = unfiltered.clustering();\n        previousRowStart = pos;\n        ++written;\n\n        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n        {\n            RangeTombstoneMarker marker = (RangeTombstoneMarker) unfiltered;\n            openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n        }\n\n        \r\n        if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n            addIndexBlock();\n    }\n","date":"2020-04-11 08:38:41","endLine":272,"groupId":"10496","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"add","params":"(Unfilteredunfiltered)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/e1/1f784ec55bfbbd743cf6df1f87be8f459e5004.src","preCode":"    private void add(Unfiltered unfiltered) throws IOException\n    {\n        long pos = currentPosition();\n\n        if (firstClustering == null)\n        {\n            \r\n            firstClustering = unfiltered.clustering();\n            startPosition = pos;\n        }\n\n        UnfilteredSerializer.serializer.serialize(unfiltered, header, writer, pos - previousRowStart, version);\n\n        \r\n        if (!observers.isEmpty())\n            observers.forEach((o) -> o.nextUnfilteredCluster(unfiltered));\n\n        lastClustering = unfiltered.clustering();\n        previousRowStart = pos;\n        ++written;\n\n        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)\n        {\n            RangeTombstoneMarker marker = (RangeTombstoneMarker) unfiltered;\n            openMarker = marker.isOpen(false) ? marker.openDeletionTime(false) : null;\n        }\n\n        \r\n        if (currentPosition() - startPosition >= DatabaseDescriptor.getColumnIndexSize())\n            addIndexBlock();\n    }\n","realPath":"src/java/org/apache/cassandra/db/ColumnIndex.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":242,"status":"M"}],"commitId":"8576e769d13b3e887ea604074641fd4c42af5e8a","commitMessage":"@@@Minimize BTree iterator allocations\n\nPatch by Blake Eggleston; Reviewed by Benedict Elliott Smith for CASSANDRA-15389\n","date":"2020-04-11 08:38:41","modifiedFileCount":"35","status":"M","submitter":"Blake Eggleston"}]
