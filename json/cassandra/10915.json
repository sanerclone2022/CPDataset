[{"authorTime":"2015-06-30 21:58:02","codes":[{"authorDate":"2015-12-05 02:19:33","commitOrder":3,"curCode":"    public void testSSTablesPerReadHistogramWhenRowCache()\n    {\n        CompactionManager.instance.disableAutoCompaction();\n\n        Keyspace keyspace = Keyspace.open(KEYSPACE_CACHED);\n        ColumnFamilyStore cachedStore  = keyspace.getColumnFamilyStore(CF_CACHED);\n\n        \r\n        CacheService.instance.invalidateRowCache();\n\n        \r\n        CacheService.instance.setRowCacheCapacityInMB(1);\n\n        \r\n        SchemaLoader.insertData(KEYSPACE_CACHED, CF_CACHED, 0, 100);\n\n        \r\n        cachedStore.forceBlockingFlush();\n\n        ((ClearableHistogram)cachedStore.metric.sstablesPerReadHistogram.cf).clear();\n\n        for (int i = 0; i < 100; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            long count_before = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            \r\n            \r\n            long count_after = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            double belowMedian = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49D);\n            double mean_after = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMean();\n            assertEquals(\"SSTablePerReadHistogram should be updated even key found in row cache\", count_before + 1, count_after);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so 49 percentile (\" + belowMedian + \") must be strongly less than 0.9\", belowMedian < 0.9D);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so mean value (\" + mean_after + \") must be strongly less than 1, but greater than 0\", mean_after < 0.999D && mean_after > 0.001D);\n        }\n\n        assertEquals(\"Min value of SSTablesPerRead should be zero\", 0, cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMin());\n\n        CacheService.instance.setRowCacheCapacityInMB(0);\n    }\n","date":"2015-12-05 02:19:33","endLine":449,"groupId":"13517","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSSTablesPerReadHistogramWhenRowCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/7e5e491d1a50bdd8400cd97b8515ae9b1e627d.src","preCode":"    public void testSSTablesPerReadHistogramWhenRowCache()\n    {\n        CompactionManager.instance.disableAutoCompaction();\n\n        Keyspace keyspace = Keyspace.open(KEYSPACE_CACHED);\n        ColumnFamilyStore cachedStore  = keyspace.getColumnFamilyStore(CF_CACHED);\n\n        \r\n        CacheService.instance.invalidateRowCache();\n\n        \r\n        CacheService.instance.setRowCacheCapacityInMB(1);\n\n        \r\n        SchemaLoader.insertData(KEYSPACE_CACHED, CF_CACHED, 0, 100);\n\n        \r\n        cachedStore.forceBlockingFlush();\n\n        ((ClearableHistogram)cachedStore.metric.sstablesPerReadHistogram.cf).clear();\n\n        for (int i = 0; i < 100; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            long count_before = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            \r\n            \r\n            long count_after = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            double belowMedian = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49D);\n            double mean_after = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMean();\n            assertEquals(\"SSTablePerReadHistogram should be updated even key found in row cache\", count_before + 1, count_after);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so 49 percentile (\" + belowMedian + \") must be strongly less than 0.9\", belowMedian < 0.9D);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so mean value (\" + mean_after + \") must be strongly less than 1, but greater than 0\", mean_after < 0.999D && mean_after > 0.001D);\n        }\n\n        assertEquals(\"Min value of SSTablesPerRead should be zero\", 0, cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMin());\n\n        CacheService.instance.setRowCacheCapacityInMB(0);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/RowCacheTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":404,"status":"B"},{"authorDate":"2015-06-30 21:58:02","commitOrder":3,"curCode":"    private static void readData(String keyspace, String columnFamily, int offset, int numberOfRows)\n    {\n        ColumnFamilyStore store = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);\n        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace, columnFamily);\n\n        for (int i = offset; i < offset + numberOfRows; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n            Clustering cl = new Clustering(ByteBufferUtil.bytes(\"col\" + i));\n            Util.getAll(Util.cmd(store, key).build());\n        }\n    }\n","date":"2015-07-23 00:05:09","endLine":353,"groupId":"15350","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"readData","params":"(Stringkeyspace@StringcolumnFamily@intoffset@intnumberOfRows)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/88/3149f30428ff1812374156f46d264623c10650.src","preCode":"    private static void readData(String keyspace, String columnFamily, int offset, int numberOfRows)\n    {\n        ColumnFamilyStore store = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);\n        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace, columnFamily);\n\n        for (int i = offset; i < offset + numberOfRows; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n            Clustering cl = new Clustering(ByteBufferUtil.bytes(\"col\" + i));\n            Util.getAll(Util.cmd(store, key).build());\n        }\n    }\n","realPath":"test/unit/org/apache/cassandra/db/RowCacheTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"NB"}],"commitId":"084590c4134a022dc9da05e6f97da882b33b9854","commitMessage":"@@@Merge branch 'cassandra-3.1' into trunk\n","date":"2015-12-05 02:19:33","modifiedFileCount":"9","status":"M","submitter":"Joshua McKenzie"},{"authorTime":"2015-11-05 01:03:38","codes":[{"authorDate":"2015-12-05 02:19:33","commitOrder":4,"curCode":"    public void testSSTablesPerReadHistogramWhenRowCache()\n    {\n        CompactionManager.instance.disableAutoCompaction();\n\n        Keyspace keyspace = Keyspace.open(KEYSPACE_CACHED);\n        ColumnFamilyStore cachedStore  = keyspace.getColumnFamilyStore(CF_CACHED);\n\n        \r\n        CacheService.instance.invalidateRowCache();\n\n        \r\n        CacheService.instance.setRowCacheCapacityInMB(1);\n\n        \r\n        SchemaLoader.insertData(KEYSPACE_CACHED, CF_CACHED, 0, 100);\n\n        \r\n        cachedStore.forceBlockingFlush();\n\n        ((ClearableHistogram)cachedStore.metric.sstablesPerReadHistogram.cf).clear();\n\n        for (int i = 0; i < 100; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            long count_before = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            \r\n            \r\n            long count_after = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            double belowMedian = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49D);\n            double mean_after = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMean();\n            assertEquals(\"SSTablePerReadHistogram should be updated even key found in row cache\", count_before + 1, count_after);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so 49 percentile (\" + belowMedian + \") must be strongly less than 0.9\", belowMedian < 0.9D);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so mean value (\" + mean_after + \") must be strongly less than 1, but greater than 0\", mean_after < 0.999D && mean_after > 0.001D);\n        }\n\n        assertEquals(\"Min value of SSTablesPerRead should be zero\", 0, cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMin());\n\n        CacheService.instance.setRowCacheCapacityInMB(0);\n    }\n","date":"2015-12-05 02:19:33","endLine":449,"groupId":"13517","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSSTablesPerReadHistogramWhenRowCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/7e5e491d1a50bdd8400cd97b8515ae9b1e627d.src","preCode":"    public void testSSTablesPerReadHistogramWhenRowCache()\n    {\n        CompactionManager.instance.disableAutoCompaction();\n\n        Keyspace keyspace = Keyspace.open(KEYSPACE_CACHED);\n        ColumnFamilyStore cachedStore  = keyspace.getColumnFamilyStore(CF_CACHED);\n\n        \r\n        CacheService.instance.invalidateRowCache();\n\n        \r\n        CacheService.instance.setRowCacheCapacityInMB(1);\n\n        \r\n        SchemaLoader.insertData(KEYSPACE_CACHED, CF_CACHED, 0, 100);\n\n        \r\n        cachedStore.forceBlockingFlush();\n\n        ((ClearableHistogram)cachedStore.metric.sstablesPerReadHistogram.cf).clear();\n\n        for (int i = 0; i < 100; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            long count_before = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            \r\n            \r\n            long count_after = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            double belowMedian = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49D);\n            double mean_after = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMean();\n            assertEquals(\"SSTablePerReadHistogram should be updated even key found in row cache\", count_before + 1, count_after);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so 49 percentile (\" + belowMedian + \") must be strongly less than 0.9\", belowMedian < 0.9D);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so mean value (\" + mean_after + \") must be strongly less than 1, but greater than 0\", mean_after < 0.999D && mean_after > 0.001D);\n        }\n\n        assertEquals(\"Min value of SSTablesPerRead should be zero\", 0, cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMin());\n\n        CacheService.instance.setRowCacheCapacityInMB(0);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/RowCacheTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":404,"status":"N"},{"authorDate":"2015-11-05 01:03:38","commitOrder":4,"curCode":"    private static void readData(String keyspace, String columnFamily, int offset, int numberOfRows)\n    {\n        ColumnFamilyStore store = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);\n        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace, columnFamily);\n\n        for (int i = offset; i < offset + numberOfRows; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n            Clustering cl = Clustering.make(ByteBufferUtil.bytes(\"col\" + i));\n            Util.getAll(Util.cmd(store, key).build());\n        }\n    }\n","date":"2016-01-27 18:49:26","endLine":486,"groupId":"17941","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"readData","params":"(Stringkeyspace@StringcolumnFamily@intoffset@intnumberOfRows)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/21/d7b8fb16c5d1128a0c6e2db61dfc70f44d6925.src","preCode":"    private static void readData(String keyspace, String columnFamily, int offset, int numberOfRows)\n    {\n        ColumnFamilyStore store = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);\n        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace, columnFamily);\n\n        for (int i = offset; i < offset + numberOfRows; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n            Clustering cl = new Clustering(ByteBufferUtil.bytes(\"col\" + i));\n            Util.getAll(Util.cmd(store, key).build());\n        }\n    }\n","realPath":"test/unit/org/apache/cassandra/db/RowCacheTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":475,"status":"M"}],"commitId":"2f41243191c381193a3bf6ec3730ff6555325d06","commitMessage":"@@@9472: Reintroduce Off-Heap Memtables\n\npatch by benedict and stefania\n","date":"2016-01-27 18:49:26","modifiedFileCount":"54","status":"M","submitter":"Benedict Elliott Smith"},{"authorTime":"2016-11-10 09:16:59","codes":[{"authorDate":"2015-12-05 02:19:33","commitOrder":5,"curCode":"    public void testSSTablesPerReadHistogramWhenRowCache()\n    {\n        CompactionManager.instance.disableAutoCompaction();\n\n        Keyspace keyspace = Keyspace.open(KEYSPACE_CACHED);\n        ColumnFamilyStore cachedStore  = keyspace.getColumnFamilyStore(CF_CACHED);\n\n        \r\n        CacheService.instance.invalidateRowCache();\n\n        \r\n        CacheService.instance.setRowCacheCapacityInMB(1);\n\n        \r\n        SchemaLoader.insertData(KEYSPACE_CACHED, CF_CACHED, 0, 100);\n\n        \r\n        cachedStore.forceBlockingFlush();\n\n        ((ClearableHistogram)cachedStore.metric.sstablesPerReadHistogram.cf).clear();\n\n        for (int i = 0; i < 100; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            long count_before = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            \r\n            \r\n            long count_after = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            double belowMedian = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49D);\n            double mean_after = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMean();\n            assertEquals(\"SSTablePerReadHistogram should be updated even key found in row cache\", count_before + 1, count_after);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so 49 percentile (\" + belowMedian + \") must be strongly less than 0.9\", belowMedian < 0.9D);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so mean value (\" + mean_after + \") must be strongly less than 1, but greater than 0\", mean_after < 0.999D && mean_after > 0.001D);\n        }\n\n        assertEquals(\"Min value of SSTablesPerRead should be zero\", 0, cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMin());\n\n        CacheService.instance.setRowCacheCapacityInMB(0);\n    }\n","date":"2015-12-05 02:19:33","endLine":449,"groupId":"10915","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSSTablesPerReadHistogramWhenRowCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/26/7e5e491d1a50bdd8400cd97b8515ae9b1e627d.src","preCode":"    public void testSSTablesPerReadHistogramWhenRowCache()\n    {\n        CompactionManager.instance.disableAutoCompaction();\n\n        Keyspace keyspace = Keyspace.open(KEYSPACE_CACHED);\n        ColumnFamilyStore cachedStore  = keyspace.getColumnFamilyStore(CF_CACHED);\n\n        \r\n        CacheService.instance.invalidateRowCache();\n\n        \r\n        CacheService.instance.setRowCacheCapacityInMB(1);\n\n        \r\n        SchemaLoader.insertData(KEYSPACE_CACHED, CF_CACHED, 0, 100);\n\n        \r\n        cachedStore.forceBlockingFlush();\n\n        ((ClearableHistogram)cachedStore.metric.sstablesPerReadHistogram.cf).clear();\n\n        for (int i = 0; i < 100; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            long count_before = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            Util.getAll(Util.cmd(cachedStore, key).build());\n\n            \r\n            \r\n            long count_after = cachedStore.metric.sstablesPerReadHistogram.cf.getCount();\n            double belowMedian = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49D);\n            double mean_after = cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMean();\n            assertEquals(\"SSTablePerReadHistogram should be updated even key found in row cache\", count_before + 1, count_after);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so 49 percentile (\" + belowMedian + \") must be strongly less than 0.9\", belowMedian < 0.9D);\n            assertTrue(\"In half of requests we have not touched SSTables, \" +\n                       \"so mean value (\" + mean_after + \") must be strongly less than 1, but greater than 0\", mean_after < 0.999D && mean_after > 0.001D);\n        }\n\n        assertEquals(\"Min value of SSTablesPerRead should be zero\", 0, cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMin());\n\n        CacheService.instance.setRowCacheCapacityInMB(0);\n    }\n","realPath":"test/unit/org/apache/cassandra/db/RowCacheTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":404,"status":"N"},{"authorDate":"2016-11-10 09:16:59","commitOrder":5,"curCode":"    private static void readData(String keyspace, String columnFamily, int offset, int numberOfRows)\n    {\n        ColumnFamilyStore store = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);\n\n        for (int i = offset; i < offset + numberOfRows; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n            Util.getAll(Util.cmd(store, key).build());\n        }\n    }\n","date":"2017-01-28 06:17:46","endLine":556,"groupId":"10915","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"readData","params":"(Stringkeyspace@StringcolumnFamily@intoffset@intnumberOfRows)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/fe/e3f2c102fb032ba0b7b80aa0d0d053ac60685e.src","preCode":"    private static void readData(String keyspace, String columnFamily, int offset, int numberOfRows)\n    {\n        ColumnFamilyStore store = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);\n        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace, columnFamily);\n\n        for (int i = offset; i < offset + numberOfRows; i++)\n        {\n            DecoratedKey key = Util.dk(\"key\" + i);\n            Clustering cl = Clustering.make(ByteBufferUtil.bytes(\"col\" + i));\n            Util.getAll(Util.cmd(store, key).build());\n        }\n    }\n","realPath":"test/unit/org/apache/cassandra/db/RowCacheTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":547,"status":"M"}],"commitId":"af3fe39dcabd9ef77a00309ce6741268423206df","commitMessage":"@@@Make TableMetadata immutable.  optimize Schema\n\npatch by Aleksey Yeschenko; reviewed by Sylvain Lebresne for\nCASSANDRA-9425\n","date":"2017-01-28 06:17:46","modifiedFileCount":"511","status":"M","submitter":"Aleksey Yeschenko"}]
