[{"authorTime":"2016-09-01 06:48:43","codes":[{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public synchronized void handlePrepareResponse(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.debug(\"Consistent repair {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Failed prepare response received from {} for session {}\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.debug(\"Successful prepare response received from {} for session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                prepareFuture.set(true);\n            }\n        }\n    }\n","date":"2017-02-07 11:11:18","endLine":171,"groupId":"3847","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"handlePrepareResponse","params":"(InetAddressparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ef/3eacda4ff0a5679ec05b441c1888da9f425138.src","preCode":"    public synchronized void handlePrepareResponse(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.debug(\"Consistent repair {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Failed prepare response received from {} for session {}\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.debug(\"Successful prepare response received from {} for session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                prepareFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"B"},{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public synchronized void handleFinalizePromise(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.debug(\"Consistent repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Failed finalize promise received from {} for session {}\", participant, sessionID);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.debug(\"Successful finalize promise received from {} for session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","date":"2017-02-07 11:11:18","endLine":211,"groupId":"3847","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"handleFinalizePromise","params":"(InetAddressparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/ef/3eacda4ff0a5679ec05b441c1888da9f425138.src","preCode":"    public synchronized void handleFinalizePromise(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.debug(\"Consistent repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Failed finalize promise received from {} for session {}\", participant, sessionID);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.debug(\"Successful finalize promise received from {} for session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"B"}],"commitId":"98d74ed998706e9e047dc0f7886a1e9b18df3ce9","commitMessage":"@@@Fix consistency of incrementally repaired data\n\npatch by Blake Eggleston.  reviewed by Marcus Eriksson for CASSANDRA-9143\n","date":"2017-02-07 11:11:18","modifiedFileCount":"81","status":"B","submitter":"Blake Eggleston"},{"authorTime":"2017-04-21 04:24:14","codes":[{"authorDate":"2017-04-21 04:24:14","commitOrder":2,"curCode":"    public synchronized void handlePrepareResponse(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair session {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"{} failed the prepare phase for incremental repair session {}. Aborting session\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                logger.debug(\"Incremental repair session {} successfully prepared.\", sessionID);\n                prepareFuture.set(true);\n            }\n        }\n    }\n","date":"2017-05-03 00:19:27","endLine":173,"groupId":"21390","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"handlePrepareResponse","params":"(InetAddressparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cd/4844b0146ceb27cd4de1ec0046872950aa8c02.src","preCode":"    public synchronized void handlePrepareResponse(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.debug(\"Consistent repair {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Failed prepare response received from {} for session {}\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.debug(\"Successful prepare response received from {} for session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                prepareFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"},{"authorDate":"2017-04-21 04:24:14","commitOrder":2,"curCode":"    public synchronized void handleFinalizePromise(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.debug(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","date":"2017-05-03 00:19:27","endLine":214,"groupId":"21387","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"handleFinalizePromise","params":"(InetAddressparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/cd/4844b0146ceb27cd4de1ec0046872950aa8c02.src","preCode":"    public synchronized void handleFinalizePromise(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.debug(\"Consistent repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Failed finalize promise received from {} for session {}\", participant, sessionID);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.debug(\"Successful finalize promise received from {} for session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"4ef0bf8861ee12f5c7e826298c42fe3ddb29c198","commitMessage":"@@@Improve incremental repair logging\n\nPatch by Blake Eggleston; reviewed by Marcus Eriksson for CASSANDRA-13468\n","date":"2017-05-03 00:19:27","modifiedFileCount":"3","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-11-10 00:33:48","codes":[{"authorDate":"2017-11-10 00:33:48","commitOrder":3,"curCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair session {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"{} failed the prepare phase for incremental repair session {}. Aborting session\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                logger.debug(\"Incremental repair session {} successfully prepared.\", sessionID);\n                prepareFuture.set(true);\n            }\n        }\n    }\n","date":"2018-01-26 03:32:24","endLine":176,"groupId":"21390","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"handlePrepareResponse","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f5/2a28de31ff87c0fdbeba4c654fe65bf3e0e55a.src","preCode":"    public synchronized void handlePrepareResponse(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair session {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"{} failed the prepare phase for incremental repair session {}. Aborting session\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                logger.debug(\"Incremental repair session {} successfully prepared.\", sessionID);\n                prepareFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2017-11-10 00:33:48","commitOrder":3,"curCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.debug(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","date":"2018-01-26 03:32:24","endLine":217,"groupId":"21387","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"handleFinalizePromise","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f5/2a28de31ff87c0fdbeba4c654fe65bf3e0e55a.src","preCode":"    public synchronized void handleFinalizePromise(InetAddress participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.debug(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"}],"commitId":"59b5b6bef0fa76bf5740b688fcd4d9cf525760d0","commitMessage":"@@@Allow storage port to be configurable per node\n\nPatch by Ariel Weisberg; Reviewed by Jason Brown for CASSANDRA-7544\n","date":"2018-01-26 03:32:24","modifiedFileCount":"308","status":"M","submitter":"Ariel Weisberg"},{"authorTime":"2017-11-10 00:33:48","codes":[{"authorDate":"2019-02-15 17:03:47","commitOrder":4,"curCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (!success)\n        {\n            logger.debug(\"{} failed the prepare phase for incremental repair session {}\", participant, sessionID);\n            sendFailureMessageToParticipants();\n            setParticipantState(participant, State.FAILED);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n        }\n\n        \r\n        if(Iterables.any(participantStates.values(), v -> v == State.PREPARING))\n            return;\n\n        if (getState() == State.PREPARED)\n        {\n            logger.info(\"Incremental repair session {} successfully prepared.\", sessionID);\n            prepareFuture.set(true);\n        }\n        else\n        {\n            fail();\n            prepareFuture.set(false);\n        }\n    }\n","date":"2019-02-23 02:55:08","endLine":189,"groupId":"20279","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"handlePrepareResponse","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b9/21342ec78bd6223839e716efd7e43db29a8f3f.src","preCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair session {} has failed, ignoring prepare response from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"{} failed the prepare phase for incremental repair session {}. Aborting session\", participant, sessionID);\n            fail();\n            prepareFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n            if (getState() == State.PREPARED)\n            {\n                logger.debug(\"Incremental repair session {} successfully prepared.\", sessionID);\n                prepareFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"},{"authorDate":"2017-11-10 00:33:48","commitOrder":4,"curCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.debug(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","date":"2018-01-26 03:32:24","endLine":217,"groupId":"21387","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"handleFinalizePromise","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f5/2a28de31ff87c0fdbeba4c654fe65bf3e0e55a.src","preCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.debug(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"N"}],"commitId":"9bde713ee8883f70d130efb6290ec0e6daea524f","commitMessage":"@@@Fix IR prepare anti-compaction race\n\nPatch by Stefan Podkowinski; Reviewed by Blake Eggleston for CASSANDRA-15027\n","date":"2019-02-23 02:55:08","modifiedFileCount":"14","status":"M","submitter":"Stefan Podkowinski"},{"authorTime":"2020-03-25 04:44:17","codes":[{"authorDate":"2020-03-25 04:44:17","commitOrder":5,"curCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (!success)\n        {\n            logger.warn(\"{} failed the prepare phase for incremental repair session {}\", participant, sessionID);\n            sendFailureMessageToParticipants();\n            setParticipantState(participant, State.FAILED);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n        }\n\n        \r\n        if(Iterables.any(participantStates.values(), v -> v == State.PREPARING))\n            return;\n\n        if (getState() == State.PREPARED)\n        {\n            logger.info(\"Incremental repair session {} successfully prepared.\", sessionID);\n            prepareFuture.set(true);\n        }\n        else\n        {\n            fail();\n            prepareFuture.set(false);\n        }\n    }\n","date":"2020-04-01 23:15:41","endLine":191,"groupId":"20279","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"handlePrepareResponse","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9d/440c2cc093ff4c71291804d09151bf415d4b2c.src","preCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (!success)\n        {\n            logger.debug(\"{} failed the prepare phase for incremental repair session {}\", participant, sessionID);\n            sendFailureMessageToParticipants();\n            setParticipantState(participant, State.FAILED);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n        }\n\n        \r\n        if(Iterables.any(participantStates.values(), v -> v == State.PREPARING))\n            return;\n\n        if (getState() == State.PREPARED)\n        {\n            logger.info(\"Incremental repair session {} successfully prepared.\", sessionID);\n            prepareFuture.set(true);\n        }\n        else\n        {\n            fail();\n            prepareFuture.set(false);\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-03-25 04:44:17","commitOrder":5,"curCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.warn(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.info(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","date":"2020-04-01 23:15:41","endLine":232,"groupId":"21390","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"handleFinalizePromise","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9d/440c2cc093ff4c71291804d09151bf415d4b2c.src","preCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.debug(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.debug(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":210,"status":"M"}],"commitId":"dd9a6e0a8a691bdee357eb6559f1b2b92b076925","commitMessage":"@@@Use more appropriate logging levels.\n\nThe following logging was changed:\n\n* When the Commit log reader finishes logging each segment.  from debug to info\n* When starting a new compaction.  logging details of the compaction task.  from debug -> info\n* When finishing a compaction.  logging details of how many sstables.  sizes.  etc.  from debug -> info\n* When performing a validation compaction.  adding helpful logging\n* When flushing memtables.  log details. debug -> info\n* When flushing largest memtable to free up room.  logging more details at INFO\n* Various logging messages for incremental repair moved to INFO from debug\n* When failing incremental repair phase.  log a warning instead of debug message\n\nPatch by Jon Haddad; Reviewed by Alexander Dejanovski for CASSANDRA-15661\n","date":"2020-04-01 23:15:41","modifiedFileCount":"11","status":"M","submitter":"Jon Haddad jon@jonhaddad.com"},{"authorTime":"2020-03-25 04:44:17","codes":[{"authorDate":"2020-08-21 15:01:51","commitOrder":6,"curCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring prepare response from {}\", sessionID, participant);\n            return;\n        }\n        if (!success)\n        {\n            logger.warn(\"{} failed the prepare phase for incremental repair session {}\", participant, sessionID);\n            sendFailureMessageToParticipants();\n            setParticipantState(participant, State.FAILED);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n        }\n\n        \r\n        if(Iterables.any(participantStates.values(), v -> v == State.PREPARING))\n            return;\n\n        if (getState() == State.PREPARED)\n        {\n            logger.info(\"Incremental repair session {} successfully prepared.\", sessionID);\n            prepareFuture.set(true);\n        }\n        else\n        {\n            fail();\n            prepareFuture.set(false);\n        }\n    }\n","date":"2020-09-16 17:23:54","endLine":196,"groupId":"102172","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"handlePrepareResponse","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d6/0541e17e0c9fc51f8af8d39e228c77d4cf74a1.src","preCode":"    public synchronized void handlePrepareResponse(InetAddressAndPort participant, boolean success)\n    {\n        if (!success)\n        {\n            logger.warn(\"{} failed the prepare phase for incremental repair session {}\", participant, sessionID);\n            sendFailureMessageToParticipants();\n            setParticipantState(participant, State.FAILED);\n        }\n        else\n        {\n            logger.trace(\"Successful prepare response received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.PREPARED);\n        }\n\n        \r\n        if(Iterables.any(participantStates.values(), v -> v == State.PREPARING))\n            return;\n\n        if (getState() == State.PREPARED)\n        {\n            logger.info(\"Incremental repair session {} successfully prepared.\", sessionID);\n            prepareFuture.set(true);\n        }\n        else\n        {\n            fail();\n            prepareFuture.set(false);\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-03-25 04:44:17","commitOrder":6,"curCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.warn(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.info(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","date":"2020-04-01 23:15:41","endLine":232,"groupId":"102172","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"handleFinalizePromise","params":"(InetAddressAndPortparticipant@booleansuccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/9d/440c2cc093ff4c71291804d09151bf415d4b2c.src","preCode":"    public synchronized void handleFinalizePromise(InetAddressAndPort participant, boolean success)\n    {\n        if (getState() == State.FAILED)\n        {\n            logger.trace(\"Incremental repair {} has failed, ignoring finalize promise from {}\", sessionID, participant);\n        }\n        else if (!success)\n        {\n            logger.warn(\"Finalization proposal of session {} rejected by {}. Aborting session\", sessionID, participant);\n            fail();\n            finalizeProposeFuture.set(false);\n        }\n        else\n        {\n            logger.trace(\"Successful finalize promise received from {} for repair session {}\", participant, sessionID);\n            setParticipantState(participant, State.FINALIZE_PROMISED);\n            if (getState() == State.FINALIZE_PROMISED)\n            {\n                logger.info(\"Finalization proposal for repair session {} accepted by all participants.\", sessionID);\n                finalizeProposeFuture.set(true);\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":210,"status":"N"}],"commitId":"da3806795fe7cf8412249a0fab9934e071a7511e","commitMessage":"@@@Avoid invalid state transition exception during incremental repair\n\nPatch by marcuse; reviewed by Blake Eggleston and Jon Meredith for CASSANDRA-16067\n","date":"2020-09-16 17:23:54","modifiedFileCount":"1","status":"M","submitter":"Marcus Eriksson"}]
