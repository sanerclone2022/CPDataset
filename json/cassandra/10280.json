[{"authorTime":"2018-09-05 01:38:27","codes":[{"authorDate":"2018-09-05 01:38:27","commitOrder":4,"curCode":"    public void fullRepairStreamPlan() throws Exception\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1, r2, NO_PENDING_REPAIR, true, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan(local, Lists.newArrayList(RANGE1));\n\n        assertEquals(NO_PENDING_REPAIR, plan.getPendingRepair());\n        assertTrue(plan.getFlushBeforeTransfer());\n    }\n","date":"2018-09-12 04:58:01","endLine":168,"groupId":"9905","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"fullRepairStreamPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6e/691f528ff08819c47cee5465369cb31387afed.src","preCode":"    public void fullRepairStreamPlan() throws Exception\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1, r2, NO_PENDING_REPAIR, true, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan(local, Lists.newArrayList(RANGE1));\n\n        assertEquals(NO_PENDING_REPAIR, plan.getPendingRepair());\n        assertTrue(plan.getFlushBeforeTransfer());\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"MB"},{"authorDate":"2018-09-05 01:38:27","commitOrder":4,"curCode":"    public void transientLocalStreamPlan()\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1, r2, desc.parentSessionId, false, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan(local, Lists.newArrayList(RANGE1));\n        assertNumInOut(plan, 0, 1);\n    }\n","date":"2018-09-12 04:58:01","endLine":230,"groupId":"9905","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"transientLocalStreamPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6e/691f528ff08819c47cee5465369cb31387afed.src","preCode":"    public void transientLocalStreamPlan()\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1, r2, desc.parentSessionId, false, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan(local, Lists.newArrayList(RANGE1));\n        assertNumInOut(plan, 0, 1);\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":218,"status":"B"}],"commitId":"0841353e90f1cc94dc47b435af87e4d5876478ea","commitMessage":"@@@Allow transient node to serve as a repair coordinator\n\nPatch by Alex Petrov and Blake Eggleston.  reviewed by Ariel Weisberg.  Blake Eggleston.  Marcus Eriksson for CASSANDRA-14693\n\nCo-authored-by: Blake Eggleston <bdeggleston@gmail.com>\n","date":"2018-09-12 04:58:01","modifiedFileCount":"14","status":"M","submitter":"Alex Petrov"},{"authorTime":"2018-10-01 21:30:58","codes":[{"authorDate":"2018-10-01 21:30:58","commitOrder":5,"curCode":"    public void fullRepairStreamPlan() throws Exception\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1.endpoint, r2.endpoint, MerkleTrees.difference(r1.trees, r2.trees),\n                                               NO_PENDING_REPAIR, true, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan();\n\n        assertEquals(NO_PENDING_REPAIR, plan.getPendingRepair());\n        assertTrue(plan.getFlushBeforeTransfer());\n    }\n","date":"2018-10-10 05:33:31","endLine":171,"groupId":"9905","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"fullRepairStreamPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/90/3a273178dd060d2a5fe702fd5205ec41e26b8b.src","preCode":"    public void fullRepairStreamPlan() throws Exception\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1, r2, NO_PENDING_REPAIR, true, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan(local, Lists.newArrayList(RANGE1));\n\n        assertEquals(NO_PENDING_REPAIR, plan.getPendingRepair());\n        assertTrue(plan.getFlushBeforeTransfer());\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"},{"authorDate":"2018-10-01 21:30:58","commitOrder":5,"curCode":"    public void transientLocalStreamPlan()\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1.endpoint, r2.endpoint, MerkleTrees.difference(r1.trees, r2.trees),\n                                               desc.parentSessionId, false, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan();\n        assertNumInOut(plan, 0, 1);\n    }\n","date":"2018-10-10 05:33:31","endLine":236,"groupId":"9905","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"transientLocalStreamPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/90/3a273178dd060d2a5fe702fd5205ec41e26b8b.src","preCode":"    public void transientLocalStreamPlan()\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1, r2, desc.parentSessionId, false, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan(local, Lists.newArrayList(RANGE1));\n        assertNumInOut(plan, 0, 1);\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"M"}],"commitId":"a05785d82c621c9cd04d8a064c38fd2012ef981c","commitMessage":"@@@Add tests for RepairJob\n\nPatch by Alex Petrov; reviewed by Marcus Eriksson for CASSANDRA-14717","date":"2018-10-10 05:33:31","modifiedFileCount":"7","status":"M","submitter":"Alex Petrov"},{"authorTime":"2021-03-17 22:28:05","codes":[{"authorDate":"2018-10-01 21:30:58","commitOrder":6,"curCode":"    public void fullRepairStreamPlan() throws Exception\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1.endpoint, r2.endpoint, MerkleTrees.difference(r1.trees, r2.trees),\n                                               NO_PENDING_REPAIR, true, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan();\n\n        assertEquals(NO_PENDING_REPAIR, plan.getPendingRepair());\n        assertTrue(plan.getFlushBeforeTransfer());\n    }\n","date":"2018-10-10 05:33:31","endLine":171,"groupId":"10280","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"fullRepairStreamPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/90/3a273178dd060d2a5fe702fd5205ec41e26b8b.src","preCode":"    public void fullRepairStreamPlan() throws Exception\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1.endpoint, r2.endpoint, MerkleTrees.difference(r1.trees, r2.trees),\n                                               NO_PENDING_REPAIR, true, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan();\n\n        assertEquals(NO_PENDING_REPAIR, plan.getPendingRepair());\n        assertTrue(plan.getFlushBeforeTransfer());\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"N"},{"authorDate":"2021-03-17 22:28:05","commitOrder":6,"curCode":"    public void transientLocalStreamPlan() throws NoSuchRepairSessionException\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1.endpoint, r2.endpoint, MerkleTrees.difference(r1.trees, r2.trees),\n                                               desc.parentSessionId, false, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan();\n        assertNumInOut(plan, 0, 1);\n    }\n","date":"2021-07-22 05:21:23","endLine":232,"groupId":"10280","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"transientLocalStreamPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/58/e4cc93e4e3d177ef8a69866bac8de6a4966f02.src","preCode":"    public void transientLocalStreamPlan()\n    {\n        UUID sessionID = registerSession(cfs, true, true);\n        ActiveRepairService.ParentRepairSession prs = ActiveRepairService.instance.getParentRepairSession(sessionID);\n        RepairJobDesc desc = new RepairJobDesc(sessionID, UUIDGen.getTimeUUID(), KEYSPACE1, CF_STANDARD, prs.getRanges());\n\n        TreeResponse r1 = new TreeResponse(local, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n        TreeResponse r2 = new TreeResponse(PARTICIPANT2, createInitialTree(desc, DatabaseDescriptor.getPartitioner()));\n\n        LocalSyncTask task = new LocalSyncTask(desc, r1.endpoint, r2.endpoint, MerkleTrees.difference(r1.trees, r2.trees),\n                                               desc.parentSessionId, false, true, PreviewKind.NONE);\n        StreamPlan plan = task.createStreamPlan();\n        assertNumInOut(plan, 0, 1);\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"}],"commitId":"f49c29ee8c7374a05e32be01cb0046236d5309e6","commitMessage":"@@@Reduce the log level on \"expected\" repair exceptions\n\npatch by Caleb Rackliffe and Marcus Eriksson; reviewed by Josh McKenzie for CASSANDRA-16775\n","date":"2021-07-22 05:21:23","modifiedFileCount":"30","status":"M","submitter":"Marcus Eriksson"}]
