[{"authorTime":"2016-01-26 11:13:36","codes":[{"authorDate":"2016-01-26 11:13:36","commitOrder":2,"curCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.EQ, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-06 03:56:23","endLine":1147,"groupId":"10382","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnicodeSupport","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b3/2bfc55205929c7bc45439ad848da8e9fd21b83.src","preCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.EQ, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1081,"status":"MB"},{"authorDate":"2016-01-26 11:13:36","commitOrder":2,"curCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.EQ, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-06 03:56:23","endLine":1216,"groupId":"23041","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnicodeSuffixModeNoSplits","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b3/2bfc55205929c7bc45439ad848da8e9fd21b83.src","preCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.EQ, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1157,"status":"B"}],"commitId":"392866546e6377aafd018c3fcb2e124674a318dc","commitMessage":"@@@add LIKE support to CQL3\npatch by xedin; reviewed by beobal for CASSANDRA-11067\n","date":"2016-02-06 03:56:23","modifiedFileCount":"28","status":"M","submitter":"Pavel Yaskevich"},{"authorTime":"2016-02-08 09:15:21","codes":[{"authorDate":"2016-02-08 09:15:21","commitOrder":3,"curCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-12 03:24:40","endLine":1147,"groupId":"10382","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnicodeSupport","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/a8/8e5940f8dc20287822e7c5aeb174cbab1c67af.src","preCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.EQ, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1081,"status":"M"},{"authorDate":"2016-02-08 09:15:21","commitOrder":3,"curCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2016-02-12 03:24:40","endLine":1216,"groupId":"23041","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnicodeSuffixModeNoSplits","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/a8/8e5940f8dc20287822e7c5aeb174cbab1c67af.src","preCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.EQ, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1157,"status":"M"}],"commitId":"479e8aff1346d41ebc05e1a113996a803228284d","commitMessage":"@@@fix EQ semantics of analyzed SASI indexes\n\npatch by xedin; reviewed by beobal for CASSANDRA-11130\n","date":"2016-02-12 03:24:40","modifiedFileCount":"13","status":"M","submitter":"Pavel Yaskevich"},{"authorTime":"2017-09-13 21:57:50","codes":[{"authorDate":"2017-09-13 21:57:50","commitOrder":4,"curCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2018-01-09 15:10:23","endLine":1190,"groupId":"10382","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnicodeSupport","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/07/1f84d05f620db46530bd7aab58b09331bd9d26.src","preCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1124,"status":"M"},{"authorDate":"2017-09-13 21:57:50","commitOrder":4,"curCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","date":"2018-01-09 15:10:23","endLine":1259,"groupId":"23041","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnicodeSuffixModeNoSplits","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/07/1f84d05f620db46530bd7aab58b09331bd9d26.src","preCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation rm = new Mutation(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        rm = new Mutation(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1200,"status":"M"}],"commitId":"de7c24b395265ff619c622ed6be8d88453f158ac","commitMessage":"@@@Make PartitionUpdate and Mutation immutable\n\nPatch by marcuse; reviewed by Aleksey Yeschenko for CASSANDRA-13867\n","date":"2018-01-09 15:10:23","modifiedFileCount":"33","status":"M","submitter":"Marcus Eriksson"},{"authorTime":"2021-03-08 18:31:12","codes":[{"authorDate":"2021-03-08 18:31:12","commitOrder":5,"curCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), 1000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), 2000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), 3000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), 4000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), 5000);\n        rm.build().apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key2\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key2\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        assertRows(rows, \"key2\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        assertRows(rows, \"key2\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        assertRows(rows, \"key5\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        assertRows(rows, \"key4\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        assertRows(rows, \"key3\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        assertRows(rows, \"key5\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key4\", \"key5\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        assertRows(rows, \"key4\");\n    }\n","date":"2021-03-08 18:31:59","endLine":1256,"groupId":"101071","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnicodeSupport","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/33/96e3d86732343cf4348530977ce2e41af0605a.src","preCode":"    private void testUnicodeSupport(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"��������������������������������������������������������������������������������������������������������������������� and normal ones\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key5\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"normal\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\", \"key5\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"���������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1190,"status":"M"},{"authorDate":"2021-03-08 18:31:12","commitOrder":5,"curCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), 1000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), 2000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), 3000);\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), 4000);\n        rm.build().apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        assertRows(rows, \"key1\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        assertRows(rows, \"key4\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        assertRows(rows, \"key3\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        assertRows(rows, \"key2\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        assertRows(rows, \"key4\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key2\", \"key3\", \"key4\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        assertRows(rows, \"key3\");\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        assertRows(rows, \"key4\");\n    }\n","date":"2021-03-08 18:31:59","endLine":1325,"groupId":"101071","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnicodeSuffixModeNoSplits","params":"(booleanforceFlush)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/33/96e3d86732343cf4348530977ce2e41af0605a.src","preCode":"    private void testUnicodeSuffixModeNoSplits(boolean forceFlush)\n    {\n        ColumnFamilyStore store = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);\n\n        final ByteBuffer comment = UTF8Type.instance.decompose(\"comment_suffix_split\");\n\n        Mutation.PartitionUpdateCollector rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key1\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key2\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key3\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"���������������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        rm = new Mutation.PartitionUpdateCollector(KS_NAME, decoratedKey(\"key4\"));\n        update(rm, comment, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\"), System.currentTimeMillis());\n        rm.build().apply();\n\n        if (forceFlush)\n            store.forceBlockingFlush();\n\n        Set<String> rows;\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key1\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key2\", \"key3\", \"key4\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_SUFFIX, UTF8Type.instance.decompose(\"���������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key3\" }, rows.toArray(new String[rows.size()])));\n\n        rows = getIndexed(store, 10, buildExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose(\"������������������������������������������������������ ������������������������������������\")));\n        Assert.assertTrue(rows.toString(), Arrays.equals(new String[] { \"key4\" }, rows.toArray(new String[rows.size()])));\n    }\n","realPath":"test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":1266,"status":"M"}],"commitId":"2aa22ba99dcc1dacb07b7af31b2664e7db839063","commitMessage":"@@@Merge branch cassandra-3.11 into trunk\n","date":"2021-03-08 18:31:59","modifiedFileCount":"1","status":"M","submitter":"Benjamin Lerer"}]
