[{"authorTime":"2016-09-01 06:48:43","codes":[{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","date":"2017-02-07 11:11:18","endLine":71,"groupId":"5262","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"needsCleanupFinalized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1c/2f02e24d5e4b3d5fb9b01aa5ea8525bc0ea11a.src","preCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"B"},{"authorDate":"2016-09-01 06:48:43","commitOrder":1,"curCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertEquals(1, prm.getMaximalTasks(FBUtilities.nowInSeconds(), false).size());\n    }\n","date":"2017-02-07 11:11:18","endLine":183,"groupId":"5262","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"maximalTaskNeedsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1c/2f02e24d5e4b3d5fb9b01aa5ea8525bc0ea11a.src","preCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertEquals(1, prm.getMaximalTasks(FBUtilities.nowInSeconds(), false).size());\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"B"}],"commitId":"98d74ed998706e9e047dc0f7886a1e9b18df3ce9","commitMessage":"@@@Fix consistency of incrementally repaired data\n\npatch by Blake Eggleston.  reviewed by Marcus Eriksson for CASSANDRA-9143\n","date":"2017-02-07 11:11:18","modifiedFileCount":"81","status":"B","submitter":"Blake Eggleston"},{"authorTime":"2017-02-16 02:47:24","codes":[{"authorDate":"2017-02-16 02:47:24","commitOrder":2,"curCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","date":"2017-02-18 05:57:17","endLine":71,"groupId":"5262","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"needsCleanupFinalized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1b/4321701b7daab4d5a691c3b836cfa5a12cfcc5.src","preCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2017-02-16 02:47:24","commitOrder":2,"curCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertEquals(1, prm.getMaximalTasks(FBUtilities.nowInSeconds(), false).size());\n    }\n","date":"2017-02-18 05:57:17","endLine":183,"groupId":"5262","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"maximalTaskNeedsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1b/4321701b7daab4d5a691c3b836cfa5a12cfcc5.src","preCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertEquals(1, prm.getMaximalTasks(FBUtilities.nowInSeconds(), false).size());\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"c878b6968be88fa89fb1d1d0212411bcbc4fae7c","commitMessage":"@@@StreamPlan for incremental repairs flushing memtables unnecessarily\nPatch by Blake Eggleston; Reviewed by Marcus Eriksson for CASSANDRA-13226\n","date":"2017-02-18 05:57:17","modifiedFileCount":"8","status":"M","submitter":"Blake Eggleston"},{"authorTime":"2017-04-04 23:09:16","codes":[{"authorDate":"2017-02-16 02:47:24","commitOrder":3,"curCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","date":"2017-02-18 05:57:17","endLine":71,"groupId":"5262","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"needsCleanupFinalized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/1b/4321701b7daab4d5a691c3b836cfa5a12cfcc5.src","preCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"N"},{"authorDate":"2017-04-04 23:09:16","commitOrder":3,"curCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Collection<AbstractCompactionTask> tasks = prm.getMaximalTasks(FBUtilities.nowInSeconds(), false);\n        try\n        {\n            Assert.assertEquals(1, tasks.size());\n        }\n        finally\n        {\n            tasks.stream().forEach(t -> t.transaction.abort());\n        }\n    }\n","date":"2017-04-06 21:16:54","endLine":199,"groupId":"5262","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"maximalTaskNeedsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/a1/73b4b945041eeff6045a736436c2a266ce5045.src","preCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertEquals(1, prm.getMaximalTasks(FBUtilities.nowInSeconds(), false).size());\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"}],"commitId":"30820eacb9c565d06260031260910f020e16e83d","commitMessage":"@@@Disable compaction during PendingRepairTests\n\nPatch by Paulo Motta; Reviewed by Blake Eggleston for CASSANDRA-13224\n","date":"2017-04-06 21:16:54","modifiedFileCount":"3","status":"M","submitter":"Paulo Motta"},{"authorTime":"2018-07-06 06:10:40","codes":[{"authorDate":"2018-07-06 06:10:40","commitOrder":4,"curCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID, false);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","date":"2018-09-01 09:34:22","endLine":72,"groupId":"10835","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"needsCleanupFinalized","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d8/3e0633ea6f49ad1349c54f95b17699fd0fe49e.src","preCode":"    public void needsCleanupFinalized()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Assert.assertTrue(prm.canCleanup(repairID));\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"M"},{"authorDate":"2018-07-06 06:10:40","commitOrder":4,"curCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID, false);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Collection<AbstractCompactionTask> tasks = prm.getMaximalTasks(FBUtilities.nowInSeconds(), false);\n        try\n        {\n            Assert.assertEquals(1, tasks.size());\n        }\n        finally\n        {\n            tasks.stream().forEach(t -> t.transaction.abort());\n        }\n    }\n","date":"2018-09-01 09:34:22","endLine":220,"groupId":"10835","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"maximalTaskNeedsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d8/3e0633ea6f49ad1349c54f95b17699fd0fe49e.src","preCode":"    public void maximalTaskNeedsCleanup()\n    {\n        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);\n\n        UUID repairID = registerSession(cfs, true, true);\n        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);\n        SSTableReader sstable = makeSSTable(true);\n        mutateRepaired(sstable, repairID);\n        prm.addSSTable(sstable);\n        Assert.assertNotNull(prm.get(repairID));\n        Assert.assertNotNull(prm.get(repairID));\n        LocalSessionAccessor.finalizeUnsafe(repairID);\n\n        Collection<AbstractCompactionTask> tasks = prm.getMaximalTasks(FBUtilities.nowInSeconds(), false);\n        try\n        {\n            Assert.assertEquals(1, tasks.size());\n        }\n        finally\n        {\n            tasks.stream().forEach(t -> t.transaction.abort());\n        }\n    }\n","realPath":"test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"}],"commitId":"f7431b432875e334170ccdb19934d05545d2cebd","commitMessage":"@@@Transient Replication and Cheap Quorums\n\nPatch by Blake Eggleston.  Benedict Elliott Smith.  Marcus Eriksson.  Alex Petrov.  Ariel Weisberg; Reviewed by Blake Eggleston.  Marcus Eriksson.  Benedict Elliott Smith.  Alex Petrov.  Ariel Weisberg for CASSANDRA-14404\n\nCo-authored-by: Blake Eggleston <bdeggleston@gmail.com>\nCo-authored-by: Benedict Elliott Smith <benedict@apache.org>\nCo-authored-by: Marcus Eriksson <marcuse@apache.org>\nCo-authored-by: Alex Petrov <oleksandr.petrov@gmail.com>\n","date":"2018-09-01 09:34:22","modifiedFileCount":"230","status":"M","submitter":"Ariel Weisberg"}]
