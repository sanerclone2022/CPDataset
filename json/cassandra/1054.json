[{"authorTime":"2015-05-06 02:38:23","codes":[{"authorDate":"2014-12-15 23:51:30","commitOrder":6,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2014-12-15 23:51:30","endLine":127,"groupId":"9323","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/7a/a7257825baed54333f7be72e171e0c819bcb8d.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"NB"},{"authorDate":"2015-05-06 02:38:23","commitOrder":6,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","date":"2015-05-06 04:57:39","endLine":273,"groupId":"30452","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/e5e3d9ce269079e2b3390bdadea9cd0aacffae.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"B"}],"commitId":"f698cc228452e847e3ad46bd8178549cf8171767","commitMessage":"@@@Remove Thrift dependencies in bundled tools\n\npatch by Philip Thompson; reviewed by Aleksey Yeschenko for\nCASSANDRA-8358\n","date":"2015-05-06 04:57:39","modifiedFileCount":"22","status":"M","submitter":"Philip Thompson"},{"authorTime":"2015-05-06 02:38:23","codes":[{"authorDate":"2015-06-26 02:35:10","commitOrder":7,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n        PoolingOptions poolingOpts = new PoolingOptions();\n        poolingOpts.setCoreConnectionsPerHost(HostDistance.LOCAL, 8);\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withProtocolVersion(ProtocolVersion.V2)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2015-06-26 02:35:10","endLine":131,"groupId":"9323","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d8/2ebfd49960e426e73c1e1895c6fb0f7346ca72.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"M"},{"authorDate":"2015-05-06 02:38:23","commitOrder":7,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","date":"2015-05-06 04:57:39","endLine":273,"groupId":"30452","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/e5e3d9ce269079e2b3390bdadea9cd0aacffae.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"N"}],"commitId":"9a712387062164405fc5a96facd239a0bb537b7d","commitMessage":"@@@Merge branch 'cassandra-2.2' into trunk\n","date":"2015-06-26 02:35:10","modifiedFileCount":"1","status":"M","submitter":"T Jake Luciani"},{"authorTime":"2015-05-06 02:38:23","codes":[{"authorDate":"2015-08-28 04:03:08","commitOrder":8,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, 8, 8)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, 128)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2015-08-28 04:03:08","endLine":135,"groupId":"9323","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/00/4000394111d1508ba6b6be059dd1b690b8a609.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n        PoolingOptions poolingOpts = new PoolingOptions();\n        poolingOpts.setCoreConnectionsPerHost(HostDistance.LOCAL, 8);\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withProtocolVersion(ProtocolVersion.V2)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"M"},{"authorDate":"2015-05-06 02:38:23","commitOrder":8,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","date":"2015-05-06 04:57:39","endLine":273,"groupId":"30452","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/e5e3d9ce269079e2b3390bdadea9cd0aacffae.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"N"}],"commitId":"f744b6c05537b84b60f53917fafb32bc1d8b1b03","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2015-08-28 04:03:08","modifiedFileCount":"1","status":"M","submitter":"T Jake Luciani"},{"authorTime":"2015-05-06 02:38:23","codes":[{"authorDate":"2015-11-25 22:04:55","commitOrder":9,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2015-11-25 22:04:55","endLine":153,"groupId":"21377","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/d0/779edf44aa41f30e10c312e7a9e2085273c3b4.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, 8, 8)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, 128)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\"Connected to cluster: %s%n\",\n                metadata.getClusterName());\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2015-05-06 02:38:23","commitOrder":9,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","date":"2015-05-06 04:57:39","endLine":273,"groupId":"30452","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/e5e3d9ce269079e2b3390bdadea9cd0aacffae.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"N"}],"commitId":"d58a50b8ccb897f68e874dd00550146eeb98d2c5","commitMessage":"@@@Merge branch 'cassandra-3.1' into trunk\n","date":"2015-11-25 22:04:55","modifiedFileCount":"2","status":"M","submitter":"T Jake Luciani"},{"authorTime":"2015-05-06 02:38:23","codes":[{"authorDate":"2015-12-16 22:20:53","commitOrder":10,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2015-12-16 22:21:07","endLine":154,"groupId":"21377","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/7d/5f38c09a17fca82554cffeff669d3d30fe8ab8.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2015-05-06 02:38:23","commitOrder":10,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","date":"2015-05-06 04:57:39","endLine":273,"groupId":"30452","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/51/e5e3d9ce269079e2b3390bdadea9cd0aacffae.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"N"}],"commitId":"abf7df3bd609f999fdcc2dcfb91688be50c46664","commitMessage":"@@@Merge branch cassandra-3.0 into trunk\n","date":"2015-12-16 22:21:07","modifiedFileCount":"3","status":"M","submitter":"Benjamin Lerer"},{"authorTime":"2016-02-05 02:32:41","codes":[{"authorDate":"2016-02-05 02:32:41","commitOrder":11,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2016-02-05 02:33:21","endLine":156,"groupId":"17392","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/bb/f10083568ab2349837b8c68d69f051be1404c7.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = new SSLOptions(sslContext, encryptionOptions.cipher_suites);\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2016-02-05 02:32:41","commitOrder":11,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2016-02-05 02:33:21","endLine":280,"groupId":"30452","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/2d/c915d7c77ea24a246a3792f421d65ce870431d.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return new SSLOptions(sslContext, clientEncryptionOptions.cipher_suites);\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"M"}],"commitId":"b51f9495e5f1dc9573aa08139009569a1916f82f","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2016-02-05 02:33:21","modifiedFileCount":"6","status":"M","submitter":"Robert Stupp"},{"authorTime":"2015-11-03 03:50:35","codes":[{"authorDate":"2016-02-05 02:32:41","commitOrder":12,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2016-02-05 02:33:21","endLine":156,"groupId":"17392","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/bb/f10083568ab2349837b8c68d69f051be1404c7.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2015-11-03 03:50:35","commitOrder":12,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2016-02-25 01:35:39","endLine":268,"groupId":"30452","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f1/9924e2335c0db1fb0ee6abc17ea607208efb67.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n            return null;\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"}],"commitId":"6d15a6da7da8fc41f97d4346d65f6bf9d0e1637f","commitMessage":"@@@Extract LoaderOptions to be able to be used from outside\n\npatch by Eric Fenderbosch; reviewed by yukim for CASSANDRA-10637\n","date":"2016-02-25 01:35:39","modifiedFileCount":"1","status":"M","submitter":"Eric Fenderbosch"},{"authorTime":"2015-11-03 03:50:35","codes":[{"authorDate":"2016-04-18 22:01:29","commitOrder":13,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2016-04-18 22:01:29","endLine":158,"groupId":"17392","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/4f/173b46288ae65f048025f21f3fdad263cd7fa3.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"M"},{"authorDate":"2015-11-03 03:50:35","commitOrder":13,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2016-02-25 01:35:39","endLine":268,"groupId":"30452","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f1/9924e2335c0db1fb0ee6abc17ea607208efb67.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"N"}],"commitId":"fb13df431b283a386706961540bdbccc2b375beb","commitMessage":"@@@Merge branch 'cassandra-3.0' into trunk\n","date":"2016-04-18 22:01:29","modifiedFileCount":"2","status":"M","submitter":"T Jake Luciani"},{"authorTime":"2015-11-03 03:50:35","codes":[{"authorDate":"2016-04-18 04:15:52","commitOrder":14,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2016-04-19 00:15:15","endLine":167,"groupId":"3556","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/53/d878693b22fcb9a1ff1f0636199f211f580672.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (whitelist != null)\n            clusterBuilder.withLoadBalancingPolicy(whitelist);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2015-11-03 03:50:35","commitOrder":14,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2016-02-25 01:35:39","endLine":268,"groupId":"30452","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f1/9924e2335c0db1fb0ee6abc17ea607208efb67.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"N"}],"commitId":"ba926ff6d8c09834d5c45f4eae8d75d9051b1058","commitMessage":"@@@(stress) Add datacenter option to -node options\n\npatch by Christopher Batey; reviewed by Aleksey Yeschenko for\nCASSANDRA-11591\n","date":"2016-04-19 00:15:15","modifiedFileCount":"2","status":"M","submitter":"Christopher Batey"},{"authorTime":"2015-11-03 03:50:35","codes":[{"authorDate":"2017-03-10 13:35:42","commitOrder":15,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2017-03-21 05:50:01","endLine":173,"groupId":"3556","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3a/7c51311c3ffdfb1cf9c96b7f78b9ac3284fd50.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datatacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2015-11-03 03:50:35","commitOrder":15,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2016-02-25 01:35:39","endLine":268,"groupId":"30452","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptions.ClientEncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f1/9924e2335c0db1fb0ee6abc17ea607208efb67.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"N"}],"commitId":"5b8b1ce26cd073a44ddf7c7a6750da409a343eba","commitMessage":"@@@Fix typo in stress JavaDriverClient.java\n\nCloses #97\n\nPatch by Ian Macalinao; Reviewed by Jeff Jirsa for CASSANDRA-13355\n","date":"2017-03-21 05:50:01","modifiedFileCount":"1","status":"M","submitter":"Ian Macalinao"},{"authorTime":"2017-02-15 21:41:30","codes":[{"authorDate":"2017-03-10 13:35:42","commitOrder":16,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2017-03-21 05:50:01","endLine":173,"groupId":"3556","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3a/7c51311c3ffdfb1cf9c96b7f78b9ac3284fd50.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"N"},{"authorDate":"2017-02-15 21:41:30","commitOrder":16,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2017-11-03 20:06:38","endLine":267,"groupId":"30452","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/08/12e53b5afebcff4dfd48c78d267c69cb8f1e7f.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions.ClientEncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"260846685b6129a324a7cb7396da135fee85ec04","commitMessage":"@@@Node to Node encryption transitional mode\n\npatch by jasobrown; reviewed by Stefan Podkowinski for CASSANDRA-10404\n","date":"2017-11-03 20:06:38","modifiedFileCount":"23","status":"M","submitter":"Jason Brown"},{"authorTime":"2017-02-15 21:41:30","codes":[{"authorDate":"2017-11-10 00:33:48","commitOrder":17,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (allowServerPortDiscovery)\n            clusterBuilder = clusterBuilder.allowServerPortDiscovery();\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2018-01-26 03:32:24","endLine":178,"groupId":"0","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/fb/cab4b95741f6d1bfc0ccbd6a0b80adb0448edb.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2017-02-15 21:41:30","commitOrder":17,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","date":"2017-11-03 20:06:38","endLine":267,"groupId":"30452","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/08/12e53b5afebcff4dfd48c78d267c69cb8f1e7f.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"N"}],"commitId":"59b5b6bef0fa76bf5740b688fcd4d9cf525760d0","commitMessage":"@@@Allow storage port to be configurable per node\n\nPatch by Ariel Weisberg; Reviewed by Jason Brown for CASSANDRA-7544\n","date":"2018-01-26 03:32:24","modifiedFileCount":"308","status":"M","submitter":"Ariel Weisberg"},{"authorTime":"2019-06-12 23:26:54","codes":[{"authorDate":"2019-06-12 23:26:54","commitOrder":18,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (allowServerPortDiscovery)\n            clusterBuilder = clusterBuilder.allowServerPortDiscovery();\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites.toArray(new String[0])).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2019-06-12 23:26:54","endLine":178,"groupId":"9136","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/36/361f7de2f718ecaa091abd4e372638275673c4.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (allowServerPortDiscovery)\n            clusterBuilder = clusterBuilder.allowServerPortDiscovery();\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2019-06-12 23:26:54","commitOrder":18,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites.toArray(new String[0]))\n                            .build();\n    }\n","date":"2019-06-12 23:26:54","endLine":270,"groupId":"30452","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/2c/a2a3d5b2736b12ba113070b165b34d2134d16b.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites)\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"M"}],"commitId":"310a48efcfdc0fb77fbd5fd6e734bf17667f617d","commitMessage":"@@@Rewrite the internode messaging subsystem\n\npatch by Aleksey Yeschenko and Benedict Elliott Smith; reviewed by Alex\nPetrov.  Aleksey Yeschenko.  and Benedict Elliott Smith for CASSANDRA-15066\n\nCo-authored-by: Aleksey Yeschenko <aleksey@apache.org>\nCo-authored-by: Benedict Elliott Smith <benedict@apache.org>\n","date":"2019-06-12 23:26:54","modifiedFileCount":"253","status":"M","submitter":"Benedict Elliott Smith"},{"authorTime":"2019-06-12 23:26:54","codes":[{"authorDate":"2018-04-11 06:01:48","commitOrder":19,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites.toArray(new String[0])).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2019-10-08 03:19:42","endLine":174,"groupId":"9136","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/72/487dc8e0a883391c2562284e019eaa3697db9f.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n        if (allowServerPortDiscovery)\n            clusterBuilder = clusterBuilder.allowServerPortDiscovery();\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites.toArray(new String[0])).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2019-06-12 23:26:54","commitOrder":19,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites.toArray(new String[0]))\n                            .build();\n    }\n","date":"2019-06-12 23:26:54","endLine":270,"groupId":"30452","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/2c/a2a3d5b2736b12ba113070b165b34d2134d16b.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites.toArray(new String[0]))\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"N"}],"commitId":"38b49904dd1c71fcb16abfbc205edfd6ce008b76","commitMessage":"@@@Upgrading Guava to 27.  and to java-driver 3.6.0 (from 3.4.0-SNAPSHOT).  plus refactoring to remove nativePort argument for NativeSSTableLoaderClient constructor\n\nPatch by Sumanth Pasupuleti; reviewed by Michael Semb Wever for CASSANDRA-14655\n","date":"2019-10-08 03:19:42","modifiedFileCount":"23","status":"M","submitter":"Sumanth Pasupuleti"},{"authorTime":"2019-08-17 09:15:55","codes":[{"authorDate":"2019-08-17 09:15:55","commitOrder":20,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites.toArray(new String[0])).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2020-06-21 09:59:41","endLine":174,"groupId":"9136","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/64/3e58f91160d7f50e2ac1f6d08bd76806cb7839.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.enabled)\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites.toArray(new String[0])).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2019-08-17 09:15:55","commitOrder":20,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites.toArray(new String[0]))\n                            .build();\n    }\n","date":"2020-06-21 09:59:41","endLine":268,"groupId":"30452","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/c0/8881bb4450d107d93e042f3231ec60399c49de.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.enabled)\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites.toArray(new String[0]))\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"}],"commitId":"674b6cc1a5e905a9c234c649adaad2de79cfa560","commitMessage":"@@@Update defaults for server and client TLS settings\n\nThis fixes backwards compatibility with the 3.11 server_encryption_options\nwhile exposing the correct defaults after the 4.0 Netty refactor.\n\nPatch by Joseph Lynch; Reviewed by Ekaterina Dimitrova for CASSANDRA-15262\n","date":"2020-06-21 09:59:41","modifiedFileCount":"15","status":"M","submitter":"Joseph Lynch"},{"authorTime":"2020-12-03 07:33:36","codes":[{"authorDate":"2020-12-03 07:33:36","commitOrder":21,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipherSuitesArray()).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2020-12-03 08:44:54","endLine":174,"groupId":"9136","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b9/3476901f061f598413464959e5884c3febf49c.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipher_suites.toArray(new String[0])).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2020-12-03 07:33:36","commitOrder":21,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipherSuitesArray())\n                            .build();\n    }\n","date":"2020-12-03 08:44:54","endLine":268,"groupId":"30452","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/5f/d388546568851c75a21b2fff5c996a43742a90.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipher_suites.toArray(new String[0]))\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"}],"commitId":"919a8964a83511d96766c3e53ba603e77bca626c","commitMessage":"@@@Bring back the accepted encryption protocols list as configurable option\n\npatch by Jon Meredith; reviewed by Berenguer Blasi.  David Capwell.  Dinesh Joshi for CASSANDRA-13325\n","date":"2020-12-03 08:44:54","modifiedFileCount":"12","status":"M","submitter":"Jon Meredith"},{"authorTime":"2021-01-08 05:10:53","codes":[{"authorDate":"2021-01-08 05:10:53","commitOrder":22,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n\n            \r\n            \r\n            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)\n            {\n                protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)\n                {\n                    SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);\n\n                    String[] acceptedProtocols = encryptionOptions.acceptedProtocolsArray();\n                    if (acceptedProtocols != null && acceptedProtocols.length > 0)\n                        engine.setEnabledProtocols(acceptedProtocols);\n\n                    return engine;\n                }\n            };\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2021-01-08 06:42:10","endLine":190,"groupId":"9136","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/49/cb0a86399adc856d5d6c6eb52cd7ee378ecbe5.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n            SSLOptions sslOptions = JdkSSLOptions.builder()\n                                                 .withSSLContext(sslContext)\n                                                 .withCipherSuites(encryptionOptions.cipherSuitesArray()).build();\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"M"},{"authorDate":"2021-01-08 05:10:53","commitOrder":22,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        \r\n        \r\n        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)\n        {\n            protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)\n            {\n                SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);\n\n                String[] acceptedProtocols = clientEncryptionOptions.acceptedProtocolsArray();\n                if (acceptedProtocols != null && acceptedProtocols.length > 0)\n                    engine.setEnabledProtocols(acceptedProtocols);\n\n                return engine;\n            }\n        };\n        return sslOptions;\n    }\n","date":"2021-01-08 06:42:10","endLine":282,"groupId":"9136","id":34,"instanceNumber":2,"isCurCommit":1,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/c1/de1ffa8aaeff92d701e44cddbde6dd20bf4523.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        return JdkSSLOptions.builder()\n                            .withSSLContext(sslContext)\n                            .withCipherSuites(clientEncryptionOptions.cipherSuitesArray())\n                            .build();\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"M"}],"commitId":"7637acc3d762047f2a478855eb4d239b4f314cd8","commitMessage":"@@@SSLFactory should initialize SSLContext before setting protocols\n\npatch by Jon Meredith; reviewed by David Capwell.  Dinesh Joshi for CASSANDRA-16362\n","date":"2021-01-08 06:42:10","modifiedFileCount":"6","status":"M","submitter":"Jon Meredith"},{"authorTime":"2021-01-08 05:10:53","codes":[{"authorDate":"2021-03-20 01:16:04","commitOrder":23,"curCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        HostAndPort hap = HostAndPort.fromString(host).withDefaultPort(port);\n        InetSocketAddress contact = new InetSocketAddress(InetAddress.getByName(hap.getHost()), hap.getPort());\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPointsWithPorts(contact)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n\n            \r\n            \r\n            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)\n            {\n                protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)\n                {\n                    SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);\n\n                    String[] acceptedProtocols = encryptionOptions.acceptedProtocolsArray();\n                    if (acceptedProtocols != null && acceptedProtocols.length > 0)\n                        engine.setEnabledProtocols(acceptedProtocols);\n\n                    return engine;\n                }\n            };\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","date":"2021-03-20 04:24:56","endLine":194,"groupId":"1054","id":35,"instanceNumber":1,"isCurCommit":1,"methodName":"connect","params":"(ProtocolOptions.Compressioncompression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/e0/b734ed2e3fc21ca1f1e84adb074448722f2e13.src","preCode":"    public void connect(ProtocolOptions.Compression compression) throws Exception\n    {\n\n        PoolingOptions poolingOpts = new PoolingOptions()\n                                     .setConnectionsPerHost(HostDistance.LOCAL, connectionsPerHost, connectionsPerHost)\n                                     .setMaxRequestsPerConnection(HostDistance.LOCAL, maxPendingPerConnection)\n                                     .setNewConnectionThreshold(HostDistance.LOCAL, 100);\n\n        Cluster.Builder clusterBuilder = Cluster.builder()\n                                                .addContactPoint(host)\n                                                .withPort(port)\n                                                .withPoolingOptions(poolingOpts)\n                                                .withoutJMXReporting()\n                                                .withProtocolVersion(protocolVersion)\n                                                .withoutMetrics(); \r\n\n        if (loadBalancingPolicy != null)\n            clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);\n        clusterBuilder.withCompression(compression);\n        if (encryptionOptions.isEnabled())\n        {\n            SSLContext sslContext;\n            sslContext = SSLFactory.createSSLContext(encryptionOptions, true);\n\n            \r\n            \r\n            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)\n            {\n                protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)\n                {\n                    SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);\n\n                    String[] acceptedProtocols = encryptionOptions.acceptedProtocolsArray();\n                    if (acceptedProtocols != null && acceptedProtocols.length > 0)\n                        engine.setEnabledProtocols(acceptedProtocols);\n\n                    return engine;\n                }\n            };\n            clusterBuilder.withSSL(sslOptions);\n        }\n\n        if (authProvider != null)\n        {\n            clusterBuilder.withAuthProvider(authProvider);\n        }\n        else if (username != null)\n        {\n            clusterBuilder.withCredentials(username, password);\n        }\n\n        cluster = clusterBuilder.build();\n        Metadata metadata = cluster.getMetadata();\n        System.out.printf(\n                \"Connected to cluster: %s, max pending requests per connection %d, max connections per host %d%n\",\n                metadata.getClusterName(),\n                maxPendingPerConnection,\n                connectionsPerHost);\n        for (Host host : metadata.getAllHosts())\n        {\n            System.out.printf(\"Datacenter: %s; Host: %s; Rack: %s%n\",\n                    host.getDatacenter(), host.getAddress() + \":\" + host.getSocketAddress().getPort(), host.getRack());\n        }\n\n        session = cluster.connect();\n    }\n","realPath":"tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"M"},{"authorDate":"2021-01-08 05:10:53","commitOrder":23,"curCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        \r\n        \r\n        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)\n        {\n            protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)\n            {\n                SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);\n\n                String[] acceptedProtocols = clientEncryptionOptions.acceptedProtocolsArray();\n                if (acceptedProtocols != null && acceptedProtocols.length > 0)\n                    engine.setEnabledProtocols(acceptedProtocols);\n\n                return engine;\n            }\n        };\n        return sslOptions;\n    }\n","date":"2021-01-08 06:42:10","endLine":282,"groupId":"1054","id":36,"instanceNumber":2,"isCurCommit":1,"methodName":"buildSSLOptions","params":"(EncryptionOptionsclientEncryptionOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/c1/de1ffa8aaeff92d701e44cddbde6dd20bf4523.src","preCode":"    private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)\n    {\n\n        if (!clientEncryptionOptions.isEnabled())\n        {\n            return null;\n        }\n\n        SSLContext sslContext;\n        try\n        {\n            sslContext = SSLFactory.createSSLContext(clientEncryptionOptions, true);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Could not create SSL Context.\", e);\n        }\n\n        \r\n        \r\n        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)\n        {\n            protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)\n            {\n                SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);\n\n                String[] acceptedProtocols = clientEncryptionOptions.acceptedProtocolsArray();\n                if (acceptedProtocols != null && acceptedProtocols.length > 0)\n                    engine.setEnabledProtocols(acceptedProtocols);\n\n                return engine;\n            }\n        };\n        return sslOptions;\n    }\n","realPath":"src/java/org/apache/cassandra/tools/BulkLoader.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"N"}],"commitId":"932b0a483eb9f7cfd23b29cb90b328e1825a02bc","commitMessage":"@@@make cassandra-stress -node work with host:port\n\nPatch by Adam Holmberg; reviewed by brandonwilliams for CASSANDRA-16529\n","date":"2021-03-20 04:24:56","modifiedFileCount":"2","status":"M","submitter":"Adam Holmberg"}]
