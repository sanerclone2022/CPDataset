[{"authorTime":"2019-02-15 17:03:47","codes":[{"authorDate":"2019-02-15 17:03:47","commitOrder":1,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2019-02-23 02:55:08","endLine":147,"groupId":"29878","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b5/32abdcd5737781f7a6a3b0ccf289b8f2a495bc.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"B"},{"authorDate":"2019-02-15 17:03:47","commitOrder":1,"curCode":"    private void testMockedMessagingPrepareFailure() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2019-02-23 02:55:08","endLine":221,"groupId":"29876","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b5/32abdcd5737781f7a6a3b0ccf289b8f2a495bc.src","preCode":"    private void testMockedMessagingPrepareFailure() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"B"}],"commitId":"9bde713ee8883f70d130efb6290ec0e6daea524f","commitMessage":"@@@Fix IR prepare anti-compaction race\n\nPatch by Stefan Podkowinski; Reviewed by Blake Eggleston for CASSANDRA-15027\n","date":"2019-02-23 02:55:08","modifiedFileCount":"14","status":"B","submitter":"Stefan Podkowinski"},{"authorTime":"2020-03-31 21:53:51","codes":[{"authorDate":"2020-03-31 21:53:51","commitOrder":2,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":147,"groupId":"8704","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet());\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"},{"authorDate":"2020-03-31 21:53:51","commitOrder":2,"curCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":227,"groupId":"29876","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareFailure","params":"(CountDownLatchprepareLatch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    private void testMockedMessagingPrepareFailure() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"b4e640a96e76f8d4a45937b1312b64ddc1aeb8ac","commitMessage":"@@@Fix flaky CoordinatorMessagingTest and docstring in OutboundSink and ConsistentSession\n\npatch by Aleksandr Sorokoumov; reviewed by Stefania Alborghetti for CASSANDRA-15672\n","date":"2020-04-06 20:28:53","modifiedFileCount":"3","status":"M","submitter":"Aleksandr Sorokoumov"},{"authorTime":"2020-02-25 21:10:22","codes":[{"authorDate":"2020-03-31 21:53:51","commitOrder":3,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-06 20:28:53","endLine":147,"groupId":"8704","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/6f/0d8467e63b70d6f2d905cbc89667a82ebd1701.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"N"},{"authorDate":"2020-02-25 21:10:22","commitOrder":3,"curCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2020-04-14 21:57:50","endLine":226,"groupId":"8706","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMockedMessagingPrepareFailure","params":"(CountDownLatchprepareLatch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/42/0cd546a3fcbf4db4f757a3ac56e0b841854c6c.src","preCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        Assert.assertFalse(proposeFailed.get());\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"78c785367f2836960ae26e5e5ef258162ef30ec3","commitMessage":"@@@Improve logging around incremental repairs\n\nPatch by marcuse; reviewed by Sam Tunnicliffe for CASSANDRA-15599\n","date":"2020-04-14 21:57:50","modifiedFileCount":"8","status":"M","submitter":"Marcus Eriksson"},{"authorTime":"2021-03-17 22:28:05","codes":[{"authorDate":"2021-03-17 22:28:05","commitOrder":4,"curCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException, NoSuchRepairSessionException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2021-07-22 05:21:23","endLine":148,"groupId":"10315","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testMockedMessagingHappyPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3c/288b0ef5a547b9bff3065e3757620a36dfe4c9.src","preCode":"    public void testMockedMessagingHappyPath() throws InterruptedException, ExecutionException, TimeoutException\n    {\n        CountDownLatch prepareLatch = createLatch();\n        CountDownLatch finalizeLatch = createLatch();\n\n        MockMessagingSpy spyPrepare = createPrepareSpy(Collections.emptySet(), Collections.emptySet(), prepareLatch);\n        MockMessagingSpy spyFinalize = createFinalizeSpy(Collections.emptySet(), Collections.emptySet(), finalizeLatch);\n        MockMessagingSpy spyCommit = createCommitSpy();\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean hasFailures = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, hasFailures);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n        \r\n        prepareLatch.countDown();\n        spyPrepare.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(sessionResult.isDone());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        repairFuture.set(Lists.newArrayList(createResult(coordinator), createResult(coordinator), createResult(coordinator)));\n\n        \r\n        finalizeLatch.countDown();\n        spyFinalize.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n\n        \r\n        spyCommit.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertTrue(sessionResult.get());\n        Assert.assertFalse(hasFailures.get());\n\n        \r\n        spyPrepare.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyFinalize.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n        spyCommit.interceptNoMsg(100, TimeUnit.MILLISECONDS);\n\n        Assert.assertEquals(ConsistentSession.State.FINALIZED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"},{"authorDate":"2021-03-17 22:28:05","commitOrder":4,"curCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException, NoSuchRepairSessionException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","date":"2021-07-22 05:21:23","endLine":227,"groupId":"10315","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testMockedMessagingPrepareFailure","params":"(CountDownLatchprepareLatch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/3c/288b0ef5a547b9bff3065e3757620a36dfe4c9.src","preCode":"    private void testMockedMessagingPrepareFailure(CountDownLatch prepareLatch) throws InterruptedException, ExecutionException, TimeoutException\n    {\n        \r\n        MockMessagingSpy sendFailSessionExpectedSpy = createFailSessionSpy(Lists.newArrayList(PARTICIPANT1, PARTICIPANT2, PARTICIPANT3));\n\n        UUID uuid = registerSession(cfs, true, true);\n        CoordinatorSession coordinator = ActiveRepairService.instance.consistent.coordinated.registerSession(uuid, PARTICIPANTS, false);\n        AtomicBoolean repairSubmitted = new AtomicBoolean(false);\n        SettableFuture<List<RepairSessionResult>> repairFuture = SettableFuture.create();\n        Supplier<ListenableFuture<List<RepairSessionResult>>> sessionSupplier = () ->\n        {\n            repairSubmitted.set(true);\n            return repairFuture;\n        };\n\n        \r\n        AtomicBoolean proposeFailed = new AtomicBoolean(false);\n        Assert.assertFalse(repairSubmitted.get());\n\n        \r\n        ListenableFuture<Boolean> sessionResult = coordinator.execute(sessionSupplier, proposeFailed);\n        prepareLatch.countDown();\n        \r\n        try\n        {\n            sessionResult.get(1, TimeUnit.SECONDS);\n            fail(\"Completed session without failure after prepare failed\");\n        }\n        catch (ExecutionException e)\n        {\n        }\n        sendFailSessionExpectedSpy.interceptMessageOut(3).get(1, TimeUnit.SECONDS);\n        Assert.assertFalse(repairSubmitted.get());\n        Assert.assertTrue(proposeFailed.get());\n        Assert.assertEquals(ConsistentSession.State.FAILED, coordinator.getState());\n        Assert.assertFalse(ActiveRepairService.instance.consistent.local.isSessionInProgress(uuid));\n    }\n","realPath":"test/unit/org/apache/cassandra/repair/consistent/CoordinatorMessagingTest.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"}],"commitId":"f49c29ee8c7374a05e32be01cb0046236d5309e6","commitMessage":"@@@Reduce the log level on \"expected\" repair exceptions\n\npatch by Caleb Rackliffe and Marcus Eriksson; reviewed by Josh McKenzie for CASSANDRA-16775\n","date":"2021-07-22 05:21:23","modifiedFileCount":"30","status":"M","submitter":"Marcus Eriksson"}]
