[{"authorTime":"2018-12-18 15:42:14","codes":[{"authorDate":"2018-10-03 16:12:54","commitOrder":3,"curCode":"    public static void dump(List<String> arguments, String rollCycle, boolean follow)\n    {\n        StringBuilder sb = new StringBuilder();\n        ReadMarshallable reader = wireIn ->\n        {\n            sb.setLength(0);\n\n            int version = wireIn.read(FullQueryLogger.VERSION).int16();\n            if (version != FullQueryLogger.CURRENT_VERSION)\n                throw new UnsupportedOperationException(\"Full query log of unexpected version \" + version + \" encountered\");\n\n            String type = wireIn.read(FullQueryLogger.TYPE).text();\n            sb.append(\"Type: \")\n              .append(type)\n              .append(System.lineSeparator());\n\n            long queryStartTime = wireIn.read(FullQueryLogger.QUERY_START_TIME).int64();\n            sb.append(\"Query start time: \")\n              .append(queryStartTime)\n              .append(System.lineSeparator());\n\n            int protocolVersion = wireIn.read(FullQueryLogger.PROTOCOL_VERSION).int32();\n            sb.append(\"Protocol version: \")\n              .append(protocolVersion)\n              .append(System.lineSeparator());\n\n            QueryOptions options =\n                QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read(FullQueryLogger.QUERY_OPTIONS).bytes()),\n                                          ProtocolVersion.decode(protocolVersion, true));\n\n            long generatedTimestamp = wireIn.read(FullQueryLogger.GENERATED_TIMESTAMP).int64();\n            sb.append(\"Generated timestamp:\")\n              .append(generatedTimestamp)\n              .append(System.lineSeparator());\n\n            int generatedNowInSeconds = wireIn.read(FullQueryLogger.GENERATED_NOW_IN_SECONDS).int32();\n            sb.append(\"Generated nowInSeconds:\")\n              .append(generatedNowInSeconds)\n              .append(System.lineSeparator());\n\n            switch (type)\n            {\n                case (FullQueryLogger.SINGLE_QUERY):\n                    dumpQuery(options, wireIn, sb);\n                    break;\n\n                case (FullQueryLogger.BATCH):\n                    dumpBatch(options, wireIn, sb);\n                    break;\n\n                default:\n                    throw new UnsupportedOperationException(\"Log entry of unsupported type \" + type);\n            }\n\n            System.out.print(sb.toString());\n            System.out.flush();\n        };\n\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());\n        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(reader))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","date":"2018-10-04 14:23:49","endLine":154,"groupId":"10431","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"dump","params":"(List<String>arguments@StringrollCycle@booleanfollow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/b3/e1f22747f3fe74ecf78d600b013c039076e3b6.src","preCode":"    public static void dump(List<String> arguments, String rollCycle, boolean follow)\n    {\n        StringBuilder sb = new StringBuilder();\n        ReadMarshallable reader = wireIn ->\n        {\n            sb.setLength(0);\n\n            int version = wireIn.read(FullQueryLogger.VERSION).int16();\n            if (version != FullQueryLogger.CURRENT_VERSION)\n                throw new UnsupportedOperationException(\"Full query log of unexpected version \" + version + \" encountered\");\n\n            String type = wireIn.read(FullQueryLogger.TYPE).text();\n            sb.append(\"Type: \")\n              .append(type)\n              .append(System.lineSeparator());\n\n            long queryStartTime = wireIn.read(FullQueryLogger.QUERY_START_TIME).int64();\n            sb.append(\"Query start time: \")\n              .append(queryStartTime)\n              .append(System.lineSeparator());\n\n            int protocolVersion = wireIn.read(FullQueryLogger.PROTOCOL_VERSION).int32();\n            sb.append(\"Protocol version: \")\n              .append(protocolVersion)\n              .append(System.lineSeparator());\n\n            QueryOptions options =\n                QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read(FullQueryLogger.QUERY_OPTIONS).bytes()),\n                                          ProtocolVersion.decode(protocolVersion, true));\n\n            long generatedTimestamp = wireIn.read(FullQueryLogger.GENERATED_TIMESTAMP).int64();\n            sb.append(\"Generated timestamp:\")\n              .append(generatedTimestamp)\n              .append(System.lineSeparator());\n\n            int generatedNowInSeconds = wireIn.read(FullQueryLogger.GENERATED_NOW_IN_SECONDS).int32();\n            sb.append(\"Generated nowInSeconds:\")\n              .append(generatedNowInSeconds)\n              .append(System.lineSeparator());\n\n            switch (type)\n            {\n                case (FullQueryLogger.SINGLE_QUERY):\n                    dumpQuery(options, wireIn, sb);\n                    break;\n\n                case (FullQueryLogger.BATCH):\n                    dumpBatch(options, wireIn, sb);\n                    break;\n\n                default:\n                    throw new UnsupportedOperationException(\"Log entry of unsupported type \" + type);\n            }\n\n            System.out.print(sb.toString());\n            System.out.flush();\n        };\n\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());\n        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(reader))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","realPath":"tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"NB"},{"authorDate":"2018-12-18 15:42:14","commitOrder":3,"curCode":"    static void dump(List<String> pathList, String rollCycle, boolean follow, Consumer<String> displayFun)\n    {\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ExcerptTailer> tailers = pathList.stream()\n                                              .distinct()\n                                              .map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build())\n                                              .map(SingleChronicleQueue::createTailer)\n                                              .collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(new DisplayRecord(displayFun)))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","date":"2019-01-23 21:36:56","endLine":103,"groupId":"30440","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"dump","params":"(List<String>pathList@StringrollCycle@booleanfollow@Consumer<String>displayFun)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/01/ea7b37ca8a4093f590efd1130d70007e25bdec.src","preCode":"    static void dump(List<String> pathList, String rollCycle, boolean follow, Consumer<String> displayFun)\n    {\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ExcerptTailer> tailers = pathList.stream()\n                                              .distinct()\n                                              .map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build())\n                                              .map(SingleChronicleQueue::createTailer)\n                                              .collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(new DisplayRecord(displayFun)))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/tools/AuditLogViewer.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"B"}],"commitId":"7d138e20ea987d44fffbc47de4674b253b7431ff","commitMessage":"@@@Add a new tool to dump audit logs\n\nPatch by Vinay Chella; reviewed by marcuse for CASSANDRA-14885\n","date":"2019-01-23 21:36:56","modifiedFileCount":"1","status":"M","submitter":"Vinay Chella"},{"authorTime":"2019-04-24 20:41:57","codes":[{"authorDate":"2019-04-24 20:41:57","commitOrder":4,"curCode":"    public static void dump(List<String> arguments, String rollCycle, boolean follow)\n    {\n        StringBuilder sb = new StringBuilder();\n        ReadMarshallable reader = wireIn ->\n        {\n            sb.setLength(0);\n\n            int version = wireIn.read(BinLog.VERSION).int16();\n            if (version > FullQueryLogger.CURRENT_VERSION)\n            {\n                throw new IORuntimeException(\"Unsupported record version [\" + version\n                                             + \"] - highest supported version is [\" + FullQueryLogger.CURRENT_VERSION + ']');\n            }\n\n            String type = wireIn.read(BinLog.TYPE).text();\n            if (!FullQueryLogger.SINGLE_QUERY.equals((type)) && !FullQueryLogger.BATCH.equals((type)))\n            {\n                throw new IORuntimeException(\"Unsupported record type field [\" + type\n                                             + \"] - supported record types are [\" + FullQueryLogger.SINGLE_QUERY + \", \" + FullQueryLogger.BATCH + ']');\n            }\n\n            sb.append(\"Type: \")\n              .append(type)\n              .append(System.lineSeparator());\n\n            long queryStartTime = wireIn.read(FullQueryLogger.QUERY_START_TIME).int64();\n            sb.append(\"Query start time: \")\n              .append(queryStartTime)\n              .append(System.lineSeparator());\n\n            int protocolVersion = wireIn.read(FullQueryLogger.PROTOCOL_VERSION).int32();\n            sb.append(\"Protocol version: \")\n              .append(protocolVersion)\n              .append(System.lineSeparator());\n\n            QueryOptions options =\n                QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read(FullQueryLogger.QUERY_OPTIONS).bytes()),\n                                          ProtocolVersion.decode(protocolVersion, true));\n\n            long generatedTimestamp = wireIn.read(FullQueryLogger.GENERATED_TIMESTAMP).int64();\n            sb.append(\"Generated timestamp:\")\n              .append(generatedTimestamp)\n              .append(System.lineSeparator());\n\n            int generatedNowInSeconds = wireIn.read(FullQueryLogger.GENERATED_NOW_IN_SECONDS).int32();\n            sb.append(\"Generated nowInSeconds:\")\n              .append(generatedNowInSeconds)\n              .append(System.lineSeparator());\n\n            switch (type)\n            {\n                case (FullQueryLogger.SINGLE_QUERY):\n                    dumpQuery(options, wireIn, sb);\n                    break;\n\n                case (FullQueryLogger.BATCH):\n                    dumpBatch(options, wireIn, sb);\n                    break;\n\n                default:\n                    throw new IORuntimeException(\"Log entry of unsupported type \" + type);\n            }\n\n            System.out.print(sb.toString());\n            System.out.flush();\n        };\n\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());\n        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(reader))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","date":"2019-11-28 16:43:07","endLine":165,"groupId":"10431","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"dump","params":"(List<String>arguments@StringrollCycle@booleanfollow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/46/c731f943c92a999dada9aa6e3eaf8b6b3856f0.src","preCode":"    public static void dump(List<String> arguments, String rollCycle, boolean follow)\n    {\n        StringBuilder sb = new StringBuilder();\n        ReadMarshallable reader = wireIn ->\n        {\n            sb.setLength(0);\n\n            int version = wireIn.read(FullQueryLogger.VERSION).int16();\n            if (version != FullQueryLogger.CURRENT_VERSION)\n                throw new UnsupportedOperationException(\"Full query log of unexpected version \" + version + \" encountered\");\n\n            String type = wireIn.read(FullQueryLogger.TYPE).text();\n            sb.append(\"Type: \")\n              .append(type)\n              .append(System.lineSeparator());\n\n            long queryStartTime = wireIn.read(FullQueryLogger.QUERY_START_TIME).int64();\n            sb.append(\"Query start time: \")\n              .append(queryStartTime)\n              .append(System.lineSeparator());\n\n            int protocolVersion = wireIn.read(FullQueryLogger.PROTOCOL_VERSION).int32();\n            sb.append(\"Protocol version: \")\n              .append(protocolVersion)\n              .append(System.lineSeparator());\n\n            QueryOptions options =\n                QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read(FullQueryLogger.QUERY_OPTIONS).bytes()),\n                                          ProtocolVersion.decode(protocolVersion, true));\n\n            long generatedTimestamp = wireIn.read(FullQueryLogger.GENERATED_TIMESTAMP).int64();\n            sb.append(\"Generated timestamp:\")\n              .append(generatedTimestamp)\n              .append(System.lineSeparator());\n\n            int generatedNowInSeconds = wireIn.read(FullQueryLogger.GENERATED_NOW_IN_SECONDS).int32();\n            sb.append(\"Generated nowInSeconds:\")\n              .append(generatedNowInSeconds)\n              .append(System.lineSeparator());\n\n            switch (type)\n            {\n                case (FullQueryLogger.SINGLE_QUERY):\n                    dumpQuery(options, wireIn, sb);\n                    break;\n\n                case (FullQueryLogger.BATCH):\n                    dumpBatch(options, wireIn, sb);\n                    break;\n\n                default:\n                    throw new UnsupportedOperationException(\"Log entry of unsupported type \" + type);\n            }\n\n            System.out.print(sb.toString());\n            System.out.flush();\n        };\n\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());\n        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(reader))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","realPath":"tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"},{"authorDate":"2019-04-24 20:41:57","commitOrder":4,"curCode":"    static void dump(List<String> pathList, String rollCycle, boolean follow, boolean ignoreUnsupported, Consumer<String> displayFun)\n    {\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ExcerptTailer> tailers = pathList.stream()\n                                              .distinct()\n                                              .map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build())\n                                              .map(SingleChronicleQueue::createTailer)\n                                              .collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(new DisplayRecord(ignoreUnsupported, displayFun)))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","date":"2019-11-28 16:43:07","endLine":105,"groupId":"30440","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"dump","params":"(List<String>pathList@StringrollCycle@booleanfollow@booleanignoreUnsupported@Consumer<String>displayFun)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f1/a6e3723ab5b336c2923e984d9f536b540ac3d6.src","preCode":"    static void dump(List<String> pathList, String rollCycle, boolean follow, Consumer<String> displayFun)\n    {\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ExcerptTailer> tailers = pathList.stream()\n                                              .distinct()\n                                              .map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build())\n                                              .map(SingleChronicleQueue::createTailer)\n                                              .collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(new DisplayRecord(displayFun)))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/tools/AuditLogViewer.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"d5e5c459f5c4c54c853b5fcfb5c2b3bfeee0d59c","commitMessage":"@@@Align record header of FQL and audit binary log\n\nPatch by Per Otterstr?m; reviewed by Vinay Chella and marcuse for CASSANDRA-15076\n","date":"2019-11-28 16:43:07","modifiedFileCount":"11","status":"M","submitter":"Per Otterstr?m"},{"authorTime":"2021-01-17 21:31:59","codes":[{"authorDate":"2021-01-17 21:31:59","commitOrder":5,"curCode":"    public static void dump(List<String> arguments, String rollCycle, boolean follow)\n    {\n        StringBuilder sb = new StringBuilder();\n        ReadMarshallable reader = wireIn ->\n        {\n            sb.setLength(0);\n\n            int version = wireIn.read(BinLog.VERSION).int16();\n            if (version > FullQueryLogger.CURRENT_VERSION)\n            {\n                throw new IORuntimeException(\"Unsupported record version [\" + version\n                                             + \"] - highest supported version is [\" + FullQueryLogger.CURRENT_VERSION + ']');\n            }\n\n            String type = wireIn.read(BinLog.TYPE).text();\n            if (!FullQueryLogger.SINGLE_QUERY.equals((type)) && !FullQueryLogger.BATCH.equals((type)))\n            {\n                throw new IORuntimeException(\"Unsupported record type field [\" + type\n                                             + \"] - supported record types are [\" + FullQueryLogger.SINGLE_QUERY + \", \" + FullQueryLogger.BATCH + ']');\n            }\n\n            sb.append(\"Type: \")\n              .append(type)\n              .append(System.lineSeparator());\n\n            long queryStartTime = wireIn.read(FullQueryLogger.QUERY_START_TIME).int64();\n            sb.append(\"Query start time: \")\n              .append(queryStartTime)\n              .append(System.lineSeparator());\n\n            int protocolVersion = wireIn.read(FullQueryLogger.PROTOCOL_VERSION).int32();\n            sb.append(\"Protocol version: \")\n              .append(protocolVersion)\n              .append(System.lineSeparator());\n\n            QueryOptions options =\n                QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read(FullQueryLogger.QUERY_OPTIONS).bytes()),\n                                          ProtocolVersion.decode(protocolVersion, true));\n\n            long generatedTimestamp = wireIn.read(FullQueryLogger.GENERATED_TIMESTAMP).int64();\n            sb.append(\"Generated timestamp:\")\n              .append(generatedTimestamp)\n              .append(System.lineSeparator());\n\n            int generatedNowInSeconds = wireIn.read(FullQueryLogger.GENERATED_NOW_IN_SECONDS).int32();\n            sb.append(\"Generated nowInSeconds:\")\n              .append(generatedNowInSeconds)\n              .append(System.lineSeparator());\n\n            switch (type)\n            {\n                case (FullQueryLogger.SINGLE_QUERY):\n                    dumpQuery(options, wireIn, sb);\n                    break;\n\n                case (FullQueryLogger.BATCH):\n                    dumpBatch(options, wireIn, sb);\n                    break;\n\n                default:\n                    throw new IORuntimeException(\"Log entry of unsupported type \" + type);\n            }\n\n            System.out.print(sb.toString());\n            System.out.flush();\n        };\n\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> SingleChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());\n        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(reader))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","date":"2021-01-22 17:02:20","endLine":165,"groupId":"1013","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"dump","params":"(List<String>arguments@StringrollCycle@booleanfollow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/f2/6f0f92adfb508ada62d91c49d2d7da56485b42.src","preCode":"    public static void dump(List<String> arguments, String rollCycle, boolean follow)\n    {\n        StringBuilder sb = new StringBuilder();\n        ReadMarshallable reader = wireIn ->\n        {\n            sb.setLength(0);\n\n            int version = wireIn.read(BinLog.VERSION).int16();\n            if (version > FullQueryLogger.CURRENT_VERSION)\n            {\n                throw new IORuntimeException(\"Unsupported record version [\" + version\n                                             + \"] - highest supported version is [\" + FullQueryLogger.CURRENT_VERSION + ']');\n            }\n\n            String type = wireIn.read(BinLog.TYPE).text();\n            if (!FullQueryLogger.SINGLE_QUERY.equals((type)) && !FullQueryLogger.BATCH.equals((type)))\n            {\n                throw new IORuntimeException(\"Unsupported record type field [\" + type\n                                             + \"] - supported record types are [\" + FullQueryLogger.SINGLE_QUERY + \", \" + FullQueryLogger.BATCH + ']');\n            }\n\n            sb.append(\"Type: \")\n              .append(type)\n              .append(System.lineSeparator());\n\n            long queryStartTime = wireIn.read(FullQueryLogger.QUERY_START_TIME).int64();\n            sb.append(\"Query start time: \")\n              .append(queryStartTime)\n              .append(System.lineSeparator());\n\n            int protocolVersion = wireIn.read(FullQueryLogger.PROTOCOL_VERSION).int32();\n            sb.append(\"Protocol version: \")\n              .append(protocolVersion)\n              .append(System.lineSeparator());\n\n            QueryOptions options =\n                QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read(FullQueryLogger.QUERY_OPTIONS).bytes()),\n                                          ProtocolVersion.decode(protocolVersion, true));\n\n            long generatedTimestamp = wireIn.read(FullQueryLogger.GENERATED_TIMESTAMP).int64();\n            sb.append(\"Generated timestamp:\")\n              .append(generatedTimestamp)\n              .append(System.lineSeparator());\n\n            int generatedNowInSeconds = wireIn.read(FullQueryLogger.GENERATED_NOW_IN_SECONDS).int32();\n            sb.append(\"Generated nowInSeconds:\")\n              .append(generatedNowInSeconds)\n              .append(System.lineSeparator());\n\n            switch (type)\n            {\n                case (FullQueryLogger.SINGLE_QUERY):\n                    dumpQuery(options, wireIn, sb);\n                    break;\n\n                case (FullQueryLogger.BATCH):\n                    dumpBatch(options, wireIn, sb);\n                    break;\n\n                default:\n                    throw new IORuntimeException(\"Log entry of unsupported type \" + type);\n            }\n\n            System.out.print(sb.toString());\n            System.out.flush();\n        };\n\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());\n        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(reader))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","realPath":"tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"},{"authorDate":"2021-01-17 21:31:59","commitOrder":5,"curCode":"    static void dump(List<String> pathList, String rollCycle, boolean follow, boolean ignoreUnsupported, Consumer<String> displayFun)\n    {\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ExcerptTailer> tailers = pathList.stream()\n                                              .distinct()\n                                              .map(path -> SingleChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build())\n                                              .map(SingleChronicleQueue::createTailer)\n                                              .collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(new DisplayRecord(ignoreUnsupported, displayFun)))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","date":"2021-01-22 17:02:20","endLine":105,"groupId":"1013","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"dump","params":"(List<String>pathList@StringrollCycle@booleanfollow@booleanignoreUnsupported@Consumer<String>displayFun)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cassandra-10-0.7/blobInfo/CC_OUT/blobs/dd/0e839832e1d21373e670e97dac90cd6b1600e9.src","preCode":"    static void dump(List<String> pathList, String rollCycle, boolean follow, boolean ignoreUnsupported, Consumer<String> displayFun)\n    {\n        \r\n        Pauser pauser = Pauser.millis(100);\n        List<ExcerptTailer> tailers = pathList.stream()\n                                              .distinct()\n                                              .map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build())\n                                              .map(SingleChronicleQueue::createTailer)\n                                              .collect(Collectors.toList());\n        boolean hadWork = true;\n        while (hadWork)\n        {\n            hadWork = false;\n            for (ExcerptTailer tailer : tailers)\n            {\n                while (tailer.readDocument(new DisplayRecord(ignoreUnsupported, displayFun)))\n                {\n                    hadWork = true;\n                }\n            }\n\n            if (follow)\n            {\n                if (!hadWork)\n                {\n                    \r\n                    pauser.pause();\n                }\n                \r\n                hadWork = true;\n            }\n        }\n    }\n","realPath":"src/java/org/apache/cassandra/tools/AuditLogViewer.java","repoName":"cassandra","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"7f1659cd1d46ab8904eee99daefcaaa7a521e00b","commitMessage":"@@@Upgrade netty and chronicle-queue dependencies to get Auditing and native library loading working on arm64 architectures\n\n CASSANDRA-16384 test case AuditLoggerTest fail on aarch64 platform\n CASSANDRA-16392 Unable to load the library netty_tcnative_linux_aarch_64\n\n patch by Zhao Renhai (? ??); reviewed by Mick Semb Wever for CASSANDRA-16384. CASSANDRA-16392\n","date":"2021-01-22 17:02:20","modifiedFileCount":"10","status":"M","submitter":"zhaorenhai"}]
