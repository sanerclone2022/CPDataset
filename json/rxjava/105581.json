[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void combine2Observable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestObserver<Object> testObserver = TestObserver.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Observable<Integer> emptyObservable = Observable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, ObservableSource<Integer>>() {\n                        @Override\n                        public ObservableSource<Integer> apply(Long aLong) throws Exception {\n                            return Observable.error(new Exception());\n                        }\n                    });\n            Observable<Object> errorObservable = Observable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Observable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyObservable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyObservable: doFinally\");\n                                        }\n                                    }),\n                            errorObservable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorObservable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":1163,"groupId":"12037","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"combine2Observable2Errors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/bb/27338d843fdf8ea09e0e1c117cee59cfb5c7b6.src","preCode":"    public void combine2Observable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestObserver<Object> testObserver = TestObserver.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Observable<Integer> emptyObservable = Observable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, ObservableSource<Integer>>() {\n                        @Override\n                        public ObservableSource<Integer> apply(Long aLong) throws Exception {\n                            return Observable.error(new Exception());\n                        }\n                    });\n            Observable<Object> errorObservable = Observable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Observable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyObservable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyObservable: doFinally\");\n                                        }\n                                    }),\n                            errorObservable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorObservable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCombineLatestTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":1085,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void combine2Flowable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestSubscriber<Object> testObserver = TestSubscriber.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Flowable<Integer> emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, Publisher<Integer>>() {\n                        @Override\n                        public Publisher<Integer> apply(Long aLong) throws Exception {\n                            return Flowable.error(new Exception());\n                        }\n                    });\n            Flowable<Object> errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Flowable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyFlowable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyFlowable: doFinally\");\n                                        }\n                                    }),\n                            errorFlowable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorFlowable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":1485,"groupId":"12037","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"combine2Flowable2Errors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/bb/ffd97ee457fba272e7ee1c19226e6ba9b1aa23.src","preCode":"    public void combine2Flowable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestSubscriber<Object> testObserver = TestSubscriber.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Flowable<Integer> emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, Publisher<Integer>>() {\n                        @Override\n                        public Publisher<Integer> apply(Long aLong) throws Exception {\n                            return Flowable.error(new Exception());\n                        }\n                    });\n            Flowable<Object> errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Flowable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyFlowable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyFlowable: doFinally\");\n                                        }\n                                    }),\n                            errorFlowable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorFlowable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCombineLatestTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":1407,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2020-02-12 23:26:52","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void combine2Observable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestObserver<Object> testObserver = TestObserver.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Observable<Integer> emptyObservable = Observable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, ObservableSource<Integer>>() {\n                        @Override\n                        public ObservableSource<Integer> apply(Long aLong) throws Exception {\n                            return Observable.error(new Exception());\n                        }\n                    });\n            Observable<Object> errorObservable = Observable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Observable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyObservable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyObservable: doFinally\");\n                                        }\n                                    }),\n                            errorObservable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorObservable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":1163,"groupId":"105581","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"combine2Observable2Errors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/bb/27338d843fdf8ea09e0e1c117cee59cfb5c7b6.src","preCode":"    public void combine2Observable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestObserver<Object> testObserver = TestObserver.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Observable<Integer> emptyObservable = Observable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, ObservableSource<Integer>>() {\n                        @Override\n                        public ObservableSource<Integer> apply(Long aLong) throws Exception {\n                            return Observable.error(new Exception());\n                        }\n                    });\n            Observable<Object> errorObservable = Observable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Observable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyObservable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyObservable: doFinally\");\n                                        }\n                                    }),\n                            errorObservable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorObservable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorObservable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCombineLatestTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":1085,"status":"N"},{"authorDate":"2020-02-12 23:26:52","commitOrder":2,"curCode":"    public void combine2Flowable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestSubscriber<Object> testSubscriber = TestSubscriber.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Flowable<Integer> emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, Publisher<Integer>>() {\n                        @Override\n                        public Publisher<Integer> apply(Long aLong) throws Exception {\n                            return Flowable.error(new Exception());\n                        }\n                    });\n            Flowable<Object> errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Flowable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyFlowable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyFlowable: doFinally\");\n                                        }\n                                    }),\n                            errorFlowable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorFlowable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testSubscriber);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testSubscriber.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","date":"2020-02-12 23:26:52","endLine":1473,"groupId":"105581","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"combine2Flowable2Errors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/06/b29eadbeb615a157d1f79a8eaa4efbfaa53900.src","preCode":"    public void combine2Flowable2Errors() throws Exception {\n        List<Throwable> errors = TestHelper.trackPluginErrors();\n        try {\n            TestSubscriber<Object> testObserver = TestSubscriber.create();\n\n            TestScheduler testScheduler = new TestScheduler();\n\n            Flowable<Integer> emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler)\n                    .flatMap(new Function<Long, Publisher<Integer>>() {\n                        @Override\n                        public Publisher<Integer> apply(Long aLong) throws Exception {\n                            return Flowable.error(new Exception());\n                        }\n                    });\n            Flowable<Object> errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() {\n                @Override\n                public Object apply(Long aLong) throws Exception {\n                    throw new Exception();\n                }\n            });\n\n            Flowable.combineLatestDelayError(\n                    Arrays.asList(\n                            emptyFlowable\n                                    .doOnEach(new Consumer<Notification<Integer>>() {\n                                        @Override\n                                        public void accept(Notification<Integer> integerNotification) throws Exception {\n                                            System.out.println(\"emptyFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"emptyFlowable: doFinally\");\n                                        }\n                                    }),\n                            errorFlowable\n                                    .doOnEach(new Consumer<Notification<Object>>() {\n                                        @Override\n                                        public void accept(Notification<Object> integerNotification) throws Exception {\n                                            System.out.println(\"errorFlowable: \" + integerNotification);\n                                        }\n                                    })\n                                    .doFinally(new Action() {\n                                        @Override\n                                        public void run() throws Exception {\n                                            System.out.println(\"errorFlowable: doFinally\");\n                                        }\n                                    })),\n                    new Function<Object[], Object>() {\n                        @Override\n                        public Object apply(Object[] objects) throws Exception {\n                            return 0;\n                        }\n                    }\n            )\n                    .doOnEach(new Consumer<Notification<Object>>() {\n                        @Override\n                        public void accept(Notification<Object> integerNotification) throws Exception {\n                            System.out.println(\"combineLatestDelayError: \" + integerNotification);\n                        }\n                    })\n                    .doFinally(new Action() {\n                        @Override\n                        public void run() throws Exception {\n                            System.out.println(\"combineLatestDelayError: doFinally\");\n                        }\n                    })\n                    .subscribe(testObserver);\n\n            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);\n\n            testObserver.awaitDone(5, TimeUnit.SECONDS);\n\n            assertTrue(errors.toString(), errors.isEmpty());\n        } finally {\n            RxJavaPlugins.reset();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCombineLatestTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":1395,"status":"M"}],"commitId":"b3ad0752de398f4536bb88a7b1c77b0b9fbecb87","commitMessage":"@@@3.x: Add missing coverage.  fix unused/inconsistent ops (#6901)\n\n* 3.x: Add missing coverage.  fix unused/inconsistent ops\n\n* More coverage improvements and cleanup\n\n* Some more coverage\n\n* Observable coverage and cleanup\n\n* Improve Flowable internals and coverage\n\n* More Flowable operator coverage and fixes\n\n* Last set of coverage & cleanup for Flowable operators\n\n* Fix wrong use of j.u.Observable\n","date":"2020-02-12 23:26:52","modifiedFileCount":"219","status":"M","submitter":"David Karnok"}]
