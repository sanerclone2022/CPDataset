[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int NUM_RETRIES = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));\n                                TestObserverEx<String> to = new TestObserverEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(to);\n                                to.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(to.values());\n                                if (onNextEvents.size() != NUM_RETRIES + 2) {\n                                    for (Throwable t : to.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = to.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":748,"groupId":"12975","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"retryWithBackpressureParallel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/26/377c742c77d0f71be68a43c5e61734117ad6c6.src","preCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int NUM_RETRIES = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));\n                                TestObserverEx<String> to = new TestObserverEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(to);\n                                to.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(to.values());\n                                if (onNextEvents.size() != NUM_RETRIES + 2) {\n                                    for (Throwable t : to.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = to.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":693,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int numRetries = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));\n                                TestSubscriberEx<String> ts = new TestSubscriberEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(ts);\n                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(ts.values());\n                                if (onNextEvents.size() != numRetries + 2) {\n                                    for (Throwable t : ts.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = ts.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":797,"groupId":"3190","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"retryWithBackpressureParallel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/92/6b37be8498fd805faa5ed1fcc2721995dd4e60.src","preCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int numRetries = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));\n                                TestSubscriberEx<String> ts = new TestSubscriberEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(ts);\n                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(ts.values());\n                                if (onNextEvents.size() != numRetries + 2) {\n                                    for (Throwable t : ts.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = ts.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int NUM_RETRIES = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));\n                                TestObserverEx<String> to = new TestObserverEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(to);\n                                to.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(to.values());\n                                if (onNextEvents.size() != NUM_RETRIES + 2) {\n                                    for (Throwable t : to.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = to.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":748,"groupId":"12975","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"retryWithBackpressureParallel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/26/377c742c77d0f71be68a43c5e61734117ad6c6.src","preCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int NUM_RETRIES = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));\n                                TestObserverEx<String> to = new TestObserverEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(to);\n                                to.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(to.values());\n                                if (onNextEvents.size() != NUM_RETRIES + 2) {\n                                    for (Throwable t : to.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = to.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":693,"status":"N"},{"authorDate":"2019-12-22 18:39:23","commitOrder":2,"curCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int numRetries = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));\n                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(ts);\n                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<>(ts.values());\n                                if (onNextEvents.size() != numRetries + 2) {\n                                    for (Throwable t : ts.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = ts.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","date":"2019-12-22 18:39:23","endLine":797,"groupId":"671","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"retryWithBackpressureParallel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/4d/e1cfb8b0d7ed46d90f8994f62782b0e5d4945e.src","preCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int numRetries = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));\n                                TestSubscriberEx<String> ts = new TestSubscriberEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(ts);\n                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(ts.values());\n                                if (onNextEvents.size() != numRetries + 2) {\n                                    for (Throwable t : ts.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = ts.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"M"}],"commitId":"e162d664d86639b97c214054aca346fc2ba37e33","commitMessage":"@@@diamond operators in unit tests.  flowable package (#6787)\n\n","date":"2019-12-22 18:39:23","modifiedFileCount":"111","status":"M","submitter":"Dmitry Volkov"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-12-22 18:59:44","commitOrder":3,"curCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int NUM_RETRIES = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));\n                                TestObserverEx<String> to = new TestObserverEx<>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(to);\n                                to.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<>(to.values());\n                                if (onNextEvents.size() != NUM_RETRIES + 2) {\n                                    for (Throwable t : to.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = to.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","date":"2019-12-22 18:59:44","endLine":748,"groupId":"102378","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"retryWithBackpressureParallel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/38/1ee0a7901d9076402271666fcf35b8e91064d5.src","preCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int NUM_RETRIES = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));\n                                TestObserverEx<String> to = new TestObserverEx<String>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(to);\n                                to.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<String>(to.values());\n                                if (onNextEvents.size() != NUM_RETRIES + 2) {\n                                    for (Throwable t : to.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = to.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":693,"status":"M"},{"authorDate":"2019-12-22 18:39:23","commitOrder":3,"curCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int numRetries = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));\n                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(ts);\n                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<>(ts.values());\n                                if (onNextEvents.size() != numRetries + 2) {\n                                    for (Throwable t : ts.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = ts.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","date":"2019-12-22 18:39:23","endLine":797,"groupId":"102378","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"retryWithBackpressureParallel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/4d/e1cfb8b0d7ed46d90f8994f62782b0e5d4945e.src","preCode":"    public void retryWithBackpressureParallel() throws InterruptedException {\n        final int NUM_LOOPS = 1;\n        final int numRetries = Flowable.bufferSize() * 2;\n        int ncpu = Runtime.getRuntime().availableProcessors();\n        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));\n        try {\n            for (int r = 0; r < NUM_LOOPS; r++) {\n                if (r % 10 == 0) {\n                    System.out.println(\"testRetryWithBackpressureParallelLoop -> \" + r);\n                }\n\n                final AtomicInteger timeouts = new AtomicInteger();\n                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();\n\n                int m = 5000;\n                final CountDownLatch cdl = new CountDownLatch(m);\n                for (int i = 0; i < m; i++) {\n                    final int j = i;\n                    exec.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            final AtomicInteger nexts = new AtomicInteger();\n                            try {\n                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));\n                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();\n                                origin.retry()\n                                .observeOn(Schedulers.computation()).subscribe(ts);\n                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);\n                                List<String> onNextEvents = new ArrayList<>(ts.values());\n                                if (onNextEvents.size() != numRetries + 2) {\n                                    for (Throwable t : ts.errors()) {\n                                        onNextEvents.add(t.toString());\n                                    }\n                                    for (long err = ts.completions(); err != 0; err--) {\n                                        onNextEvents.add(\"onComplete\");\n                                    }\n                                    data.put(j, onNextEvents);\n                                }\n                            } catch (Throwable t) {\n                                timeouts.incrementAndGet();\n                                System.out.println(j + \" | \" + cdl.getCount() + \" !!! \" + nexts.get());\n                            }\n                            cdl.countDown();\n                        }\n                    });\n                }\n                cdl.await();\n                assertEquals(0, timeouts.get());\n                if (data.size() > 0) {\n                    fail(\"Data content mismatch: \" + allSequenceFrequency(data));\n                }\n            }\n        } finally {\n            exec.shutdown();\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"N"}],"commitId":"d6d698213b6c4091f4d5a0fb47f0922d0d0618e3","commitMessage":"@@@diamond operators in unit tests.  observable package (#6786)\n\n","date":"2019-12-22 18:59:44","modifiedFileCount":"95","status":"M","submitter":"Dmitry Volkov"}]
