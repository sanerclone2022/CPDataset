[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposables.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-08-16 20:51:17","endLine":374,"groupId":"589","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/e5/90ec166324f0d875756b9075dbf705a14c0cfc.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposables.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-08-16 20:51:17","endLine":374,"groupId":"8213","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ff/0b91113af9b9ee8c76c898f7a38e412f75c702.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-12-20 02:39:40","commitOrder":2,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposable.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-12-20 02:39:40","endLine":374,"groupId":"589","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/9e/6540e0b326382ea2df43b9097064d69290fc0b.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposables.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"},{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-08-16 20:51:17","endLine":374,"groupId":"8213","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ff/0b91113af9b9ee8c76c898f7a38e412f75c702.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"}],"commitId":"166c529eb165b473c9bff11e8fedbde6c471b005","commitMessage":"@@@Migrate Disposables static factories to Disposable interface (#6781)\n\n","date":"2019-12-20 02:39:40","modifiedFileCount":"202","status":"M","submitter":"Jake Wharton"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-12-20 02:39:40","commitOrder":3,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposable.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-12-20 02:39:40","endLine":374,"groupId":"589","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/9e/6540e0b326382ea2df43b9097064d69290fc0b.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposable.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"},{"authorDate":"2019-12-22 18:39:23","commitOrder":3,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-12-22 18:39:23","endLine":374,"groupId":"2061","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/7e/55fa0d773ebb94bcab1ff9c761a301709f67e6.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"}],"commitId":"e162d664d86639b97c214054aca346fc2ba37e33","commitMessage":"@@@diamond operators in unit tests.  flowable package (#6787)\n\n","date":"2019-12-22 18:39:23","modifiedFileCount":"111","status":"M","submitter":"Dmitry Volkov"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-12-22 18:59:44","commitOrder":4,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposable.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-12-22 18:59:44","endLine":374,"groupId":"105160","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/60/cb5a8b92766f6c00cce914967b3a0ea1f4ca82.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {\n            @Override\n            public Observable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Observable.unsafeCreate(new ObservableSource<Integer>() {\n                        @Override\n                        public void subscribe(Observer<? super Integer> observer) {\n                            observer.onSubscribe(Disposable.empty());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            observer.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishSubject.create();\n                }\n            }\n        };\n\n        final Observer<Integer> o = TestHelper.mockObserver();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(o).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(o).onComplete();\n\n        final TestObserver<Integer> to = new TestObserver<Integer>(o);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishSubject<Integer> source = PublishSubject.create();\n                source.timeout(timeoutFunc, Observable.just(3)).subscribe(to);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(o);\n        inOrder.verify(o).onSubscribe((Disposable)notNull());\n        inOrder.verify(o).onNext(1);\n        inOrder.verify(o).onNext(2);\n        inOrder.verify(o, never()).onNext(3);\n        inOrder.verify(o).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"},{"authorDate":"2019-12-22 18:39:23","commitOrder":4,"curCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","date":"2019-12-22 18:39:23","endLine":374,"groupId":"105160","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"timeoutSelectorWithTimeoutAndOnNextRaceCondition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/7e/55fa0d773ebb94bcab1ff9c761a301709f67e6.src","preCode":"    public void timeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);\n        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);\n        final CountDownLatch observerCompleted = new CountDownLatch(1);\n        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);\n        final AtomicBoolean latchTimeout = new AtomicBoolean(false);\n\n        final Function<Integer, Flowable<Integer>> timeoutFunc = new Function<Integer, Flowable<Integer>>() {\n            @Override\n            public Flowable<Integer> apply(Integer t1) {\n                if (t1 == 1) {\n                    \r\n                    return Flowable.unsafeCreate(new Publisher<Integer>() {\n                        @Override\n                        public void subscribe(Subscriber<? super Integer> subscriber) {\n                            subscriber.onSubscribe(new BooleanSubscription());\n                            enteredTimeoutOne.countDown();\n                            \r\n                            while (true) {\n                                try {\n                                    if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {\n                                        \r\n                                        \r\n                                        latchTimeout.set(true);\n                                    }\n                                    break;\n                                } catch (InterruptedException e) {\n                                    \r\n                                    \r\n                                }\n                            }\n                            subscriber.onNext(1);\n                            timeoutEmittedOne.countDown();\n                        }\n                    }).subscribeOn(Schedulers.newThread());\n                } else {\n                    return PublishProcessor.create();\n                }\n            }\n        };\n\n        final Subscriber<Integer> subscriber = TestHelper.mockSubscriber();\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerReceivedTwo.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onNext(2);\n        doAnswer(new Answer<Void>() {\n\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                observerCompleted.countDown();\n                return null;\n            }\n\n        }).when(subscriber).onComplete();\n\n        final TestSubscriber<Integer> ts = new TestSubscriber<>(subscriber);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                PublishProcessor<Integer> source = PublishProcessor.create();\n                source.timeout(timeoutFunc, Flowable.just(3)).subscribe(ts);\n                source.onNext(1); \r\n                try {\n                    if (!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onNext(2); \r\n                try {\n                    if (!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {\n                        latchTimeout.set(true);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                source.onComplete();\n            }\n\n        }).start();\n\n        if (!observerCompleted.await(30, TimeUnit.SECONDS)) {\n            latchTimeout.set(true);\n        }\n\n        assertFalse(\"CoundDownLatch timeout\", latchTimeout.get());\n\n        InOrder inOrder = inOrder(subscriber);\n        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());\n        inOrder.verify(subscriber).onNext(1);\n        inOrder.verify(subscriber).onNext(2);\n        inOrder.verify(subscriber, never()).onNext(3);\n        inOrder.verify(subscriber).onComplete();\n        inOrder.verifyNoMoreInteractions();\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"}],"commitId":"d6d698213b6c4091f4d5a0fb47f0922d0d0618e3","commitMessage":"@@@diamond operators in unit tests.  observable package (#6786)\n\n","date":"2019-12-22 18:59:44","modifiedFileCount":"95","status":"M","submitter":"Dmitry Volkov"}]
