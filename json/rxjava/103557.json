[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {\n\n                    @Override\n                    public void subscribe(final Observer<? super Integer> o) {\n                        o.onSubscribe(Disposables.empty());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        o.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    o.onComplete();\n                                } catch (Throwable e) {\n                                    o.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = next(obs).iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":313,"groupId":"1171","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"noBufferingOrBlockingOfSequence","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/93/8f757a0c1aa489736dff2fcba89784d7c29c3e.src","preCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {\n\n                    @Override\n                    public void subscribe(final Observer<? super Integer> o) {\n                        o.onSubscribe(Disposables.empty());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        o.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    o.onComplete();\n                                } catch (Throwable e) {\n                                    o.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = next(obs).iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {\n\n                    @Override\n                    public void subscribe(final Subscriber<? super Integer> subscriber) {\n                        subscriber.onSubscribe(new BooleanSubscription());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        subscriber.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    subscriber.onComplete();\n                                } catch (Throwable e) {\n                                    subscriber.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = obs.blockingNext().iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":308,"groupId":"11424","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"noBufferingOrBlockingOfSequence","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/8b/c31fa85ef97c8a5d2c369e4c5711b9a7781e45.src","preCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {\n\n                    @Override\n                    public void subscribe(final Subscriber<? super Integer> subscriber) {\n                        subscriber.onSubscribe(new BooleanSubscription());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        subscriber.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    subscriber.onComplete();\n                                } catch (Throwable e) {\n                                    subscriber.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = obs.blockingNext().iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableNextTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-12-20 02:39:40","commitOrder":2,"curCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {\n\n                    @Override\n                    public void subscribe(final Observer<? super Integer> o) {\n                        o.onSubscribe(Disposable.empty());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        o.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    o.onComplete();\n                                } catch (Throwable e) {\n                                    o.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = next(obs).iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","date":"2019-12-20 02:39:40","endLine":312,"groupId":"103557","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"noBufferingOrBlockingOfSequence","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/0f/cec3a17249eca70164fb8490f028044c0b3476.src","preCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {\n\n                    @Override\n                    public void subscribe(final Observer<? super Integer> o) {\n                        o.onSubscribe(Disposables.empty());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        o.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    o.onComplete();\n                                } catch (Throwable e) {\n                                    o.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = next(obs).iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNextTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"M"},{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {\n\n                    @Override\n                    public void subscribe(final Subscriber<? super Integer> subscriber) {\n                        subscriber.onSubscribe(new BooleanSubscription());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        subscriber.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    subscriber.onComplete();\n                                } catch (Throwable e) {\n                                    subscriber.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = obs.blockingNext().iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","date":"2019-08-16 20:51:17","endLine":308,"groupId":"103557","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"noBufferingOrBlockingOfSequence","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/8b/c31fa85ef97c8a5d2c369e4c5711b9a7781e45.src","preCode":"    public void noBufferingOrBlockingOfSequence() throws Throwable {\n        int repeat = 0;\n        for (;;) {\n            final SerialDisposable task = new SerialDisposable();\n            try {\n                final CountDownLatch finished = new CountDownLatch(1);\n                final int COUNT = 30;\n                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);\n                final AtomicBoolean running = new AtomicBoolean(true);\n                final AtomicInteger count = new AtomicInteger(0);\n                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {\n\n                    @Override\n                    public void subscribe(final Subscriber<? super Integer> subscriber) {\n                        subscriber.onSubscribe(new BooleanSubscription());\n                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {\n\n                            @Override\n                            public void run() {\n                                try {\n                                    while (running.get() && !task.isDisposed()) {\n                                        subscriber.onNext(count.incrementAndGet());\n                                        timeHasPassed.countDown();\n                                    }\n                                    subscriber.onComplete();\n                                } catch (Throwable e) {\n                                    subscriber.onError(e);\n                                } finally {\n                                    finished.countDown();\n                                }\n                            }\n                        }));\n                    }\n\n                });\n\n                Iterator<Integer> it = obs.blockingNext().iterator();\n\n                assertTrue(it.hasNext());\n                int a = it.next();\n                assertTrue(it.hasNext());\n                int b = it.next();\n                \r\n                assertTrue(\"a and b should be different\", a != b);\n\n                \r\n                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);\n\n                assertTrue(it.hasNext());\n                int c = it.next();\n\n                assertTrue(\"c should not just be the next in sequence\", c != (b + 1));\n                assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);\n\n                assertTrue(it.hasNext());\n                int d = it.next();\n                assertTrue(d > c);\n\n                \r\n                running.set(false);\n\n                finished.await();\n\n                assertFalse(it.hasNext());\n\n                System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c);\n                break;\n            } catch (AssertionError ex) {\n                if (++repeat == 3) {\n                    throw ex;\n                }\n                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));\n            } finally {\n                task.dispose();\n            }\n        }\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableNextTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"N"}],"commitId":"166c529eb165b473c9bff11e8fedbde6c471b005","commitMessage":"@@@Migrate Disposables static factories to Disposable interface (#6781)\n\n","date":"2019-12-20 02:39:40","modifiedFileCount":"202","status":"M","submitter":"Jake Wharton"}]
