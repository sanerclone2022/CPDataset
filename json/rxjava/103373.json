[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        int i = index;\n                        if (i == sources.length) {\n                            a.onComplete();\n                            return;\n                        }\n                        index = i + 1;\n\n                        sources[i].subscribe(this);\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":161,"groupId":"6266","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ba/b81330b25c86d1dedb986d32d4c45ec566b558.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        int i = index;\n                        if (i == sources.length) {\n                            a.onComplete();\n                            return;\n                        }\n                        index = i + 1;\n\n                        sources[i].subscribe(this);\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatArray.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        boolean b;\n\n                        try {\n                            b = sources.hasNext();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            a.onError(ex);\n                            return;\n                        }\n\n                        if (b) {\n                            MaybeSource<? extends T> source;\n\n                            try {\n                                source = ObjectHelper.requireNonNull(sources.next(), \"The source Iterator returned a null MaybeSource\");\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                a.onError(ex);\n                                return;\n                            }\n\n                            source.subscribe(this);\n                        } else {\n                            a.onComplete();\n                        }\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":190,"groupId":"6266","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/b0/1b58c6a02cd86061d63ae693083467018f55d2.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        boolean b;\n\n                        try {\n                            b = sources.hasNext();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            a.onError(ex);\n                            return;\n                        }\n\n                        if (b) {\n                            MaybeSource<? extends T> source;\n\n                            try {\n                                source = ObjectHelper.requireNonNull(sources.next(), \"The source Iterator returned a null MaybeSource\");\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                a.onError(ex);\n                                return;\n                            }\n\n                            source.subscribe(this);\n                        } else {\n                            a.onComplete();\n                        }\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatIterable.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-12-18 03:06:44","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        int i = index;\n                        if (i == sources.length) {\n                            a.onComplete();\n                            return;\n                        }\n                        index = i + 1;\n\n                        sources[i].subscribe(this);\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":161,"groupId":"103373","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ba/b81330b25c86d1dedb986d32d4c45ec566b558.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        int i = index;\n                        if (i == sources.length) {\n                            a.onComplete();\n                            return;\n                        }\n                        index = i + 1;\n\n                        sources[i].subscribe(this);\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatArray.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"N"},{"authorDate":"2019-12-18 03:06:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        boolean b;\n\n                        try {\n                            b = sources.hasNext();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            a.onError(ex);\n                            return;\n                        }\n\n                        if (b) {\n                            MaybeSource<? extends T> source;\n\n                            try {\n                                source = Objects.requireNonNull(sources.next(), \"The source Iterator returned a null MaybeSource\");\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                a.onError(ex);\n                                return;\n                            }\n\n                            source.subscribe(this);\n                        } else {\n                            a.onComplete();\n                        }\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":190,"groupId":"103373","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f3/abd7ddb84390bec9ba53d94e0f2d687d023229.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            AtomicReference<Object> c = current;\n            Subscriber<? super T> a = downstream;\n            Disposable cancelled = disposables;\n\n            for (;;) {\n                if (cancelled.isDisposed()) {\n                    c.lazySet(null);\n                    return;\n                }\n\n                Object o = c.get();\n\n                if (o != null) {\n                    boolean goNextSource;\n                    if (o != NotificationLite.COMPLETE) {\n                        long p = produced;\n                        if (p != requested.get()) {\n                            produced = p + 1;\n                            c.lazySet(null);\n                            goNextSource = true;\n\n                            a.onNext((T)o);\n                        } else {\n                            goNextSource = false;\n                        }\n                    } else {\n                        goNextSource = true;\n                        c.lazySet(null);\n                    }\n\n                    if (goNextSource && !cancelled.isDisposed()) {\n                        boolean b;\n\n                        try {\n                            b = sources.hasNext();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            a.onError(ex);\n                            return;\n                        }\n\n                        if (b) {\n                            MaybeSource<? extends T> source;\n\n                            try {\n                                source = ObjectHelper.requireNonNull(sources.next(), \"The source Iterator returned a null MaybeSource\");\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                a.onError(ex);\n                                return;\n                            }\n\n                            source.subscribe(this);\n                        } else {\n                            a.onComplete();\n                        }\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatIterable.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"}],"commitId":"6ba932c9a3752c6d85d65bd2292c3a47cab64fd6","commitMessage":"@@@Replace ObjectHelper.requireNonNull with Objects.requireNonNull (#6771)\n\n","date":"2019-12-18 03:06:44","modifiedFileCount":"199","status":"M","submitter":"Jake Wharton"}]
