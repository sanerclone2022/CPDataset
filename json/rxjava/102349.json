[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = ObjectHelper.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":336,"groupId":"10860","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/b6/c9f811f432766060cc1dafd44dbc7b0d6b3fe2.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = ObjectHelper.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.<TRight>create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = ObjectHelper.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":347,"groupId":"1506","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/21/3073c6729436c9c0fc6010743204572ecd3afb.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.<TRight>create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = ObjectHelper.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-12-18 03:06:44","codes":[{"authorDate":"2019-12-18 03:06:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":335,"groupId":"869","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/7b/125799666a427d95777f9a38853fbd188be05f.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = ObjectHelper.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"},{"authorDate":"2019-12-18 03:06:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.<TRight>create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":346,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/cc/d80c53d9422d65c3b207b58b75346cc2b8ca2c.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.<TRight>create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = ObjectHelper.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"}],"commitId":"6ba932c9a3752c6d85d65bd2292c3a47cab64fd6","commitMessage":"@@@Replace ObjectHelper.requireNonNull with Objects.requireNonNull (#6771)\n\n","date":"2019-12-18 03:06:44","modifiedFileCount":"199","status":"M","submitter":"Jake Wharton"},{"authorTime":"2019-12-28 03:01:34","codes":[{"authorDate":"2019-12-18 03:06:44","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":335,"groupId":"869","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/7b/125799666a427d95777f9a38853fbd188be05f.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"N"},{"authorDate":"2019-12-28 03:01:34","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":346,"groupId":"3827","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/a9/50de7a96f061cb888dfb739ae7c589ea7bb0e7.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.<TRight>create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"}],"commitId":"79f8e6dde6446b1aa33c146eaedbb958086daf56","commitMessage":"@@@3.x: Fix diamonds.  spelling.  unnecessary code (#6804)\n\n","date":"2019-12-28 03:01:34","modifiedFileCount":"463","status":"M","submitter":"David Karnok"},{"authorTime":"2020-02-12 23:26:52","codes":[{"authorDate":"2020-02-12 23:26:52","commitOrder":4,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else  {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2020-02-12 23:26:52","endLine":335,"groupId":"102349","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/2a/553fd1b174ed055f407017b6d2c6b6f4580680.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastSubject<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastSubject<TRight> up = UnicastSubject.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        a.onNext(w);\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastSubject<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        UnicastSubject<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"},{"authorDate":"2020-02-12 23:26:52","commitOrder":4,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2020-02-12 23:26:52","endLine":346,"groupId":"102349","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/e8/32cf89505e496be40cd891d5f261c51303170c.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n                        for (UnicastProcessor<?> up : lefts.values()) {\n                            up.onComplete();\n                        }\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        UnicastProcessor<TRight> up = UnicastProcessor.create();\n                        int idx = leftIndex++;\n                        lefts.put(idx, up);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        R w;\n\n                        try {\n                            w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        \r\n                        if (requested.get() != 0L) {\n                            a.onNext(w);\n                            BackpressureHelper.produced(requested, 1);\n                        } else {\n                            fail(new MissingBackpressureException(\"Could not emit value due to lack of requests\"), a, q);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (UnicastProcessor<TRight> up : lefts.values()) {\n                            up.onNext(right);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        UnicastProcessor<TRight> up = lefts.remove(end.index);\n                        disposables.remove(end);\n                        if (up != null) {\n                            up.onComplete();\n                        }\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"}],"commitId":"b3ad0752de398f4536bb88a7b1c77b0b9fbecb87","commitMessage":"@@@3.x: Add missing coverage.  fix unused/inconsistent ops (#6901)\n\n* 3.x: Add missing coverage.  fix unused/inconsistent ops\n\n* More coverage improvements and cleanup\n\n* Some more coverage\n\n* Observable coverage and cleanup\n\n* Improve Flowable internals and coverage\n\n* More Flowable operator coverage and fixes\n\n* Last set of coverage & cleanup for Flowable operators\n\n* Fix wrong use of j.u.Observable\n","date":"2020-02-12 23:26:52","modifiedFileCount":"219","status":"M","submitter":"David Karnok"}]
