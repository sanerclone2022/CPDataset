[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousObservable o1 = new TestASynchronousObservable();\n        final TestASynchronousObservable o2 = new TestASynchronousObservable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));\n        m.subscribe(new DefaultObserver<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                throw new RuntimeException(\"failed\", e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousObservable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        o1.onNextBeingSent.await();\n        o2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            o1.t.join();\n            o2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","date":"2019-08-16 20:51:17","endLine":290,"groupId":"11369","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"synchronizationOfMultipleSequences","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/87/36bd4ae332523594a8bd4235fb8a57ab596441.src","preCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousObservable o1 = new TestASynchronousObservable();\n        final TestASynchronousObservable o2 = new TestASynchronousObservable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));\n        m.subscribe(new DefaultObserver<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                throw new RuntimeException(\"failed\", e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousObservable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        o1.onNextBeingSent.await();\n        o2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            o1.t.join();\n            o2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":214,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();\n        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n\n        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));\n        m.subscribe(new DefaultSubscriber<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousFlowable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        f1.onNextBeingSent.await();\n        f2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            if (error.get() != null) {\n                throw ExceptionHelper.wrapOrThrow(error.get());\n            }\n\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            f1.t.join();\n            f2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","date":"2019-08-16 20:51:17","endLine":306,"groupId":"9580","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"synchronizationOfMultipleSequences","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/22/526d1922532b741c7161dad0d1db1939ced05a.src","preCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();\n        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n\n        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));\n        m.subscribe(new DefaultSubscriber<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousFlowable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        f1.onNextBeingSent.await();\n        f2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            if (error.get() != null) {\n                throw ExceptionHelper.wrapOrThrow(error.get());\n            }\n\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            f1.t.join();\n            f2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMergeTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousObservable o1 = new TestASynchronousObservable();\n        final TestASynchronousObservable o2 = new TestASynchronousObservable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));\n        m.subscribe(new DefaultObserver<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                throw new RuntimeException(\"failed\", e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousObservable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        o1.onNextBeingSent.await();\n        o2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            o1.t.join();\n            o2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","date":"2019-08-16 20:51:17","endLine":290,"groupId":"104827","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"synchronizationOfMultipleSequences","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/87/36bd4ae332523594a8bd4235fb8a57ab596441.src","preCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousObservable o1 = new TestASynchronousObservable();\n        final TestASynchronousObservable o2 = new TestASynchronousObservable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));\n        m.subscribe(new DefaultObserver<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                throw new RuntimeException(\"failed\", e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousObservable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        o1.onNextBeingSent.await();\n        o2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            o1.t.join();\n            o2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":214,"status":"N"},{"authorDate":"2019-12-22 18:39:23","commitOrder":2,"curCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();\n        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        final AtomicReference<Throwable> error = new AtomicReference<>();\n\n        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));\n        m.subscribe(new DefaultSubscriber<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousFlowable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        f1.onNextBeingSent.await();\n        f2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            if (error.get() != null) {\n                throw ExceptionHelper.wrapOrThrow(error.get());\n            }\n\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            f1.t.join();\n            f2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","date":"2019-12-22 18:39:23","endLine":306,"groupId":"104827","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"synchronizationOfMultipleSequences","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/6b/3f72e2f941a8cf958bf4d1ac1b1c79d905228f.src","preCode":"    public void synchronizationOfMultipleSequences() throws Throwable {\n        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();\n        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();\n\n        \r\n        final CountDownLatch endLatch = new CountDownLatch(1);\n\n        final AtomicInteger concurrentCounter = new AtomicInteger();\n        final AtomicInteger totalCounter = new AtomicInteger();\n\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n\n        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));\n        m.subscribe(new DefaultSubscriber<String>() {\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(e);\n            }\n\n            @Override\n            public void onNext(String v) {\n                totalCounter.incrementAndGet();\n                concurrentCounter.incrementAndGet();\n                try {\n                    \r\n                    if (Thread.currentThread().getName().equals(\"TestASynchronousFlowable\")) {\n                        \r\n                        endLatch.await();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"failed\", e);\n                } finally {\n                    concurrentCounter.decrementAndGet();\n                }\n            }\n\n        });\n\n        \r\n        f1.onNextBeingSent.await();\n        f2.onNextBeingSent.await();\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        int timeout = 20;\n\n        while (timeout-- > 0 && concurrentCounter.get() != 1) {\n            Thread.sleep(100);\n        }\n\n        try { \r\n            if (error.get() != null) {\n                throw ExceptionHelper.wrapOrThrow(error.get());\n            }\n\n            assertEquals(1, concurrentCounter.get());\n        } finally {\n            \r\n            endLatch.countDown();\n        }\n\n        try {\n            f1.t.join();\n            f2.t.join();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n\n        assertEquals(2, totalCounter.get());\n        assertEquals(0, concurrentCounter.get());\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMergeTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"}],"commitId":"e162d664d86639b97c214054aca346fc2ba37e33","commitMessage":"@@@diamond operators in unit tests.  flowable package (#6787)\n\n","date":"2019-12-22 18:39:23","modifiedFileCount":"111","status":"M","submitter":"Dmitry Volkov"}]
