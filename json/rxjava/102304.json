[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposables.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-08-16 20:51:17","endLine":103,"groupId":"6195","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/26/377c742c77d0f71be68a43c5e61734117ad6c6.src","preCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposables.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<String>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-08-16 20:51:17","endLine":103,"groupId":"5414","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/92/6b37be8498fd805faa5ed1fcc2721995dd4e60.src","preCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<String>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-12-20 02:39:40","commitOrder":2,"curCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-20 02:39:40","endLine":103,"groupId":"6195","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/82/d96dc5d7b83880f95273c37765c05c13afd27a.src","preCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposables.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"},{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<String>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-08-16 20:51:17","endLine":103,"groupId":"5414","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/92/6b37be8498fd805faa5ed1fcc2721995dd4e60.src","preCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<String>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"166c529eb165b473c9bff11e8fedbde6c471b005","commitMessage":"@@@Migrate Disposables static factories to Disposable interface (#6781)\n\n","date":"2019-12-20 02:39:40","modifiedFileCount":"202","status":"M","submitter":"Jake Wharton"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-12-20 02:39:40","commitOrder":3,"curCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-20 02:39:40","endLine":103,"groupId":"6195","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/82/d96dc5d7b83880f95273c37765c05c13afd27a.src","preCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"N"},{"authorDate":"2019-12-22 18:39:23","commitOrder":3,"curCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-22 18:39:23","endLine":103,"groupId":"5414","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/4d/e1cfb8b0d7ed46d90f8994f62782b0e5d4945e.src","preCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<String>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"e162d664d86639b97c214054aca346fc2ba37e33","commitMessage":"@@@diamond operators in unit tests.  flowable package (#6787)\n\n","date":"2019-12-22 18:39:23","modifiedFileCount":"111","status":"M","submitter":"Dmitry Volkov"},{"authorTime":"2019-12-22 18:39:23","codes":[{"authorDate":"2019-12-22 18:59:44","commitOrder":4,"curCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-22 18:59:44","endLine":103,"groupId":"6195","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/38/1ee0a7901d9076402271666fcf35b8e91064d5.src","preCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<String>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"},{"authorDate":"2019-12-22 18:39:23","commitOrder":4,"curCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-22 18:39:23","endLine":103,"groupId":"5414","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/4d/e1cfb8b0d7ed46d90f8994f62782b0e5d4945e.src","preCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"d6d698213b6c4091f4d5a0fb47f0922d0d0618e3","commitMessage":"@@@diamond operators in unit tests.  observable package (#6786)\n\n","date":"2019-12-22 18:59:44","modifiedFileCount":"95","status":"M","submitter":"Dmitry Volkov"},{"authorTime":"2019-12-26 06:52:13","codes":[{"authorDate":"2019-12-26 06:52:13","commitOrder":5,"curCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(1L, n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-26 06:52:13","endLine":103,"groupId":"102304","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/94/009c5b86aa7f28540c27424a44ae11ff2c176f.src","preCode":"    public void iterativeBackoff() {\n        Observer<String> consumer = TestHelper.mockObserver();\n\n        Observable<String> producer = Observable.unsafeCreate(new ObservableSource<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Observer<? super String> t1) {\n                t1.onSubscribe(Disposable.empty());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestObserver<String> to = new TestObserver<>(consumer);\n        producer.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() {\n\n            @Override\n            public Observable<Object> apply(Observable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Observable<Long>>() {\n                        @Override\n                        public Observable<Long> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Observable.<Long>error(t.n) :\n                                Observable.timer(t.count * 1L, TimeUnit.MILLISECONDS);\n                    }}).cast(Object.class);\n            }\n        }).subscribe(to);\n        to.awaitDone(5, TimeUnit.SECONDS);\n        to.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"},{"authorDate":"2019-12-26 06:52:13","commitOrder":5,"curCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(1L, n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","date":"2019-12-26 06:52:13","endLine":103,"groupId":"102304","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"iterativeBackoff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/60/7801bd195bd032140deff7605d1e2838905f5d.src","preCode":"    public void iterativeBackoff() {\n        Subscriber<String> consumer = TestHelper.mockSubscriber();\n\n        Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {\n\n            private AtomicInteger count = new AtomicInteger(4);\n            long last = System.currentTimeMillis();\n\n            @Override\n            public void subscribe(Subscriber<? super String> t1) {\n                t1.onSubscribe(new BooleanSubscription());\n                System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));\n                last = System.currentTimeMillis();\n                if (count.getAndDecrement() == 0) {\n                    t1.onNext(\"hello\");\n                    t1.onComplete();\n                } else {\n                    t1.onError(new RuntimeException());\n                }\n            }\n\n        });\n        TestSubscriber<String> ts = new TestSubscriber<>(consumer);\n        producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {\n\n            @Override\n            public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {\n                \r\n                return attempts\n                    .map(new Function<Throwable, Tuple>() {\n                        @Override\n                        public Tuple apply(Throwable n) {\n                            return new Tuple(new Long(1), n);\n                        }})\n                    .scan(new BiFunction<Tuple, Tuple, Tuple>() {\n                        @Override\n                        public Tuple apply(Tuple t, Tuple n) {\n                            return new Tuple(t.count + n.count, n.n);\n                        }})\n                    .flatMap(new Function<Tuple, Flowable<Object>>() {\n                        @Override\n                        public Flowable<Object> apply(Tuple t) {\n                            System.out.println(\"Retry # \" + t.count);\n                            return t.count > 20 ?\n                                Flowable.<Object>error(t.n) :\n                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)\n                                .cast(Object.class);\n                    }});\n            }\n        }).subscribe(ts);\n        ts.awaitDone(5, TimeUnit.SECONDS);\n        ts.assertNoErrors();\n\n        InOrder inOrder = inOrder(consumer);\n        inOrder.verify(consumer, never()).onError(any(Throwable.class));\n        inOrder.verify(consumer, times(1)).onNext(\"hello\");\n        inOrder.verify(consumer, times(1)).onComplete();\n        inOrder.verifyNoMoreInteractions();\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"480889c58d3b762b073ef80229bf27f9d9429dd7","commitMessage":"@@@3.x: Add missing annotations.  fix many diamonds (#6795)\n\n* 3.x: Add missing annotations.  fix many diamonds\n\n* Fix accidental JDK 9 API usage\n\n* Fix NPE in unicast due to null-cleanup\n","date":"2019-12-26 06:52:13","modifiedFileCount":"52","status":"M","submitter":"David Karnok"}]
