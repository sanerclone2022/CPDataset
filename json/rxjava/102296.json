[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        downstream.onNext(w);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":246,"groupId":"3925","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f1/52f6f263730d0f29365060a85809fa9d007e87.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        downstream.onNext(w);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            downstream.onNext(w);\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.addThrowable(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":263,"groupId":"3925","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/e6/f70107da594bcfc9e96d54aea85a472176a796.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            downstream.onNext(w);\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.addThrowable(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-28 22:07:44","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        downstream.onNext(w);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":246,"groupId":"3925","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f1/52f6f263730d0f29365060a85809fa9d007e87.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        downstream.onNext(w);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"N"},{"authorDate":"2019-08-28 22:07:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            downstream.onNext(w);\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.tryAddThrowableOrReport(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-28 22:07:44","endLine":259,"groupId":"3925","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ba/43da6d845148b9d5f6ba753e2cf388dc686146.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            downstream.onNext(w);\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.addThrowable(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"a07c45eeeb68b1cfc24f913c75edbc2820aadb76","commitMessage":"@@@3.x: Cleanup addThrowable.  \"2.x\" and null-value error messages (#6639)\n\n","date":"2019-08-28 22:07:44","modifiedFileCount":"106","status":"M","submitter":"David Karnok"},{"authorTime":"2019-12-17 17:19:08","codes":[{"authorDate":"2019-12-17 17:19:08","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(w);\n                        downstream.onNext(intercept);\n                        if (intercept.tryAbandon()) {\n                            w.onComplete();\n                        }\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-17 17:19:08","endLine":246,"groupId":"3925","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/48/de711a04d0ec7d5f3cc27c52d1091f9c43de93.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        downstream.onNext(w);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":158,"status":"M"},{"authorDate":"2019-12-17 17:19:08","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<T>(w);\n                            downstream.onNext(intercept);\n                            if (intercept.tryAbandon()) {\n                                w.onComplete();\n                            }\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.tryAddThrowableOrReport(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-17 17:19:08","endLine":263,"groupId":"3925","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/2e/07d3eec8f33452e6fb16ebe6874505febb83e7.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            downstream.onNext(w);\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.tryAddThrowableOrReport(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"f96821f14c91752d323877a7874f480fd6b02f12","commitMessage":"@@@3.x: Fix window (boundary.  start/end) cancel and abandonment (#6762)\n\n","date":"2019-12-17 17:19:08","modifiedFileCount":"12","status":"M","submitter":"David Karnok"},{"authorTime":"2019-12-28 03:01:34","codes":[{"authorDate":"2019-12-28 03:01:34","commitOrder":4,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<>(w);\n                        downstream.onNext(intercept);\n                        if (intercept.tryAbandon()) {\n                            w.onComplete();\n                        }\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":246,"groupId":"102296","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/50/3a5cbd2954f7a1517e68687d85ec2448e77e81.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super Observable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastSubject<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastSubject.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(w);\n                        downstream.onNext(intercept);\n                        if (intercept.tryAbandon()) {\n                            w.onComplete();\n                        }\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":158,"status":"M"},{"authorDate":"2019-12-28 03:01:34","commitOrder":4,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<>(w);\n                            downstream.onNext(intercept);\n                            if (intercept.tryAbandon()) {\n                                w.onComplete();\n                            }\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.tryAddThrowableOrReport(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":263,"groupId":"102296","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/c8/6d3faab1d1bc6bc550295d6f7ba596efa83c4a.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super Flowable<T>> downstream = this.downstream;\n            MpscLinkedQueue<Object> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (windows.get() == 0) {\n                        queue.clear();\n                        window = null;\n                        return;\n                    }\n\n                    UnicastProcessor<T> w = window;\n\n                    boolean d = done;\n\n                    if (d && errors.get() != null) {\n                        queue.clear();\n                        Throwable ex = errors.terminate();\n                        if (w != null) {\n                            window = null;\n                            w.onError(ex);\n                        }\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    Object v = queue.poll();\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        Throwable ex = errors.terminate();\n                        if (ex == null) {\n                            if (w != null) {\n                                window = null;\n                                w.onComplete();\n                            }\n                            downstream.onComplete();\n                        } else {\n                            if (w != null) {\n                                window = null;\n                                w.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        }\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (v != NEXT_WINDOW) {\n                        w.onNext((T)v);\n                        continue;\n                    }\n\n                    if (w != null) {\n                        window = null;\n                        w.onComplete();\n                    }\n\n                    if (!stopWindows.get()) {\n                        w = UnicastProcessor.create(capacityHint, this);\n                        window = w;\n                        windows.getAndIncrement();\n\n                        if (emitted != requested.get()) {\n                            emitted++;\n                            FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<T>(w);\n                            downstream.onNext(intercept);\n                            if (intercept.tryAbandon()) {\n                                w.onComplete();\n                            }\n                        } else {\n                            SubscriptionHelper.cancel(upstream);\n                            boundarySubscriber.dispose();\n                            errors.tryAddThrowableOrReport(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\"));\n                            done = true;\n                        }\n                    }\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundary.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"79f8e6dde6446b1aa33c146eaedbb958086daf56","commitMessage":"@@@3.x: Fix diamonds.  spelling.  unnecessary code (#6804)\n\n","date":"2019-12-28 03:01:34","modifiedFileCount":"463","status":"M","submitter":"David Karnok"}]
