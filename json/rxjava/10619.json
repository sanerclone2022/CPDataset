[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplaySubject<Long> replay = ReplaySubject.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Observable.unsafeCreate(new ObservableSource<Long>() {\n\n                    @Override\n                    public void subscribe(Observer<? super Long> o) {\n                        o.onSubscribe(Disposables.empty());\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            o.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        o.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","date":"2019-08-16 20:51:17","endLine":227,"groupId":"10926","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"replaySubjectConcurrentSubscriptions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/b0/d2e55aad389a77a35856ad0ca7130ac468751a.src","preCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplaySubject<Long> replay = ReplaySubject.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Observable.unsafeCreate(new ObservableSource<Long>() {\n\n                    @Override\n                    public void subscribe(Observer<? super Long> o) {\n                        o.onSubscribe(Disposables.empty());\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            o.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        o.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectConcurrencyTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplayProcessor<Long> replay = ReplayProcessor.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Flowable.unsafeCreate(new Publisher<Long>() {\n\n                    @Override\n                    public void subscribe(Subscriber<? super Long> subscriber) {\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            subscriber.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        subscriber.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","date":"2019-08-16 20:51:17","endLine":223,"groupId":"10926","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"replaySubjectConcurrentSubscriptions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f9/754a49ee824ffba98a3fc6ebec40fdd545aeeb.src","preCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplayProcessor<Long> replay = ReplayProcessor.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Flowable.unsafeCreate(new Publisher<Long>() {\n\n                    @Override\n                    public void subscribe(Subscriber<? super Long> subscriber) {\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            subscriber.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        subscriber.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/processors/ReplayProcessorConcurrencyTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-12-20 02:39:40","commitOrder":2,"curCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplaySubject<Long> replay = ReplaySubject.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Observable.unsafeCreate(new ObservableSource<Long>() {\n\n                    @Override\n                    public void subscribe(Observer<? super Long> o) {\n                        o.onSubscribe(Disposable.empty());\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            o.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        o.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","date":"2019-12-20 02:39:40","endLine":227,"groupId":"10926","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"replaySubjectConcurrentSubscriptions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/c6/08875071ac73c50e5039f7af1c54b3934f5e44.src","preCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplaySubject<Long> replay = ReplaySubject.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Observable.unsafeCreate(new ObservableSource<Long>() {\n\n                    @Override\n                    public void subscribe(Observer<? super Long> o) {\n                        o.onSubscribe(Disposables.empty());\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            o.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        o.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectConcurrencyTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"},{"authorDate":"2019-08-16 20:51:17","commitOrder":2,"curCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplayProcessor<Long> replay = ReplayProcessor.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Flowable.unsafeCreate(new Publisher<Long>() {\n\n                    @Override\n                    public void subscribe(Subscriber<? super Long> subscriber) {\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            subscriber.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        subscriber.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","date":"2019-08-16 20:51:17","endLine":223,"groupId":"10926","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"replaySubjectConcurrentSubscriptions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f9/754a49ee824ffba98a3fc6ebec40fdd545aeeb.src","preCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplayProcessor<Long> replay = ReplayProcessor.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Flowable.unsafeCreate(new Publisher<Long>() {\n\n                    @Override\n                    public void subscribe(Subscriber<? super Long> subscriber) {\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            subscriber.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        subscriber.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/processors/ReplayProcessorConcurrencyTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"N"}],"commitId":"166c529eb165b473c9bff11e8fedbde6c471b005","commitMessage":"@@@Migrate Disposables static factories to Disposable interface (#6781)\n\n","date":"2019-12-20 02:39:40","modifiedFileCount":"202","status":"M","submitter":"Jake Wharton"},{"authorTime":"2019-12-22 19:17:37","codes":[{"authorDate":"2019-12-22 19:17:37","commitOrder":3,"curCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplaySubject<Long> replay = ReplaySubject.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Observable.unsafeCreate(new ObservableSource<Long>() {\n\n                    @Override\n                    public void subscribe(Observer<? super Long> o) {\n                        o.onSubscribe(Disposable.empty());\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            o.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        o.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","date":"2019-12-22 19:17:37","endLine":227,"groupId":"10619","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"replaySubjectConcurrentSubscriptions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/76/7553dc59926a306e184b9fd25da9a0af41917f.src","preCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplaySubject<Long> replay = ReplaySubject.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Observable.unsafeCreate(new ObservableSource<Long>() {\n\n                    @Override\n                    public void subscribe(Observer<? super Long> o) {\n                        o.onSubscribe(Disposable.empty());\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            o.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        o.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/subjects/ReplaySubjectConcurrencyTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"},{"authorDate":"2019-12-22 19:17:37","commitOrder":3,"curCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplayProcessor<Long> replay = ReplayProcessor.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Flowable.unsafeCreate(new Publisher<Long>() {\n\n                    @Override\n                    public void subscribe(Subscriber<? super Long> subscriber) {\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            subscriber.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        subscriber.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","date":"2019-12-22 19:17:37","endLine":223,"groupId":"10619","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"replaySubjectConcurrentSubscriptions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/3c/acc0d67a2ce1b1a6adbc5996dac54a5f0c8b65.src","preCode":"    public void replaySubjectConcurrentSubscriptions() throws InterruptedException {\n        final ReplayProcessor<Long> replay = ReplayProcessor.create();\n        Thread source = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                Flowable.unsafeCreate(new Publisher<Long>() {\n\n                    @Override\n                    public void subscribe(Subscriber<? super Long> subscriber) {\n                        System.out.println(\"********* Start Source Data ***********\");\n                        for (long l = 1; l <= 10000; l++) {\n                            subscriber.onNext(l);\n                        }\n                        System.out.println(\"********* Finished Source Data ***********\");\n                        subscriber.onComplete();\n                    }\n                }).subscribe(replay);\n            }\n        });\n\n        \r\n        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n\n        for (int i = 1; i <= 200; i++) {\n            final int count = i;\n            if (count == 20) {\n                \r\n                \r\n                source.start();\n            }\n            if (count == 100) {\n                \r\n                source.join();\n            }\n            Thread t = new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    List<Long> values = replay.toList().blockingGet();\n                    listOfListsOfValues.add(values);\n                    System.out.println(\"Finished thread: \" + count);\n                }\n            });\n            t.start();\n            System.out.println(\"Started thread: \" + i);\n            threads.add(t);\n        }\n\n        \r\n        for (Thread t : threads) {\n            t.join();\n        }\n\n        \r\n        List<Long> sums = new ArrayList<Long>();\n        for (List<Long> values : listOfListsOfValues) {\n            long v = 0;\n            for (long l : values) {\n                v += l;\n            }\n            sums.add(v);\n        }\n\n        long expected = sums.get(0);\n        boolean success = true;\n        for (long l : sums) {\n            if (l != expected) {\n                success = false;\n                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n            }\n        }\n\n        if (success) {\n            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n        } else {\n            throw new RuntimeException(\"Concurrency Bug\");\n        }\n\n    }\n","realPath":"src/test/java/io/reactivex/rxjava3/processors/ReplayProcessorConcurrencyTest.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"}],"commitId":"0bd2a0152b64723ac3daf3e2fbad3d59c7f3bbb8","commitMessage":"@@@diamond operators in unit tests.  small packages (#6789)\n\n","date":"2019-12-22 19:17:37","modifiedFileCount":"106","status":"M","submitter":"Dmitry Volkov"}]
