[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    } else {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":317,"groupId":"4991","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/cf/98732637d190628b86d4274f080dc6efc3fcc1.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    } else {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":356,"groupId":"1934","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/59/1cdb159a958f825b2d20e26df55a570b92196b.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-12-18 03:06:44","codes":[{"authorDate":"2019-12-18 03:06:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    } else {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":316,"groupId":"5135","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/66/60d342f3c3da8ed3ea95cf31fa1d7de656e2ab.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    } else {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2019-12-18 03:06:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":355,"groupId":"1934","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/df/8eff7049771a22c351beaaa7c584b6db456f5b.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = ObjectHelper.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = ObjectHelper.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"6ba932c9a3752c6d85d65bd2292c3a47cab64fd6","commitMessage":"@@@Replace ObjectHelper.requireNonNull with Objects.requireNonNull (#6771)\n\n","date":"2019-12-18 03:06:44","modifiedFileCount":"199","status":"M","submitter":"Jake Wharton"},{"authorTime":"2020-02-12 23:26:52","codes":[{"authorDate":"2019-12-18 03:06:44","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    } else {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":316,"groupId":"102484","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/66/60d342f3c3da8ed3ea95cf31fa1d7de656e2ab.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Observer<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        ObservableSource<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        ObservableSource<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            a.onNext(w);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    } else {\n                        LeftRightEndObserver end = (LeftRightEndObserver)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"N"},{"authorDate":"2020-02-12 23:26:52","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    }\n                    else {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","date":"2020-02-12 23:26:52","endLine":355,"groupId":"102484","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/34/06b7411de882828d89056af7d04aeea9eaffae.src","preCode":"        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SpscLinkedArrayQueue<Object> q = queue;\n            Subscriber<? super R> a = downstream;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        q.clear();\n                        cancelAll();\n                        errorAll(a);\n                        return;\n                    }\n\n                    boolean d = active.get() == 0;\n\n                    Integer mode = (Integer)q.poll();\n\n                    boolean empty = mode == null;\n\n                    if (d && empty) {\n\n                        lefts.clear();\n                        rights.clear();\n                        disposables.dispose();\n\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    Object val = q.poll();\n\n                    if (mode == LEFT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TLeft left = (TLeft)val;\n\n                        int idx = leftIndex++;\n                        lefts.put(idx, left);\n\n                        Publisher<TLeftEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TRight right : rights.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == RIGHT_VALUE) {\n                        @SuppressWarnings(\"unchecked\")\n                        TRight right = (TRight)val;\n\n                        int idx = rightIndex++;\n\n                        rights.put(idx, right);\n\n                        Publisher<TRightEnd> p;\n\n                        try {\n                            p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");\n                        } catch (Throwable exc) {\n                            fail(exc, a, q);\n                            return;\n                        }\n\n                        LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);\n                        disposables.add(end);\n\n                        p.subscribe(end);\n\n                        ex = error.get();\n                        if (ex != null) {\n                            q.clear();\n                            cancelAll();\n                            errorAll(a);\n                            return;\n                        }\n\n                        long r = requested.get();\n                        long e = 0L;\n\n                        for (TLeft left : lefts.values()) {\n\n                            R w;\n\n                            try {\n                                w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");\n                            } catch (Throwable exc) {\n                                fail(exc, a, q);\n                                return;\n                            }\n\n                            if (e != r) {\n                                a.onNext(w);\n\n                                e++;\n                            } else {\n                                ExceptionHelper.addThrowable(error, new MissingBackpressureException(\"Could not emit value due to lack of requests\"));\n                                q.clear();\n                                cancelAll();\n                                errorAll(a);\n                                return;\n                            }\n                        }\n\n                        if (e != 0L) {\n                            BackpressureHelper.produced(requested, e);\n                        }\n                    }\n                    else if (mode == LEFT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        lefts.remove(end.index);\n                        disposables.remove(end);\n                    }\n                    else if (mode == RIGHT_CLOSE) {\n                        LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;\n\n                        rights.remove(end.index);\n                        disposables.remove(end);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoin.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"b3ad0752de398f4536bb88a7b1c77b0b9fbecb87","commitMessage":"@@@3.x: Add missing coverage.  fix unused/inconsistent ops (#6901)\n\n* 3.x: Add missing coverage.  fix unused/inconsistent ops\n\n* More coverage improvements and cleanup\n\n* Some more coverage\n\n* Observable coverage and cleanup\n\n* Improve Flowable internals and coverage\n\n* More Flowable operator coverage and fixes\n\n* Last set of coverage & cleanup for Flowable operators\n\n* Fix wrong use of j.u.Observable\n","date":"2020-02-12 23:26:52","modifiedFileCount":"219","status":"M","submitter":"David Karnok"}]
