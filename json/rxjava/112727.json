[{"authorTime":"2019-08-16 20:51:17","codes":[{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.addThrowable(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":350,"groupId":"10762","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/6a/ea36d5d202b81502d6c76986670a366bdefb34.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.addThrowable(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"B"},{"authorDate":"2019-08-16 20:51:17","commitOrder":1,"curCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            if (errors.addThrowable(e)) {\n                                errors.tryTerminateConsumer(downstream);\n                            } else {\n                                RxJavaPlugins.onError(e);\n                            }\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.addThrowable(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-08-16 20:51:17","endLine":555,"groupId":"10763","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/6a/ea36d5d202b81502d6c76986670a366bdefb34.src","preCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            if (errors.addThrowable(e)) {\n                                errors.tryTerminateConsumer(downstream);\n                            } else {\n                                RxJavaPlugins.onError(e);\n                            }\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.addThrowable(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":448,"status":"B"}],"commitId":"a1693ecc9215027a7a3eae75272979ebb4d79a27","commitMessage":"@@@3.x: Refactor to io.reactivex.rxjava3.** (#6621)\n\n* 3.x: Refactor to io.reactivex.rxjava3.**\n\n* fix javadoc cleanup gradle\n\n* javadoc gradle again\n\n* Fix package location in text\n","date":"2019-08-16 20:51:17","modifiedFileCount":"0","status":"B","submitter":"David Karnok"},{"authorTime":"2019-08-28 22:07:44","codes":[{"authorDate":"2019-08-28 22:07:44","commitOrder":2,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-08-28 22:07:44","endLine":345,"groupId":"1995","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/a1/1f206dde79a1961d4fc6713c4d0ad6407b23e9.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.addThrowable(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.addThrowable(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-08-28 22:07:44","commitOrder":2,"curCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-08-28 22:07:44","endLine":543,"groupId":"13070","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/a1/1f206dde79a1961d4fc6713c4d0ad6407b23e9.src","preCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            if (errors.addThrowable(e)) {\n                                errors.tryTerminateConsumer(downstream);\n                            } else {\n                                RxJavaPlugins.onError(e);\n                            }\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.addThrowable(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.addThrowable(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":439,"status":"M"}],"commitId":"a07c45eeeb68b1cfc24f913c75edbc2820aadb76","commitMessage":"@@@3.x: Cleanup addThrowable.  \"2.x\" and null-value error messages (#6639)\n\n","date":"2019-08-28 22:07:44","modifiedFileCount":"106","status":"M","submitter":"David Karnok"},{"authorTime":"2019-12-18 03:06:44","codes":[{"authorDate":"2019-12-18 03:06:44","commitOrder":3,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":345,"groupId":"1995","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f7/57fb5f3b073fb3c67d838593ad7eb04355823d.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-12-18 03:06:44","commitOrder":3,"curCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-18 03:06:44","endLine":543,"groupId":"13070","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/f7/57fb5f3b073fb3c67d838593ad7eb04355823d.src","preCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":439,"status":"M"}],"commitId":"6ba932c9a3752c6d85d65bd2292c3a47cab64fd6","commitMessage":"@@@Replace ObjectHelper.requireNonNull with Objects.requireNonNull (#6771)\n\n","date":"2019-12-18 03:06:44","modifiedFileCount":"199","status":"M","submitter":"Jake Wharton"},{"authorTime":"2019-12-28 03:01:34","codes":[{"authorDate":"2019-12-28 03:01:34","commitOrder":4,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":345,"groupId":"1995","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/98/d8ea44107c656bcd6646a41ba0ae9d64258ce8.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-12-28 03:01:34","commitOrder":4,"curCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":543,"groupId":"13070","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/98/d8ea44107c656bcd6646a41ba0ae9d64258ce8.src","preCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<R>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":439,"status":"M"}],"commitId":"79f8e6dde6446b1aa33c146eaedbb958086daf56","commitMessage":"@@@3.x: Fix diamonds.  spelling.  unnecessary code (#6804)\n\n","date":"2019-12-28 03:01:34","modifiedFileCount":"463","status":"M","submitter":"David Karnok"},{"authorTime":"2019-12-28 03:01:34","codes":[{"authorDate":"2020-02-12 23:26:52","commitOrder":5,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (!HalfSerializer.onNext(downstream, vr, this, errors)) {\n                                        return;\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2020-02-12 23:26:52","endLine":325,"groupId":"1995","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/ae/a261f5aaba92ce5fd5b709acdae927562d149c.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (get() == 0 && compareAndSet(0, 1)) {\n                                        downstream.onNext(vr);\n                                        if (!compareAndSet(1, 0)) {\n                                            errors.tryTerminateConsumer(downstream);\n                                            return;\n                                        }\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"},{"authorDate":"2019-12-28 03:01:34","commitOrder":5,"curCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2019-12-28 03:01:34","endLine":543,"groupId":"13070","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/98/d8ea44107c656bcd6646a41ba0ae9d64258ce8.src","preCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":439,"status":"N"}],"commitId":"b3ad0752de398f4536bb88a7b1c77b0b9fbecb87","commitMessage":"@@@3.x: Add missing coverage.  fix unused/inconsistent ops (#6901)\n\n* 3.x: Add missing coverage.  fix unused/inconsistent ops\n\n* More coverage improvements and cleanup\n\n* Some more coverage\n\n* Observable coverage and cleanup\n\n* Improve Flowable internals and coverage\n\n* More Flowable operator coverage and fixes\n\n* Last set of coverage & cleanup for Flowable operators\n\n* Fix wrong use of j.u.Observable\n","date":"2020-02-12 23:26:52","modifiedFileCount":"219","status":"M","submitter":"David Karnok"},{"authorTime":"2020-10-05 20:07:15","codes":[{"authorDate":"2020-10-05 20:07:15","commitOrder":6,"curCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (!HalfSerializer.onNext(downstream, vr, this, errors)) {\n                                        return;\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2020-10-05 20:07:15","endLine":325,"groupId":"112727","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/94/09bc7a2e17e23d1d2b16a7052bcb4781d0e8c9.src","preCode":"        void drain() {\n            if (wip.getAndIncrement() == 0) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n                        boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            downstream.onComplete();\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    upstream.cancel();\n                                    errors.tryAddThrowableOrReport(e);\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    if (!HalfSerializer.onNext(downstream, vr, this, errors)) {\n                                        return;\n                                    }\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (wip.decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"},{"authorDate":"2020-10-05 20:07:15","commitOrder":6,"curCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","date":"2020-10-05 20:07:15","endLine":525,"groupId":"112727","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"drain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-rxjava-10-0.7/blobInfo/CC_OUT/blobs/94/09bc7a2e17e23d1d2b16a7052bcb4781d0e8c9.src","preCode":"        void drain() {\n            if (getAndIncrement() == 0) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!active) {\n\n                        boolean d = done;\n\n                        if (d && !veryEnd) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (!empty) {\n                            Publisher<? extends R> p;\n\n                            try {\n                                p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n\n                                upstream.cancel();\n                                errors.tryAddThrowableOrReport(e);\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n\n                            if (sourceMode != QueueSubscription.SYNC) {\n                                int c = consumed + 1;\n                                if (c == limit) {\n                                    consumed = 0;\n                                    upstream.request(c);\n                                } else {\n                                    consumed = c;\n                                }\n                            }\n\n                            if (p instanceof Supplier) {\n                                @SuppressWarnings(\"unchecked\")\n                                Supplier<R> supplier = (Supplier<R>) p;\n\n                                R vr;\n\n                                try {\n                                    vr = supplier.get();\n                                } catch (Throwable e) {\n                                    Exceptions.throwIfFatal(e);\n                                    errors.tryAddThrowableOrReport(e);\n                                    if (!veryEnd) {\n                                        upstream.cancel();\n                                        errors.tryTerminateConsumer(downstream);\n                                        return;\n                                    }\n                                    vr = null;\n                                }\n\n                                if (vr == null) {\n                                    continue;\n                                }\n\n                                if (inner.isUnbounded()) {\n                                    downstream.onNext(vr);\n                                    continue;\n                                } else {\n                                    active = true;\n                                    inner.setSubscription(new WeakScalarSubscription<>(vr, inner));\n                                }\n                            } else {\n                                active = true;\n                                p.subscribe(inner);\n                            }\n                        }\n                    }\n                    if (decrementAndGet() == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n","realPath":"src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.java","repoName":"rxjava","snippetEndLine":0,"snippetStartLine":0,"startLine":421,"status":"M"}],"commitId":"0668d042b47d3585f856af831bd3b1e1742c080f","commitMessage":"@@@3.x: Fix Flowable.concatMap backpressure w/ scalars (#7089)\n\n","date":"2020-10-05 20:07:15","modifiedFileCount":"4","status":"M","submitter":"David Karnok"}]
