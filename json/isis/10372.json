[{"authorTime":"2021-04-14 23:26:49","codes":[{"authorDate":"2021-04-14 23:26:49","commitOrder":1,"curCode":"\tpublic void testTransactionCommitWithDataSource() throws SQLException {\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tTransactionTemplate tt = new TransactionTemplate();\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\n\t\tverify(pm).close();\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","date":"2021-04-14 23:26:49","endLine":620,"groupId":"4822","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransactionCommitWithDataSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-isis-10-0.7/blobInfo/CC_OUT/blobs/89/56d6d10401f84d79ae1c4d8e197572319e76d5.src","preCode":"\tpublic void testTransactionCommitWithDataSource() throws SQLException {\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tTransactionTemplate tt = new TransactionTemplate();\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\n\t\tverify(pm).close();\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","realPath":"persistence/jdo/spring/src/test/java/org/apache/isis/persistence/jdo/spring/test/integration/JdoTransactionManagerTests.java","repoName":"isis","snippetEndLine":0,"snippetStartLine":0,"startLine":581,"status":"B"},{"authorDate":"2021-04-14 23:26:49","commitOrder":1,"curCode":"\tprivate void doTestExistingTransactionWithPropagationNestedAndRollback(final boolean manualSavepoint)\n\t\t\tthrows SQLException {\n\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tDatabaseMetaData md = mock(DatabaseMetaData.class);\n\t\tSavepoint sp = mock(Savepoint.class);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tgiven(md.supportsSavepoints()).willReturn(true);\n\t\tgiven(con.getMetaData()).willReturn(md);\n\t\tgiven(con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1)).willReturn(sp);\n\t\tfinal TransactionTemplate tt = new TransactionTemplate();\n\t\ttt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\t\tgiven(tx.isActive()).willReturn(!manualSavepoint);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setNestedTransactionAllowed(true);\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tif (manualSavepoint) {\n\t\t\t\t\tObject savepoint = status.createSavepoint();\n\t\t\t\t\tstatus.rollbackToSavepoint(savepoint);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttt.execute(new TransactionCallbackWithoutResult() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void doInTransactionWithoutResult(TransactionStatus status) {\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread session\");\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread connection\");\n\t\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true).flush();\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\t\tverify(pm).flush();\n\t\tverify(pm).close();\n\t\tverify(con).setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1);\n\t\tverify(con).rollback(sp);\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","date":"2021-04-14 23:26:49","endLine":781,"groupId":"4824","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doTestExistingTransactionWithPropagationNestedAndRollback","params":"(finalbooleanmanualSavepoint)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-isis-10-0.7/blobInfo/CC_OUT/blobs/89/56d6d10401f84d79ae1c4d8e197572319e76d5.src","preCode":"\tprivate void doTestExistingTransactionWithPropagationNestedAndRollback(final boolean manualSavepoint)\n\t\t\tthrows SQLException {\n\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tDatabaseMetaData md = mock(DatabaseMetaData.class);\n\t\tSavepoint sp = mock(Savepoint.class);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tgiven(md.supportsSavepoints()).willReturn(true);\n\t\tgiven(con.getMetaData()).willReturn(md);\n\t\tgiven(con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1)).willReturn(sp);\n\t\tfinal TransactionTemplate tt = new TransactionTemplate();\n\t\ttt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\t\tgiven(tx.isActive()).willReturn(!manualSavepoint);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setNestedTransactionAllowed(true);\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tif (manualSavepoint) {\n\t\t\t\t\tObject savepoint = status.createSavepoint();\n\t\t\t\t\tstatus.rollbackToSavepoint(savepoint);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttt.execute(new TransactionCallbackWithoutResult() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void doInTransactionWithoutResult(TransactionStatus status) {\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread session\");\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread connection\");\n\t\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true).flush();\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\t\tverify(pm).flush();\n\t\tverify(pm).close();\n\t\tverify(con).setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1);\n\t\tverify(con).rollback(sp);\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","realPath":"persistence/jdo/spring/src/test/java/org/apache/isis/persistence/jdo/spring/test/integration/JdoTransactionManagerTests.java","repoName":"isis","snippetEndLine":0,"snippetStartLine":0,"startLine":716,"status":"B"}],"commitId":"75633e1f8ce37deb39e3c2e2644357af15365d05","commitMessage":"@@@Merge branch 'master' of https://github.com/apache/isis into ISIS-2505_Catch_Up_With_Demo_Examples\n","date":"2021-04-14 23:26:49","modifiedFileCount":"1999","status":"B","submitter":"J?rg Rade"},{"authorTime":"2021-08-19 14:53:32","codes":[{"authorDate":"2021-08-19 14:53:32","commitOrder":2,"curCode":"\tpublic void testTransactionCommitWithDataSource() throws SQLException {\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tTransactionTemplate tt = new TransactionTemplate();\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(final TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\n\t\tverify(pm).close();\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","date":"2021-08-19 14:53:32","endLine":621,"groupId":"10372","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testTransactionCommitWithDataSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-isis-10-0.7/blobInfo/CC_OUT/blobs/b9/096e403d26b11002576163d6bab6b11390671a.src","preCode":"\tpublic void testTransactionCommitWithDataSource() throws SQLException {\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tTransactionTemplate tt = new TransactionTemplate();\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\n\t\tverify(pm).close();\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","realPath":"persistence/jdo/spring/src/test/java/org/apache/isis/persistence/jdo/spring/test/integration/JdoTransactionManagerTests.java","repoName":"isis","snippetEndLine":0,"snippetStartLine":0,"startLine":582,"status":"M"},{"authorDate":"2021-08-19 14:53:32","commitOrder":2,"curCode":"\tprivate void doTestExistingTransactionWithPropagationNestedAndRollback(final boolean manualSavepoint)\n\t\t\tthrows SQLException {\n\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tDatabaseMetaData md = mock(DatabaseMetaData.class);\n\t\tSavepoint sp = mock(Savepoint.class);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tgiven(md.supportsSavepoints()).willReturn(true);\n\t\tgiven(con.getMetaData()).willReturn(md);\n\t\tgiven(con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1)).willReturn(sp);\n\t\tfinal TransactionTemplate tt = new TransactionTemplate();\n\t\ttt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\t\tgiven(tx.isActive()).willReturn(!manualSavepoint);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setNestedTransactionAllowed(true);\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(final TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tif (manualSavepoint) {\n\t\t\t\t\tObject savepoint = status.createSavepoint();\n\t\t\t\t\tstatus.rollbackToSavepoint(savepoint);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttt.execute(new TransactionCallbackWithoutResult() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void doInTransactionWithoutResult(final TransactionStatus status) {\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread session\");\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread connection\");\n\t\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true).flush();\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\t\tverify(pm).flush();\n\t\tverify(pm).close();\n\t\tverify(con).setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1);\n\t\tverify(con).rollback(sp);\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","date":"2021-08-19 14:53:32","endLine":782,"groupId":"10372","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"doTestExistingTransactionWithPropagationNestedAndRollback","params":"(finalbooleanmanualSavepoint)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-isis-10-0.7/blobInfo/CC_OUT/blobs/b9/096e403d26b11002576163d6bab6b11390671a.src","preCode":"\tprivate void doTestExistingTransactionWithPropagationNestedAndRollback(final boolean manualSavepoint)\n\t\t\tthrows SQLException {\n\n\t\tfinal DataSource ds = mock(DataSource.class);\n\t\tJdoDialect dialect = mock(JdoDialect.class);\n\t\tfinal Connection con = mock(Connection.class);\n\t\tDatabaseMetaData md = mock(DatabaseMetaData.class);\n\t\tSavepoint sp = mock(Savepoint.class);\n\n\t\tgiven(pmf.getPersistenceManager()).willReturn(pm);\n\t\tgiven(pm.currentTransaction()).willReturn(tx);\n\t\tgiven(md.supportsSavepoints()).willReturn(true);\n\t\tgiven(con.getMetaData()).willReturn(md);\n\t\tgiven(con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1)).willReturn(sp);\n\t\tfinal TransactionTemplate tt = new TransactionTemplate();\n\t\ttt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED);\n\t\tConnectionHandle conHandle = new SimpleConnectionHandle(con);\n\t\tgiven(dialect.getJdbcConnection(pm, false)).willReturn(conHandle);\n\t\tgiven(tx.isActive()).willReturn(!manualSavepoint);\n\n\t\tJdoTransactionManager tm = new JdoTransactionManager();\n\t\ttm.setNestedTransactionAllowed(true);\n\t\ttm.setPersistenceManagerFactory(pmf);\n\t\ttm.setDataSource(ds);\n\t\ttm.setJdoDialect(dialect);\n\t\ttt.setTransactionManager(tm);\n\t\tval l = new ArrayList<Object>();\n\t\tl.add(\"test\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\n\t\tObject result = tt.execute(new TransactionCallback<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object doInTransaction(TransactionStatus status) {\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread pm\");\n\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread con\");\n\t\t\t\tif (manualSavepoint) {\n\t\t\t\t\tObject savepoint = status.createSavepoint();\n\t\t\t\t\tstatus.rollbackToSavepoint(savepoint);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttt.execute(new TransactionCallbackWithoutResult() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void doInTransactionWithoutResult(TransactionStatus status) {\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(pmf), \"Has thread session\");\n\t\t\t\t\t\t\tassertTrue(TransactionSynchronizationManager.hasResource(ds), \"Has thread connection\");\n\t\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tPersistenceManagerFactoryUtils.getPersistenceManager(pmf, true).flush();\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\t\tassertTrue(result == l, \"Correct result list\");\n\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(pmf), \"Hasn't thread pm\");\n\t\tassertTrue(!TransactionSynchronizationManager.hasResource(ds), \"Hasn't thread con\");\n\t\tverify(pm).flush();\n\t\tverify(pm).close();\n\t\tverify(con).setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1);\n\t\tverify(con).rollback(sp);\n\t\tverify(dialect).beginTransaction(tx, tt);\n\t\tverify(dialect).releaseJdbcConnection(conHandle, pm);\n\t\tverify(dialect).cleanupTransaction(null);\n\t\tverify(tx).commit();\n\t}\n","realPath":"persistence/jdo/spring/src/test/java/org/apache/isis/persistence/jdo/spring/test/integration/JdoTransactionManagerTests.java","repoName":"isis","snippetEndLine":0,"snippetStartLine":0,"startLine":717,"status":"M"}],"commitId":"751cba2033a31d7dbbf22831a4925564e86235bd","commitMessage":"@@@ISIS-2845: Reinstate automatic injection into entities when resolved","date":"2021-08-19 14:53:32","modifiedFileCount":"6","status":"M","submitter":"Andi Huber"}]
