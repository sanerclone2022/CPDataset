[{"authorTime":"2017-10-24 18:16:08","codes":[{"authorDate":"2017-10-24 18:16:08","commitOrder":1,"curCode":"\tpublic void testFailureClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.add((ByteBuf) msg);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tList<Future<KvStateResponse>> futures = new ArrayList<>();\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\n\t\t\tByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tbuf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tassertEquals(1L, stats.getNumConnections());\n\n\t\t\tChannel ch = channel.get();\n\t\t\tassertNotNull(\"Channel not active\", ch);\n\n\t\t\t\r\n\t\t\tch.writeAndFlush(MessageSerializer.serializeServerFailure(\n\t\t\t\t\tserverChannel.alloc(),\n\t\t\t\t\tnew RuntimeException(\"Expected test server failure\")));\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(2L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(2L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\tclient.shutdown();\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","date":"2017-10-27 00:57:34","endLine":479,"groupId":"35833","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testFailureClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/a4deb953675c663609665b346e72329a9b4e6b.src","preCode":"\tpublic void testFailureClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.add((ByteBuf) msg);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tList<Future<KvStateResponse>> futures = new ArrayList<>();\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\n\t\t\tByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tbuf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tassertEquals(1L, stats.getNumConnections());\n\n\t\t\tChannel ch = channel.get();\n\t\t\tassertNotNull(\"Channel not active\", ch);\n\n\t\t\t\r\n\t\t\tch.writeAndFlush(MessageSerializer.serializeServerFailure(\n\t\t\t\t\tserverChannel.alloc(),\n\t\t\t\t\tnew RuntimeException(\"Expected test server failure\")));\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(2L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(2L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\tclient.shutdown();\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":381,"status":"B"},{"authorDate":"2017-10-24 18:16:08","commitOrder":1,"curCode":"\tpublic void testServerClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal AtomicBoolean received = new AtomicBoolean();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.set(true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\t\t\tFuture<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n\t\t\twhile (!received.get() && deadline.hasTimeLeft()) {\n\t\t\t\tThread.sleep(50L);\n\t\t\t}\n\t\t\tassertTrue(\"Receive timed out\", received.get());\n\n\t\t\tassertEquals(1, stats.getNumConnections());\n\n\t\t\tchannel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\n\t\t\ttry {\n\t\t\t\tfuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tif (!(e.getCause() instanceof ClosedChannelException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(1L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(1L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\tclient.shutdown();\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","date":"2017-10-27 00:57:34","endLine":560,"groupId":"35832","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testServerClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/a4deb953675c663609665b346e72329a9b4e6b.src","preCode":"\tpublic void testServerClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal AtomicBoolean received = new AtomicBoolean();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.set(true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\t\t\tFuture<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n\t\t\twhile (!received.get() && deadline.hasTimeLeft()) {\n\t\t\t\tThread.sleep(50L);\n\t\t\t}\n\t\t\tassertTrue(\"Receive timed out\", received.get());\n\n\t\t\tassertEquals(1, stats.getNumConnections());\n\n\t\t\tchannel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\n\t\t\ttry {\n\t\t\t\tfuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tif (!(e.getCause() instanceof ClosedChannelException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(1L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(1L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\tclient.shutdown();\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":486,"status":"B"}],"commitId":"0c771505b84cdacf7a359c3be0efe38a30f9e660","commitMessage":"@@@[FLINK-7908][QS] Restructure the queryable state module.\n\nThe QS module is split into core and client. The core should\nbe put in the lib folder to enable queryable state.  while the\nclient is the one that the user will program against. The\nreason for the restructuring in mainly to remove the dependency\non the flink-runtime from the user's program.\n","date":"2017-10-27 00:57:34","modifiedFileCount":"23","status":"B","submitter":"kkloudas"},{"authorTime":"2017-11-10 02:21:43","codes":[{"authorDate":"2017-11-10 02:21:43","commitOrder":2,"curCode":"\tpublic void testFailureClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.add((ByteBuf) msg);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tList<Future<KvStateResponse>> futures = new ArrayList<>();\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\n\t\t\tByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tbuf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tassertEquals(1L, stats.getNumConnections());\n\n\t\t\tChannel ch = channel.get();\n\t\t\tassertNotNull(\"Channel not active\", ch);\n\n\t\t\t\r\n\t\t\tch.writeAndFlush(MessageSerializer.serializeServerFailure(\n\t\t\t\t\tserverChannel.alloc(),\n\t\t\t\t\tnew RuntimeException(\"Expected test server failure\")));\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(2L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(2L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\ttry {\n\t\t\t\t\tclient.shutdown().get(10L, TimeUnit.SECONDS);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tAssert.assertTrue(client.isEventGroupShutdown());\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","date":"2017-12-06 21:33:16","endLine":519,"groupId":"35833","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testFailureClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/86/38efa680fc0661af6a04f623e9994a78335ecc.src","preCode":"\tpublic void testFailureClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.add((ByteBuf) msg);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tList<Future<KvStateResponse>> futures = new ArrayList<>();\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\t\t\tfutures.add(client.sendRequest(serverAddress, request));\n\n\t\t\tByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tbuf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\tassertNotNull(\"Receive timed out\", buf);\n\t\t\tbuf.release();\n\n\t\t\tassertEquals(1L, stats.getNumConnections());\n\n\t\t\tChannel ch = channel.get();\n\t\t\tassertNotNull(\"Channel not active\", ch);\n\n\t\t\t\r\n\t\t\tch.writeAndFlush(MessageSerializer.serializeServerFailure(\n\t\t\t\t\tserverChannel.alloc(),\n\t\t\t\t\tnew RuntimeException(\"Expected test server failure\")));\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfutures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\n\t\t\t\tif (!(e.getCause() instanceof RuntimeException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(2L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(2L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\tclient.shutdown();\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"M"},{"authorDate":"2017-11-10 02:21:43","commitOrder":2,"curCode":"\tpublic void testServerClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal AtomicBoolean received = new AtomicBoolean();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.set(true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\t\t\tFuture<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n\t\t\twhile (!received.get() && deadline.hasTimeLeft()) {\n\t\t\t\tThread.sleep(50L);\n\t\t\t}\n\t\t\tassertTrue(\"Receive timed out\", received.get());\n\n\t\t\tassertEquals(1, stats.getNumConnections());\n\n\t\t\tchannel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\n\t\t\ttry {\n\t\t\t\tfuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tif (!(e.getCause() instanceof ClosedChannelException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(1L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(1L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\ttry {\n\t\t\t\t\tclient.shutdown().get(10L, TimeUnit.SECONDS);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tAssert.assertTrue(client.isEventGroupShutdown());\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","date":"2017-12-06 21:33:16","endLine":605,"groupId":"35832","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testServerClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/86/38efa680fc0661af6a04f623e9994a78335ecc.src","preCode":"\tpublic void testServerClosesChannel() throws Exception {\n\t\tDeadline deadline = TEST_TIMEOUT.fromNow();\n\t\tAtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n\t\tfinal MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n\t\t\t\tnew MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer());\n\n\t\tClient<KvStateInternalRequest, KvStateResponse> client = null;\n\t\tChannel serverChannel = null;\n\n\t\ttry {\n\t\t\tclient = new Client<>(\"Test Client\", 1, serializer, stats);\n\n\t\t\tfinal AtomicBoolean received = new AtomicBoolean();\n\t\t\tfinal AtomicReference<Channel> channel = new AtomicReference<>();\n\n\t\t\tserverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {\n\t\t\t\t@Override\n\t\t\t\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\t\t\t\tchannel.set(ctx.channel());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\t\t\t\treceived.set(true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tInetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n\t\t\t\r\n\t\t\tKvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\t\t\tFuture<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n\t\t\twhile (!received.get() && deadline.hasTimeLeft()) {\n\t\t\t\tThread.sleep(50L);\n\t\t\t}\n\t\t\tassertTrue(\"Receive timed out\", received.get());\n\n\t\t\tassertEquals(1, stats.getNumConnections());\n\n\t\t\tchannel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\n\t\t\ttry {\n\t\t\t\tfuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\t\t\t\tfail(\"Did not throw expected server failure\");\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tif (!(e.getCause() instanceof ClosedChannelException)) {\n\t\t\t\t\tfail(\"Did not throw expected Exception\");\n\t\t\t\t}\n\t\t\t\t\r\n\t\t\t}\n\n\t\t\tassertEquals(0L, stats.getNumConnections());\n\n\t\t\t\r\n\t\t\twhile (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\n\t\t\tassertEquals(1L, stats.getNumRequests());\n\t\t\tassertEquals(0L, stats.getNumSuccessful());\n\t\t\tassertEquals(1L, stats.getNumFailed());\n\t\t} finally {\n\t\t\tif (client != null) {\n\t\t\t\tclient.shutdown();\n\t\t\t}\n\n\t\t\tif (serverChannel != null) {\n\t\t\t\tserverChannel.close();\n\t\t\t}\n\n\t\t\tassertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n\t\t}\n\t}\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":526,"status":"M"}],"commitId":"5760677b3bb26245ca4816548833da0257ec7c7a","commitMessage":"@@@[FLINK-7975][QS] Wait for QS client to shutdown.\n","date":"2017-12-06 21:33:16","modifiedFileCount":"4","status":"M","submitter":"kkloudas"},{"authorTime":"2021-08-18 01:58:34","codes":[{"authorDate":"2021-08-18 01:58:34","commitOrder":3,"curCode":"    public void testFailureClosesChannel() throws Exception {\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(\n                            new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx)\n                                        throws Exception {\n                                    channel.set(ctx.channel());\n                                }\n\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg)\n                                        throws Exception {\n                                    received.add((ByteBuf) msg);\n                                }\n                            });\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            List<Future<KvStateResponse>> futures = new ArrayList<>();\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n            futures.add(client.sendRequest(serverAddress, request));\n            futures.add(client.sendRequest(serverAddress, request));\n\n            ByteBuf buf = received.take();\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            buf = received.take();\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            assertEquals(1L, stats.getNumConnections());\n\n            Channel ch = channel.get();\n            assertNotNull(\"Channel not active\", ch);\n\n            \r\n            ch.writeAndFlush(\n                    MessageSerializer.serializeServerFailure(\n                            serverChannel.alloc(),\n                            new RuntimeException(\"Expected test server failure\")));\n\n            try {\n                futures.remove(0).get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            try {\n                futures.remove(0).get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(2L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(2L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","date":"2021-08-18 01:58:34","endLine":532,"groupId":"36810","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testFailureClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/80/134fcc790af2072290c667ffdffd6ee6f1cfa5.src","preCode":"    public void testFailureClosesChannel() throws Exception {\n        Deadline deadline = TEST_TIMEOUT.fromNow();\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(\n                            new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx)\n                                        throws Exception {\n                                    channel.set(ctx.channel());\n                                }\n\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg)\n                                        throws Exception {\n                                    received.add((ByteBuf) msg);\n                                }\n                            });\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            List<Future<KvStateResponse>> futures = new ArrayList<>();\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n            futures.add(client.sendRequest(serverAddress, request));\n            futures.add(client.sendRequest(serverAddress, request));\n\n            ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            assertEquals(1L, stats.getNumConnections());\n\n            Channel ch = channel.get();\n            assertNotNull(\"Channel not active\", ch);\n\n            \r\n            ch.writeAndFlush(\n                    MessageSerializer.serializeServerFailure(\n                            serverChannel.alloc(),\n                            new RuntimeException(\"Expected test server failure\")));\n\n            try {\n                futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            try {\n                futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (deadline.hasTimeLeft()\n                    && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(2L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(2L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get(10L, TimeUnit.SECONDS);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":422,"status":"M"},{"authorDate":"2021-08-18 01:58:34","commitOrder":3,"curCode":"    public void testServerClosesChannel() throws Exception {\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final AtomicBoolean received = new AtomicBoolean();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(\n                            new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx)\n                                        throws Exception {\n                                    channel.set(ctx.channel());\n                                }\n\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg)\n                                        throws Exception {\n                                    received.set(true);\n                                }\n                            });\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n            Future<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n            while (!received.get()) {\n                Thread.sleep(50L);\n            }\n            assertTrue(\"Receive timed out\", received.get());\n\n            assertEquals(1, stats.getNumConnections());\n\n            channel.get().close().await();\n\n            try {\n                future.get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n                if (!(e.getCause() instanceof ClosedChannelException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(1L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(1L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","date":"2021-08-18 01:58:34","endLine":624,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testServerClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/80/134fcc790af2072290c667ffdffd6ee6f1cfa5.src","preCode":"    public void testServerClosesChannel() throws Exception {\n        Deadline deadline = TEST_TIMEOUT.fromNow();\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final AtomicBoolean received = new AtomicBoolean();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(\n                            new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx)\n                                        throws Exception {\n                                    channel.set(ctx.channel());\n                                }\n\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg)\n                                        throws Exception {\n                                    received.set(true);\n                                }\n                            });\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n            Future<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n            while (!received.get() && deadline.hasTimeLeft()) {\n                Thread.sleep(50L);\n            }\n            assertTrue(\"Receive timed out\", received.get());\n\n            assertEquals(1, stats.getNumConnections());\n\n            channel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n\n            try {\n                future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n                if (!(e.getCause() instanceof ClosedChannelException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (deadline.hasTimeLeft()\n                    && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(1L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(1L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get(10L, TimeUnit.SECONDS);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":539,"status":"M"}],"commitId":"650d463f5133b91551a5cbe96963e3fc678aebf0","commitMessage":"@@@[FLINK-23362][tests] Remove timeouts\n\n","date":"2021-08-18 01:58:34","modifiedFileCount":"1","status":"M","submitter":"Chesnay Schepler"},{"authorTime":"2021-08-21 01:14:41","codes":[{"authorDate":"2021-08-21 01:14:41","commitOrder":4,"curCode":"    public void testFailureClosesChannel() throws Exception {\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(new ChannelDataCollectingHandler(channel, received));\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            List<Future<KvStateResponse>> futures = new ArrayList<>();\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n            futures.add(client.sendRequest(serverAddress, request));\n            futures.add(client.sendRequest(serverAddress, request));\n\n            ByteBuf buf = received.take();\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            buf = received.take();\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            assertEquals(1L, stats.getNumConnections());\n\n            Channel ch = channel.get();\n            assertNotNull(\"Channel not active\", ch);\n\n            \r\n            ch.writeAndFlush(\n                    MessageSerializer.serializeServerFailure(\n                            serverChannel.alloc(),\n                            new RuntimeException(\"Expected test server failure\")));\n\n            try {\n                futures.remove(0).get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            try {\n                futures.remove(0).get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(2L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(2L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","date":"2021-08-30 16:57:49","endLine":481,"groupId":"102461","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testFailureClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/75/16d766b03eb09c079812f17dbc70703315230a.src","preCode":"    public void testFailureClosesChannel() throws Exception {\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(\n                            new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx)\n                                        throws Exception {\n                                    channel.set(ctx.channel());\n                                }\n\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg)\n                                        throws Exception {\n                                    received.add((ByteBuf) msg);\n                                }\n                            });\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            List<Future<KvStateResponse>> futures = new ArrayList<>();\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n\n            futures.add(client.sendRequest(serverAddress, request));\n            futures.add(client.sendRequest(serverAddress, request));\n\n            ByteBuf buf = received.take();\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            buf = received.take();\n            assertNotNull(\"Receive timed out\", buf);\n            buf.release();\n\n            assertEquals(1L, stats.getNumConnections());\n\n            Channel ch = channel.get();\n            assertNotNull(\"Channel not active\", ch);\n\n            \r\n            ch.writeAndFlush(\n                    MessageSerializer.serializeServerFailure(\n                            serverChannel.alloc(),\n                            new RuntimeException(\"Expected test server failure\")));\n\n            try {\n                futures.remove(0).get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            try {\n                futures.remove(0).get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n\n                if (!(e.getCause() instanceof RuntimeException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(2L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(2L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"M"},{"authorDate":"2021-08-21 01:14:41","commitOrder":4,"curCode":"    public void testServerClosesChannel() throws Exception {\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(new ChannelDataCollectingHandler(channel, received));\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n            Future<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n            received.take();\n\n            assertEquals(1, stats.getNumConnections());\n\n            channel.get().close().await();\n\n            try {\n                future.get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n                if (!(e.getCause() instanceof ClosedChannelException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(1L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(1L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","date":"2021-08-30 16:57:49","endLine":557,"groupId":"102461","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testServerClosesChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/75/16d766b03eb09c079812f17dbc70703315230a.src","preCode":"    public void testServerClosesChannel() throws Exception {\n        AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats();\n\n        final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =\n                new MessageSerializer<>(\n                        new KvStateInternalRequest.KvStateInternalRequestDeserializer(),\n                        new KvStateResponse.KvStateResponseDeserializer());\n\n        Client<KvStateInternalRequest, KvStateResponse> client = null;\n        Channel serverChannel = null;\n\n        try {\n            client = new Client<>(\"Test Client\", 1, serializer, stats);\n\n            final AtomicBoolean received = new AtomicBoolean();\n            final AtomicReference<Channel> channel = new AtomicReference<>();\n\n            serverChannel =\n                    createServerChannel(\n                            new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx)\n                                        throws Exception {\n                                    channel.set(ctx.channel());\n                                }\n\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg)\n                                        throws Exception {\n                                    received.set(true);\n                                }\n                            });\n\n            InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel);\n\n            \r\n            KvStateInternalRequest request =\n                    new KvStateInternalRequest(new KvStateID(), new byte[0]);\n            Future<KvStateResponse> future = client.sendRequest(serverAddress, request);\n\n            while (!received.get()) {\n                Thread.sleep(50L);\n            }\n            assertTrue(\"Receive timed out\", received.get());\n\n            assertEquals(1, stats.getNumConnections());\n\n            channel.get().close().await();\n\n            try {\n                future.get();\n                fail(\"Did not throw expected server failure\");\n            } catch (ExecutionException e) {\n                if (!(e.getCause() instanceof ClosedChannelException)) {\n                    fail(\"Did not throw expected Exception\");\n                }\n                \r\n            }\n\n            assertEquals(0L, stats.getNumConnections());\n\n            \r\n            while (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L) {\n                Thread.sleep(100L);\n            }\n\n            assertEquals(1L, stats.getNumRequests());\n            assertEquals(0L, stats.getNumSuccessful());\n            assertEquals(1L, stats.getNumFailed());\n        } finally {\n            if (client != null) {\n                try {\n                    client.shutdown().get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                Assert.assertTrue(client.isEventGroupShutdown());\n            }\n\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n\n            assertEquals(\"Channel leak\", 0L, stats.getNumConnections());\n        }\n    }\n","realPath":"flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":488,"status":"M"}],"commitId":"bad537d6b4517341e33253354d6273153e571747","commitMessage":"@@@[FLINK-9925][tests] Harden ClientTest by making handler shareable\n\nThis commit makes the handler that is used for the testConcurrentQueries shareable so\nthat Netty won't fail if another pipeline is created.\n","date":"2021-08-30 16:57:49","modifiedFileCount":"1","status":"M","submitter":"Till Rohrmann"}]
