[{"authorTime":"2017-09-27 21:10:52","codes":[{"authorDate":"2017-09-27 21:10:52","commitOrder":1,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tverify(stateBackend).createStreamFactory(\n\t\t\tany(JobID.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCheckpointStreamFactory streamFactory = stateContext.checkpointStreamFactory();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(streamFactory);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","date":"2018-01-22 21:06:37","endLine":143,"groupId":"32173","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/34/95bc04d7d2a6a17245249cc1ce69ce01702f39.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tverify(stateBackend).createStreamFactory(\n\t\t\tany(JobID.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCheckpointStreamFactory streamFactory = stateContext.checkpointStreamFactory();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(streamFactory);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"},{"authorDate":"2017-09-27 21:10:52","commitOrder":1,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic StreamStateHandle resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStreamFactory createStreamFactory(\n\t\t\t\tJobID jobId, String operatorIdentifier) throws IOException {\n\t\t\t\treturn mock(CheckpointStreamFactory.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStreamFactory createSavepointStreamFactory(\n\t\t\t\tJobID jobId, String operatorIdentifier, @Nullable String targetLocation) throws IOException {\n\t\t\t\treturn mock(CheckpointStreamFactory.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tverify(mockingBackend).createStreamFactory(\n\t\t\tany(JobID.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCheckpointStreamFactory streamFactory = stateContext.checkpointStreamFactory();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(streamFactory);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-01-22 21:06:37","endLine":289,"groupId":"32173","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/34/95bc04d7d2a6a17245249cc1ce69ce01702f39.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic StreamStateHandle resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStreamFactory createStreamFactory(\n\t\t\t\tJobID jobId, String operatorIdentifier) throws IOException {\n\t\t\t\treturn mock(CheckpointStreamFactory.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStreamFactory createSavepointStreamFactory(\n\t\t\t\tJobID jobId, String operatorIdentifier, @Nullable String targetLocation) throws IOException {\n\t\t\t\treturn mock(CheckpointStreamFactory.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tverify(mockingBackend).createStreamFactory(\n\t\t\tany(JobID.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCheckpointStreamFactory streamFactory = stateContext.checkpointStreamFactory();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(streamFactory);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"B"}],"commitId":"517b3f87214168a445b5751cda210ecf3a292fd6","commitMessage":"@@@[FLINK-7720] [checkpoints] Centralize creation of backends and state related resources\n\nThis closes #4745.\n","date":"2018-01-22 21:06:37","modifiedFileCount":"69","status":"B","submitter":"Stefan Richter"},{"authorTime":"2018-01-11 00:14:06","codes":[{"authorDate":"2018-01-11 00:14:06","commitOrder":2,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","date":"2018-02-01 20:54:55","endLine":134,"groupId":"32173","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6b/69707bc6de2f4d546bfef7b3f6ec197131148e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tverify(stateBackend).createStreamFactory(\n\t\t\tany(JobID.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCheckpointStreamFactory streamFactory = stateContext.checkpointStreamFactory();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(streamFactory);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"},{"authorDate":"2018-01-11 00:14:06","commitOrder":2,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic StreamStateHandle resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-02-01 20:54:55","endLine":262,"groupId":"32173","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6b/69707bc6de2f4d546bfef7b3f6ec197131148e.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic StreamStateHandle resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStreamFactory createStreamFactory(\n\t\t\t\tJobID jobId, String operatorIdentifier) throws IOException {\n\t\t\t\treturn mock(CheckpointStreamFactory.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStreamFactory createSavepointStreamFactory(\n\t\t\t\tJobID jobId, String operatorIdentifier, @Nullable String targetLocation) throws IOException {\n\t\t\t\treturn mock(CheckpointStreamFactory.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tverify(mockingBackend).createStreamFactory(\n\t\t\tany(JobID.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCheckpointStreamFactory streamFactory = stateContext.checkpointStreamFactory();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(streamFactory);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":138,"status":"M"}],"commitId":"1887187f6b5c210d2091c69ef14fa8b8a5cae82c","commitMessage":"@@@[FLINK-8531] [checkpoints] (part 6) Tasks resolve CheckpointStreamFactory from CheckpointStorage and Checkpoint Location Reference to persist checkpoint data.\n","date":"2018-02-01 20:54:55","modifiedFileCount":"39","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2018-01-31 23:57:45","codes":[{"authorDate":"2018-01-11 00:14:06","commitOrder":3,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","date":"2018-02-01 20:54:55","endLine":134,"groupId":"32173","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6b/69707bc6de2f4d546bfef7b3f6ec197131148e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"N"},{"authorDate":"2018-01-31 23:57:45","commitOrder":3,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-02-01 20:54:56","endLine":262,"groupId":"32173","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0e/b140a39349b8f3a1e6a656653c90e33b109bbe.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic StreamStateHandle resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":138,"status":"M"}],"commitId":"f577d2603fb0432fa7a15d54ee25f481bde95d95","commitMessage":"@@@[FLINK-8539] [checkpointing] (part 2) Modify all tests to use CompletedCheckpointStorageLocation.\n","date":"2018-02-01 20:54:56","modifiedFileCount":"15","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2018-02-06 21:44:01","codes":[{"authorDate":"2018-02-06 21:44:01","commitOrder":4,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-02-25 22:14:21","endLine":117,"groupId":"23682","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/3a69ea1e6f8a1656eabf9f69e83dba85e851f7.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(stateBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(stateBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\tAssert.fail();\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"},{"authorDate":"2018-02-06 21:44:01","commitOrder":4,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-02-25 22:14:21","endLine":232,"groupId":"32173","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/3a69ea1e6f8a1656eabf9f69e83dba85e851f7.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tverify(mockingBackend).createKeyedStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(JobID.class),\n\t\t\tany(String.class),\n\t\t\teq(typeSerializer),\n\t\t\tanyInt(),\n\t\t\tany(KeyGroupRange.class),\n\t\t\tany(TaskKvStateRegistry.class));\n\n\t\tverify(mockingBackend).createOperatorStateBackend(\n\t\t\tany(Environment.class),\n\t\t\tany(String.class));\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"df3e6bb7627db03635febd48eff4c10032b668ef","commitMessage":"@@@[FLINK-8360][checkpointing] Implement state storage for local recovery and integrate with task lifecycle\n","date":"2018-02-25 22:14:21","modifiedFileCount":"107","status":"M","submitter":"Stefan Richter"},{"authorTime":"2018-05-24 21:08:02","codes":[{"authorDate":"2018-05-24 21:08:02","commitOrder":5,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-05-31 15:53:10","endLine":117,"groupId":"23682","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/0cf31c0861d6cd2a241ea0e468f03517c3fcfc.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"},{"authorDate":"2018-05-24 21:08:02","commitOrder":5,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-05-31 15:53:10","endLine":232,"groupId":"23685","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/0cf31c0861d6cd2a241ea0e468f03517c3fcfc.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?, ?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"57b950796deebed46ae95f97152e09b2e2655de8","commitMessage":"@@@[FLINK-9436][state] Remove generic parameter namespace from InternalTimeServiceManager.\n\nThis closes #6077.\n","date":"2018-05-31 15:53:10","modifiedFileCount":"9","status":"M","submitter":"Stefan Richter"},{"authorTime":"2018-07-04 01:23:41","codes":[{"authorDate":"2018-05-24 21:08:02","commitOrder":6,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-05-31 15:53:10","endLine":117,"groupId":"23682","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/0cf31c0861d6cd2a241ea0e468f03517c3fcfc.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"N"},{"authorDate":"2018-07-04 01:23:41","commitOrder":6,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-07-13 02:18:23","endLine":234,"groupId":"23685","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/62/33c4c12c475e84ae06c17d8f64a8d306ea641b.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"}],"commitId":"f45b7f7ff27df019e9045895e718fa112d12139c","commitMessage":"@@@[FLINK-9701] Introduce TTL configuration in state descriptors\n\nThis closes #6313.\n","date":"2018-07-13 02:18:23","modifiedFileCount":"35","status":"M","submitter":"Andrey Zagrebin"},{"authorTime":"2018-10-19 17:01:03","codes":[{"authorDate":"2018-10-19 17:01:03","commitOrder":7,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-10-19 17:01:03","endLine":121,"groupId":"50485","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/afa024f8b0ea938620fc1069f77afe1102617e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2018-10-19 17:01:03","commitOrder":7,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2018-10-19 17:01:03","endLine":239,"groupId":"27259","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/afa024f8b0ea938620fc1069f77afe1102617e.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"M"}],"commitId":"e62a7eabe34da42e4cb56d1b14905a3b9e9c9bd4","commitMessage":"@@@[FLINK-10423][rocksdb][metrics] Expose Rocksdb native metrics\n\n","date":"2018-10-19 17:01:03","modifiedFileCount":"22","status":"M","submitter":"Seth Wiesman"},{"authorTime":"2019-02-23 03:16:41","codes":[{"authorDate":"2018-10-19 17:01:03","commitOrder":8,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-10-19 17:01:03","endLine":121,"groupId":"50485","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/afa024f8b0ea938620fc1069f77afe1102617e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"},{"authorDate":"2019-02-23 03:16:41","commitOrder":8,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup, Collection<KeyedStateHandle> stateHandles) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2019-02-23 03:16:41","endLine":241,"groupId":"27259","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/4a17fa904ed87b6b0bfb3c3a50149fac61721f.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"}],"commitId":"3bf06b9dd3dc66dcfdeccaaa591ace41ea51e343","commitMessage":"@@@[FLINK-10043] [State Backends] Refactor RocksDBKeyedStateBackend object construction/initialization/restore code\n\nThis closes #7674.\n","date":"2019-02-23 03:16:41","modifiedFileCount":"36","status":"M","submitter":"Yu Li"},{"authorTime":"2019-03-01 11:52:14","codes":[{"authorDate":"2018-10-19 17:01:03","commitOrder":9,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-10-19 17:01:03","endLine":121,"groupId":"50485","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/afa024f8b0ea938620fc1069f77afe1102617e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"},{"authorDate":"2019-03-01 11:52:14","commitOrder":9,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2019-03-05 03:27:50","endLine":245,"groupId":"27259","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b6/6a7b4336b602b21e1d6a00516b14e6b205b2ef.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup, Collection<KeyedStateHandle> stateHandles) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"}],"commitId":"eada52be5194a018a41e7ea51ea86e0273df2073","commitMessage":"@@@[FLINK-11804] [State Backends] Make sure the CloseableRegistry used in backend builder is registered with task\n\nWe need to make sure each stream constructed in restore could also be closed in case of task cancel. \nfor example the data input stream opened for serDe during restore.\n\nAlso removed close of CloseableRegistry in RocksDBKeyedStateBackendBuilder.\n","date":"2019-03-05 03:27:50","modifiedFileCount":"23","status":"M","submitter":"Yu Li"},{"authorTime":"2019-03-02 18:19:21","codes":[{"authorDate":"2018-10-19 17:01:03","commitOrder":10,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-10-19 17:01:03","endLine":121,"groupId":"50485","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/afa024f8b0ea938620fc1069f77afe1102617e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"},{"authorDate":"2019-03-02 18:19:21","commitOrder":10,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2019-03-05 21:52:36","endLine":248,"groupId":"27259","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/22/f6441672432a74cc0f2d2be2cdd63b98f315f6.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env, String operatorIdentifier) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"}],"commitId":"94f84a5c7b4876dee5b34e6a3725da7ee06a607f","commitMessage":"@@@[FLINK-11731] [State Backends] Make DefaultOperatorStateBackend follow the builder pattern\n\nThis closes #7899.\n","date":"2019-03-05 21:52:36","modifiedFileCount":"19","status":"M","submitter":"Yu Li"},{"authorTime":"2019-03-03 03:00:43","codes":[{"authorDate":"2018-10-19 17:01:03","commitOrder":11,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2018-10-19 17:01:03","endLine":121,"groupId":"50485","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/afa024f8b0ea938620fc1069f77afe1102617e.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"},{"authorDate":"2019-03-03 03:00:43","commitOrder":11,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2019-03-05 21:52:36","endLine":242,"groupId":"27259","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/43/0c0576896abd7817330149ed9a25b7d9b2b380.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\t\r\n\t\tverify(operatorStateBackend).restore(eq(operatorSubtaskState.getManagedOperatorState()));\n\t\tverify(keyedStateBackend).restore(eq(operatorSubtaskState.getManagedKeyedState()));\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"}],"commitId":"e8daa49a593edc401cd44761b25b1324b11be4a6","commitMessage":"@@@[FLINK-11796] [State Backends] Remove Snapshotable interface\n","date":"2019-03-05 21:52:36","modifiedFileCount":"8","status":"M","submitter":"Yu Li"},{"authorTime":"2019-09-05 21:53:57","codes":[{"authorDate":"2019-09-05 21:53:57","commitOrder":12,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2019-10-24 16:56:47","endLine":124,"groupId":"49826","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/4bdfc2d7cc7a0581fc8990d39588bfbdd32888.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2019-09-05 21:53:57","commitOrder":12,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2019-10-24 16:56:47","endLine":244,"groupId":"49827","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/4bdfc2d7cc7a0581fc8990d39588bfbdd32888.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"M"}],"commitId":"92eb7b15eaaf3d14ca6155c3cf438417cbe5aa95","commitMessage":"@@@[FLINK-14156][runtime] Refactoring: move ProcessingTimeService access request at operator level\n","date":"2019-10-24 16:56:47","modifiedFileCount":"13","status":"M","submitter":"Aleksey Pak"},{"authorTime":"2020-03-20 00:35:24","codes":[{"authorDate":"2019-09-05 21:53:57","commitOrder":13,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2019-10-24 16:56:47","endLine":124,"groupId":"49826","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/4bdfc2d7cc7a0581fc8990d39588bfbdd32888.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"N"},{"authorDate":"2020-03-20 00:35:24","commitOrder":13,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-04-08 20:45:23","endLine":249,"groupId":"0","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/97/3383c657f23fc340551ced2f6b9211554fc9d7.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"M"}],"commitId":"d6982e6a61b586314a19c1551b4dc84f93d518b3","commitMessage":"@@@[FLINK-16513][checkpointing] add task channel state for unaligned checkpoints\n\nChanges:\n1. add channel state metadata to OperatorSubtaskState\n2. adjust StateAssignmentOperation\n3. adjust metadata serialization\n4. adjust related classes\n\nThis closes #11491.\n","date":"2020-04-08 20:45:23","modifiedFileCount":"35","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2020-04-25 20:35:38","codes":[{"authorDate":"2019-09-05 21:53:57","commitOrder":14,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2019-10-24 16:56:47","endLine":124,"groupId":"49826","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/00/4bdfc2d7cc7a0581fc8990d39588bfbdd32888.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"N"},{"authorDate":"2020-04-25 20:35:38","commitOrder":14,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-05-16 22:32:18","endLine":249,"groupId":"51099","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/329012715d7c7e15efd073dc75ed7c8e99f35f.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"M"}],"commitId":"c5583c75394972dd4564132e3a0896a7f4f85a19","commitMessage":"@@@[FLINK-5763][state backends] Make savepoint selfcontain and relocatable\n","date":"2020-05-16 22:32:18","modifiedFileCount":"20","status":"M","submitter":"klion26"},{"authorTime":"2020-09-16 20:38:42","codes":[{"authorDate":"2020-09-16 20:38:42","commitOrder":15,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-09-22 23:58:57","endLine":128,"groupId":"51098","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/8cada26ad0b40ece4bc0f0cf0c6e8d722c83c4.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(false, stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2020-09-16 20:38:42","commitOrder":15,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-09-22 23:58:57","endLine":250,"groupId":"51099","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/8cada26ad0b40ece4bc0f0cf0c6e8d722c83c4.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tAbstractKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertEquals(true, stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"23a41077bde3a2854ffe0bcd9aa525f5d4360761","commitMessage":"@@@[FLINK-19270] Extract CheckpointableKeyedStateBackend interface\n\nThis commit extracts a minimal interface from AbstractKeyedStateBackend.\nThis interface is returned by StateBackend interface.  making it easier\nto implement custom keyed state backend without pulling in all the logic\nof AbstractKeyedStateBackend.\n\nThis closes #13405\n","date":"2020-09-22 23:58:57","modifiedFileCount":"14","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2020-09-28 15:41:37","codes":[{"authorDate":"2020-09-28 15:41:37","commitOrder":16,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-10-13 09:43:32","endLine":129,"groupId":"49826","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/f4f4c9735de5c2dc17f6e8ada5f47f704760c4.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2020-09-28 15:41:37","commitOrder":16,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-10-13 09:43:32","endLine":252,"groupId":"51099","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/f4f4c9735de5c2dc17f6e8ada5f47f704760c4.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup());\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"}],"commitId":"a97e4bf237491394deee21a34894c3813437c938","commitMessage":"@@@[FLINK-19180][state backends] Make rocksdb state backend respect managed memory fraction.\n\nThis closes #13500.\n","date":"2020-10-13 09:43:32","modifiedFileCount":"18","status":"M","submitter":"Xintong Song"},{"authorTime":"2020-10-26 22:45:15","codes":[{"authorDate":"2020-09-28 15:41:37","commitOrder":17,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-10-13 09:43:32","endLine":129,"groupId":"49826","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/f4f4c9735de5c2dc17f6e8ada5f47f704760c4.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"N"},{"authorDate":"2020-10-26 22:45:15","commitOrder":17,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorageAccess createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-10-27 21:28:56","endLine":252,"groupId":"51099","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/49/3ba55fe500972c519d8240788e30f5cc75af36.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"}],"commitId":"d2b86a1af9bfb4e3356c73f04eb6866a46c2c378","commitMessage":"@@@[FLINK-19464][runtime] Rename CheckpointStorage interface to CheckpointStorageAccess\n\nThis closes #13794\n","date":"2020-10-27 21:28:56","modifiedFileCount":"31","status":"M","submitter":"Seth Wiesman"},{"authorTime":"2020-10-22 06:30:26","codes":[{"authorDate":"2020-09-28 15:41:37","commitOrder":18,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-10-13 09:43:32","endLine":129,"groupId":"49826","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/f4f4c9735de5c2dc17f6e8ada5f47f704760c4.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"N"},{"authorDate":"2020-10-22 06:30:26","commitOrder":18,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorageAccess createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = OperatorSubtaskState.builder()\n\t\t\t.setManagedOperatorState(new OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0, 10}, SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)))\n\t\t\t.setRawOperatorState(new OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0, 20, 30}, SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)))\n\t\t\t.setManagedKeyedState(CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n\t\t\t.setRawKeyedState(CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n\t\t\t.setInputChannelState(singleton(createNewInputChannelStateHandle(10, random)))\n\t\t\t.setResultSubpartitionState(singleton(createNewResultSubpartitionStateHandle(10, random)))\n\t\t\t.build();\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-11-06 15:03:57","endLine":250,"groupId":"51099","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a0/2630b8c9da3f22a0fed3c87a3e0e30eae94eda.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorageAccess createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 10},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tnew OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(\n\t\t\t\t\t\tnew long[]{0, 20, 30},\n\t\t\t\t\t\tOperatorStateHandle.Mode.SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tCheckpointTestUtils.createDummyKeyGroupStateHandle(random, null),\n\t\t\tsingleton(createNewInputChannelStateHandle(10, random)),\n\t\t\tsingleton(createNewResultSubpartitionStateHandle(10, random)));\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"}],"commitId":"32a2dedba276fcc270b236ea8343746c5b733a44","commitMessage":"@@@[FLINK-19533][checkpoint] Introduce builder for OperatorSubtaskState.\n\nThe builder will make it easier to add more fields to OperatorSubtaskState in future commits.\n","date":"2020-11-06 15:03:57","modifiedFileCount":"38","status":"M","submitter":"Arvid Heise"},{"authorTime":"2020-10-23 13:48:24","codes":[{"authorDate":"2020-10-23 13:48:24","commitOrder":19,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0,\n\t\t\tfalse);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-11-07 10:27:28","endLine":131,"groupId":"24204","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/5fb07045e58f16754655223254314daaa43c36.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2020-10-23 13:48:24","commitOrder":19,"curCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorageAccess createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = OperatorSubtaskState.builder()\n\t\t\t.setManagedOperatorState(new OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0, 10}, SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)))\n\t\t\t.setRawOperatorState(new OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0, 20, 30}, SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)))\n\t\t\t.setManagedKeyedState(CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n\t\t\t.setRawKeyedState(CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n\t\t\t.setInputChannelState(singleton(createNewInputChannelStateHandle(10, random)))\n\t\t\t.setResultSubpartitionState(singleton(createNewResultSubpartitionStateHandle(10, random)))\n\t\t\t.build();\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0,\n\t\t\tfalse);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","date":"2020-11-07 10:27:28","endLine":252,"groupId":"51099","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/5fb07045e58f16754655223254314daaa43c36.src","preCode":"\tpublic void testWithRestore() throws Exception {\n\n\t\tStateBackend mockingBackend = spy(new StateBackend() {\n\t\t\t@Override\n\t\t\tpublic CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CheckpointStorageAccess createCheckpointStorage(JobID jobId) throws IOException {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tJobID jobID,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\tTypeSerializer<K> keySerializer,\n\t\t\t\tint numberOfKeyGroups, KeyGroupRange keyGroupRange,\n\t\t\t\tTaskKvStateRegistry kvStateRegistry,\n\t\t\t\tTtlTimeProvider ttlTimeProvider,\n\t\t\t\tMetricGroup metricGroup,\n\t\t\t\t@Nonnull Collection<KeyedStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(AbstractKeyedStateBackend.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic OperatorStateBackend createOperatorStateBackend(\n\t\t\t\tEnvironment env,\n\t\t\t\tString operatorIdentifier,\n\t\t\t\t@Nonnull Collection<OperatorStateHandle> stateHandles,\n\t\t\t\tCloseableRegistry cancelStreamRegistry) throws Exception {\n\t\t\t\treturn mock(OperatorStateBackend.class);\n\t\t\t}\n\t\t});\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tTaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n\t\tRandom random = new Random(0x42);\n\n\t\tOperatorSubtaskState operatorSubtaskState = OperatorSubtaskState.builder()\n\t\t\t.setManagedOperatorState(new OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0, 10}, SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)))\n\t\t\t.setRawOperatorState(new OperatorStreamStateHandle(\n\t\t\t\tCollections.singletonMap(\n\t\t\t\t\t\"_default_\",\n\t\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0, 20, 30}, SPLIT_DISTRIBUTE)),\n\t\t\t\tCheckpointTestUtils.createDummyStreamStateHandle(random, null)))\n\t\t\t.setManagedKeyedState(CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n\t\t\t.setRawKeyedState(CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n\t\t\t.setInputChannelState(singleton(createNewInputChannelStateHandle(10, random)))\n\t\t\t.setResultSubpartitionState(singleton(createNewResultSubpartitionStateHandle(10, random)))\n\t\t\t.build();\n\n\t\ttaskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore jobManagerTaskRestore = new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n\t\tStreamTaskStateInitializer streamTaskStateManager =\n\t\t\tstreamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\t\r\n\t\tAssert.assertNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tint count = 0;\n\t\tfor (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(1, count);\n\n\t\tcount = 0;\n\t\tfor (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n\t\t\t++count;\n\t\t}\n\t\tAssert.assertEquals(3, count);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"}],"commitId":"c151abc5bd6b4b642100cf75f8981f08535c5936","commitMessage":"@@@[FLINK-19741] Let timer service skip reading raw keyed state if it isn't the writer\n\nThis closes #13761.\n","date":"2020-11-07 10:27:28","modifiedFileCount":"14","status":"M","submitter":"Tzu-Li (Gordon) Tai"},{"authorTime":"2020-10-27 05:39:37","codes":[{"authorDate":"2020-10-23 13:48:24","commitOrder":20,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0,\n\t\t\tfalse);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-11-07 10:27:28","endLine":131,"groupId":"24204","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/5fb07045e58f16754655223254314daaa43c36.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0,\n\t\t\tfalse);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"},{"authorDate":"2020-10-27 05:39:37","commitOrder":20,"curCode":"    public void testWithRestore() throws Exception {\n\n        StateBackend mockingBackend =\n                spy(\n                        new StateBackend() {\n\n                            @Override\n                            public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n                                    Environment env,\n                                    JobID jobID,\n                                    String operatorIdentifier,\n                                    TypeSerializer<K> keySerializer,\n                                    int numberOfKeyGroups,\n                                    KeyGroupRange keyGroupRange,\n                                    TaskKvStateRegistry kvStateRegistry,\n                                    TtlTimeProvider ttlTimeProvider,\n                                    MetricGroup metricGroup,\n                                    @Nonnull Collection<KeyedStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(AbstractKeyedStateBackend.class);\n                            }\n\n                            @Override\n                            public OperatorStateBackend createOperatorStateBackend(\n                                    Environment env,\n                                    String operatorIdentifier,\n                                    @Nonnull Collection<OperatorStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(OperatorStateBackend.class);\n                            }\n                        });\n\n        OperatorID operatorID = new OperatorID(47L, 11L);\n        TaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n        Random random = new Random(0x42);\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"a\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 10}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setRawOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"_default_\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 20, 30}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setManagedKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setRawKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setInputChannelState(\n                                singleton(createNewInputChannelStateHandle(10, random)))\n                        .setResultSubpartitionState(\n                                singleton(createNewResultSubpartitionStateHandle(10, random)))\n                        .build();\n\n        taskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore jobManagerTaskRestore =\n                new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n        StreamTaskStateInitializer streamTaskStateManager =\n                streamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n        AbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n        when(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n        TypeSerializer<?> typeSerializer = new IntSerializer();\n        CloseableRegistry closeableRegistry = new CloseableRegistry();\n\n        StreamOperatorStateContext stateContext =\n                streamTaskStateManager.streamOperatorStateContext(\n                        streamOperator.getOperatorID(),\n                        streamOperator.getClass().getSimpleName(),\n                        new TestProcessingTimeService(),\n                        streamOperator,\n                        typeSerializer,\n                        closeableRegistry,\n                        new UnregisteredMetricsGroup(),\n                        1.0,\n                        false);\n\n        OperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n        CheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n        InternalTimeServiceManager<?> timeServiceManager =\n                stateContext.internalTimerServiceManager();\n        CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs =\n                stateContext.rawKeyedStateInputs();\n        CloseableIterable<StatePartitionStreamProvider> operatorStateInputs =\n                stateContext.rawOperatorStateInputs();\n\n        Assert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n        Assert.assertNotNull(operatorStateBackend);\n        Assert.assertNotNull(keyedStateBackend);\n        \r\n        \r\n        Assert.assertNull(timeServiceManager);\n        Assert.assertNotNull(keyedStateInputs);\n        Assert.assertNotNull(operatorStateInputs);\n\n        int count = 0;\n        for (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(1, count);\n\n        count = 0;\n        for (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(3, count);\n\n        checkCloseablesRegistered(\n                closeableRegistry,\n                operatorStateBackend,\n                keyedStateBackend,\n                keyedStateInputs,\n                operatorStateInputs);\n    }\n","date":"2021-01-26 00:07:56","endLine":265,"groupId":"51099","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d1/4d54df584482d5651234160e170cdcd49e83cb.src","preCode":"    public void testWithRestore() throws Exception {\n\n        StateBackend mockingBackend =\n                spy(\n                        new StateBackend() {\n                            @Override\n                            public CompletedCheckpointStorageLocation resolveCheckpoint(\n                                    String pointer) throws IOException {\n                                throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public CheckpointStorageAccess createCheckpointStorage(JobID jobId)\n                                    throws IOException {\n                                throw new UnsupportedOperationException();\n                            }\n\n                            @Override\n                            public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n                                    Environment env,\n                                    JobID jobID,\n                                    String operatorIdentifier,\n                                    TypeSerializer<K> keySerializer,\n                                    int numberOfKeyGroups,\n                                    KeyGroupRange keyGroupRange,\n                                    TaskKvStateRegistry kvStateRegistry,\n                                    TtlTimeProvider ttlTimeProvider,\n                                    MetricGroup metricGroup,\n                                    @Nonnull Collection<KeyedStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(AbstractKeyedStateBackend.class);\n                            }\n\n                            @Override\n                            public OperatorStateBackend createOperatorStateBackend(\n                                    Environment env,\n                                    String operatorIdentifier,\n                                    @Nonnull Collection<OperatorStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(OperatorStateBackend.class);\n                            }\n                        });\n\n        OperatorID operatorID = new OperatorID(47L, 11L);\n        TaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n        Random random = new Random(0x42);\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"a\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 10}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setRawOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"_default_\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 20, 30}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setManagedKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setRawKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setInputChannelState(\n                                singleton(createNewInputChannelStateHandle(10, random)))\n                        .setResultSubpartitionState(\n                                singleton(createNewResultSubpartitionStateHandle(10, random)))\n                        .build();\n\n        taskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore jobManagerTaskRestore =\n                new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n        StreamTaskStateInitializer streamTaskStateManager =\n                streamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n        AbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n        when(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n        TypeSerializer<?> typeSerializer = new IntSerializer();\n        CloseableRegistry closeableRegistry = new CloseableRegistry();\n\n        StreamOperatorStateContext stateContext =\n                streamTaskStateManager.streamOperatorStateContext(\n                        streamOperator.getOperatorID(),\n                        streamOperator.getClass().getSimpleName(),\n                        new TestProcessingTimeService(),\n                        streamOperator,\n                        typeSerializer,\n                        closeableRegistry,\n                        new UnregisteredMetricsGroup(),\n                        1.0,\n                        false);\n\n        OperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n        CheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n        InternalTimeServiceManager<?> timeServiceManager =\n                stateContext.internalTimerServiceManager();\n        CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs =\n                stateContext.rawKeyedStateInputs();\n        CloseableIterable<StatePartitionStreamProvider> operatorStateInputs =\n                stateContext.rawOperatorStateInputs();\n\n        Assert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n        Assert.assertNotNull(operatorStateBackend);\n        Assert.assertNotNull(keyedStateBackend);\n        \r\n        \r\n        Assert.assertNull(timeServiceManager);\n        Assert.assertNotNull(keyedStateInputs);\n        Assert.assertNotNull(operatorStateInputs);\n\n        int count = 0;\n        for (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(1, count);\n\n        count = 0;\n        for (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(3, count);\n\n        checkCloseablesRegistered(\n                closeableRegistry,\n                operatorStateBackend,\n                keyedStateBackend,\n                keyedStateInputs,\n                operatorStateInputs);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"}],"commitId":"2426d84268ad330ec661a0ea6bedb2a3a2bd08e6","commitMessage":"@@@[FLINK-19465][runtime / statebackends] Remove checkpoint storage methods from StateBackend interface\n\nThis closes #13797\n","date":"2021-01-26 00:07:56","modifiedFileCount":"32","status":"M","submitter":"Seth Wiesman"},{"authorTime":"2021-08-24 22:24:01","codes":[{"authorDate":"2020-10-23 13:48:24","commitOrder":21,"curCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0,\n\t\t\tfalse);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","date":"2020-11-07 10:27:28","endLine":131,"groupId":"103137","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"testNoRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/5fb07045e58f16754655223254314daaa43c36.src","preCode":"\tpublic void testNoRestore() throws Exception {\n\n\t\tMemoryStateBackend stateBackend = spy(new MemoryStateBackend(1024));\n\n\t\t\r\n\t\tStreamTaskStateInitializer streamTaskStateManager = streamTaskStateManager(stateBackend, null, true);\n\n\t\tOperatorID operatorID = new OperatorID(47L, 11L);\n\t\tAbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n\t\twhen(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n\t\tTypeSerializer<?> typeSerializer = new IntSerializer();\n\t\tCloseableRegistry closeableRegistry = new CloseableRegistry();\n\n\t\tStreamOperatorStateContext stateContext = streamTaskStateManager.streamOperatorStateContext(\n\t\t\tstreamOperator.getOperatorID(),\n\t\t\tstreamOperator.getClass().getSimpleName(),\n\t\t\tnew TestProcessingTimeService(),\n\t\t\tstreamOperator,\n\t\t\ttypeSerializer,\n\t\t\tcloseableRegistry,\n\t\t\tnew UnregisteredMetricsGroup(),\n\t\t\t1.0,\n\t\t\tfalse);\n\n\t\tOperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n\t\tCheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n\t\tInternalTimeServiceManager<?> timeServiceManager = stateContext.internalTimerServiceManager();\n\t\tCloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs = stateContext.rawKeyedStateInputs();\n\t\tCloseableIterable<StatePartitionStreamProvider> operatorStateInputs = stateContext.rawOperatorStateInputs();\n\n\t\tAssert.assertFalse(\"Expected the context to NOT be restored\", stateContext.isRestored());\n\t\tAssert.assertNotNull(operatorStateBackend);\n\t\tAssert.assertNotNull(keyedStateBackend);\n\t\tAssert.assertNotNull(timeServiceManager);\n\t\tAssert.assertNotNull(keyedStateInputs);\n\t\tAssert.assertNotNull(operatorStateInputs);\n\n\t\tcheckCloseablesRegistered(\n\t\t\tcloseableRegistry,\n\t\t\toperatorStateBackend,\n\t\t\tkeyedStateBackend,\n\t\t\tkeyedStateInputs,\n\t\t\toperatorStateInputs);\n\n\t\tAssert.assertFalse(keyedStateInputs.iterator().hasNext());\n\t\tAssert.assertFalse(operatorStateInputs.iterator().hasNext());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"},{"authorDate":"2021-08-24 22:24:01","commitOrder":21,"curCode":"    public void testWithRestore() throws Exception {\n\n        StateBackend mockingBackend =\n                spy(\n                        new StateBackend() {\n\n                            @Override\n                            public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n                                    Environment env,\n                                    JobID jobID,\n                                    String operatorIdentifier,\n                                    TypeSerializer<K> keySerializer,\n                                    int numberOfKeyGroups,\n                                    KeyGroupRange keyGroupRange,\n                                    TaskKvStateRegistry kvStateRegistry,\n                                    TtlTimeProvider ttlTimeProvider,\n                                    MetricGroup metricGroup,\n                                    @Nonnull Collection<KeyedStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(AbstractKeyedStateBackend.class);\n                            }\n\n                            @Override\n                            public OperatorStateBackend createOperatorStateBackend(\n                                    Environment env,\n                                    String operatorIdentifier,\n                                    @Nonnull Collection<OperatorStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(OperatorStateBackend.class);\n                            }\n                        });\n\n        OperatorID operatorID = new OperatorID(47L, 11L);\n        TaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n        Random random = new Random(0x42);\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"a\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 10}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setRawOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"_default_\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 20, 30}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setManagedKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setRawKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setInputChannelState(\n                                singleton(createNewInputChannelStateHandle(10, random)))\n                        .setResultSubpartitionState(\n                                singleton(createNewResultSubpartitionStateHandle(10, random)))\n                        .build();\n\n        taskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore jobManagerTaskRestore =\n                new JobManagerTaskRestore(42L, taskStateSnapshot);\n\n        StreamTaskStateInitializer streamTaskStateManager =\n                streamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n        AbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n        when(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n        TypeSerializer<?> typeSerializer = new IntSerializer();\n        CloseableRegistry closeableRegistry = new CloseableRegistry();\n\n        StreamOperatorStateContext stateContext =\n                streamTaskStateManager.streamOperatorStateContext(\n                        streamOperator.getOperatorID(),\n                        streamOperator.getClass().getSimpleName(),\n                        new TestProcessingTimeService(),\n                        streamOperator,\n                        typeSerializer,\n                        closeableRegistry,\n                        new UnregisteredMetricsGroup(),\n                        1.0,\n                        false);\n\n        OperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n        CheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n        InternalTimeServiceManager<?> timeServiceManager =\n                stateContext.internalTimerServiceManager();\n        CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs =\n                stateContext.rawKeyedStateInputs();\n        CloseableIterable<StatePartitionStreamProvider> operatorStateInputs =\n                stateContext.rawOperatorStateInputs();\n\n        Assert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n        Assert.assertEquals(OptionalLong.of(42L), stateContext.getRestoredCheckpointId());\n\n        Assert.assertNotNull(operatorStateBackend);\n        Assert.assertNotNull(keyedStateBackend);\n        \r\n        \r\n        Assert.assertNull(timeServiceManager);\n        Assert.assertNotNull(keyedStateInputs);\n        Assert.assertNotNull(operatorStateInputs);\n\n        int count = 0;\n        for (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(1, count);\n\n        count = 0;\n        for (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(3, count);\n\n        checkCloseablesRegistered(\n                closeableRegistry,\n                operatorStateBackend,\n                keyedStateBackend,\n                keyedStateInputs,\n                operatorStateInputs);\n    }\n","date":"2021-09-01 14:27:59","endLine":268,"groupId":"103137","id":42,"instanceNumber":2,"isCurCommit":1,"methodName":"testWithRestore","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/83/a608c6189160caf7f38f3faf57a29f06162786.src","preCode":"    public void testWithRestore() throws Exception {\n\n        StateBackend mockingBackend =\n                spy(\n                        new StateBackend() {\n\n                            @Override\n                            public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(\n                                    Environment env,\n                                    JobID jobID,\n                                    String operatorIdentifier,\n                                    TypeSerializer<K> keySerializer,\n                                    int numberOfKeyGroups,\n                                    KeyGroupRange keyGroupRange,\n                                    TaskKvStateRegistry kvStateRegistry,\n                                    TtlTimeProvider ttlTimeProvider,\n                                    MetricGroup metricGroup,\n                                    @Nonnull Collection<KeyedStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(AbstractKeyedStateBackend.class);\n                            }\n\n                            @Override\n                            public OperatorStateBackend createOperatorStateBackend(\n                                    Environment env,\n                                    String operatorIdentifier,\n                                    @Nonnull Collection<OperatorStateHandle> stateHandles,\n                                    CloseableRegistry cancelStreamRegistry)\n                                    throws Exception {\n                                return mock(OperatorStateBackend.class);\n                            }\n                        });\n\n        OperatorID operatorID = new OperatorID(47L, 11L);\n        TaskStateSnapshot taskStateSnapshot = new TaskStateSnapshot();\n\n        Random random = new Random(0x42);\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"a\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 10}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setRawOperatorState(\n                                new OperatorStreamStateHandle(\n                                        Collections.singletonMap(\n                                                \"_default_\",\n                                                new OperatorStateHandle.StateMetaInfo(\n                                                        new long[] {0, 20, 30}, SPLIT_DISTRIBUTE)),\n                                        CheckpointTestUtils.createDummyStreamStateHandle(\n                                                random, null)))\n                        .setManagedKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setRawKeyedState(\n                                CheckpointTestUtils.createDummyKeyGroupStateHandle(random, null))\n                        .setInputChannelState(\n                                singleton(createNewInputChannelStateHandle(10, random)))\n                        .setResultSubpartitionState(\n                                singleton(createNewResultSubpartitionStateHandle(10, random)))\n                        .build();\n\n        taskStateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore jobManagerTaskRestore =\n                new JobManagerTaskRestore(0L, taskStateSnapshot);\n\n        StreamTaskStateInitializer streamTaskStateManager =\n                streamTaskStateManager(mockingBackend, jobManagerTaskRestore, false);\n\n        AbstractStreamOperator<?> streamOperator = mock(AbstractStreamOperator.class);\n        when(streamOperator.getOperatorID()).thenReturn(operatorID);\n\n        TypeSerializer<?> typeSerializer = new IntSerializer();\n        CloseableRegistry closeableRegistry = new CloseableRegistry();\n\n        StreamOperatorStateContext stateContext =\n                streamTaskStateManager.streamOperatorStateContext(\n                        streamOperator.getOperatorID(),\n                        streamOperator.getClass().getSimpleName(),\n                        new TestProcessingTimeService(),\n                        streamOperator,\n                        typeSerializer,\n                        closeableRegistry,\n                        new UnregisteredMetricsGroup(),\n                        1.0,\n                        false);\n\n        OperatorStateBackend operatorStateBackend = stateContext.operatorStateBackend();\n        CheckpointableKeyedStateBackend<?> keyedStateBackend = stateContext.keyedStateBackend();\n        InternalTimeServiceManager<?> timeServiceManager =\n                stateContext.internalTimerServiceManager();\n        CloseableIterable<KeyGroupStatePartitionStreamProvider> keyedStateInputs =\n                stateContext.rawKeyedStateInputs();\n        CloseableIterable<StatePartitionStreamProvider> operatorStateInputs =\n                stateContext.rawOperatorStateInputs();\n\n        Assert.assertTrue(\"Expected the context to be restored\", stateContext.isRestored());\n\n        Assert.assertNotNull(operatorStateBackend);\n        Assert.assertNotNull(keyedStateBackend);\n        \r\n        \r\n        Assert.assertNull(timeServiceManager);\n        Assert.assertNotNull(keyedStateInputs);\n        Assert.assertNotNull(operatorStateInputs);\n\n        int count = 0;\n        for (KeyGroupStatePartitionStreamProvider keyedStateInput : keyedStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(1, count);\n\n        count = 0;\n        for (StatePartitionStreamProvider operatorStateInput : operatorStateInputs) {\n            ++count;\n        }\n        Assert.assertEquals(3, count);\n\n        checkCloseablesRegistered(\n                closeableRegistry,\n                operatorStateBackend,\n                keyedStateBackend,\n                keyedStateInputs,\n                operatorStateInputs);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamTaskStateInitializerImplTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":137,"status":"M"}],"commitId":"f01c636aa4871590fb44f09e63aa97216277ff29","commitMessage":"@@@[FLINK-23854][datastream] Expose the restored checkpoint id in ManagedInitializationContext.\n","date":"2021-09-01 14:27:59","modifiedFileCount":"21","status":"M","submitter":"Arvid Heise"}]
