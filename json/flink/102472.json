[{"authorTime":"2021-08-25 23:59:20","codes":[{"authorDate":"2021-08-25 23:59:20","commitOrder":1,"curCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<Integer> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                SourceOperatorStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)\n                        .setupOutputForSingletonOperatorChain(sourceOperatorFactory)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(1, 1),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","date":"2021-08-27 10:40:25","endLine":274,"groupId":"24713","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTriggeringStopWithSavepointWithDrain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a9/1be4fd6f86eb87ebf78505a24adef6b0ee12aa.src","preCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<Integer> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                SourceOperatorStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)\n                        .setupOutputForSingletonOperatorChain(sourceOperatorFactory)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(1, 1),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"B"},{"authorDate":"2021-08-25 23:59:20","commitOrder":1,"curCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .setCollectNetworkEvents()\n                        .modifyStreamConfig(config -> config.setCheckpointingEnabled(true))\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .setTaskStateSnapshot(1, TaskStateSnapshot.FINISHED_ON_RESTORE)\n                        .setupOperatorChain(new LifeCycleMonitorMultipleInputOperatorFactory())\n                        .finishForSingletonOperatorChain(StringSerializer.INSTANCE)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(1, 1),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","date":"2021-08-27 10:40:25","endLine":1121,"groupId":"1219","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTriggeringStopWithSavepointWithDrain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/a0549178f0bf402030cca27da90fc4f944f235.src","preCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .setCollectNetworkEvents()\n                        .modifyStreamConfig(config -> config.setCheckpointingEnabled(true))\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .setTaskStateSnapshot(1, TaskStateSnapshot.FINISHED_ON_RESTORE)\n                        .setupOperatorChain(new LifeCycleMonitorMultipleInputOperatorFactory())\n                        .finishForSingletonOperatorChain(StringSerializer.INSTANCE)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(1, 1),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1065,"status":"B"}],"commitId":"475d9cace988fc7a8b163df64b19bbd84c360bfc","commitMessage":"@@@[FLINK-23884][checkpoint] Fix the concurrent problem between triggering savepoint with drain and task finishing\n\nThis closes #16905.\n","date":"2021-08-27 10:40:25","modifiedFileCount":"6","status":"B","submitter":"Yun Gao"},{"authorTime":"2021-09-02 20:26:54","codes":[{"authorDate":"2021-09-02 20:26:54","commitOrder":2,"curCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<Integer> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                SourceOperatorStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)\n                        .setupOutputForSingletonOperatorChain(sourceOperatorFactory)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(2, 2),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(2));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","date":"2021-09-06 10:47:00","endLine":277,"groupId":"102472","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testTriggeringStopWithSavepointWithDrain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ff/e4c154e7548aa552e5d27812d0774c398dfd32.src","preCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<Integer> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                SourceOperatorStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)\n                        .setupOutputForSingletonOperatorChain(sourceOperatorFactory)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(1, 1),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"M"},{"authorDate":"2021-09-02 20:26:54","commitOrder":2,"curCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .setCollectNetworkEvents()\n                        .modifyStreamConfig(config -> config.setCheckpointingEnabled(true))\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .setTaskStateSnapshot(1, TaskStateSnapshot.FINISHED_ON_RESTORE)\n                        .setupOperatorChain(new LifeCycleMonitorMultipleInputOperatorFactory())\n                        .finishForSingletonOperatorChain(StringSerializer.INSTANCE)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(2, 2),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(2));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","date":"2021-09-06 10:47:00","endLine":1122,"groupId":"102472","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testTriggeringStopWithSavepointWithDrain","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f8/eb7337c93bf9e2b82268d70d869155466c61b6.src","preCode":"    public void testTriggeringStopWithSavepointWithDrain() throws Exception {\n        SourceOperatorFactory<Integer> sourceOperatorFactory =\n                new SourceOperatorFactory<>(\n                        new MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2),\n                        WatermarkStrategy.noWatermarks());\n\n        CompletableFuture<Boolean> checkpointCompleted = new CompletableFuture<>();\n        CheckpointResponder checkpointResponder =\n                new TestCheckpointResponder() {\n                    @Override\n                    public void acknowledgeCheckpoint(\n                            JobID jobID,\n                            ExecutionAttemptID executionAttemptID,\n                            long checkpointId,\n                            CheckpointMetrics checkpointMetrics,\n                            TaskStateSnapshot subtaskState) {\n                        super.acknowledgeCheckpoint(\n                                jobID,\n                                executionAttemptID,\n                                checkpointId,\n                                checkpointMetrics,\n                                subtaskState);\n                        checkpointCompleted.complete(null);\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .setCollectNetworkEvents()\n                        .modifyStreamConfig(config -> config.setCheckpointingEnabled(true))\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.INT_TYPE_INFO)\n                        .setTaskStateSnapshot(1, TaskStateSnapshot.FINISHED_ON_RESTORE)\n                        .setupOperatorChain(new LifeCycleMonitorMultipleInputOperatorFactory())\n                        .finishForSingletonOperatorChain(StringSerializer.INSTANCE)\n                        .setCheckpointResponder(checkpointResponder)\n                        .build()) {\n            CompletableFuture<Boolean> triggerResult =\n                    testHarness.streamTask.triggerCheckpointAsync(\n                            new CheckpointMetaData(1, 1),\n                            CheckpointOptions.alignedNoTimeout(\n                                    SAVEPOINT_TERMINATE,\n                                    CheckpointStorageLocationReference.getDefault()));\n            checkpointCompleted.whenComplete(\n                    (ignored, exception) ->\n                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n\n            assertTrue(triggerResult.isDone());\n            assertTrue(triggerResult.get());\n            assertTrue(checkpointCompleted.isDone());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1066,"status":"M"}],"commitId":"888b3653bd8c7b0c9088d143227eacb82f480a4d","commitMessage":"@@@[FLINK-24096][checkpoint] Skip the complete notification for checkpoints before task startup\n\nThis closes #17123.\n","date":"2021-09-06 10:47:00","modifiedFileCount":"10","status":"M","submitter":"Yun Gao"}]
