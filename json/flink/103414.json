[{"authorTime":"2020-05-11 13:45:45","codes":[{"authorDate":"2020-05-16 04:49:44","commitOrder":4,"curCode":"\tpublic void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.notifyCheckpointComplete(checkpointId);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of complete checkpoint for not-running task {}\", taskName);\n\t\t}\n\t\tenv.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n\t}\n","date":"2020-05-19 21:09:43","endLine":189,"groupId":"45258","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"notifyCheckpointComplete","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8a/55aa658f325b0794aa76d77c36aab1e0824370.src","preCode":"\tpublic void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.notifyCheckpointComplete(checkpointId);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of complete checkpoint for not-running task {}\", taskName);\n\t\t}\n\t\tenv.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"NB"},{"authorDate":"2020-05-11 13:45:45","commitOrder":4,"curCode":"\tpublic void notifyCheckpointAborted(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\n\t\tException previousException = null;\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of aborted checkpoint for task {}\", taskName);\n\n\t\t\tboolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n\t\t\tif (!canceled) {\n\t\t\t\tif (checkpointId > lastCheckpointId) {\n\t\t\t\t\t\r\n\t\t\t\t\tabortedCheckpointIds.add(checkpointId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\ttry {\n\t\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tpreviousException = e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of aborted checkpoint for not-running task {}\", taskName);\n\t\t}\n\n\t\tenv.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n\t\tExceptionUtils.tryRethrowException(previousException);\n\t}\n","date":"2020-05-20 14:58:00","endLine":284,"groupId":"24609","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"notifyCheckpointAborted","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/75/08a1680572602e2d7e6225fd92f9d52bba72ca.src","preCode":"\tpublic void notifyCheckpointAborted(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\n\t\tException previousException = null;\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of aborted checkpoint for task {}\", taskName);\n\n\t\t\tboolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n\t\t\tif (!canceled) {\n\t\t\t\tif (checkpointId > lastCheckpointId) {\n\t\t\t\t\t\r\n\t\t\t\t\tabortedCheckpointIds.add(checkpointId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\ttry {\n\t\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tpreviousException = e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of aborted checkpoint for not-running task {}\", taskName);\n\t\t}\n\n\t\tenv.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n\t\tExceptionUtils.tryRethrowException(previousException);\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":255,"status":"B"}],"commitId":"f0ed29c06d331892a06ee9bddea4173d6300835d","commitMessage":"@@@[FLINK-8871][checkpoint] Support to cancel checkpoing via notification on task side\n","date":"2020-05-20 14:58:00","modifiedFileCount":"62","status":"M","submitter":"Yun Tang"},{"authorTime":"2020-06-04 16:06:15","codes":[{"authorDate":"2020-05-16 04:49:44","commitOrder":5,"curCode":"\tpublic void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.notifyCheckpointComplete(checkpointId);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of complete checkpoint for not-running task {}\", taskName);\n\t\t}\n\t\tenv.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n\t}\n","date":"2020-05-19 21:09:43","endLine":189,"groupId":"45258","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"notifyCheckpointComplete","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8a/55aa658f325b0794aa76d77c36aab1e0824370.src","preCode":"\tpublic void notifyCheckpointComplete(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.notifyCheckpointComplete(checkpointId);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of complete checkpoint for not-running task {}\", taskName);\n\t\t}\n\t\tenv.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"N"},{"authorDate":"2020-06-04 16:06:15","commitOrder":5,"curCode":"\tpublic void notifyCheckpointAborted(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\n\t\tException previousException = null;\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of aborted checkpoint for task {}\", taskName);\n\n\t\t\tboolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n\t\t\tif (!canceled) {\n\t\t\t\tif (checkpointId > lastCheckpointId) {\n\t\t\t\t\t\r\n\t\t\t\t\tabortedCheckpointIds.add(checkpointId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchannelStateWriter.abort(checkpointId, new CancellationException(\"checkpoint aborted via notification\"), false);\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\ttry {\n\t\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tpreviousException = e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of aborted checkpoint for not-running task {}\", taskName);\n\t\t}\n\n\t\tenv.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n\t\tExceptionUtils.tryRethrowException(previousException);\n\t}\n","date":"2020-06-10 17:47:33","endLine":325,"groupId":"45257","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"notifyCheckpointAborted","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d9/04c87d7e991a0b46b9e99a42a2fbe51444c392.src","preCode":"\tpublic void notifyCheckpointAborted(long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning) throws Exception {\n\n\t\tException previousException = null;\n\t\tif (isRunning.get()) {\n\t\t\tLOG.debug(\"Notification of aborted checkpoint for task {}\", taskName);\n\n\t\t\tboolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n\t\t\tif (!canceled) {\n\t\t\t\tif (checkpointId > lastCheckpointId) {\n\t\t\t\t\t\r\n\t\t\t\t\tabortedCheckpointIds.add(checkpointId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\ttry {\n\t\t\t\t\toperatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tpreviousException = e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tLOG.debug(\"Ignoring notification of aborted checkpoint for not-running task {}\", taskName);\n\t\t}\n\n\t\tenv.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n\t\tExceptionUtils.tryRethrowException(previousException);\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"b2d1c2d784741ae8d26382f4d64e0fca82ae5241","commitMessage":"@@@[FLINK-17869][task][checkpointing] Abort writing of channel state by RPC\nnotification\n","date":"2020-06-10 17:47:33","modifiedFileCount":"1","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2021-01-12 05:26:52","codes":[{"authorDate":"2021-01-12 05:26:52","commitOrder":6,"curCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        if (isRunning.get()) {\n            LOG.debug(\n                    \"Notification of completed checkpoint {} for task {}\", checkpointId, taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.notifyCheckpointComplete(checkpointId);\n            }\n        } else {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n    }\n","date":"2021-01-26 00:56:42","endLine":329,"groupId":"23186","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"notifyCheckpointComplete","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d4/557fccb952c19948fca1175af06818acdbb617.src","preCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        if (isRunning.get()) {\n            LOG.debug(\"Notification of complete checkpoint for task {}\", taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.notifyCheckpointComplete(checkpointId);\n            }\n        } else {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint for not-running task {}\",\n                    taskName);\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"M"},{"authorDate":"2021-01-12 05:26:52","commitOrder":6,"curCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (isRunning.get()) {\n            LOG.debug(\"Notification of aborted checkpoint {} for task {}\", checkpointId, taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = e;\n                }\n            }\n\n        } else {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","date":"2021-01-26 00:56:42","endLine":372,"groupId":"45257","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"notifyCheckpointAborted","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d4/557fccb952c19948fca1175af06818acdbb617.src","preCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (isRunning.get()) {\n            LOG.debug(\"Notification of aborted checkpoint for task {}\", taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = e;\n                }\n            }\n\n        } else {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint for not-running task {}\",\n                    taskName);\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"M"}],"commitId":"b8c0000f87a90e7abcbb5414e683c192ecec32f3","commitMessage":"@@@[hotfix][checkpointing] Log checkpoint ID from notification\n","date":"2021-01-26 00:56:42","modifiedFileCount":"1","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2021-07-11 11:37:19","codes":[{"authorDate":"2021-07-11 11:37:19","commitOrder":7,"curCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\n                    \"Notification of completed checkpoint {} for task {}\", checkpointId, taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.notifyCheckpointComplete(checkpointId);\n            }\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n    }\n","date":"2021-07-15 15:44:11","endLine":358,"groupId":"42549","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"notifyCheckpointComplete","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/beb801b88ebdc700d3c350d7405af1d3c91435.src","preCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        if (isRunning.get()) {\n            LOG.debug(\n                    \"Notification of completed checkpoint {} for task {}\", checkpointId, taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.notifyCheckpointComplete(checkpointId);\n            }\n        } else {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":335,"status":"M"},{"authorDate":"2021-07-11 11:37:19","commitOrder":7,"curCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\"Notification of aborted checkpoint {} for task {}\", checkpointId, taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = e;\n                }\n            }\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","date":"2021-07-15 15:44:11","endLine":405,"groupId":"27892","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"notifyCheckpointAborted","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/beb801b88ebdc700d3c350d7405af1d3c91435.src","preCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (isRunning.get()) {\n            LOG.debug(\"Notification of aborted checkpoint {} for task {}\", checkpointId, taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = e;\n                }\n            }\n\n        } else {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":361,"status":"M"}],"commitId":"874c627114b185e4a94645c3519df17f86614e7c","commitMessage":"@@@[FLINK-21089][runtime] Skip the lifecycle method of operators if finished on restore\n","date":"2021-07-15 15:44:11","modifiedFileCount":"3","status":"M","submitter":"Yun Gao"},{"authorTime":"2021-07-22 18:27:05","codes":[{"authorDate":"2021-07-22 18:27:05","commitOrder":8,"curCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        Exception previousException = null;\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\n                    \"Notification of completed checkpoint {} for task {}\", checkpointId, taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.notifyCheckpointComplete(checkpointId);\n                } catch (Exception e) {\n                    previousException = ExceptionUtils.firstOrSuppressed(e, previousException);\n                }\n            }\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","date":"2021-07-23 19:51:26","endLine":369,"groupId":"42549","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"notifyCheckpointComplete","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f7/4dcc45caa50008d74a10d8fe73d533a99cb3ab.src","preCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\n                    \"Notification of completed checkpoint {} for task {}\", checkpointId, taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.notifyCheckpointComplete(checkpointId);\n            }\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"},{"authorDate":"2021-07-22 18:27:05","commitOrder":8,"curCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\"Notification of aborted checkpoint {} for task {}\", checkpointId, taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = ExceptionUtils.firstOrSuppressed(e, previousException);\n                }\n            }\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","date":"2021-07-23 19:51:26","endLine":416,"groupId":"27892","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"notifyCheckpointAborted","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f7/4dcc45caa50008d74a10d8fe73d533a99cb3ab.src","preCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\"Notification of aborted checkpoint {} for task {}\", checkpointId, taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = e;\n                }\n            }\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"}],"commitId":"fdde1e445ac2a9e4f49e86e55b7d85ef4501ab33","commitMessage":"@@@[FLINK-23471][checkpoint] Try best to ensure all operators and state manager handle the checkpoint complete notification\n","date":"2021-07-23 19:51:26","modifiedFileCount":"1","status":"M","submitter":"Yun Tang"},{"authorTime":"2021-08-10 21:05:00","codes":[{"authorDate":"2021-08-10 21:05:00","commitOrder":9,"curCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        try {\n            if (!isRunning.get()) {\n                LOG.debug(\n                        \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                        checkpointId,\n                        taskName);\n            } else {\n                LOG.debug(\n                        \"Notification of completed checkpoint {} for task {}\",\n                        checkpointId,\n                        taskName);\n                operatorChain.notifyCheckpointComplete(checkpointId);\n            }\n        } finally {\n            env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n        }\n    }\n","date":"2021-08-14 17:24:42","endLine":354,"groupId":"103414","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"notifyCheckpointComplete","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/16/72a650b1de1365805d8f518040a16d32453544.src","preCode":"    public void notifyCheckpointComplete(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n        Exception previousException = null;\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of complete checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\n                    \"Notification of completed checkpoint {} for task {}\", checkpointId, taskName);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.notifyCheckpointComplete(checkpointId);\n                } catch (Exception e) {\n                    previousException = ExceptionUtils.firstOrSuppressed(e, previousException);\n                }\n            }\n        }\n        env.getTaskStateManager().notifyCheckpointComplete(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":335,"status":"M"},{"authorDate":"2021-08-10 21:05:00","commitOrder":9,"curCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        try {\n            if (!isRunning.get()) {\n                LOG.debug(\n                        \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                        checkpointId,\n                        taskName);\n            } else {\n                LOG.debug(\n                        \"Notification of aborted checkpoint {} for task {}\",\n                        checkpointId,\n                        taskName);\n\n                boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n                if (!canceled) {\n                    if (checkpointId > lastCheckpointId) {\n                        \r\n                        abortedCheckpointIds.add(checkpointId);\n                    }\n                }\n\n                channelStateWriter.abort(\n                        checkpointId,\n                        new CancellationException(\"checkpoint aborted via notification\"),\n                        false);\n\n                operatorChain.notifyCheckpointAborted(checkpointId);\n            }\n        } finally {\n            env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        }\n    }\n","date":"2021-08-14 17:24:42","endLine":392,"groupId":"103414","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"notifyCheckpointAborted","params":"(longcheckpointId@OperatorChain<?@?>operatorChain@Supplier<Boolean>isRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/16/72a650b1de1365805d8f518040a16d32453544.src","preCode":"    public void notifyCheckpointAborted(\n            long checkpointId, OperatorChain<?, ?> operatorChain, Supplier<Boolean> isRunning)\n            throws Exception {\n\n        Exception previousException = null;\n        if (!isRunning.get()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for not-running task {}\",\n                    checkpointId,\n                    taskName);\n        } else if (operatorChain.isFinishedOnRestore()) {\n            LOG.debug(\n                    \"Ignoring notification of aborted checkpoint {} for finished on restore task {}\",\n                    checkpointId,\n                    taskName);\n        } else {\n            LOG.debug(\"Notification of aborted checkpoint {} for task {}\", checkpointId, taskName);\n\n            boolean canceled = cancelAsyncCheckpointRunnable(checkpointId);\n\n            if (!canceled) {\n                if (checkpointId > lastCheckpointId) {\n                    \r\n                    abortedCheckpointIds.add(checkpointId);\n                }\n            }\n\n            channelStateWriter.abort(\n                    checkpointId,\n                    new CancellationException(\"checkpoint aborted via notification\"),\n                    false);\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                try {\n                    operatorWrapper.getStreamOperator().notifyCheckpointAborted(checkpointId);\n                } catch (Exception e) {\n                    previousException = ExceptionUtils.firstOrSuppressed(e, previousException);\n                }\n            }\n        }\n\n        env.getTaskStateManager().notifyCheckpointAborted(checkpointId);\n        ExceptionUtils.tryRethrowException(previousException);\n    }\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"M"}],"commitId":"0bc3bae27a0fcb920ac25a8e6acebe50243e50a1","commitMessage":"@@@[FLINK-23708][task][refactor] Split OperatorChain into Finished and Regular classes\n","date":"2021-08-14 17:24:42","modifiedFileCount":"8","status":"M","submitter":"Piotr Nowojski"}]
