[{"authorTime":"2020-01-06 22:11:40","codes":[{"authorDate":"2019-12-07 03:51:48","commitOrder":2,"curCode":"\tpublic void testCancellationWithSourceBlockedOnLock(boolean withPendingMail, boolean throwInCancel) throws Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new CancelLockingSource(throwInCancel)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\tCancelLockingSource.awaitRunning();\n\t\tif (withPendingMail) {\n\t\t\t\r\n\t\t\t\r\n\t\t\ttestHarness.getTask().getMailboxExecutorFactory().createExecutor(0).execute(\n\t\t\t\t() -> assertFalse(\n\t\t\t\t\t\"This should never execute before task cancelation\",\n\t\t\t\t\ttestHarness.getTask().isRunning()),\n\t\t\t\t\"Test\");\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.getTask().cancel();\n\t\t}\n\t\tcatch (ExpectedTestException e) {\n\t\t\tcheckState(throwInCancel);\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Throwable t) {\n\t\t\tif (!ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t}\n\t}\n","date":"2019-12-10 18:32:57","endLine":317,"groupId":"50948","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCancellationWithSourceBlockedOnLock","params":"(booleanwithPendingMail@booleanthrowInCancel)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4e/02a865a52f930011432db9953cd136ef76a347.src","preCode":"\tpublic void testCancellationWithSourceBlockedOnLock(boolean withPendingMail, boolean throwInCancel) throws Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new CancelLockingSource(throwInCancel)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\tCancelLockingSource.awaitRunning();\n\t\tif (withPendingMail) {\n\t\t\t\r\n\t\t\t\r\n\t\t\ttestHarness.getTask().getMailboxExecutorFactory().createExecutor(0).execute(\n\t\t\t\t() -> assertFalse(\n\t\t\t\t\t\"This should never execute before task cancelation\",\n\t\t\t\t\ttestHarness.getTask().isRunning()),\n\t\t\t\t\"Test\");\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.getTask().cancel();\n\t\t}\n\t\tcatch (ExpectedTestException e) {\n\t\t\tcheckState(throwInCancel);\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Throwable t) {\n\t\t\tif (!ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":272,"status":"NB"},{"authorDate":"2020-01-06 22:11:40","commitOrder":2,"curCode":"\tprivate void testInterruptionExceptionNotSwallowed(InterruptedSource.ExceptionGenerator exceptionGenerator)\n\t\t\tthrows Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new InterruptedSource(exceptionGenerator)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Exception e) {\n\t\t\tif (!(e.getCause() instanceof InterruptedException)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-01-15 20:23:48","endLine":413,"groupId":"50947","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testInterruptionExceptionNotSwallowed","params":"(InterruptedSource.ExceptionGeneratorexceptionGenerator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1a/329edb0ffea52358aa9ff2564111cec44b525a.src","preCode":"\tprivate void testInterruptionExceptionNotSwallowed(InterruptedSource.ExceptionGenerator exceptionGenerator)\n\t\t\tthrows Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new InterruptedSource(exceptionGenerator)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Exception e) {\n\t\t\tif (!(e.getCause() instanceof InterruptedException)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"B"}],"commitId":"48520025f1cd1f566101fe914d18da8b3a827870","commitMessage":"@@@[FLINK-15327][runtime] No warning of InterruptedException during cancel.\n\nInterruptedException are previously only handled when wrapped in\nWrappingRuntimeException. This patch looks through the whole exception\nchain.\n","date":"2020-01-15 20:23:48","modifiedFileCount":"2","status":"M","submitter":"Arvid Heise"},{"authorTime":"2020-01-24 23:36:47","codes":[{"authorDate":"2020-01-24 23:36:47","commitOrder":3,"curCode":"\tpublic void testCancellationWithSourceBlockedOnLock(boolean withPendingMail, boolean throwInCancel) throws Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new CancelLockingSource(throwInCancel)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\tCancelLockingSource.awaitRunning();\n\t\tif (withPendingMail) {\n\t\t\t\r\n\t\t\t\r\n\t\t\ttestHarness.getTask().getMailboxExecutorFactory().createExecutor(0).execute(\n\t\t\t\t() -> assertFalse(\n\t\t\t\t\t\"This should never execute before task cancelation\",\n\t\t\t\t\ttestHarness.getTask().isRunning()),\n\t\t\t\t\"Test\");\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.getTask().cancel();\n\t\t}\n\t\tcatch (ExpectedTestException e) {\n\t\t\tcheckState(throwInCancel);\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Throwable t) {\n\t\t\tif (!ExceptionUtils.findThrowable(t, InterruptedException.class).isPresent() &&\n\t\t\t\t!ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-01-27 22:12:18","endLine":320,"groupId":"50948","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCancellationWithSourceBlockedOnLock","params":"(booleanwithPendingMail@booleanthrowInCancel)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/39b574d4efcfb6191512ef273716f41fe6f039.src","preCode":"\tpublic void testCancellationWithSourceBlockedOnLock(boolean withPendingMail, boolean throwInCancel) throws Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new CancelLockingSource(throwInCancel)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\tCancelLockingSource.awaitRunning();\n\t\tif (withPendingMail) {\n\t\t\t\r\n\t\t\t\r\n\t\t\ttestHarness.getTask().getMailboxExecutorFactory().createExecutor(0).execute(\n\t\t\t\t() -> assertFalse(\n\t\t\t\t\t\"This should never execute before task cancelation\",\n\t\t\t\t\ttestHarness.getTask().isRunning()),\n\t\t\t\t\"Test\");\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.getTask().cancel();\n\t\t}\n\t\tcatch (ExpectedTestException e) {\n\t\t\tcheckState(throwInCancel);\n\t\t}\n\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Throwable t) {\n\t\t\tif (!ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"M"},{"authorDate":"2020-01-24 23:36:47","commitOrder":3,"curCode":"\tprivate void testInterruptionExceptionNotSwallowed(InterruptedSource.ExceptionGenerator exceptionGenerator)\n\t\t\tthrows Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new InterruptedSource(exceptionGenerator)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Exception e) {\n\t\t\tif (!ExceptionUtils.findThrowable(e, InterruptedException.class).isPresent()) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-01-27 22:12:18","endLine":414,"groupId":"50947","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testInterruptionExceptionNotSwallowed","params":"(InterruptedSource.ExceptionGeneratorexceptionGenerator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/39b574d4efcfb6191512ef273716f41fe6f039.src","preCode":"\tprivate void testInterruptionExceptionNotSwallowed(InterruptedSource.ExceptionGenerator exceptionGenerator)\n\t\t\tthrows Exception {\n\t\tfinal StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(\n\t\t\tSourceStreamTask::new,\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tCancelLockingSource.reset();\n\t\ttestHarness\n\t\t\t.setupOperatorChain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew StreamSource<>(new InterruptedSource(exceptionGenerator)))\n\t\t\t.chain(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew TestBoundedOneInputStreamOperator(\"Operator1\"),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t.finish();\n\n\t\tStreamConfig streamConfig = testHarness.getStreamConfig();\n\t\tstreamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n\t\ttestHarness.invoke();\n\t\ttry {\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t} catch (Exception e) {\n\t\t\tif (!(e.getCause() instanceof InterruptedException)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":386,"status":"M"}],"commitId":"7c6ecc498b85d8eb1c550b468fab5b8a07b9ddb2","commitMessage":"@@@[FLINK-15751][task] Let all exceptions propagate from the StreamTask#runMailboxLoop\n\nIf the StreamTask is being cancelled.  let the Task handle the exception.\n","date":"2020-01-27 22:12:18","modifiedFileCount":"2","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-02-10 21:37:17","codes":[{"authorDate":"2021-02-10 21:37:17","commitOrder":4,"curCode":"    public void testCancellationWithSourceBlockedOnLock(\n            boolean withPendingMail, boolean throwInCancel) throws Exception {\n        final StreamTaskTestHarness<String> testHarness =\n                new StreamTaskTestHarness<>(SourceStreamTask::new, STRING_TYPE_INFO);\n\n        CancelLockingSource.reset();\n        testHarness\n                .setupOperatorChain(\n                        new OperatorID(),\n                        new StreamSource<>(new CancelLockingSource(throwInCancel)))\n                .chain(\n                        new OperatorID(),\n                        new TestBoundedOneInputStreamOperator(\"Operator1\"),\n                        STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n                .finish();\n\n        StreamConfig streamConfig = testHarness.getStreamConfig();\n        streamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n        testHarness.invoke();\n        CancelLockingSource.awaitRunning();\n        if (withPendingMail) {\n            \r\n            \r\n            testHarness\n                    .getTask()\n                    .getMailboxExecutorFactory()\n                    .createExecutor(0)\n                    .execute(\n                            () ->\n                                    assertFalse(\n                                            \"This should never execute before task cancelation\",\n                                            testHarness.getTask().isRunning()),\n                            \"Test\");\n        }\n\n        try {\n            testHarness.getTask().cancel();\n        } catch (ExpectedTestException e) {\n            checkState(throwInCancel);\n        }\n\n        try {\n            testHarness.waitForTaskCompletion();\n        } catch (Throwable t) {\n            if (!ExceptionUtils.findThrowable(t, InterruptedException.class).isPresent()\n                    && !ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {\n                throw t;\n            }\n        }\n    }\n","date":"2021-02-11 22:28:54","endLine":382,"groupId":"102492","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCancellationWithSourceBlockedOnLock","params":"(booleanwithPendingMail@booleanthrowInCancel)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4d/743f7d3181a521409d4ff6c87c43b2564c11f6.src","preCode":"    public void testCancellationWithSourceBlockedOnLock(\n            boolean withPendingMail, boolean throwInCancel) throws Exception {\n        final StreamTaskTestHarness<String> testHarness =\n                new StreamTaskTestHarness<>(SourceStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO);\n\n        CancelLockingSource.reset();\n        testHarness\n                .setupOperatorChain(\n                        new OperatorID(),\n                        new StreamSource<>(new CancelLockingSource(throwInCancel)))\n                .chain(\n                        new OperatorID(),\n                        new TestBoundedOneInputStreamOperator(\"Operator1\"),\n                        BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n                .finish();\n\n        StreamConfig streamConfig = testHarness.getStreamConfig();\n        streamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n        testHarness.invoke();\n        CancelLockingSource.awaitRunning();\n        if (withPendingMail) {\n            \r\n            \r\n            testHarness\n                    .getTask()\n                    .getMailboxExecutorFactory()\n                    .createExecutor(0)\n                    .execute(\n                            () ->\n                                    assertFalse(\n                                            \"This should never execute before task cancelation\",\n                                            testHarness.getTask().isRunning()),\n                            \"Test\");\n        }\n\n        try {\n            testHarness.getTask().cancel();\n        } catch (ExpectedTestException e) {\n            checkState(throwInCancel);\n        }\n\n        try {\n            testHarness.waitForTaskCompletion();\n        } catch (Throwable t) {\n            if (!ExceptionUtils.findThrowable(t, InterruptedException.class).isPresent()\n                    && !ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {\n                throw t;\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"M"},{"authorDate":"2021-02-10 21:37:17","commitOrder":4,"curCode":"    private void testInterruptionExceptionNotSwallowed(\n            InterruptedSource.ExceptionGenerator exceptionGenerator) throws Exception {\n        final StreamTaskTestHarness<String> testHarness =\n                new StreamTaskTestHarness<>(SourceStreamTask::new, STRING_TYPE_INFO);\n\n        CancelLockingSource.reset();\n        testHarness\n                .setupOperatorChain(\n                        new OperatorID(),\n                        new StreamSource<>(new InterruptedSource(exceptionGenerator)))\n                .chain(\n                        new OperatorID(),\n                        new TestBoundedOneInputStreamOperator(\"Operator1\"),\n                        STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n                .finish();\n\n        StreamConfig streamConfig = testHarness.getStreamConfig();\n        streamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n        testHarness.invoke();\n        try {\n            testHarness.waitForTaskCompletion();\n        } catch (Exception e) {\n            if (!ExceptionUtils.findThrowable(e, InterruptedException.class).isPresent()) {\n                throw e;\n            }\n        }\n    }\n","date":"2021-02-11 22:28:54","endLine":472,"groupId":"102492","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testInterruptionExceptionNotSwallowed","params":"(InterruptedSource.ExceptionGeneratorexceptionGenerator)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4d/743f7d3181a521409d4ff6c87c43b2564c11f6.src","preCode":"    private void testInterruptionExceptionNotSwallowed(\n            InterruptedSource.ExceptionGenerator exceptionGenerator) throws Exception {\n        final StreamTaskTestHarness<String> testHarness =\n                new StreamTaskTestHarness<>(SourceStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO);\n\n        CancelLockingSource.reset();\n        testHarness\n                .setupOperatorChain(\n                        new OperatorID(),\n                        new StreamSource<>(new InterruptedSource(exceptionGenerator)))\n                .chain(\n                        new OperatorID(),\n                        new TestBoundedOneInputStreamOperator(\"Operator1\"),\n                        BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n                .finish();\n\n        StreamConfig streamConfig = testHarness.getStreamConfig();\n        streamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);\n\n        testHarness.invoke();\n        try {\n            testHarness.waitForTaskCompletion();\n        } catch (Exception e) {\n            if (!ExceptionUtils.findThrowable(e, InterruptedException.class).isPresent()) {\n                throw e;\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":445,"status":"M"}],"commitId":"afeca005884d92ad616a784d73ff4444c119657b","commitMessage":"@@@[hotfix][tests] Import static constant in SourceStreamTaskTest\n","date":"2021-02-11 22:28:54","modifiedFileCount":"1","status":"M","submitter":"Roman Khachatryan"}]
