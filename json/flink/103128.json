[{"authorTime":"2016-12-15 00:37:39","codes":[{"authorDate":"2016-12-15 00:37:39","commitOrder":1,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tFuture<List<AsyncResult>> pollOperation = FlinkFuture.supplyAsync(new Callable<List<AsyncResult>>() {\n\t\t\t@Override\n\t\t\tpublic List<AsyncResult> call() throws Exception {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}, executor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.collect(Collections.<Integer>emptyList());\n\n\t\tentry4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2016-12-20 12:04:51","endLine":123,"groupId":"40795","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/03/8051246a62693b7c3d4ddaa0715a5953860c2d.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tFuture<List<AsyncResult>> pollOperation = FlinkFuture.supplyAsync(new Callable<List<AsyncResult>>() {\n\t\t\t@Override\n\t\t\tpublic List<AsyncResult> call() throws Exception {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}, executor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.collect(Collections.<Integer>emptyList());\n\n\t\tentry4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/OrderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"B"},{"authorDate":"2016-12-15 00:37:39","commitOrder":1,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tFuture<AsyncResult> firstPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\t\r\n\t\trecord3.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tFuture<AsyncResult> secondPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\trecord6.collect(Collections.<Integer>emptyList());\n\t\trecord4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tFuture<AsyncResult> thirdPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2016-12-20 12:04:51","endLine":181,"groupId":"18959","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0a/57f92bbcaff07d50c5ae4367f47d1b900e1e41.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tFuture<AsyncResult> firstPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\t\r\n\t\trecord3.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tFuture<AsyncResult> secondPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\trecord6.collect(Collections.<Integer>emptyList());\n\t\trecord4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tFuture<AsyncResult> thirdPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/UnorderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"B"}],"commitId":"ad603d59ec17a07adef995c2f1fd58fb8571a3d8","commitMessage":"@@@[FLINK-4391] Polish asynchronous I/O operations\n\nPolish AsyncFunction\n\nMove AsyncCollectorBuffer to operators package\n\nRework AsyncWaitOperator and AsyncStreamElementQueue implementation\n\nRename AsyncCollectorQueue into StreamElementQueue\n\nReworked StreamingOperatorsITCase and RichAsyncFunctionTest\n\nRefactor AsyncWaitOperatorTest\n\nAdd StreamElementQueueTests\n\nAdd EmitterTest case\n\nAdd comments\n","date":"2016-12-20 12:04:51","modifiedFileCount":"13","status":"B","submitter":"Till Rohrmann"},{"authorTime":"2017-08-01 17:33:48","codes":[{"authorDate":"2017-08-01 17:33:48","commitOrder":2,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tCompletableFuture<List<AsyncResult>> pollOperation = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.collect(Collections.<Integer>emptyList());\n\n\t\tentry4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2017-08-03 19:45:38","endLine":126,"groupId":"40795","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f3/b68c4b361557ee9e3c155d0a311234f35374af.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tFuture<List<AsyncResult>> pollOperation = FlinkFuture.supplyAsync(new Callable<List<AsyncResult>>() {\n\t\t\t@Override\n\t\t\tpublic List<AsyncResult> call() throws Exception {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}, executor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.collect(Collections.<Integer>emptyList());\n\n\t\tentry4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/OrderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2017-08-01 17:33:48","commitOrder":2,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\t\r\n\t\trecord3.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tCompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\trecord6.collect(Collections.<Integer>emptyList());\n\t\trecord4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2017-08-03 19:45:38","endLine":190,"groupId":"18959","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cc/0bc309a35dff61cd5ca524ed32209109fc4421.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tFuture<AsyncResult> firstPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\t\r\n\t\trecord3.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tFuture<AsyncResult> secondPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\trecord6.collect(Collections.<Integer>emptyList());\n\t\trecord4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tFuture<AsyncResult> thirdPoll = FlinkFuture.supplyAsync(new Callable<AsyncResult>() {\n\t\t\t@Override\n\t\t\tpublic AsyncResult call() throws Exception {\n\t\t\t\treturn queue.poll();\n\t\t\t}\n\t\t}, executor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/UnorderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"}],"commitId":"eddafc1ac9e4d787df44b63809f0d6dfd1f3def7","commitMessage":"@@@[FLINK-7334] [futures] Replace Flink's futures with Java 8's CompletableFuture in RpcEndpoint.  RpcGateways and RpcService\n\nRemove Futures from RpcGateways\n\nRemove Future usage\n\nFix failing AkkaRpcActorTest\n\nThis closes #4462.\n","date":"2017-08-03 19:45:38","modifiedFileCount":"67","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2017-07-02 23:14:21","codes":[{"authorDate":"2017-07-02 23:14:21","commitOrder":3,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tCompletableFuture<List<AsyncResult>> pollOperation = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.complete(Collections.<Integer>emptyList());\n\n\t\tentry4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2017-08-22 21:05:13","endLine":126,"groupId":"40795","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c7/b811a28ba67e13be13d09fbab78d3e3d039127.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tCompletableFuture<List<AsyncResult>> pollOperation = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.collect(Collections.<Integer>emptyList());\n\n\t\tentry4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/OrderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2017-07-02 23:14:21","commitOrder":3,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\t\r\n\t\trecord3.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tCompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\trecord6.complete(Collections.<Integer>emptyList());\n\t\trecord4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2017-08-22 21:05:13","endLine":190,"groupId":"18959","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ac/c6b8ea8aa62b7c728e222204c0f4be10531bb2.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\t\r\n\t\trecord3.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tCompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\trecord6.collect(Collections.<Integer>emptyList());\n\t\trecord4.collect(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.collect(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/UnorderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"}],"commitId":"40cec17f4303b43bbf65d8be542f0646eada57e8","commitMessage":"@@@[FLINK-5851] [streaming API] Rename AsyncCollector into ResultFuture\n\nComplete renaming AsyncCollector -> ResultFuture\n\nThis closes #4243.\n","date":"2017-08-22 21:05:13","modifiedFileCount":"13","status":"M","submitter":"zhangminglei"},{"authorTime":"2017-09-22 01:21:07","codes":[{"authorDate":"2017-09-22 01:21:07","commitOrder":4,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tCompletableFuture<List<AsyncResult>> pollOperation = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.complete(Collections.<Integer>emptyList());\n\n\t\tentry4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2017-09-26 17:25:42","endLine":126,"groupId":"40795","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1b/c3c20335cc5e5880d3d2c82df5ea55c22cb0bb.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tCompletableFuture<List<AsyncResult>> pollOperation = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.complete(Collections.<Integer>emptyList());\n\n\t\tentry4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/OrderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2017-09-22 01:21:07","commitOrder":4,"curCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\t\r\n\t\trecord3.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tCompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\trecord6.complete(Collections.<Integer>emptyList());\n\t\trecord4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","date":"2017-09-26 17:25:42","endLine":190,"groupId":"18959","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/73/bdcc5b156199f57214b99cdd0dbfa84766c2e0.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\t\r\n\t\trecord3.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tCompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\trecord6.complete(Collections.<Integer>emptyList());\n\t\trecord4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new FlinkFutureException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/UnorderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"}],"commitId":"d3458ec7ba0a8e61d07dc5330bda8a1f81de81fe","commitMessage":"@@@[FLINK-7664] Replace FlinkFutureException by java.util.concurrent.CompletionException\n\nFlinkFutureException was introduced to fail a CompletableFuture callback. However.  there\nwas already such a class which allows to better handle failures in different stages which\nis the java.util.CompletionException. Therefore we replace FlinkFutureException by\nCompletionException and remove the former.\n\nThis closes #4701.\n","date":"2017-09-26 17:25:42","modifiedFileCount":"41","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2019-10-01 16:27:41","codes":[{"authorDate":"2019-10-01 16:27:41","commitOrder":5,"curCode":"\tpublic void testCompletionOrder() {\n\t\tfinal OrderedStreamElementQueue<Integer> queue = new OrderedStreamElementQueue<>(4);\n\n\t\tResultFuture<Integer> entry1 = putSuccessfully(queue, new StreamRecord<>(1, 0L));\n\t\tResultFuture<Integer> entry2 = putSuccessfully(queue, new StreamRecord<>(2, 1L));\n\t\tputSuccessfully(queue, new Watermark(2L));\n\t\tResultFuture<Integer> entry4 = putSuccessfully(queue, new StreamRecord<>(3, 3L));\n\n\t\tAssert.assertEquals(Collections.emptyList(), popCompleted(queue));\n\t\tAssert.assertEquals(4, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\tentry2.complete(Collections.singleton(11));\n\t\tentry4.complete(Collections.singleton(13));\n\n\t\tAssert.assertEquals(Collections.emptyList(), popCompleted(queue));\n\t\tAssert.assertEquals(4, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\tentry1.complete(Collections.singleton(10));\n\n\t\tList<StreamElement> expected = Arrays.asList(\n\t\t\tnew StreamRecord<>(10, 0L),\n\t\t\tnew StreamRecord<>(11, 1L),\n\t\t\tnew Watermark(2L),\n\t\t\tnew StreamRecord<>(13, 3L));\n\t\tAssert.assertEquals(expected, popCompleted(queue));\n\t\tAssert.assertEquals(0, queue.size());\n\t\tAssert.assertTrue(queue.isEmpty());\n\t}\n","date":"2019-10-07 15:24:26","endLine":75,"groupId":"103128","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f6/37c40e7da438118712c08a7993869de6306c5d.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\t\tfinal OrderedStreamElementQueue queue = new OrderedStreamElementQueue(4, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> entry1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> entry2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry entry3 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> entry4 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\n\t\tList<StreamElementQueueEntry<?>> expected = Arrays.asList(entry1, entry2, entry3, entry4);\n\n\t\tfor (StreamElementQueueEntry<?> entry : expected) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tCompletableFuture<List<AsyncResult>> pollOperation = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\tList<AsyncResult> result = new ArrayList<>(4);\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.add(queue.poll());\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(pollOperation.isDone());\n\n\t\tentry2.complete(Collections.<Integer>emptyList());\n\n\t\tentry4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertEquals(4, queue.size());\n\n\t\tentry1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(expected, pollOperation.get());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/OrderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2019-10-01 16:27:41","commitOrder":5,"curCode":"\tpublic void testCompletionOrder() {\n\t\tfinal UnorderedStreamElementQueue<Integer> queue = new UnorderedStreamElementQueue<>(8);\n\n\t\tResultFuture<Integer> record1 = putSuccessfully(queue, new StreamRecord<>(1, 0L));\n\t\tResultFuture<Integer> record2 = putSuccessfully(queue, new StreamRecord<>(2, 1L));\n\t\tputSuccessfully(queue, new Watermark(2L));\n\t\tResultFuture<Integer> record3 = putSuccessfully(queue, new StreamRecord<>(3, 3L));\n\t\tResultFuture<Integer> record4 = putSuccessfully(queue, new StreamRecord<>(4, 4L));\n\t\tputSuccessfully(queue, new Watermark(5L));\n\t\tResultFuture<Integer> record5 = putSuccessfully(queue, new StreamRecord<>(5, 6L));\n\t\tResultFuture<Integer> record6 = putSuccessfully(queue, new StreamRecord<>(6, 7L));\n\n\t\tAssert.assertEquals(Collections.emptyList(), popCompleted(queue));\n\t\tAssert.assertEquals(8, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\t\r\n\t\trecord3.complete(Arrays.asList(13));\n\n\t\tAssert.assertEquals(Collections.emptyList(), popCompleted(queue));\n\t\tAssert.assertEquals(8, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\trecord2.complete(Arrays.asList(12));\n\n\t\tAssert.assertEquals(Arrays.asList(new StreamRecord<>(12, 1L)), popCompleted(queue));\n\t\tAssert.assertEquals(7, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\t\r\n\t\trecord6.complete(Arrays.asList(16));\n\t\trecord4.complete(Arrays.asList(14));\n\n\t\tAssert.assertEquals(Collections.emptyList(), popCompleted(queue));\n\t\tAssert.assertEquals(7, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\t\r\n\t\trecord1.complete(Arrays.asList(11));\n\n\t\tAssert.assertEquals(Arrays.asList(\n\t\t\t\tnew StreamRecord<>(11, 0L),\n\t\t\tnew Watermark(2L),\n\t\t\tnew StreamRecord<>(13, 3L),\n\t\t\tnew StreamRecord<>(14, 4L),\n\t\t\tnew Watermark(5L),\n\t\t\tnew StreamRecord<>(16, 7L)),\n\t\t\tpopCompleted(queue));\n\t\tAssert.assertEquals(1, queue.size());\n\t\tAssert.assertFalse(queue.isEmpty());\n\n\t\t\r\n\t\trecord5.complete(Arrays.asList(15));\n\n\t\tAssert.assertEquals(Arrays.asList(new StreamRecord<>(15, 6L)), popCompleted(queue));\n\t\tAssert.assertEquals(0, queue.size());\n\t\tAssert.assertTrue(queue.isEmpty());\n\t\tAssert.assertEquals(Collections.emptyList(), popCompleted(queue));\n\t}\n","date":"2019-10-07 15:24:26","endLine":101,"groupId":"103128","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testCompletionOrder","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0c/bded622a4405ee283c9ce385de799b2397d554.src","preCode":"\tpublic void testCompletionOrder() throws Exception {\n\t\tOperatorActions operatorActions = mock(OperatorActions.class);\n\n\t\tfinal UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions);\n\n\t\tStreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L));\n\t\tStreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L));\n\t\tWatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L));\n\t\tStreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L));\n\t\tStreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L));\n\t\tWatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L));\n\t\tStreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L));\n\t\tStreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L));\n\n\t\tList<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3,\n\t\t\trecord4, watermark2, record5, record6);\n\n\t\t\r\n\t\tfor (StreamElementQueueEntry<?> entry : entries) {\n\t\t\tqueue.put(entry);\n\t\t}\n\n\t\tAssert.assertTrue(8 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\t\r\n\t\trecord3.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(firstPoll.isDone());\n\n\t\trecord2.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record2, firstPoll.get());\n\n\t\tCompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\trecord6.complete(Collections.<Integer>emptyList());\n\t\trecord4.complete(Collections.<Integer>emptyList());\n\n\t\tThread.sleep(10L);\n\n\t\t\r\n\t\tAssert.assertFalse(secondPoll.isDone());\n\n\t\trecord1.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record1, secondPoll.get());\n\n\t\t\r\n\t\tAssert.assertEquals(watermark1, queue.poll());\n\n\t\t\r\n\t\tSet<AsyncResult> expected = new HashSet<>(2);\n\t\texpected.add(record3);\n\t\texpected.add(record4);\n\n\t\tSet<AsyncResult> actual = new HashSet<>(2);\n\n\t\tactual.add(queue.poll());\n\t\tactual.add(queue.poll());\n\n\t\tAssert.assertEquals(expected, actual);\n\n\t\tAssert.assertEquals(watermark2, queue.poll());\n\n\t\t\r\n\t\t\r\n\t\tAssert.assertEquals(record6, queue.poll());\n\n\t\t\r\n\t\tAssert.assertTrue(1 == queue.size());\n\n\t\tCompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(\n\t\t\t() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn queue.poll();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\texecutor);\n\n\t\tThread.sleep(10L);\n\n\t\tAssert.assertFalse(thirdPoll.isDone());\n\n\t\trecord5.complete(Collections.<Integer>emptyList());\n\n\t\tAssert.assertEquals(record5, thirdPoll.get());\n\n\t\tAssert.assertTrue(queue.isEmpty());\n\n\t\tverify(operatorActions, never()).failOperator(any(Exception.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/queue/UnorderedStreamElementQueueTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":43,"status":"M"}],"commitId":"148ca3b61726748d0698f3ed526e87e619899179","commitMessage":"@@@[FLINK-14044] [runtime] Removing EmitterThread and reducing synchronization in AsyncWaitOperator\n","date":"2019-10-07 15:24:26","modifiedFileCount":"11","status":"M","submitter":"Arvid Heise"}]
