[{"authorTime":"2020-12-31 00:43:10","codes":[{"authorDate":"2020-12-31 00:43:10","commitOrder":4,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTime = 42;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, false})) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        Thread.sleep(sleepTime + 1);\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            executor.submit(\n                    () -> {\n                        executor.submit(\n                                completeFutureTask,\n                                \"This task will complete the future to resume process input action.\");\n                    },\n                    \"This task will submit another task to execute after processing input once.\");\n\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTime));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        }\n    }\n","date":"2021-01-06 15:49:23","endLine":1282,"groupId":"30055","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ff/cf60334b942c10730f21fe6a4c9b6aced55d43.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTime = 42;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, false})) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        Thread.sleep(sleepTime + 1);\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            executor.submit(\n                    () -> {\n                        executor.submit(\n                                completeFutureTask,\n                                \"This task will complete the future to resume process input action.\");\n                    },\n                    \"This task will submit another task to execute after processing input once.\");\n\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTime));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1245,"status":"MB"},{"authorDate":"2020-12-31 00:43:10","commitOrder":4,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long unAvailableTime = 42;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, true})) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor(unAvailableTime);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(unAvailableTime));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        }\n    }\n","date":"2021-01-06 15:49:23","endLine":1304,"groupId":"30055","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ff/cf60334b942c10730f21fe6a4c9b6aced55d43.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long unAvailableTime = 42;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, true})) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor(unAvailableTime);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(unAvailableTime));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1285,"status":"B"}],"commitId":"9c68f02c5635b1e2e426a8da52c23c84d0bf4fdf","commitMessage":"@@@[FLINK-20717][metrics] Provide new backPressuredTimeMsPerSecond metric\n","date":"2021-01-06 15:49:23","modifiedFileCount":"8","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-01-06 21:57:53","codes":[{"authorDate":"2021-01-06 21:57:53","commitOrder":5,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, false})) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            \r\n            executor.submit(\n                    () ->\n                            new WaitingThread(\n                                            executor,\n                                            completeFutureTask,\n                                            sleepTimeInsideMail,\n                                            sleepTimeOutsideMail)\n                                    .start(),\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        }\n    }\n","date":"2021-01-08 01:37:37","endLine":1340,"groupId":"45095","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/1e24c86b098575a772e02de407beac2b2dccf2.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTime = 42;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, false})) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        Thread.sleep(sleepTime + 1);\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            executor.submit(\n                    () -> {\n                        executor.submit(\n                                completeFutureTask,\n                                \"This task will complete the future to resume process input action.\");\n                    },\n                    \"This task will submit another task to execute after processing input once.\");\n\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTime));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1294,"status":"M"},{"authorDate":"2021-01-06 21:57:53","commitOrder":5,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, true})) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            \r\n            executor.submit(\n                    () ->\n                            new WaitingThread(\n                                            executor,\n                                            completeFutureTask,\n                                            sleepTimeInsideMail,\n                                            sleepTimeOutsideMail)\n                                    .start(),\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        }\n    }\n","date":"2021-01-08 01:37:37","endLine":1388,"groupId":"45095","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/1e24c86b098575a772e02de407beac2b2dccf2.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long unAvailableTime = 42;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, true})) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor(unAvailableTime);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(unAvailableTime));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1343,"status":"M"}],"commitId":"2931750f1219be6ee8136f1a0794175a574d170c","commitMessage":"@@@[FLINK-20868][task][metrics] Pause the idle/back pressure timers during processing mailbox actions\n\nFLINK-20717 introduced a bug.  where any time spent on processing mails.  when task is idle or\nback pressured.  will be accounted to idle or back pressured time instead of the busy time.\n\nThe fix is to assign idle or back pressure timer to the suspenssion marker and pause this\ntimer when MailboxProcessor is running mails.\n","date":"2021-01-08 01:37:37","modifiedFileCount":"5","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-01-07 18:43:00","codes":[{"authorDate":"2021-01-07 18:43:00","commitOrder":6,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail);\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-01-08 01:37:37","endLine":1346,"groupId":"22565","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8e/207a773082e253683abdcad36182856edbe355.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, false})) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            \r\n            executor.submit(\n                    () ->\n                            new WaitingThread(\n                                            executor,\n                                            completeFutureTask,\n                                            sleepTimeInsideMail,\n                                            sleepTimeOutsideMail)\n                                    .start(),\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1295,"status":"M"},{"authorDate":"2021-01-07 18:43:00","commitOrder":6,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail);\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-01-08 01:37:37","endLine":1400,"groupId":"22565","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8e/207a773082e253683abdcad36182856edbe355.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        try (final MockEnvironment environment = setupEnvironment(new boolean[] {true, true})) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            \r\n            executor.submit(\n                    () ->\n                            new WaitingThread(\n                                            executor,\n                                            completeFutureTask,\n                                            sleepTimeInsideMail,\n                                            sleepTimeOutsideMail)\n                                    .start(),\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1349,"status":"M"}],"commitId":"93a88a59a84015edf9e6f8d68dabed7ebd3aed18","commitMessage":"@@@[hotfix][test] Use varargs in StreamTaskTest#setupEnvironment\n","date":"2021-01-08 01:37:37","modifiedFileCount":"1","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-02-08 18:42:01","codes":[{"authorDate":"2021-02-08 18:42:01","commitOrder":7,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-02-09 16:30:58","endLine":1451,"groupId":"6964","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/41/f1585493fee9990abe4b5427f7d8da319fc193.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail);\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1398,"status":"M"},{"authorDate":"2021-02-08 18:42:01","commitOrder":7,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-02-09 16:30:58","endLine":1506,"groupId":"6965","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/41/f1585493fee9990abe4b5427f7d8da319fc193.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail);\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1454,"status":"M"}],"commitId":"10f4ed0579eaf4f079008a16d7bf6300de3d4e09","commitMessage":"@@@[FLINK-20957][task][tests] Make sure we enter the measured sleep after the Task thread started measuring backPressure/idle time\n\nMake sure that the Task thread actually starts measuring the backpressure before\nwe start the measured sleep. The WaitingThread is started from within the mailbox\nso we should first wait until mailbox loop starts idling before we enter the\nmeasured sleep\n\nBug was easy to reproduce/verify after modifying `WaitingThread` starting sequence from:\n```\nexecutor.submit(\n  waitingThread::start. \n  \"This task will submit another task to execute after processing input once.\");\n```\nto:\n```\nexecutor.submit(() -> {\n    waitingThread.start();\n    Thread.sleep(10);\n  }. \n  \"This task will submit another task to execute after processing input once.\");\n```\n","date":"2021-02-09 16:30:58","modifiedFileCount":"2","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-07-28 00:41:07","codes":[{"authorDate":"2021-07-28 00:41:07","commitOrder":8,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-07-29 20:01:28","endLine":1513,"groupId":"6964","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/db/c2f25c565c3b8632fe4e9b276f8433958bf103.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1460,"status":"M"},{"authorDate":"2021-07-28 00:41:07","commitOrder":8,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputMeter();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            throughputCalculator.calculateThroughput();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-07-29 20:01:28","endLine":1578,"groupId":"37787","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/db/c2f25c565c3b8632fe4e9b276f8433958bf103.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1516,"status":"M"}],"commitId":"230f659e790785fd6b8b7660a0bfee5807718b0b","commitMessage":"@@@[FLINK-23452][streaming] Integration ThroughputCalculator in StreamTask for the calculation of the subtask level throughput\n","date":"2021-07-29 20:01:28","modifiedFileCount":"14","status":"M","submitter":"Anton Kalashnikov"},{"authorTime":"2021-08-04 20:01:24","codes":[{"authorDate":"2021-07-28 00:41:07","commitOrder":9,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-07-29 20:01:28","endLine":1513,"groupId":"6964","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/db/c2f25c565c3b8632fe4e9b276f8433958bf103.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1460,"status":"N"},{"authorDate":"2021-08-04 20:01:24","commitOrder":9,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputMeter();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.relativeTimeMillis();\n            throughputCalculator.calculateThroughput();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.relativeTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-08-05 01:42:50","endLine":1589,"groupId":"27118","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ef/b1dea55bade538ec223bb103f917dff3ab30b3.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputMeter();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            long startTs = System.currentTimeMillis();\n            throughputCalculator.calculateThroughput();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = System.currentTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1525,"status":"M"}],"commitId":"97727afa449ae1a576ad78dbb98aa42625545785","commitMessage":"@@@[FLINK-23590][streaming] Replace System.currentTimeMillis with SystemClock.relativeTimeMillis() in the test\nPreviously test was using System.currentTimeMillis() while production code effectively was using System.nanoTime().  which was causing inconsistencies between readings.\n","date":"2021-08-05 01:42:50","modifiedFileCount":"1","status":"M","submitter":"Anton Kalashnikov"},{"authorTime":"2021-08-04 20:05:10","codes":[{"authorDate":"2021-07-28 00:41:07","commitOrder":10,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-07-29 20:01:28","endLine":1513,"groupId":"6964","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/db/c2f25c565c3b8632fe4e9b276f8433958bf103.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1460,"status":"N"},{"authorDate":"2021-08-04 20:05:10","commitOrder":10,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputMeter();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.relativeTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.relativeTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-08-05 01:42:50","endLine":1588,"groupId":"27118","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/15/c77f8695253c2eb90b9a8e071b06fe60e1aff1.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputMeter();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.relativeTimeMillis();\n            throughputCalculator.calculateThroughput();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.relativeTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1525,"status":"M"}],"commitId":"233e5d47450e5d5a980e45045d81dc3e26af1c97","commitMessage":"@@@[hotfix][streaming] Removed useless calculateThroughput in the test\n","date":"2021-08-05 01:42:50","modifiedFileCount":"1","status":"M","submitter":"Anton Kalashnikov"},{"authorTime":"2021-08-05 19:16:50","codes":[{"authorDate":"2021-07-28 00:41:07","commitOrder":11,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-07-29 20:01:28","endLine":1513,"groupId":"6964","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/db/c2f25c565c3b8632fe4e9b276f8433958bf103.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1460,"status":"N"},{"authorDate":"2021-08-05 19:16:50","commitOrder":11,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputCalculator();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.relativeTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.relativeTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-08-12 02:54:47","endLine":1561,"groupId":"27118","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d5/e149bc3842d464f6398fc65fb2ff9ed9a8dc67.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputMeter();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.relativeTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.relativeTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1498,"status":"M"}],"commitId":"e6996cd0b1bb7059ab32f63f051ebdedf93bcc9d","commitMessage":"@@@[hotfix][runtime] setThroughputMeter renamed to setThroughputCalculator according to name of the set object.\n","date":"2021-08-12 02:54:47","modifiedFileCount":"10","status":"M","submitter":"Anton Kalashnikov"},{"authorTime":"2021-08-16 16:54:16","codes":[{"authorDate":"2021-07-28 00:41:07","commitOrder":12,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-07-29 20:01:28","endLine":1513,"groupId":"6964","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/db/c2f25c565c3b8632fe4e9b276f8433958bf103.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1460,"status":"N"},{"authorDate":"2021-08-16 16:54:16","commitOrder":12,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputCalculator();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.absoluteTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.absoluteTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-08-16 16:54:16","endLine":1569,"groupId":"27118","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/d719518441fd7285655d6d661f613d36dc0e0c.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputCalculator();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.relativeTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.relativeTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1506,"status":"M"}],"commitId":"6d89c1de833ddde82d85826e428242c74de77034","commitMessage":"@@@[FLINK-23560][runtime] Calculate absoluteTimeMillis only once for idle metric and throughput calculation. (#16772)\n\n* [FLINK-23560][runtime] Calculate absoluteTimeMillis only once for idle metric and throughput calculation.\n\n* [hotfix][runtime] Update measurement start time only if the measurement was started before throughput calculation.","date":"2021-08-16 16:54:16","modifiedFileCount":"5","status":"M","submitter":"Anton Kalashnikov"},{"authorTime":"2021-08-16 16:54:16","codes":[{"authorDate":"2021-08-26 23:12:25","commitOrder":13,"curCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertFalse(task.mailboxProcessor.isDefaultActionAvailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-08-27 16:00:15","endLine":1504,"groupId":"102488","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessWithUnAvailableOutput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e3/8c459af793a415caf85107121d05e04b69b788.src","preCode":"    public void testProcessWithUnAvailableOutput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, false)) {\n            final int numberOfProcessCalls = 10;\n            final AvailabilityTestInputProcessor inputProcessor =\n                    new AvailabilityTestInputProcessor(numberOfProcessCalls);\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        assertEquals(1, inputProcessor.currentNumProcessCalls);\n                        assertTrue(task.mailboxProcessor.isDefaultActionUnavailable());\n                        environment.getWriter(1).getAvailableFuture().complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getBackPressuredTimePerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"This task will submit another task to execute after processing input once.\");\n\n            long startTs = System.currentTimeMillis();\n\n            task.invoke();\n            long totalDuration = System.currentTimeMillis() - startTs;\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getBackPressuredTimePerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getIdleTimeMsPerSecond().getCount(), is(0L));\n            assertEquals(numberOfProcessCalls, inputProcessor.currentNumProcessCalls);\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1451,"status":"M"},{"authorDate":"2021-08-16 16:54:16","commitOrder":13,"curCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputCalculator();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.absoluteTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.absoluteTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","date":"2021-08-16 16:54:16","endLine":1569,"groupId":"102488","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testProcessWithUnAvailableInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/d719518441fd7285655d6d661f613d36dc0e0c.src","preCode":"    public void testProcessWithUnAvailableInput() throws Exception {\n        final long sleepTimeOutsideMail = 42;\n        final long sleepTimeInsideMail = 44;\n        final int incomingDataSize = 10_000;\n\n        @Nullable WaitingThread waitingThread = null;\n        try (final MockEnvironment environment = setupEnvironment(true, true)) {\n            final UnAvailableTestInputProcessor inputProcessor =\n                    new UnAvailableTestInputProcessor();\n            final StreamTask task =\n                    new MockStreamTaskBuilder(environment)\n                            .setStreamInputProcessor(inputProcessor)\n                            .build();\n            TaskIOMetricGroup ioMetricGroup =\n                    task.getEnvironment().getMetricGroup().getIOMetricGroup();\n            ThroughputCalculator throughputCalculator = environment.getThroughputCalculator();\n\n            final MailboxExecutor executor = task.mailboxProcessor.getMainMailboxExecutor();\n            final RunnableWithException completeFutureTask =\n                    () -> {\n                        inputProcessor\n                                .availabilityProvider\n                                .getUnavailableToResetAvailable()\n                                .complete(null);\n                    };\n\n            waitingThread =\n                    new WaitingThread(\n                            executor,\n                            completeFutureTask,\n                            sleepTimeInsideMail,\n                            sleepTimeOutsideMail,\n                            ioMetricGroup.getIdleTimeMsPerSecond());\n            \r\n            executor.submit(\n                    waitingThread::start,\n                    \"Start WaitingThread after Task starts processing input.\");\n\n            SystemClock clock = SystemClock.getInstance();\n\n            long startTs = clock.absoluteTimeMillis();\n            throughputCalculator.incomingDataSize(incomingDataSize);\n            task.invoke();\n            long resultThroughput = throughputCalculator.calculateThroughput();\n            long totalDuration = clock.absoluteTimeMillis() - startTs;\n\n            assertThat(\n                    resultThroughput,\n                    greaterThanOrEqualTo(\n                            incomingDataSize * 1000 / (totalDuration - sleepTimeOutsideMail)));\n\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    greaterThanOrEqualTo(sleepTimeOutsideMail));\n            assertThat(\n                    ioMetricGroup.getIdleTimeMsPerSecond().getCount(),\n                    Matchers.lessThanOrEqualTo(totalDuration - sleepTimeInsideMail));\n            assertThat(ioMetricGroup.getBackPressuredTimePerSecond().getCount(), is(0L));\n        } finally {\n            if (waitingThread != null) {\n                waitingThread.join();\n            }\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1506,"status":"N"}],"commitId":"93292a64d10e01d66735843d26a82890628172f3","commitMessage":"@@@[hotfix][runtime] Invert MailboxProcessor#isDefaultUnactionAvailable to MailboxProcessor#isDefaultActionAvailable\n","date":"2021-08-27 16:00:15","modifiedFileCount":"4","status":"M","submitter":"Fabian Paul"}]
