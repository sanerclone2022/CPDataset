[{"authorTime":"2018-12-18 00:09:47","codes":[{"authorDate":"2018-12-18 00:09:47","commitOrder":3,"curCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","date":"2019-01-26 02:14:54","endLine":1414,"groupId":"9740","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7a/585db9ec5549f6bb358f2d48e45463996047af.src","preCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1389,"status":"MB"},{"authorDate":"2018-12-18 00:09:47","commitOrder":3,"curCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tStateDescriptor<?, V> stateDesc,\n\t\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(newMetaInfo);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","date":"2019-01-26 02:14:54","endLine":271,"groupId":"26631","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/56/374fe6aa386619eee4fd2bbe5313b240f8f3e2.src","preCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tStateDescriptor<?, V> stateDesc,\n\t\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(newMetaInfo);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"B"}],"commitId":"bced96a5a0b8f7b7848add316c12071e0398404a","commitMessage":"@@@[FLINK-11171] Avoid concurrent usage of StateSnapshotTransformer\n\nTest non concurrent access of StateSnapshotTransformer\n\nRefactor out testNonConcurrentSnapshotTransformerAccess to separte StateSnapshotTransformerTest\n\nuse element serializer from new meta info.  duplicate it in rocksdb transformer factory.  test concurrent access for element serializer\n\nThis closes #7320.\n","date":"2019-01-26 02:14:54","modifiedFileCount":"11","status":"M","submitter":"Andrey Zagrebin"},{"authorTime":"2019-03-01 03:02:35","codes":[{"authorDate":"2018-12-18 00:09:47","commitOrder":4,"curCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","date":"2019-01-26 02:14:54","endLine":1414,"groupId":"9740","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7a/585db9ec5549f6bb358f2d48e45463996047af.src","preCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1389,"status":"N"},{"authorDate":"2019-03-01 03:02:35","commitOrder":4,"curCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(this, newMetaInfo);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","date":"2019-03-05 03:27:50","endLine":245,"groupId":"26631","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a3/a0c29b411a546896512fc3f5b0695624929fa2.src","preCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tStateDescriptor<?, V> stateDesc,\n\t\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(newMetaInfo);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"}],"commitId":"237d07c76b51c171f0f41f9f82d777df26da1dd4","commitMessage":"@@@[FLINK-11730] [State Backends] Make HeapKeyedStateBackend follow the builder pattern\n\nThis closes #7866.\n","date":"2019-03-05 03:27:50","modifiedFileCount":"18","status":"M","submitter":"Yu Li"},{"authorTime":"2019-04-08 17:32:48","codes":[{"authorDate":"2018-12-18 00:09:47","commitOrder":5,"curCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","date":"2019-01-26 02:14:54","endLine":1414,"groupId":"9740","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7a/585db9ec5549f6bb358f2d48e45463996047af.src","preCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1389,"status":"N"},{"authorDate":"2019-04-08 17:32:48","commitOrder":5,"curCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializerProvider.currentSchemaSerializer());\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","date":"2019-04-10 14:15:03","endLine":248,"groupId":"26631","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/25/c34702576149bb9844b59305a8275a266a8310.src","preCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(this, newMetaInfo);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"}],"commitId":"5dc8afd4c8bfea1b2aea0eb6f83ffce38bad3955","commitMessage":"@@@[FLINK-12121] [State Backends] Use composition instead of inheritance for InternalKeyContext in backends\n\nThis closes #8122.\n","date":"2019-04-10 14:15:03","modifiedFileCount":"21","status":"M","submitter":"Yu Li"},{"authorTime":"2019-04-10 17:32:19","codes":[{"authorDate":"2018-12-18 00:09:47","commitOrder":6,"curCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","date":"2019-01-26 02:14:54","endLine":1414,"groupId":"9740","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7a/585db9ec5549f6bb358f2d48e45463996047af.src","preCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\t\tStateDescriptor<S, SV> stateDesc,\n\t\t\tTypeSerializer<N> namespaceSerializer,\n\t\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1389,"status":"N"},{"authorDate":"2019-04-10 17:32:19","commitOrder":6,"curCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializer);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","date":"2019-04-11 12:45:21","endLine":247,"groupId":"26631","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7e/184ab958814c9c1d9084d607d18cfdaa074066.src","preCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializerProvider.currentSchemaSerializer());\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"}],"commitId":"1132a52a58c3710a9a183111fda84cd1432605fa","commitMessage":"@@@[FLINK-12066] [State Backends] Remove StateSerializerProvider field in keyed state backend\n\nThis closes #8078.\n","date":"2019-04-11 12:45:21","modifiedFileCount":"5","status":"M","submitter":"Yu Li"},{"authorTime":"2020-11-04 20:30:30","codes":[{"authorDate":"2020-11-04 20:30:30","commitOrder":7,"curCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\tStateDescriptor<S, SV> stateDesc,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\t\r\n\t\t\r\n\t\tTypeSerializer<N> previousNamespaceSerializer =\n\t\t\trestoredKvStateMetaInfo.getNamespaceSerializer();\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer (\" + namespaceSerializer + \") must be compatible with the old namespace serializer (\" + previousNamespaceSerializer + \").\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\r\n\t\t\r\n\t\tTypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer (\" + stateSerializer + \") must not be incompatible with the old state serializer (\" + previousStateSerializer + \").\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","date":"2020-11-10 19:22:22","endLine":597,"groupId":"9740","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/28b1819772317f0a8f46000b589ece4aaacf40.src","preCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\tStateDescriptor<S, SV> stateDesc,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer must be compatible.\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer cannot be incompatible.\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":563,"status":"M"},{"authorDate":"2020-11-04 20:30:30","commitOrder":7,"curCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tTypeSerializer<N> previousNamespaceSerializer =\n\t\t\t\trestoredKvMetaInfo.getNamespaceSerializer();\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer (\" + namespaceSerializer + \") must be compatible with the old namespace serializer (\" + previousNamespaceSerializer + \").\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tTypeSerializer<V> previousStateSerializer =\n\t\t\t\trestoredKvMetaInfo.getStateSerializer();\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer (\" + newStateSerializer + \") must not be incompatible with the old state serializer (\" + previousStateSerializer + \").\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializer);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","date":"2020-11-10 19:22:22","endLine":255,"groupId":"3402","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/94/d65f5671ef236ceb0ea5a29d8b1bb92af5d907.src","preCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer must be compatible.\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer must not be incompatible.\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializer);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"}],"commitId":"700a92d3dd71aa693ffa669a0fd14c7e46f95923","commitMessage":"@@@[FLINK-19972][serialization] add more hints in case of incompatbilities\n","date":"2020-11-10 19:22:22","modifiedFileCount":"4","status":"M","submitter":"Nico Kruber"},{"authorTime":"2020-11-04 20:30:30","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":8,"curCode":"            RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n                    Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>>\n                            oldStateInfo,\n                    StateDescriptor<S, SV> stateDesc,\n                    TypeSerializer<N> namespaceSerializer,\n                    TypeSerializer<SV> stateSerializer)\n                    throws Exception {\n\n        @SuppressWarnings(\"unchecked\")\n        RegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n        \r\n        \r\n        TypeSerializer<N> previousNamespaceSerializer =\n                restoredKvStateMetaInfo.getNamespaceSerializer();\n\n        TypeSerializerSchemaCompatibility<N> s =\n                restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n        if (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new namespace serializer (\"\n                            + namespaceSerializer\n                            + \") must be compatible with the old namespace serializer (\"\n                            + previousNamespaceSerializer\n                            + \").\");\n        }\n\n        restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n        \r\n        \r\n        TypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n        TypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n                restoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n        if (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n            migrateStateValues(stateDesc, oldStateInfo);\n        } else if (newStateSerializerCompatibility.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new state serializer (\"\n                            + stateSerializer\n                            + \") must not be incompatible with the old state serializer (\"\n                            + previousStateSerializer\n                            + \").\");\n        }\n\n        return restoredKvStateMetaInfo;\n    }\n","date":"2020-12-28 21:35:13","endLine":681,"groupId":"9740","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/f71926ea129b9d1c8af8a4109b4275c2beba7a.src","preCode":"\tprivate <N, S extends State, SV> RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n\t\tTuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> oldStateInfo,\n\t\tStateDescriptor<S, SV> stateDesc,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<SV> stateSerializer) throws Exception {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n\t\t\r\n\t\t\r\n\t\tTypeSerializer<N> previousNamespaceSerializer =\n\t\t\trestoredKvStateMetaInfo.getNamespaceSerializer();\n\n\t\tTypeSerializerSchemaCompatibility<N> s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\tif (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new namespace serializer (\" + namespaceSerializer + \") must be compatible with the old namespace serializer (\" + previousNamespaceSerializer + \").\");\n\t\t}\n\n\t\trestoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\r\n\t\t\r\n\t\tTypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n\t\tTypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n\t\t\trestoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n\t\tif (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n\t\t\tmigrateStateValues(stateDesc, oldStateInfo);\n\t\t} else if (newStateSerializerCompatibility.isIncompatible()) {\n\t\t\tthrow new StateMigrationException(\"The new state serializer (\" + stateSerializer + \") must not be incompatible with the old state serializer (\" + previousStateSerializer + \").\");\n\t\t}\n\n\t\treturn restoredKvStateMetaInfo;\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"M"},{"authorDate":"2020-11-04 20:30:30","commitOrder":8,"curCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tTypeSerializer<N> previousNamespaceSerializer =\n\t\t\t\trestoredKvMetaInfo.getNamespaceSerializer();\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer (\" + namespaceSerializer + \") must be compatible with the old namespace serializer (\" + previousNamespaceSerializer + \").\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tTypeSerializer<V> previousStateSerializer =\n\t\t\t\trestoredKvMetaInfo.getStateSerializer();\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer (\" + newStateSerializer + \") must not be incompatible with the old state serializer (\" + previousStateSerializer + \").\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializer);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","date":"2020-11-10 19:22:22","endLine":255,"groupId":"3402","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/94/d65f5671ef236ceb0ea5a29d8b1bb92af5d907.src","preCode":"\tprivate <N, V> StateTable<K, N, V> tryRegisterStateTable(\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tStateDescriptor<?, V> stateDesc,\n\t\t@Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tStateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n\t\tTypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n\t\tif (stateTable != null) {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo();\n\n\t\t\trestoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tTypeSerializer<N> previousNamespaceSerializer =\n\t\t\t\trestoredKvMetaInfo.getNamespaceSerializer();\n\n\t\t\tTypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n\t\t\tif (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new namespace serializer (\" + namespaceSerializer + \") must be compatible with the old namespace serializer (\" + previousNamespaceSerializer + \").\");\n\t\t\t}\n\n\t\t\trestoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tTypeSerializer<V> previousStateSerializer =\n\t\t\t\trestoredKvMetaInfo.getStateSerializer();\n\n\t\t\tTypeSerializerSchemaCompatibility<V> stateCompatibility =\n\t\t\t\trestoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n\t\t\tif (stateCompatibility.isIncompatible()) {\n\t\t\t\tthrow new StateMigrationException(\"For heap backends, the new state serializer (\" + newStateSerializer + \") must not be incompatible with the old state serializer (\" + previousStateSerializer + \").\");\n\t\t\t}\n\n\t\t\tstateTable.setMetaInfo(restoredKvMetaInfo);\n\t\t} else {\n\t\t\tRegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(\n\t\t\t\tstateDesc.getType(),\n\t\t\t\tstateDesc.getName(),\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnewStateSerializer,\n\t\t\t\tsnapshotTransformFactory);\n\n\t\t\tstateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializer);\n\t\t\tregisteredKVStates.put(stateDesc.getName(), stateTable);\n\t\t}\n\n\t\treturn stateTable;\n\t}\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"N"}],"commitId":"c6997c97c575d334679915c328792b8a3067cfb5","commitMessage":"@@@[FLINK-20651] Format code with Spotless/google-java-format\n","date":"2020-12-28 21:35:13","modifiedFileCount":"11013","status":"M","submitter":"Rufus Refactor"},{"authorTime":"2021-01-21 19:45:02","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":9,"curCode":"            RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n                    Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>>\n                            oldStateInfo,\n                    StateDescriptor<S, SV> stateDesc,\n                    TypeSerializer<N> namespaceSerializer,\n                    TypeSerializer<SV> stateSerializer)\n                    throws Exception {\n\n        @SuppressWarnings(\"unchecked\")\n        RegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n        \r\n        \r\n        TypeSerializer<N> previousNamespaceSerializer =\n                restoredKvStateMetaInfo.getNamespaceSerializer();\n\n        TypeSerializerSchemaCompatibility<N> s =\n                restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n        if (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new namespace serializer (\"\n                            + namespaceSerializer\n                            + \") must be compatible with the old namespace serializer (\"\n                            + previousNamespaceSerializer\n                            + \").\");\n        }\n\n        restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n        \r\n        \r\n        TypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n        TypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n                restoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n        if (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n            migrateStateValues(stateDesc, oldStateInfo);\n        } else if (newStateSerializerCompatibility.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new state serializer (\"\n                            + stateSerializer\n                            + \") must not be incompatible with the old state serializer (\"\n                            + previousStateSerializer\n                            + \").\");\n        }\n\n        return restoredKvStateMetaInfo;\n    }\n","date":"2020-12-28 21:35:13","endLine":681,"groupId":"9740","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/f71926ea129b9d1c8af8a4109b4275c2beba7a.src","preCode":"            RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n                    Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>>\n                            oldStateInfo,\n                    StateDescriptor<S, SV> stateDesc,\n                    TypeSerializer<N> namespaceSerializer,\n                    TypeSerializer<SV> stateSerializer)\n                    throws Exception {\n\n        @SuppressWarnings(\"unchecked\")\n        RegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n        \r\n        \r\n        TypeSerializer<N> previousNamespaceSerializer =\n                restoredKvStateMetaInfo.getNamespaceSerializer();\n\n        TypeSerializerSchemaCompatibility<N> s =\n                restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n        if (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new namespace serializer (\"\n                            + namespaceSerializer\n                            + \") must be compatible with the old namespace serializer (\"\n                            + previousNamespaceSerializer\n                            + \").\");\n        }\n\n        restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n        \r\n        \r\n        TypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n        TypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n                restoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n        if (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n            migrateStateValues(stateDesc, oldStateInfo);\n        } else if (newStateSerializerCompatibility.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new state serializer (\"\n                            + stateSerializer\n                            + \") must not be incompatible with the old state serializer (\"\n                            + previousStateSerializer\n                            + \").\");\n        }\n\n        return restoredKvStateMetaInfo;\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"N"},{"authorDate":"2021-01-21 19:45:02","commitOrder":9,"curCode":"    private <N, V> StateTable<K, N, V> tryRegisterStateTable(\n            TypeSerializer<N> namespaceSerializer,\n            StateDescriptor<?, V> stateDesc,\n            @Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory)\n            throws StateMigrationException {\n\n        @SuppressWarnings(\"unchecked\")\n        StateTable<K, N, V> stateTable =\n                (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n        TypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n        if (stateTable != null) {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo =\n                    stateTable.getMetaInfo();\n\n            restoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n            \r\n            \r\n            TypeSerializer<N> previousNamespaceSerializer =\n                    restoredKvMetaInfo.getNamespaceSerializer();\n\n            TypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n                    restoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n            if (namespaceCompatibility.isCompatibleAfterMigration()\n                    || namespaceCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new namespace serializer (\"\n                                + namespaceSerializer\n                                + \") must be compatible with the old namespace serializer (\"\n                                + previousNamespaceSerializer\n                                + \").\");\n            }\n\n            restoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n            \r\n            \r\n            TypeSerializer<V> previousStateSerializer = restoredKvMetaInfo.getStateSerializer();\n\n            TypeSerializerSchemaCompatibility<V> stateCompatibility =\n                    restoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n            if (stateCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new state serializer (\"\n                                + newStateSerializer\n                                + \") must not be incompatible with the old state serializer (\"\n                                + previousStateSerializer\n                                + \").\");\n            }\n\n            stateTable.setMetaInfo(restoredKvMetaInfo);\n        } else {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo =\n                    new RegisteredKeyValueStateBackendMetaInfo<>(\n                            stateDesc.getType(),\n                            stateDesc.getName(),\n                            namespaceSerializer,\n                            newStateSerializer,\n                            snapshotTransformFactory);\n\n            stateTable = stateTableFactory.newStateTable(keyContext, newMetaInfo, keySerializer);\n            registeredKVStates.put(stateDesc.getName(), stateTable);\n        }\n\n        return stateTable;\n    }\n","date":"2021-01-26 18:40:06","endLine":284,"groupId":"3402","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/84/fb4b2fae2e19773ada2f136c27664b4a8b3d83.src","preCode":"    private <N, V> StateTable<K, N, V> tryRegisterStateTable(\n            TypeSerializer<N> namespaceSerializer,\n            StateDescriptor<?, V> stateDesc,\n            @Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory)\n            throws StateMigrationException {\n\n        @SuppressWarnings(\"unchecked\")\n        StateTable<K, N, V> stateTable =\n                (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n        TypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n        if (stateTable != null) {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo =\n                    stateTable.getMetaInfo();\n\n            restoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n            \r\n            \r\n            TypeSerializer<N> previousNamespaceSerializer =\n                    restoredKvMetaInfo.getNamespaceSerializer();\n\n            TypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n                    restoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n            if (namespaceCompatibility.isCompatibleAfterMigration()\n                    || namespaceCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new namespace serializer (\"\n                                + namespaceSerializer\n                                + \") must be compatible with the old namespace serializer (\"\n                                + previousNamespaceSerializer\n                                + \").\");\n            }\n\n            restoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n            \r\n            \r\n            TypeSerializer<V> previousStateSerializer = restoredKvMetaInfo.getStateSerializer();\n\n            TypeSerializerSchemaCompatibility<V> stateCompatibility =\n                    restoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n            if (stateCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new state serializer (\"\n                                + newStateSerializer\n                                + \") must not be incompatible with the old state serializer (\"\n                                + previousStateSerializer\n                                + \").\");\n            }\n\n            stateTable.setMetaInfo(restoredKvMetaInfo);\n        } else {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo =\n                    new RegisteredKeyValueStateBackendMetaInfo<>(\n                            stateDesc.getType(),\n                            stateDesc.getName(),\n                            namespaceSerializer,\n                            newStateSerializer,\n                            snapshotTransformFactory);\n\n            stateTable = snapshotStrategy.newStateTable(keyContext, newMetaInfo, keySerializer);\n            registeredKVStates.put(stateDesc.getName(), stateTable);\n        }\n\n        return stateTable;\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"}],"commitId":"8778f56a469108cf3a3424a3ae5180b95fb2cfa3","commitMessage":"@@@[FLINK-21072] Refactor the SnapshotStrategy hierarchy\n\n1. The refactoring simplifies the snapshot strategy hierarchy a bit.\n\n2. It extracts the synchronous/asynchronous execution out of the SnapshotStrategy to a separate SnapshotStrategyRunner. Prior to those changes the logic was duplicated in most of the strategies.\n\n3. It introduces the concept of SnapshotResources for the synchronous part which can be later on used for introducing a common SavepointSnapshotResources.\n\nThis closes #14719\n","date":"2021-01-26 18:40:06","modifiedFileCount":"17","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-01-21 19:45:02","codes":[{"authorDate":"2021-02-09 00:09:19","commitOrder":10,"curCode":"            RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n                    Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>>\n                            oldStateInfo,\n                    StateDescriptor<S, SV> stateDesc,\n                    TypeSerializer<N> namespaceSerializer,\n                    TypeSerializer<SV> stateSerializer)\n                    throws Exception {\n\n        RegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n        \r\n        \r\n        TypeSerializer<N> previousNamespaceSerializer =\n                restoredKvStateMetaInfo.getNamespaceSerializer();\n\n        TypeSerializerSchemaCompatibility<N> s =\n                restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n        if (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new namespace serializer (\"\n                            + namespaceSerializer\n                            + \") must be compatible with the old namespace serializer (\"\n                            + previousNamespaceSerializer\n                            + \").\");\n        }\n\n        restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n        \r\n        \r\n        TypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n        TypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n                restoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n        if (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n            migrateStateValues(stateDesc, oldStateInfo);\n        } else if (newStateSerializerCompatibility.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new state serializer (\"\n                            + stateSerializer\n                            + \") must not be incompatible with the old state serializer (\"\n                            + previousStateSerializer\n                            + \").\");\n        }\n\n        return restoredKvStateMetaInfo;\n    }\n","date":"2021-02-25 00:19:05","endLine":699,"groupId":"1289","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"updateRestoredStateMetaInfo","params":"(Tuple2<ColumnFamilyHandle@RegisteredKeyValueStateBackendMetaInfo<N@SV>>oldStateInfo@StateDescriptor<S@SV>stateDesc@TypeSerializer<N>namespaceSerializer@TypeSerializer<SV>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0f/5395561c93680e5e233bd6cea993f6bb160556.src","preCode":"            RegisteredKeyValueStateBackendMetaInfo<N, SV> updateRestoredStateMetaInfo(\n                    Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>>\n                            oldStateInfo,\n                    StateDescriptor<S, SV> stateDesc,\n                    TypeSerializer<N> namespaceSerializer,\n                    TypeSerializer<SV> stateSerializer)\n                    throws Exception {\n\n        @SuppressWarnings(\"unchecked\")\n        RegisteredKeyValueStateBackendMetaInfo<N, SV> restoredKvStateMetaInfo = oldStateInfo.f1;\n\n        \r\n        \r\n        TypeSerializer<N> previousNamespaceSerializer =\n                restoredKvStateMetaInfo.getNamespaceSerializer();\n\n        TypeSerializerSchemaCompatibility<N> s =\n                restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n        if (s.isCompatibleAfterMigration() || s.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new namespace serializer (\"\n                            + namespaceSerializer\n                            + \") must be compatible with the old namespace serializer (\"\n                            + previousNamespaceSerializer\n                            + \").\");\n        }\n\n        restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);\n\n        \r\n        \r\n        TypeSerializer<SV> previousStateSerializer = restoredKvStateMetaInfo.getStateSerializer();\n\n        TypeSerializerSchemaCompatibility<SV> newStateSerializerCompatibility =\n                restoredKvStateMetaInfo.updateStateSerializer(stateSerializer);\n        if (newStateSerializerCompatibility.isCompatibleAfterMigration()) {\n            migrateStateValues(stateDesc, oldStateInfo);\n        } else if (newStateSerializerCompatibility.isIncompatible()) {\n            throw new StateMigrationException(\n                    \"The new state serializer (\"\n                            + stateSerializer\n                            + \") must not be incompatible with the old state serializer (\"\n                            + previousStateSerializer\n                            + \").\");\n        }\n\n        return restoredKvStateMetaInfo;\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":653,"status":"M"},{"authorDate":"2021-01-21 19:45:02","commitOrder":10,"curCode":"    private <N, V> StateTable<K, N, V> tryRegisterStateTable(\n            TypeSerializer<N> namespaceSerializer,\n            StateDescriptor<?, V> stateDesc,\n            @Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory)\n            throws StateMigrationException {\n\n        @SuppressWarnings(\"unchecked\")\n        StateTable<K, N, V> stateTable =\n                (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n        TypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n        if (stateTable != null) {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo =\n                    stateTable.getMetaInfo();\n\n            restoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n            \r\n            \r\n            TypeSerializer<N> previousNamespaceSerializer =\n                    restoredKvMetaInfo.getNamespaceSerializer();\n\n            TypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n                    restoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n            if (namespaceCompatibility.isCompatibleAfterMigration()\n                    || namespaceCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new namespace serializer (\"\n                                + namespaceSerializer\n                                + \") must be compatible with the old namespace serializer (\"\n                                + previousNamespaceSerializer\n                                + \").\");\n            }\n\n            restoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n            \r\n            \r\n            TypeSerializer<V> previousStateSerializer = restoredKvMetaInfo.getStateSerializer();\n\n            TypeSerializerSchemaCompatibility<V> stateCompatibility =\n                    restoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n            if (stateCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new state serializer (\"\n                                + newStateSerializer\n                                + \") must not be incompatible with the old state serializer (\"\n                                + previousStateSerializer\n                                + \").\");\n            }\n\n            stateTable.setMetaInfo(restoredKvMetaInfo);\n        } else {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo =\n                    new RegisteredKeyValueStateBackendMetaInfo<>(\n                            stateDesc.getType(),\n                            stateDesc.getName(),\n                            namespaceSerializer,\n                            newStateSerializer,\n                            snapshotTransformFactory);\n\n            stateTable = stateTableFactory.newStateTable(keyContext, newMetaInfo, keySerializer);\n            registeredKVStates.put(stateDesc.getName(), stateTable);\n        }\n\n        return stateTable;\n    }\n","date":"2021-01-26 18:40:06","endLine":284,"groupId":"1289","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"tryRegisterStateTable","params":"(TypeSerializer<N>namespaceSerializer@StateDescriptor<?@V>stateDesc@@NonnullStateSnapshotTransformFactory<V>snapshotTransformFactory)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/84/fb4b2fae2e19773ada2f136c27664b4a8b3d83.src","preCode":"    private <N, V> StateTable<K, N, V> tryRegisterStateTable(\n            TypeSerializer<N> namespaceSerializer,\n            StateDescriptor<?, V> stateDesc,\n            @Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory)\n            throws StateMigrationException {\n\n        @SuppressWarnings(\"unchecked\")\n        StateTable<K, N, V> stateTable =\n                (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName());\n\n        TypeSerializer<V> newStateSerializer = stateDesc.getSerializer();\n\n        if (stateTable != null) {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo =\n                    stateTable.getMetaInfo();\n\n            restoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory);\n\n            \r\n            \r\n            TypeSerializer<N> previousNamespaceSerializer =\n                    restoredKvMetaInfo.getNamespaceSerializer();\n\n            TypeSerializerSchemaCompatibility<N> namespaceCompatibility =\n                    restoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);\n            if (namespaceCompatibility.isCompatibleAfterMigration()\n                    || namespaceCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new namespace serializer (\"\n                                + namespaceSerializer\n                                + \") must be compatible with the old namespace serializer (\"\n                                + previousNamespaceSerializer\n                                + \").\");\n            }\n\n            restoredKvMetaInfo.checkStateMetaInfo(stateDesc);\n\n            \r\n            \r\n            TypeSerializer<V> previousStateSerializer = restoredKvMetaInfo.getStateSerializer();\n\n            TypeSerializerSchemaCompatibility<V> stateCompatibility =\n                    restoredKvMetaInfo.updateStateSerializer(newStateSerializer);\n\n            if (stateCompatibility.isIncompatible()) {\n                throw new StateMigrationException(\n                        \"For heap backends, the new state serializer (\"\n                                + newStateSerializer\n                                + \") must not be incompatible with the old state serializer (\"\n                                + previousStateSerializer\n                                + \").\");\n            }\n\n            stateTable.setMetaInfo(restoredKvMetaInfo);\n        } else {\n            RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo =\n                    new RegisteredKeyValueStateBackendMetaInfo<>(\n                            stateDesc.getType(),\n                            stateDesc.getName(),\n                            namespaceSerializer,\n                            newStateSerializer,\n                            snapshotTransformFactory);\n\n            stateTable = stateTableFactory.newStateTable(keyContext, newMetaInfo, keySerializer);\n            registeredKVStates.put(stateDesc.getName(), stateTable);\n        }\n\n        return stateTable;\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"N"}],"commitId":"a9fef44654b0c154af573f5c27398e27d3351cf9","commitMessage":"@@@[FLINK-21344] Handle heap timers in Rocks state\n\nWe serialize the heap timers into the same format as if they were\nactually stored in RocksDB instead of storing them in a raw operator\nstate. It lets users change between using heap and RocksDB timers.\n","date":"2021-02-25 00:19:05","modifiedFileCount":"14","status":"M","submitter":"Dawid Wysakowicz"}]
