[{"authorTime":"2021-05-10 13:46:43","codes":[{"authorDate":"2020-09-22 20:14:52","commitOrder":7,"curCode":"\tpublic void testWatermarkMetrics() throws Exception {\n\t\tOperatorID mainOperatorId = new OperatorID();\n\t\tOperatorID chainedOperatorId = new OperatorID();\n\n\t\tInterceptingOperatorMetricGroup mainOperatorMetricGroup = new InterceptingOperatorMetricGroup();\n\t\tInterceptingOperatorMetricGroup chainedOperatorMetricGroup = new InterceptingOperatorMetricGroup();\n\t\tInterceptingTaskMetricGroup taskMetricGroup = new InterceptingTaskMetricGroup() {\n\t\t\t@Override\n\t\t\tpublic OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n\t\t\t\tif (id.equals(mainOperatorId)) {\n\t\t\t\t\treturn mainOperatorMetricGroup;\n\t\t\t\t} else if (id.equals(chainedOperatorId)) {\n\t\t\t\t\treturn chainedOperatorMetricGroup;\n\t\t\t\t} else {\n\t\t\t\t\treturn super.getOrAddOperator(id, name);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n\t\t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n\t\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t\t.addSourceInput(\n\t\t\t\t\t\tnew SourceOperatorFactory<>(\n\t\t\t\t\t\t\tnew MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n\t\t\t\t\t\t\tWatermarkStrategy.forGenerator(ctx -> new RecordToWatermarkGenerator())))\n\t\t\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n\t\t\t\t\t.setupOperatorChain(mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n\t\t\t\t\t.chain(\n\t\t\t\t\t\tchainedOperatorId,\n\t\t\t\t\t\tnew WatermarkMetricOperator(),\n\t\t\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t\t\t.finish()\n\t\t\t\t\t.setTaskMetricGroup(taskMetricGroup)\n\t\t\t\t\t.build()) {\n\t\t\tGauge<Long> taskInputWatermarkGauge = (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n\t\t\tGauge<Long> mainInput1WatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n\t\t\tGauge<Long> mainInput2WatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n\t\t\tGauge<Long> mainInput3WatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n\t\t\tGauge<Long> mainInputWatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n\t\t\tGauge<Long> mainOutputWatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\t\t\tGauge<Long> chainedInputWatermarkGauge = (Gauge<Long>) chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n\t\t\tGauge<Long> chainedOutputWatermarkGauge = (Gauge<Long>) chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n\t\t\tassertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\ttestHarness.processElement(new Watermark(1L), 0);\n\t\t\tassertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\taddSourceRecords(testHarness, 1, 2);\n\t\t\ttestHarness.processAll();\n\t\t\tassertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\ttestHarness.processElement(new Watermark(2L), 1);\n\t\t\tassertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\ttestHarness.processElement(new Watermark(4L), 0);\n\t\t\taddSourceRecords(testHarness, 1, 3);\n\t\t\ttestHarness.processAll();\n\t\t\tassertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\tfinishAddingRecords(testHarness, 1);\n\t\t\ttestHarness.endInput();\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t}\n\t}\n","date":"2020-09-25 21:50:44","endLine":653,"groupId":"3368","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testWatermarkMetrics","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b1/c86b623ec6eb3063f14845b594e98690399260.src","preCode":"\tpublic void testWatermarkMetrics() throws Exception {\n\t\tOperatorID mainOperatorId = new OperatorID();\n\t\tOperatorID chainedOperatorId = new OperatorID();\n\n\t\tInterceptingOperatorMetricGroup mainOperatorMetricGroup = new InterceptingOperatorMetricGroup();\n\t\tInterceptingOperatorMetricGroup chainedOperatorMetricGroup = new InterceptingOperatorMetricGroup();\n\t\tInterceptingTaskMetricGroup taskMetricGroup = new InterceptingTaskMetricGroup() {\n\t\t\t@Override\n\t\t\tpublic OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n\t\t\t\tif (id.equals(mainOperatorId)) {\n\t\t\t\t\treturn mainOperatorMetricGroup;\n\t\t\t\t} else if (id.equals(chainedOperatorId)) {\n\t\t\t\t\treturn chainedOperatorMetricGroup;\n\t\t\t\t} else {\n\t\t\t\t\treturn super.getOrAddOperator(id, name);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n\t\t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n\t\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t\t.addSourceInput(\n\t\t\t\t\t\tnew SourceOperatorFactory<>(\n\t\t\t\t\t\t\tnew MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n\t\t\t\t\t\t\tWatermarkStrategy.forGenerator(ctx -> new RecordToWatermarkGenerator())))\n\t\t\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n\t\t\t\t\t.setupOperatorChain(mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n\t\t\t\t\t.chain(\n\t\t\t\t\t\tchainedOperatorId,\n\t\t\t\t\t\tnew WatermarkMetricOperator(),\n\t\t\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t\t\t.finish()\n\t\t\t\t\t.setTaskMetricGroup(taskMetricGroup)\n\t\t\t\t\t.build()) {\n\t\t\tGauge<Long> taskInputWatermarkGauge = (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n\t\t\tGauge<Long> mainInput1WatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n\t\t\tGauge<Long> mainInput2WatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n\t\t\tGauge<Long> mainInput3WatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n\t\t\tGauge<Long> mainInputWatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n\t\t\tGauge<Long> mainOutputWatermarkGauge = (Gauge<Long>) mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\t\t\tGauge<Long> chainedInputWatermarkGauge = (Gauge<Long>) chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n\t\t\tGauge<Long> chainedOutputWatermarkGauge = (Gauge<Long>) chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n\t\t\tassertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\ttestHarness.processElement(new Watermark(1L), 0);\n\t\t\tassertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\taddSourceRecords(testHarness, 1, 2);\n\t\t\ttestHarness.processAll();\n\t\t\tassertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\ttestHarness.processElement(new Watermark(2L), 1);\n\t\t\tassertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\ttestHarness.processElement(new Watermark(4L), 0);\n\t\t\taddSourceRecords(testHarness, 1, 3);\n\t\t\ttestHarness.processAll();\n\t\t\tassertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n\t\t\tassertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n\t\t\tfinishAddingRecords(testHarness, 1);\n\t\t\ttestHarness.endInput();\n\t\t\ttestHarness.waitForTaskCompletion();\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":552,"status":"NB"},{"authorDate":"2021-05-10 13:46:43","commitOrder":7,"curCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())))\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","date":"2021-05-12 20:07:58","endLine":1042,"groupId":"3111","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWatermarkTestHarness","params":"(intinputChannels@booleanreaderMarkIdleOnNoSplits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e2/82e27c5d8cd371d2e0a19e9c207523774ec908.src","preCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())))\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1023,"status":"B"}],"commitId":"62f91de993eb1c74ef92a42608e688f5cb711724","commitMessage":"@@@[FLINK-21469][runtime] Implement advanceToEndOfEventTime for MultipleInputStreamTask\n\nFor stop with savepoint.  StreamTask#advanceToEndOfEventTime() is called (in source tasks)\nto advance to the max watermark. This PR implments advanceToEndOfEventTime for\nMultipleInputStreamTask chained sources.\n","date":"2021-05-12 20:07:58","modifiedFileCount":"3","status":"M","submitter":"Yuan Mei"},{"authorTime":"2021-05-10 13:46:43","codes":[{"authorDate":"2021-02-11 22:33:36","commitOrder":8,"curCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(config -> config.enableObjectReuse())\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())))\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.finishProcessing();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","date":"2021-07-03 00:00:46","endLine":790,"groupId":"3368","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testWatermarkMetrics","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/90/8c4b807f7b329dc881844e5a6bbc104c6dcd43.src","preCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(config -> config.enableObjectReuse())\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())))\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":665,"status":"M"},{"authorDate":"2021-05-10 13:46:43","commitOrder":8,"curCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())))\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","date":"2021-05-12 20:07:58","endLine":1042,"groupId":"3111","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWatermarkTestHarness","params":"(intinputChannels@booleanreaderMarkIdleOnNoSplits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e2/82e27c5d8cd371d2e0a19e9c207523774ec908.src","preCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())))\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1023,"status":"N"}],"commitId":"85390053725b43040bf4e7afd34dfe8c0079b522","commitMessage":"@@@[FLINK-21086][runtime][checkpoint] StreamTask waits for all the records get processed by downstream tasks\n","date":"2021-07-03 00:00:46","modifiedFileCount":"19","status":"M","submitter":"Yun Gao"},{"authorTime":"2021-07-16 21:56:00","codes":[{"authorDate":"2021-07-16 21:56:00","commitOrder":9,"curCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(config -> config.enableObjectReuse())\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.finishProcessing();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","date":"2021-07-26 15:07:12","endLine":793,"groupId":"3368","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testWatermarkMetrics","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f6/9c6234435012a1f550179d795279ae9ad52da9.src","preCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(config -> config.enableObjectReuse())\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())))\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.finishProcessing();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":667,"status":"M"},{"authorDate":"2021-07-16 21:56:00","commitOrder":9,"curCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","date":"2021-07-26 15:07:12","endLine":1091,"groupId":"3111","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWatermarkTestHarness","params":"(intinputChannels@booleanreaderMarkIdleOnNoSplits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f6/9c6234435012a1f550179d795279ae9ad52da9.src","preCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())))\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1071,"status":"M"}],"commitId":"8e53edb885a4eadc20e9b43dc2b54730ee7b899c","commitMessage":"@@@[FLINK-23373][task] Fix source input serializer in StreamTaskMailboxTestHarness\n","date":"2021-07-26 15:07:12","modifiedFileCount":"3","status":"M","submitter":"Timo Walther"},{"authorTime":"2021-07-16 21:46:28","codes":[{"authorDate":"2021-07-16 21:46:28","commitOrder":10,"curCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.finishProcessing();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","date":"2021-07-26 15:08:00","endLine":851,"groupId":"3368","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testWatermarkMetrics","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/c3c2910c6ef7bc98797ecedaa08fdabefb9445.src","preCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(config -> config.enableObjectReuse())\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.finishProcessing();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":725,"status":"M"},{"authorDate":"2021-07-16 21:46:28","commitOrder":10,"curCode":"    private StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","date":"2021-07-26 15:08:00","endLine":1160,"groupId":"3111","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWatermarkTestHarness","params":"(intinputChannels@booleanreaderMarkIdleOnNoSplits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/c3c2910c6ef7bc98797ecedaa08fdabefb9445.src","preCode":"    private static StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(config -> config.enableObjectReuse())\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1140,"status":"M"}],"commitId":"2fe7b938e77b3ea88979ab1d36502604042e2ffc","commitMessage":"@@@[FLINK-23373][task] Fully support object reuse in OperatorChain\n\nThis closes #16518.\n","date":"2021-07-26 15:08:00","modifiedFileCount":"5","status":"M","submitter":"Timo Walther"},{"authorTime":"2021-07-16 21:46:28","codes":[{"authorDate":"2021-07-28 19:22:31","commitOrder":11,"curCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n        }\n    }\n","date":"2021-08-10 14:34:49","endLine":853,"groupId":"3368","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testWatermarkMetrics","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3a/169b7cd148940fd0ef49df3b3962da3ae8eb0e.src","preCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.finishProcessing();\n            testHarness.waitForTaskCompletion();\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":727,"status":"M"},{"authorDate":"2021-07-16 21:46:28","commitOrder":11,"curCode":"    private StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","date":"2021-07-26 15:08:00","endLine":1160,"groupId":"3111","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWatermarkTestHarness","params":"(intinputChannels@booleanreaderMarkIdleOnNoSplits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/c3c2910c6ef7bc98797ecedaa08fdabefb9445.src","preCode":"    private StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1140,"status":"N"}],"commitId":"64570e4c56955713ca599fd1d7ae7be891a314c6","commitMessage":"@@@[FLINK-23408] Call finish/endInput on EndOfData event\n\nWe want to be able to bring the entire topology with a single checkpoint/savepoint. In order to do that we must be able to call finish on all operators before such a checkpoint is triggered. The idea is to emit EndOfData.  which once received.  triggers finish()/endInput(). After such a sequence we can trigger a checkpoint/savepoint which meets the aforementioned criteria.\n\nAs part of the commit we made the InputProcessors and in turn InputSelection work with EndOfData.  which is a special kind of event that signals end of data.  but after that point we still might receive e.g. barriers on such inputs. Therefore we can't exclude those inputs from input selection yet.\n","date":"2021-08-10 14:34:49","modifiedFileCount":"29","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-07-16 21:46:28","codes":[{"authorDate":"2021-05-19 20:29:24","commitOrder":12,"curCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public InternalOperatorMetricGroup getOrAddOperator(\n                            OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n        }\n    }\n","date":"2021-08-14 22:42:46","endLine":858,"groupId":"102514","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testWatermarkMetrics","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/883743155002411e37ad231373fde4643a6fb4.src","preCode":"    public void testWatermarkMetrics() throws Exception {\n        OperatorID mainOperatorId = new OperatorID();\n        OperatorID chainedOperatorId = new OperatorID();\n\n        InterceptingOperatorMetricGroup mainOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingOperatorMetricGroup chainedOperatorMetricGroup =\n                new InterceptingOperatorMetricGroup();\n        InterceptingTaskMetricGroup taskMetricGroup =\n                new InterceptingTaskMetricGroup() {\n                    @Override\n                    public OperatorMetricGroup getOrAddOperator(OperatorID id, String name) {\n                        if (id.equals(mainOperatorId)) {\n                            return mainOperatorMetricGroup;\n                        } else if (id.equals(chainedOperatorId)) {\n                            return chainedOperatorMetricGroup;\n                        } else {\n                            return super.getOrAddOperator(id, name);\n                        }\n                    }\n                };\n\n        try (StreamTaskMailboxTestHarness<String> testHarness =\n                new StreamTaskMailboxTestHarnessBuilder<>(\n                                MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                        .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                        .addInput(BasicTypeInfo.STRING_TYPE_INFO)\n                        .addSourceInput(\n                                new SourceOperatorFactory<>(\n                                        new MockSource(\n                                                Boundedness.CONTINUOUS_UNBOUNDED, 2, true, false),\n                                        WatermarkStrategy.forGenerator(\n                                                ctx -> new RecordToWatermarkGenerator())),\n                                BasicTypeInfo.INT_TYPE_INFO)\n                        .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n                        .setupOperatorChain(\n                                mainOperatorId, new MapToStringMultipleInputOperatorFactory(3))\n                        .chain(\n                                chainedOperatorId,\n                                new WatermarkMetricOperator(),\n                                BasicTypeInfo.STRING_TYPE_INFO.createSerializer(\n                                        new ExecutionConfig()))\n                        .finish()\n                        .setTaskMetricGroup(taskMetricGroup)\n                        .build()) {\n            Gauge<Long> taskInputWatermarkGauge =\n                    (Gauge<Long>) taskMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainInput1WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(1));\n            Gauge<Long> mainInput2WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(2));\n            Gauge<Long> mainInput3WatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.currentInputWatermarkName(3));\n            Gauge<Long> mainInputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> mainOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            mainOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n            Gauge<Long> chainedInputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_INPUT_WATERMARK);\n            Gauge<Long> chainedOutputWatermarkGauge =\n                    (Gauge<Long>)\n                            chainedOperatorMetricGroup.get(MetricNames.IO_CURRENT_OUTPUT_WATERMARK);\n\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(1L), 0);\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            addSourceRecords(testHarness, 1, 2);\n            testHarness.processAll();\n            assertEquals(Long.MIN_VALUE, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(Long.MIN_VALUE, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(2L), 1);\n            assertEquals(1L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(1L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(1L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            testHarness.processElement(new Watermark(4L), 0);\n            addSourceRecords(testHarness, 1, 3);\n            testHarness.processAll();\n            assertEquals(2L, taskInputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, mainInput1WatermarkGauge.getValue().longValue());\n            assertEquals(3L, mainInput2WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainInput3WatermarkGauge.getValue().longValue());\n            assertEquals(2L, mainOutputWatermarkGauge.getValue().longValue());\n            assertEquals(2L, chainedInputWatermarkGauge.getValue().longValue());\n            assertEquals(4L, chainedOutputWatermarkGauge.getValue().longValue());\n\n            finishAddingRecords(testHarness, 1);\n            testHarness.endInput();\n            testHarness.waitForTaskCompletion();\n            testHarness.finishProcessing();\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":731,"status":"M"},{"authorDate":"2021-07-16 21:46:28","commitOrder":12,"curCode":"    private StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","date":"2021-07-26 15:08:00","endLine":1160,"groupId":"102514","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"buildWatermarkTestHarness","params":"(intinputChannels@booleanreaderMarkIdleOnNoSplits)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/69/c3c2910c6ef7bc98797ecedaa08fdabefb9445.src","preCode":"    private StreamTaskMailboxTestHarness<String> buildWatermarkTestHarness(\n            int inputChannels, boolean readerMarkIdleOnNoSplits) throws Exception {\n        return new StreamTaskMailboxTestHarnessBuilder<>(\n                        MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n                .modifyExecutionConfig(applyObjectReuse(objectReuse))\n                .addInput(BasicTypeInfo.STRING_TYPE_INFO, inputChannels)\n                .addSourceInput(\n                        new SourceOperatorFactory<>(\n                                new MockSource(\n                                        Boundedness.CONTINUOUS_UNBOUNDED,\n                                        2,\n                                        true,\n                                        readerMarkIdleOnNoSplits),\n                                WatermarkStrategy.forGenerator(\n                                        ctx -> new RecordToWatermarkGenerator())),\n                        BasicTypeInfo.INT_TYPE_INFO)\n                .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, inputChannels)\n                .setupOutputForSingletonOperatorChain(\n                        new MapToStringMultipleInputOperatorFactory(3))\n                .build();\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1140,"status":"N"}],"commitId":"63ee60859cac64f2bc6cfe2c5015ceb1199cea9c","commitMessage":"@@@[FLINK-23652][core/metrics] Extract Operator(IO)MetricGroup interfaces and expose them in RuntimeContext\n","date":"2021-08-14 22:42:46","modifiedFileCount":"66","status":"M","submitter":"Arvid Heise"}]
