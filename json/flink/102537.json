[{"authorTime":"2016-06-14 18:18:35","codes":[{"authorDate":"2016-06-14 18:18:35","commitOrder":1,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\theadOperator,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-06-27 22:55:17","endLine":178,"groupId":"24263","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3b/201dc7e2c6f0ba0f84917aebf435412d06d7d7.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\theadOperator,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"B"},{"authorDate":"2016-06-14 18:18:35","commitOrder":1,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\theadOperator,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-06-27 22:55:17","endLine":322,"groupId":"24264","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3b/201dc7e2c6f0ba0f84917aebf435412d06d7d7.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\theadOperator,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"B"}],"commitId":"cb2b76dc4c999398133c392c9fa4a8ef82e90fd5","commitMessage":"@@@[FLINK-3974] Fix object reuse with multi-chaining\n\nBefore.  a job would fail if object reuse was enabled and multiple\noperators were chained to one upstream operator. Now.  we create shallow\ncopies in BroadcastingOutputCollector and DirectedOutput if object reuse\nis enabled.\n","date":"2016-06-27 22:55:17","modifiedFileCount":"4","status":"B","submitter":"Aljoscha Krettek"},{"authorTime":"2016-09-01 05:59:27","codes":[{"authorDate":"2016-09-01 05:59:27","commitOrder":2,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-09-30 18:38:46","endLine":170,"groupId":"24263","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/32/e8ea90dc2fbf23b793e76ff378be970b6ab3ae.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\theadOperator,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2016-09-01 05:59:27","commitOrder":2,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-09-30 18:38:46","endLine":313,"groupId":"24264","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/32/e8ea90dc2fbf23b793e76ff378be970b6ab3ae.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\theadOperator,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"}],"commitId":"53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c","commitMessage":"@@@[FLINK-4379] [checkpoints] Introduce rescalable operator state\n\nThis introduces the Operator State Backend.  which stores state that is not partitioned\nby a key. It replaces the 'Checkpointed' interface.\n\nAdditionally.  this introduces CheckpointStateHandles as container for all checkpoint related state handles\n\nThis closes #2512\n","date":"2016-09-30 18:38:46","modifiedFileCount":"96","status":"M","submitter":"Stefan Richter"},{"authorTime":"2016-10-31 21:17:05","codes":[{"authorDate":"2016-10-31 21:17:05","commitOrder":3,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-10-31 22:12:04","endLine":167,"groupId":"24263","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c9/5a85e289e02d19f6ef03b40facfc156b9953e0.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2016-10-31 21:17:05","commitOrder":3,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-10-31 22:12:04","endLine":308,"groupId":"24264","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c9/5a85e289e02d19f6ef03b40facfc156b9953e0.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(\n\t\t\t\tmockTask,\n\t\t\t\tmock(AccumulatorRegistry.Reporter.class));\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"}],"commitId":"ba2d007e5ad270b9a403d037d186de61cdaac742","commitMessage":"@@@[FLINK-4733] Port Task IO metrics\n","date":"2016-10-31 22:12:04","modifiedFileCount":"43","status":"M","submitter":"zentol"},{"authorTime":"2016-10-31 21:17:05","codes":[{"authorDate":"2016-10-12 14:31:43","commitOrder":4,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tSystem.out.println(streamConfig);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-12-20 12:04:07","endLine":169,"groupId":"0","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4e/405fd6fb360b4695376d6eb53db1966823c31b.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2016-10-31 21:17:05","commitOrder":4,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-10-31 22:12:04","endLine":308,"groupId":"24264","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c9/5a85e289e02d19f6ef03b40facfc156b9953e0.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"N"}],"commitId":"f52830763d8f95a955c10265e2c3543a5890e719","commitMessage":"@@@[FLINK-4391] Add asynchronous I/O operations\n\n1. add an example job 2. fix a bug in state serialization in async wait operator; 3. move broadcast barrier after snapshot operator states\n\nupdate IT case\n\nadjust the whitespace in IT\n\n1. use final for member variable; 2. initialize resouce in open() 3. use ioexception instead of runtimeexception to propagate errors\n\nmake sure head operator comes first while doing shapshot for chained operators\n\n[FLINK-4391] 1. adjust the order of snapshot for operators in one chain.  so that head operator can do snapshot first. it is for the chained operator with async wait operator.  which will keep emitting data in the internal buffer to its children if stream task perform checkpoint from tail to the head.  getting incorrect result. 2. support LatencyMarker in async wait operator\n\n[FLINK-4391] use checkpoint lock in async wait operator; remove emitter thread\n\n[FLINK-4391] use checkpoint lock in async wait operator; remove emitter thread\n\n[FLINK-4391] 1. Re-add emitter thread. Without this thread.  if there is no input coming.  and we just use main thread to emit result.  the finished async collectors may have to wait uncertained period of time to be emitted. The emitter thread can help output them as soos as possible; 2. In UNORDERED mode.  only emits results prior to the oldest Watermark in the buffer; 3. Use the latest OperatorStateStore to keep partitionable operator state.\n\n[FLINK-4391] remove change to StreamTask.java\n\n[FLINK-4391] Optimize inner data structure for AsyncWaitOperator.  add extra test cases.\n\n[FLINK-4391] Fix UT failure\n\n[FLINK-4391] Fix format problem\n\n[FLINK-4391] Add a RuntimeContext wrapper for RichAsyncFunction to disable getting state from RuntimeContext.\n\nThis closes #2629.\n","date":"2016-12-20 12:04:07","modifiedFileCount":"7","status":"M","submitter":"yushi.wxg"},{"authorTime":"2016-10-31 21:17:05","codes":[{"authorDate":"2016-12-20 19:27:20","commitOrder":5,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-12-21 00:01:44","endLine":167,"groupId":"24263","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c9/5a85e289e02d19f6ef03b40facfc156b9953e0.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tSystem.out.println(streamConfig);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2016-10-31 21:17:05","commitOrder":5,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","date":"2016-10-31 22:12:04","endLine":308,"groupId":"24264","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c9/5a85e289e02d19f6ef03b40facfc156b9953e0.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1,2,3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"N"}],"commitId":"3a6585d9ef15337ed1f1cf7d90102ba6b6141580","commitMessage":"@@@[hotfix] [tests] Clean up some warnings\n","date":"2016-12-21 00:01:44","modifiedFileCount":"2","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2017-12-20 19:27:56","codes":[{"authorDate":"2017-12-20 19:27:56","commitOrder":6,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2018-01-06 12:30:12","endLine":170,"groupId":"24263","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b2/373739a74d64056b28b8cab1b9858862300a59.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2017-12-20 19:27:56","commitOrder":6,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2018-01-06 12:30:12","endLine":316,"groupId":"24264","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b2/373739a74d64056b28b8cab1b9858862300a59.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n\t\t\t\tcreateMockTask(streamConfig, chainedVertex.getName());\n\n\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\tif (operator != null) {\n\t\t\t\toperator.open();\n\t\t\t}\n\t\t}\n\n\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"}],"commitId":"091a37052b7045b3ed28c68bfea109024a5d1871","commitMessage":"@@@[FLINK-8298][tests] Properly shutdown MockEnvironment to release resources\n\nThis closes #5193.\n","date":"2018-01-06 12:30:12","modifiedFileCount":"9","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2018-02-06 17:03:03","codes":[{"authorDate":"2018-02-06 17:03:03","commitOrder":7,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2018-02-19 19:21:25","endLine":170,"groupId":"24263","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/80ab7e10bbe72c44f2d5aa7cf4b2205f1ffdbd.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2018-02-06 17:03:03","commitOrder":7,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2018-02-19 19:21:25","endLine":320,"groupId":"24264","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/80ab7e10bbe72c44f2d5aa7cf4b2205f1ffdbd.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = new OperatorChain<>(mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"M"}],"commitId":"eb96d5d2205eb1e807b2dc56bf0fd1e33b13c760","commitMessage":"@@@[FLINK-8590][runtime] Drop addBufferConsumerToAllSubpartitions method\n","date":"2018-02-19 19:21:25","modifiedFileCount":"8","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2018-05-17 23:17:27","codes":[{"authorDate":"2018-05-17 23:17:27","commitOrder":8,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2018-05-23 23:28:55","endLine":147,"groupId":"137","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9c/3b08f8ff6499715b1e83dbc7abde1e9ac22bbc.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2018-05-17 23:17:27","commitOrder":8,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2018-05-23 23:28:55","endLine":266,"groupId":"137","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9c/3b08f8ff6499715b1e83dbc7abde1e9ac22bbc.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(new MapFunction<Integer, Integer>(){\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer map(Integer value) throws Exception {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 1: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"First 2: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(new MapFunction<Integer, String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String map(Integer value) throws Exception {\n\t\t\t\t\t\treturn \"Second: \" + value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"}],"commitId":"8258029ababaeeead58e3510a6c9bd53f6829901","commitMessage":"@@@[hotfix] [tests] Cleanup and lambda-ify StreamOperatorChainingTest\n","date":"2018-05-23 23:28:55","modifiedFileCount":"1","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2019-06-13 19:14:39","codes":[{"authorDate":"2019-06-13 19:14:39","commitOrder":9,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2019-06-14 14:46:03","endLine":149,"groupId":"137","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/86/ef070c64f84e12ba18fc83d23732c3c7ee679f.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2019-06-13 19:14:39","commitOrder":9,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2019-06-14 14:46:03","endLine":271,"groupId":"137","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/86/ef070c64f84e12ba18fc83d23732c3c7ee679f.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"}],"commitId":"3fa062a8ad9cfbbef23adbfb3ad1406a68afb3eb","commitMessage":"@@@[FLINK-12800] Harden Tests when availableProcessors is 1\n\nThis closes #8716.\n","date":"2019-06-14 14:46:03","modifiedFileCount":"4","status":"M","submitter":"leesf"},{"authorTime":"2020-02-12 10:36:47","codes":[{"authorDate":"2020-02-12 10:36:47","commitOrder":10,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2020-02-21 18:59:32","endLine":148,"groupId":"137","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/4124a7f5e068a6682cb8b182e5afa534a15846.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2020-02-12 10:36:47","commitOrder":10,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2020-02-21 18:59:32","endLine":268,"groupId":"137","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/4124a7f5e068a6682cb8b182e5afa534a15846.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n\t\t\t\tif (operator != null) {\n\t\t\t\t\toperator.open();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"}],"commitId":"56ce696009f19098ce9db17a3f8c5aae816a2f86","commitMessage":"@@@[FLINK-14231][task] Add StreamOperatorWrapper that handles the close.  endInput and other related logic of an operator\n\nFor each operator in the operator chain.  its inputs must end completely before executing the \"endInput()\" method. For\nthe operator chain in a task.  such as \"OP1 - > OP2 - > ...\".  after the (source/network) input of OP1 are finished. \nthe operators on the chain are closed in the following order:\n\n1. quiesce ProcessingTimeService of OP1 to prevent the pending timers from firing.  but wait the timers in running\n   to finish.\n2. call OP1#close()\n3. call OP2#endInput()\n4. quiesce ProcessingTimeService of OP2 to prevent the pending timers from firing.  but wait the timers in running\n   to finish.\n5. call OP2#close()\n...\n","date":"2020-02-21 18:59:32","modifiedFileCount":"10","status":"M","submitter":"sunhaibotb"},{"authorTime":"2020-08-17 22:38:59","codes":[{"authorDate":"2020-08-17 22:38:59","commitOrder":11,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2020-09-03 21:00:26","endLine":148,"groupId":"137","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/08144bc9b7c26221e0f32852549922c71cd54f.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2020-08-17 22:38:59","commitOrder":11,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2020-09-03 21:00:26","endLine":268,"groupId":"137","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/08144bc9b7c26221e0f32852549922c71cd54f.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"}],"commitId":"aa0b62c4cd68f9a8b2335adb639035cd6f8f9654","commitMessage":"@@@[FLINK-18905][hotfix][task] Rename OperatorChain#chainEntryPoint to mainOperatorOutput\n","date":"2020-09-03 21:00:26","modifiedFileCount":"3","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2020-09-04 17:37:47","codes":[{"authorDate":"2020-08-17 22:38:59","commitOrder":12,"curCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2020-09-03 21:00:26","endLine":148,"groupId":"137","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b9/08144bc9b7c26221e0f32852549922c71cd54f.src","preCode":"\tprivate void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tinput\n\t\t\t\t.map(value -> \"First: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tinput\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n\t\t\tassertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"N"},{"authorDate":"2020-09-04 17:37:47","commitOrder":12,"curCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tOutputTag<Integer> oneOutput = new OutputTag<Integer>(\"one\") {};\n\t\tOutputTag<Integer> otherOutput = new OutputTag<Integer>(\"other\") {};\n\t\tSingleOutputStreamOperator<Object> split = input.process(new ProcessFunction<Integer, Object>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void processElement(\n\t\t\t\t\tInteger value,\n\t\t\t\t\tContext ctx, Collector<Object> out) throws Exception {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\tctx.output(oneOutput, value);\n\t\t\t\t} else {\n\t\t\t\t\tctx.output(otherOutput, value);\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\t\tsplit.getSideOutput(oneOutput)\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.getSideOutput(oneOutput)\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.getSideOutput(otherOutput)\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","date":"2020-09-14 23:24:39","endLine":274,"groupId":"44711","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d9/d51744045b6f2fb813593dbc51549197b5c7da.src","preCode":"\tprivate void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n\t\t\r\n\t\tenv.setParallelism(2);\n\n\t\t\r\n\t\tDataStream<Integer> input = env.fromElements(1, 2, 3);\n\n\t\tsink1Results = new ArrayList<>();\n\t\tsink2Results = new ArrayList<>();\n\t\tsink3Results = new ArrayList<>();\n\n\t\tinput = input\n\t\t\t\t.map(value -> value);\n\n\t\tSplitStream<Integer> split = input.split(new OutputSelector<Integer>() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Iterable<String> select(Integer value) {\n\t\t\t\tif (value.equals(1)) {\n\t\t\t\t\treturn Collections.singletonList(\"one\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Collections.singletonList(\"other\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 1: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink1Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"one\")\n\t\t\t\t.map(value -> \"First 2: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink2Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tsplit.select(\"other\")\n\t\t\t\t.map(value -> \"Second: \" + value)\n\t\t\t\t.addSink(new SinkFunction<String>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void invoke(String value, Context ctx) throws Exception {\n\t\t\t\t\t\tsink3Results.add(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\r\n\t\tJobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n\t\tAssert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n\t\tJobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n\t\tConfiguration configuration = chainedVertex.getConfiguration();\n\n\t\tStreamConfig streamConfig = new StreamConfig(configuration);\n\n\t\tStreamMap<Integer, Integer> headOperator =\n\t\t\t\tstreamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n\t\ttry (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n\t\t\tStreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment);\n\t\t\tOperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask);\n\n\t\t\theadOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n\t\t\tfor (StreamOperatorWrapper<?, ?> operatorWrapper : operatorChain.getAllOperators(true)) {\n\t\t\t\toperatorWrapper.getStreamOperator().open();\n\t\t\t}\n\n\t\t\theadOperator.processElement(new StreamRecord<>(1));\n\t\t\theadOperator.processElement(new StreamRecord<>(2));\n\t\t\theadOperator.processElement(new StreamRecord<>(3));\n\n\t\t\tassertThat(sink1Results, contains(\"First 1: 1\"));\n\t\t\tassertThat(sink2Results, contains(\"First 2: 1\"));\n\t\t\tassertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"}],"commitId":"1a08548a209167cafeeba1ce602fe8d542994be5","commitMessage":"@@@[FLINK-19083] Remove deprecated DataStream#split\n\nThis closes #13343\n","date":"2020-09-14 23:24:39","modifiedFileCount":"21","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-08-10 21:05:00","codes":[{"authorDate":"2021-08-10 21:05:00","commitOrder":13,"curCode":"    private void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n        \r\n        \r\n        env.setParallelism(2);\n\n        \r\n        DataStream<Integer> input = env.fromElements(1, 2, 3);\n\n        sink1Results = new ArrayList<>();\n        sink2Results = new ArrayList<>();\n\n        input = input.map(value -> value);\n\n        input.map(value -> \"First: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink1Results.add(value);\n                            }\n                        });\n\n        input.map(value -> \"Second: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink2Results.add(value);\n                            }\n                        });\n\n        \r\n        JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n        JobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n        Configuration configuration = chainedVertex.getConfiguration();\n\n        StreamConfig streamConfig = new StreamConfig(configuration);\n\n        StreamMap<Integer, Integer> headOperator =\n                streamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n        try (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n            StreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n                    createMockTask(streamConfig, environment);\n            OperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain =\n                    createOperatorChain(streamConfig, environment, mockTask);\n\n            headOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n            operatorChain.initializeStateAndOpenOperators(null);\n\n            headOperator.processElement(new StreamRecord<>(1));\n            headOperator.processElement(new StreamRecord<>(2));\n            headOperator.processElement(new StreamRecord<>(3));\n\n            assertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n            assertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n        }\n    }\n","date":"2021-08-14 17:24:42","endLine":149,"groupId":"102537","id":25,"instanceNumber":1,"isCurCommit":1,"methodName":"testMultiChaining","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/21/0f70388187abd9dd8d4e1dc9f47754f1d2ff2e.src","preCode":"    private void testMultiChaining(StreamExecutionEnvironment env) throws Exception {\n\n        \r\n        \r\n        env.setParallelism(2);\n\n        \r\n        DataStream<Integer> input = env.fromElements(1, 2, 3);\n\n        sink1Results = new ArrayList<>();\n        sink2Results = new ArrayList<>();\n\n        input = input.map(value -> value);\n\n        input.map(value -> \"First: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink1Results.add(value);\n                            }\n                        });\n\n        input.map(value -> \"Second: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink2Results.add(value);\n                            }\n                        });\n\n        \r\n        JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n        JobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n        Configuration configuration = chainedVertex.getConfiguration();\n\n        StreamConfig streamConfig = new StreamConfig(configuration);\n\n        StreamMap<Integer, Integer> headOperator =\n                streamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n        try (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n            StreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n                    createMockTask(streamConfig, environment);\n            OperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain =\n                    createOperatorChain(streamConfig, environment, mockTask);\n\n            headOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.getStreamOperator().open();\n            }\n\n            headOperator.processElement(new StreamRecord<>(1));\n            headOperator.processElement(new StreamRecord<>(2));\n            headOperator.processElement(new StreamRecord<>(3));\n\n            assertThat(sink1Results, contains(\"First: 1\", \"First: 2\", \"First: 3\"));\n            assertThat(sink2Results, contains(\"Second: 1\", \"Second: 2\", \"Second: 3\"));\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2021-08-10 21:05:00","commitOrder":13,"curCode":"    private void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n        \r\n        \r\n        env.setParallelism(2);\n\n        \r\n        DataStream<Integer> input = env.fromElements(1, 2, 3);\n\n        sink1Results = new ArrayList<>();\n        sink2Results = new ArrayList<>();\n        sink3Results = new ArrayList<>();\n\n        input = input.map(value -> value);\n\n        OutputTag<Integer> oneOutput = new OutputTag<Integer>(\"one\") {};\n        OutputTag<Integer> otherOutput = new OutputTag<Integer>(\"other\") {};\n        SingleOutputStreamOperator<Object> split =\n                input.process(\n                        new ProcessFunction<Integer, Object>() {\n                            private static final long serialVersionUID = 1L;\n\n                            @Override\n                            public void processElement(\n                                    Integer value, Context ctx, Collector<Object> out)\n                                    throws Exception {\n                                if (value.equals(1)) {\n                                    ctx.output(oneOutput, value);\n                                } else {\n                                    ctx.output(otherOutput, value);\n                                }\n                            }\n                        });\n\n        split.getSideOutput(oneOutput)\n                .map(value -> \"First 1: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink1Results.add(value);\n                            }\n                        });\n\n        split.getSideOutput(oneOutput)\n                .map(value -> \"First 2: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink2Results.add(value);\n                            }\n                        });\n\n        split.getSideOutput(otherOutput)\n                .map(value -> \"Second: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink3Results.add(value);\n                            }\n                        });\n\n        \r\n        JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n        JobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n        Configuration configuration = chainedVertex.getConfiguration();\n\n        StreamConfig streamConfig = new StreamConfig(configuration);\n\n        StreamMap<Integer, Integer> headOperator =\n                streamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n        try (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n            StreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n                    createMockTask(streamConfig, environment);\n            OperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain =\n                    createOperatorChain(streamConfig, environment, mockTask);\n\n            headOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n            operatorChain.initializeStateAndOpenOperators(null);\n\n            headOperator.processElement(new StreamRecord<>(1));\n            headOperator.processElement(new StreamRecord<>(2));\n            headOperator.processElement(new StreamRecord<>(3));\n\n            assertThat(sink1Results, contains(\"First 1: 1\"));\n            assertThat(sink2Results, contains(\"First 2: 1\"));\n            assertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n        }\n    }\n","date":"2021-08-14 17:24:42","endLine":276,"groupId":"102537","id":26,"instanceNumber":2,"isCurCommit":1,"methodName":"testMultiChainingWithSplit","params":"(StreamExecutionEnvironmentenv)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/21/0f70388187abd9dd8d4e1dc9f47754f1d2ff2e.src","preCode":"    private void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {\n\n        \r\n        \r\n        env.setParallelism(2);\n\n        \r\n        DataStream<Integer> input = env.fromElements(1, 2, 3);\n\n        sink1Results = new ArrayList<>();\n        sink2Results = new ArrayList<>();\n        sink3Results = new ArrayList<>();\n\n        input = input.map(value -> value);\n\n        OutputTag<Integer> oneOutput = new OutputTag<Integer>(\"one\") {};\n        OutputTag<Integer> otherOutput = new OutputTag<Integer>(\"other\") {};\n        SingleOutputStreamOperator<Object> split =\n                input.process(\n                        new ProcessFunction<Integer, Object>() {\n                            private static final long serialVersionUID = 1L;\n\n                            @Override\n                            public void processElement(\n                                    Integer value, Context ctx, Collector<Object> out)\n                                    throws Exception {\n                                if (value.equals(1)) {\n                                    ctx.output(oneOutput, value);\n                                } else {\n                                    ctx.output(otherOutput, value);\n                                }\n                            }\n                        });\n\n        split.getSideOutput(oneOutput)\n                .map(value -> \"First 1: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink1Results.add(value);\n                            }\n                        });\n\n        split.getSideOutput(oneOutput)\n                .map(value -> \"First 2: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink2Results.add(value);\n                            }\n                        });\n\n        split.getSideOutput(otherOutput)\n                .map(value -> \"Second: \" + value)\n                .addSink(\n                        new SinkFunction<String>() {\n\n                            @Override\n                            public void invoke(String value, Context ctx) throws Exception {\n                                sink3Results.add(value);\n                            }\n                        });\n\n        \r\n        JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2);\n\n        JobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1);\n\n        Configuration configuration = chainedVertex.getConfiguration();\n\n        StreamConfig streamConfig = new StreamConfig(configuration);\n\n        StreamMap<Integer, Integer> headOperator =\n                streamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader());\n\n        try (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {\n            StreamTask<Integer, StreamMap<Integer, Integer>> mockTask =\n                    createMockTask(streamConfig, environment);\n            OperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain =\n                    createOperatorChain(streamConfig, environment, mockTask);\n\n            headOperator.setup(mockTask, streamConfig, operatorChain.getMainOperatorOutput());\n\n            for (StreamOperatorWrapper<?, ?> operatorWrapper :\n                    operatorChain.getAllOperators(true)) {\n                operatorWrapper.getStreamOperator().open();\n            }\n\n            headOperator.processElement(new StreamRecord<>(1));\n            headOperator.processElement(new StreamRecord<>(2));\n            headOperator.processElement(new StreamRecord<>(3));\n\n            assertThat(sink1Results, contains(\"First 1: 1\"));\n            assertThat(sink2Results, contains(\"First 2: 1\"));\n            assertThat(sink3Results, contains(\"Second: 2\", \"Second: 3\"));\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamOperatorChainingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"}],"commitId":"0bc3bae27a0fcb920ac25a8e6acebe50243e50a1","commitMessage":"@@@[FLINK-23708][task][refactor] Split OperatorChain into Finished and Regular classes\n","date":"2021-08-14 17:24:42","modifiedFileCount":"8","status":"M","submitter":"Piotr Nowojski"}]
