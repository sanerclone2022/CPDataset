[{"authorTime":"2015-05-27 17:27:56","codes":[{"authorDate":"2015-05-27 17:27:56","commitOrder":1,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new DefaultMemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2015-05-27 22:36:02","endLine":260,"groupId":"21168","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/bc/65ab929c4006551d384d79dfc5f5a96cfb6b81.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new DefaultMemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"B"},{"authorDate":"2015-05-27 17:27:56","commitOrder":1,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new DefaultMemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2015-05-27 22:36:02","endLine":260,"groupId":"36606","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2d/a29e8c4787fe6648a6a14b937fe649a0f444e2.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new DefaultMemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":141,"status":"B"}],"commitId":"3061eb126a69319a4ad45995f66f98c58dc23fdc","commitMessage":"@@@[tests] Consolidate manually triggered tests into a dedicated package\n","date":"2015-05-27 22:36:02","modifiedFileCount":"0","status":"B","submitter":"Stephan Ewen"},{"authorTime":"2015-08-31 04:36:46","codes":[{"authorDate":"2015-08-31 04:36:46","commitOrder":2,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2015-09-09 02:58:05","endLine":263,"groupId":"21168","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7a/484e7e0ef19f511735ea7f9055808b03786b2c.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new DefaultMemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2015-08-31 04:36:46","commitOrder":2,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2015-09-09 02:58:05","endLine":258,"groupId":"36606","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c1/1b93c14a28a3373c616a6d4175a4085be277f6.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new DefaultMemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":139,"status":"M"}],"commitId":"655a891d929db9d858bb5c2edf54419f2b0d3ace","commitMessage":"@@@[FLINK-1320] [core] Add an off-heap variant of the managed memory\n\nThis closes #1093\n","date":"2015-09-09 02:58:05","modifiedFileCount":"153","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2015-09-10 21:35:39","codes":[{"authorDate":"2015-09-10 21:35:39","commitOrder":3,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f, false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2015-09-29 18:21:34","endLine":263,"groupId":"34790","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9a/016ccc494392529036eef8f9e85e82605aeb96.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2015-09-10 21:35:39","commitOrder":3,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f, false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2015-09-29 18:21:34","endLine":258,"groupId":"33628","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c9/bd56bb702a4e4db488b9ba756a0d6333b9aca8.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":139,"status":"M"}],"commitId":"0a8df6d513fa59d650ff875bdf3a1613d0f14af5","commitMessage":"@@@[FLINK-2653] [runtime] Enable object reuse in MergeIterator\n\nThis closes #1115\n","date":"2015-09-29 18:21:34","modifiedFileCount":"19","status":"M","submitter":"Greg Hogan"},{"authorTime":"2016-06-16 20:39:23","codes":[{"authorDate":"2016-06-16 20:39:23","commitOrder":4,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-06-22 01:10:56","endLine":265,"groupId":"34790","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9e/37b79fc24ba3c46413cbec5a40e3eb00038e01.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f, false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"},{"authorDate":"2016-06-16 20:39:23","commitOrder":4,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-06-22 01:10:56","endLine":260,"groupId":"33628","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/98/21b056e5b792221aac664ab1eb3cc902982c64.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f, false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"}],"commitId":"bce3a68d97f759a7f5731daf7dd25886f6b4d1ba","commitMessage":"@@@[FLINK-4082] Add Setting for enabling/disabling LargeRecordHandler\n\nBy default this is set to disabled because there are known issues when\nusers specify a custom TypeInformation.\n","date":"2016-06-22 01:10:56","modifiedFileCount":"18","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-05-31 03:40:47","codes":[{"authorDate":"2017-05-31 03:40:47","commitOrder":5,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-07-13 06:37:47","endLine":267,"groupId":"34790","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/3aa148890fc87c3e0ef203a509e24a39c2a05d.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"},{"authorDate":"2017-05-31 03:40:47","commitOrder":5,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-07-13 06:37:47","endLine":261,"groupId":"33628","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c6/9e6fd606b982986233a65eb403c8c754436aa7.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int NUM_STRINGS = 300000;\n\t\t\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(NUM_STRINGS, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\t\t\t\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\t\t\t\n\t\t\tString[] command = {\"/bin/bash\",\"-c\",\"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\t\t\t\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\t\t\t\t\t\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) \n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\t\t\t\t\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\t\t\t\t\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t\t\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\t\t\t\t\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\t\n\t\t\t\tint num = 0;\n\t\t\t\t\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\t\t\t\t\t\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(NUM_STRINGS, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"}],"commitId":"9bd491e05120915cbde36d4452e3982fe5d0975f","commitMessage":"@@@[FLINK-6731] [tests] Activate strict checkstyle for flink-tests\n\nThis closes #4295\n","date":"2017-07-13 06:37:47","modifiedFileCount":"185","status":"M","submitter":"Greg Hogan"},{"authorTime":"2017-11-24 18:31:48","codes":[{"authorDate":"2017-11-24 18:31:48","commitOrder":6,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-12-12 18:50:00","endLine":283,"groupId":"24756","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/72e4a8495a803b1ab0c61b350d62f790089da8.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"},{"authorDate":"2017-11-24 18:31:48","commitOrder":6,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-12-12 18:50:00","endLine":277,"groupId":"12381","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/46/e44854b92827e3e79a6fb27cc1b61f5d92910c.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\n\t\t\ttry {\n\t\t\t\tMemoryManager mm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tIOManager ioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"}],"commitId":"30fc069add77ae6783a87b6920c59e739903296f","commitMessage":"@@@[FLINK-8145][tests] fix various IOManagerAsync instances not being shut down\n\nThis closes #5064.\n","date":"2017-12-12 18:50:00","modifiedFileCount":"10","status":"M","submitter":"Nico Kruber"},{"authorTime":"2018-05-04 23:15:51","codes":[{"authorDate":"2018-05-04 23:15:51","commitOrder":7,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2018-05-05 00:48:16","endLine":283,"groupId":"24756","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5d/cf20983b00548707d7f2248e3ceb8123ea7f4c.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<StringValue, StringValue[]>>parse(\"Tuple2<org.apache.flink.types.StringValue, org.apache.flink.types.StringValue[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"},{"authorDate":"2018-05-04 23:15:51","commitOrder":7,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2018-05-05 00:48:16","endLine":277,"groupId":"12381","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/eb/9990936b0de9d75ec7b49e4a8f778a93e15918.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tTypeInfoParser.<Tuple2<String, String[]>>parse(\"Tuple2<String, String[]>\");\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"}],"commitId":"c8fa8d025684c2225824c54a7285bbfdec7cfddc","commitMessage":"@@@[FLINK-9292] [core] Remove TypeInfoParser (part 1)\n","date":"2018-05-05 00:48:16","modifiedFileCount":"26","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2019-06-18 12:09:04","codes":[{"authorDate":"2019-06-18 12:09:04","commitOrder":8,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2019-07-02 23:05:41","endLine":273,"groupId":"26573","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/86/1f1dfe84b493e26c562cc95fa599db0c33ea66.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"},{"authorDate":"2019-06-18 12:09:04","commitOrder":8,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2019-07-02 23:05:41","endLine":267,"groupId":"20807","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1d/48eee2445bf2c6002fb22412785e3d2f615a45.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\t\t\tIOManager ioMan = null;\n\n\t\t\ttry {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\t\t\t\tioMan = new IOManagerAsync();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t\tif (ioMan != null) {\n\t\t\t\t\tioMan.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"}],"commitId":"5809ed32f869fa880a70a774d5b8365fe59dba4a","commitMessage":"@@@[hotfix][runtime] IOManager implements AutoCloseable\n","date":"2019-07-02 23:05:41","modifiedFileCount":"54","status":"M","submitter":"Zhijiang"},{"authorTime":"2019-09-11 21:25:28","codes":[{"authorDate":"2019-09-11 21:25:28","commitOrder":9,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = MemoryManagerBuilder.newBuilder().setMemorySize(1024 * 1024).build();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2019-10-22 20:01:15","endLine":274,"groupId":"26573","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/12/e021b1ea58f321507d76e745c1326dfa6acd10.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":151,"status":"M"},{"authorDate":"2019-09-11 21:25:28","commitOrder":9,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = MemoryManagerBuilder.newBuilder().setMemorySize(1024 * 1024).build();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2019-10-22 20:01:15","endLine":268,"groupId":"20807","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0b/5e79871d62ce8628563c8a2da6531f8240cf7e.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = new MemoryManager(1024 * 1024, 1);\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"}],"commitId":"7a62d72bc9c431fc00390097a01e6d95708be8d3","commitMessage":"@@@[hotfix] Introduce MemoryManagerBuilder for tests\n","date":"2019-10-22 20:01:15","modifiedFileCount":"55","status":"M","submitter":"Andrey Zagrebin"},{"authorTime":"2020-09-02 17:19:04","codes":[{"authorDate":"2020-09-02 17:19:04","commitOrder":10,"curCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tSorter<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = MemoryManagerBuilder.newBuilder().setMemorySize(1024 * 1024).build();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter =\n\t\t\t\t\tExternalSorter.newBuilder(\n\t\t\t\t\t\t\tmm,\n\t\t\t\t\t\t\tnew DummyInvokable(),\n\t\t\t\t\t\t\tserializer,\n\t\t\t\t\t\t\tcomparator)\n\t\t\t\t\t\t.maxNumFileHandles(4)\n\t\t\t\t\t\t.enableSpilling(ioMan, 0.8f)\n\t\t\t\t\t\t.memoryFraction(1.0)\n\t\t\t\t\t\t.objectReuse(false)\n\t\t\t\t\t\t.largeRecords(true)\n\t\t\t\t\t\t.build(inputIterator);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-09-23 22:05:42","endLine":292,"groupId":"101537","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testStringValueTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/99/8e18e7ad12115b96711412d19488e0dfb76a20.src","preCode":"\tpublic void testStringValueTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = MemoryManagerBuilder.newBuilder().setMemorySize(1024 * 1024).build();\n\n\t\t\t\tTupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<StringValue, StringValue[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\t\t\t\tTuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((nextVerify = verifyIterator.next(nextVerify)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromFlinkSort = sortedData.next(nextFromFlinkSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromFlinkSort);\n\n\t\t\t\t\tAssert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromFlinkSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\t\r\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\t\r\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringValueSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"},{"authorDate":"2020-09-02 17:19:04","commitOrder":10,"curCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tSorter<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = MemoryManagerBuilder.newBuilder().setMemorySize(1024 * 1024).build();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter =\n\t\t\t\t\tExternalSorter.newBuilder(\n\t\t\t\t\t\t\tmm,\n\t\t\t\t\t\t\tnew DummyInvokable(),\n\t\t\t\t\t\t\tserializer,\n\t\t\t\t\t\t\tcomparator)\n\t\t\t\t\t\t.maxNumFileHandles(4)\n\t\t\t\t\t\t.enableSpilling(ioMan, 0.8f)\n\t\t\t\t\t\t.memoryFraction(1.0)\n\t\t\t\t\t\t.objectReuse(false)\n\t\t\t\t\t\t.largeRecords(true)\n\t\t\t\t\t\t.build(inputIterator);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-09-23 22:05:42","endLine":286,"groupId":"101537","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testStringTuplesSorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f4/25de13eadf629d6556c8e635cbb77f3e9d02c8.src","preCode":"\tpublic void testStringTuplesSorting() {\n\t\tfinal int numStrings = 300000;\n\n\t\tFile input = null;\n\t\tFile sorted = null;\n\n\t\ttry {\n\t\t\t\r\n\t\t\tinput = generateFileWithStringTuples(numStrings, \"http://some-uri.com/that/is/a/common/prefix/to/all\");\n\n\t\t\t\r\n\t\t\tsorted = File.createTempFile(\"sorted_strings\", \"txt\");\n\n\t\t\tString[] command = {\"/bin/bash\", \"-c\", \"export LC_ALL=\\\"C\\\" && cat \\\"\" + input.getAbsolutePath() + \"\\\" | sort > \\\"\" + sorted.getAbsolutePath() + \"\\\"\"};\n\n\t\t\tProcess p = null;\n\t\t\ttry {\n\t\t\t\tp = Runtime.getRuntime().exec(command);\n\t\t\t\tint retCode = p.waitFor();\n\t\t\t\tif (retCode != 0) {\n\t\t\t\t\tthrow new Exception(\"Command failed with return code \" + retCode);\n\t\t\t\t}\n\t\t\t\tp = null;\n\t\t\t} finally {\n\t\t\t\tif (p != null) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tUnilateralSortMerger<Tuple2<String, String[]>> sorter = null;\n\t\t\tBufferedReader reader = null;\n\t\t\tBufferedReader verifyReader = null;\n\t\t\tMemoryManager mm = null;\n\n\t\t\ttry (IOManager ioMan = new IOManagerAsync()) {\n\t\t\t\tmm = MemoryManagerBuilder.newBuilder().setMemorySize(1024 * 1024).build();\n\n\t\t\t\tTupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>)\n\t\t\t\t\t\tnew TypeHint<Tuple2<String, String[]>>(){}.getTypeInfo();\n\n\t\t\t\tTypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig());\n\t\t\t\tTypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig());\n\n\t\t\t\treader = new BufferedReader(new FileReader(input));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader);\n\n\t\t\t\tsorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(),\n\t\t\t\t\t\tnew RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f,\n\t\t\t\t\t\ttrue , false);\n\n\t\t\t\t\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator();\n\t\t\t\treader.close();\n\n\t\t\t\t\r\n\t\t\t\tverifyReader = new BufferedReader(new FileReader(sorted));\n\t\t\t\tMutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader);\n\n\t\t\t\tTuple2<String, String[]> next = new Tuple2<String, String[]>(\"\", new String[0]);\n\t\t\t\tTuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>(\"\", new String[0]);\n\n\t\t\t\tint num = 0;\n\n\t\t\t\twhile ((next = verifyIterator.next(next)) != null) {\n\t\t\t\t\tnum++;\n\n\t\t\t\t\tnextFromStratoSort = sortedData.next(nextFromStratoSort);\n\t\t\t\t\tAssert.assertNotNull(nextFromStratoSort);\n\n\t\t\t\t\tAssert.assertEquals(next.f0, nextFromStratoSort.f0);\n\t\t\t\t\tAssert.assertArrayEquals(next.f1, nextFromStratoSort.f1);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertNull(sortedData.next(nextFromStratoSort));\n\t\t\t\tAssert.assertEquals(numStrings, num);\n\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t\tif (verifyReader != null) {\n\t\t\t\t\tverifyReader.close();\n\t\t\t\t}\n\t\t\t\tif (sorter != null) {\n\t\t\t\t\tsorter.close();\n\t\t\t\t}\n\t\t\t\tif (mm != null) {\n\t\t\t\t\tmm.shutdown();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (input != null) {\n\t\t\t\tinput.delete();\n\t\t\t}\n\t\t\tif (sorted != null) {\n\t\t\t\tsorted.delete();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/manual/MassiveStringSorting.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"e2deb9227387a7fbbf090c8279698194e2611f75","commitMessage":"@@@[FLINK-19165] Refactor the UnilateralSortMerger\n\nThis is a preparation for introducing a sorted inputs in BATCH execution\nmode. It refactors the UnilateralSortMerger into more composable pieces.\nAdditionally it adds the option to use a push-based approach instead of\nspawning a Reader thread that consumes from an input iterator.\n\nThis closes #13357\n","date":"2020-09-23 22:05:42","modifiedFileCount":"16","status":"M","submitter":"Dawid Wysakowicz"}]
