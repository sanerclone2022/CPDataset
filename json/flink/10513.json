[{"authorTime":"2020-05-15 21:49:36","codes":[{"authorDate":"2020-05-13 20:55:49","commitOrder":2,"curCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t}\n","date":"2020-05-13 20:55:49","endLine":110,"groupId":"9442","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"JdbcLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@TypeInformation[]fieldTypes@String[]keyNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/11/803d04767da563e66fa035b0f401b365b2835a.src","preCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"NB"},{"authorDate":"2020-05-15 21:49:36","commitOrder":2,"curCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","date":"2020-05-18 12:30:38","endLine":113,"groupId":"17401","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"JdbcRowDataLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@DataType[]fieldTypes@String[]keyNames@RowTyperowType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a0/75aeeae288295ef57a929efaef96710dc199dd.src","preCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcRowDataLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"B"}],"commitId":"ce843a2e601cbc2ddba8d3feacaa930aea810877","commitMessage":"@@@[FLINK-17029][jdbc] Introduce a new JDBC connector with new property keys\n\nThis closes #12176\n","date":"2020-05-18 12:30:38","modifiedFileCount":"29","status":"M","submitter":"Leonard Xu"},{"authorTime":"2020-07-03 19:37:10","codes":[{"authorDate":"2020-07-03 19:37:10","commitOrder":3,"curCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = FieldNamedPreparedStatementImpl.parseNamedStatement(\n\t\t\toptions.getDialect().getSelectFromStatement(options.getTableName(), fieldNames, keyNames),\n\t\t\tnew HashMap<>());\n\t}\n","date":"2020-07-30 15:10:29","endLine":117,"groupId":"9442","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"JdbcLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@TypeInformation[]fieldTypes@String[]keyNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/2ca2172a197cdcf8b6b4bbc6a25e24717aae4c.src","preCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"M"},{"authorDate":"2020-07-03 19:37:10","commitOrder":3,"curCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","date":"2020-07-30 15:10:29","endLine":117,"groupId":"17401","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"JdbcRowDataLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@DataType[]fieldTypes@String[]keyNames@RowTyperowType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d1/526c3bcc853e779c21787a4095a4cb6d89fdc5.src","preCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcRowDataLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"bdaf1dbd80c57ac23e2d5530d845e483261f7518","commitMessage":"@@@[FLINK-15728][jdbc] Introduce FieldNamedPreparedStatement to support fields are bound multiple times in update statement\n\nThis closes #12882\n","date":"2020-07-30 15:10:29","modifiedFileCount":"13","status":"M","submitter":"Jark Wu"},{"authorTime":"2020-12-15 16:59:04","codes":[{"authorDate":"2020-12-15 16:59:04","commitOrder":4,"curCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.connectionCheckTimeoutSeconds = options.getConnectionCheckTimeoutSeconds();\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = FieldNamedPreparedStatementImpl.parseNamedStatement(\n\t\t\toptions.getDialect().getSelectFromStatement(options.getTableName(), fieldNames, keyNames),\n\t\t\tnew HashMap<>());\n\t}\n","date":"2020-12-25 10:22:51","endLine":118,"groupId":"9442","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"JdbcLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@TypeInformation[]fieldTypes@String[]keyNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ff/0dab0ccc172792ff504427b1b28c7d9093f4ea.src","preCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = FieldNamedPreparedStatementImpl.parseNamedStatement(\n\t\t\toptions.getDialect().getSelectFromStatement(options.getTableName(), fieldNames, keyNames),\n\t\t\tnew HashMap<>());\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"M"},{"authorDate":"2020-12-15 16:59:04","commitOrder":4,"curCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.keyNames = keyNames;\n\t\tthis.connectionCheckTimeoutSeconds = options.getConnectionCheckTimeoutSeconds();\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","date":"2020-12-25 10:22:51","endLine":118,"groupId":"17401","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"JdbcRowDataLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@DataType[]fieldTypes@String[]keyNames@RowTyperowType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f1/92ed04f3536b4f0c051c62852c4b5578760670.src","preCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcRowDataLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"f5e829c4ffed88e1a79b76e9fc8579013502ddc0","commitMessage":"@@@[FLINK-19691][jdbc] Support connection.max-retry-timeout configuration for JDBC connector\n\nThis closes #14387\n","date":"2020-12-25 10:22:51","modifiedFileCount":"12","status":"M","submitter":"???"},{"authorTime":"2020-12-27 13:52:54","codes":[{"authorDate":"2020-12-27 13:52:54","commitOrder":5,"curCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.connectionProvider = new SimpleJdbcConnectionProvider(options);\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = FieldNamedPreparedStatementImpl.parseNamedStatement(\n\t\t\toptions.getDialect().getSelectFromStatement(options.getTableName(), fieldNames, keyNames),\n\t\t\tnew HashMap<>());\n\t}\n","date":"2020-12-27 13:52:54","endLine":110,"groupId":"9442","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"JdbcLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@TypeInformation[]fieldTypes@String[]keyNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a7/c5f3de82c1c74554ad5516875a043ac112ddc2.src","preCode":"\tpublic JdbcLookupFunction(\n\t\t\tJdbcOptions options, JdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames, TypeInformation[] fieldTypes, String[] keyNames) {\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.connectionCheckTimeoutSeconds = options.getConnectionCheckTimeoutSeconds();\n\t\tthis.fieldNames = fieldNames;\n\t\tthis.fieldTypes = fieldTypes;\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t\t.map(s -> {\n\t\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t\t})\n\t\t\t\t.toArray(TypeInformation[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.keySqlTypes = Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.outputSqlTypes = Arrays.stream(fieldTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n\t\tthis.query = FieldNamedPreparedStatementImpl.parseNamedStatement(\n\t\t\toptions.getDialect().getSelectFromStatement(options.getTableName(), fieldNames, keyNames),\n\t\t\tnew HashMap<>());\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2020-12-27 13:52:54","commitOrder":5,"curCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.connectionProvider = new SimpleJdbcConnectionProvider(options);\n\t\tthis.keyNames = keyNames;\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tString dbURL = options.getDbURL();\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","date":"2020-12-27 13:52:54","endLine":111,"groupId":"17401","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"JdbcRowDataLookupFunction","params":"(JdbcOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@DataType[]fieldTypes@String[]keyNames@RowTyperowType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/20/4268d5c924e820c7fe1f14c80d52c61c472bca.src","preCode":"\tpublic JdbcRowDataLookupFunction(\n\t\t\tJdbcOptions options,\n\t\t\tJdbcLookupOptions lookupOptions,\n\t\t\tString[] fieldNames,\n\t\t\tDataType[] fieldTypes,\n\t\t\tString[] keyNames,\n\t\t\tRowType rowType) {\n\t\tcheckNotNull(options, \"No JdbcOptions supplied.\");\n\t\tcheckNotNull(fieldNames, \"No fieldNames supplied.\");\n\t\tcheckNotNull(fieldTypes, \"No fieldTypes supplied.\");\n\t\tcheckNotNull(keyNames, \"No keyNames supplied.\");\n\t\tthis.drivername = options.getDriverName();\n\t\tthis.dbURL = options.getDbURL();\n\t\tthis.username = options.getUsername().orElse(null);\n\t\tthis.password = options.getPassword().orElse(null);\n\t\tthis.keyNames = keyNames;\n\t\tthis.connectionCheckTimeoutSeconds = options.getConnectionCheckTimeoutSeconds();\n\t\tList<String> nameList = Arrays.asList(fieldNames);\n\t\tthis.keyTypes = Arrays.stream(keyNames)\n\t\t\t.map(s -> {\n\t\t\t\tcheckArgument(nameList.contains(s),\n\t\t\t\t\t\"keyName %s can't find in fieldNames %s.\", s, nameList);\n\t\t\t\treturn fieldTypes[nameList.indexOf(s)];\n\t\t\t})\n\t\t\t.toArray(DataType[]::new);\n\t\tthis.cacheMaxSize = lookupOptions.getCacheMaxSize();\n\t\tthis.cacheExpireMs = lookupOptions.getCacheExpireMs();\n\t\tthis.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n\t\tthis.query = options.getDialect().getSelectFromStatement(\n\t\t\toptions.getTableName(), fieldNames, keyNames);\n\t\tthis.jdbcDialect = JdbcDialects.get(dbURL)\n\t\t\t.orElseThrow(() -> new UnsupportedOperationException(String.format(\"Unknown dbUrl:%s\", dbURL)));\n\t\tthis.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n\t\tthis.lookupKeyRowConverter = jdbcDialect.getRowConverter(RowType.of(Arrays.stream(keyTypes).map(DataType::getLogicalType).toArray(LogicalType[]::new)));\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcRowDataLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"}],"commitId":"0c36b666094c01a96d341d2b0ee0b6863a6484e8","commitMessage":"@@@[FLINK-20657][connectors/jdbc] Migrate jdbc InputFormat/LookupFunction to SimpleJdbcConnectionProvider for connection establishment\n\nThis closes #14466","date":"2020-12-27 13:52:54","modifiedFileCount":"12","status":"M","submitter":"Kezhu Wang"},{"authorTime":"2021-06-30 17:15:22","codes":[{"authorDate":"2021-06-30 17:15:22","commitOrder":6,"curCode":"    public JdbcLookupFunction(\n            JdbcConnectorOptions options,\n            JdbcLookupOptions lookupOptions,\n            String[] fieldNames,\n            TypeInformation[] fieldTypes,\n            String[] keyNames) {\n        this.connectionProvider = new SimpleJdbcConnectionProvider(options);\n        this.fieldNames = fieldNames;\n        this.fieldTypes = fieldTypes;\n        this.keyNames = keyNames;\n        List<String> nameList = Arrays.asList(fieldNames);\n        this.keyTypes =\n                Arrays.stream(keyNames)\n                        .map(\n                                s -> {\n                                    checkArgument(\n                                            nameList.contains(s),\n                                            \"keyName %s can't find in fieldNames %s.\",\n                                            s,\n                                            nameList);\n                                    return fieldTypes[nameList.indexOf(s)];\n                                })\n                        .toArray(TypeInformation[]::new);\n        this.cacheMaxSize = lookupOptions.getCacheMaxSize();\n        this.cacheExpireMs = lookupOptions.getCacheExpireMs();\n        this.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n        this.keySqlTypes =\n                Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n        this.outputSqlTypes =\n                Arrays.stream(fieldTypes)\n                        .mapToInt(JdbcTypeUtil::typeInformationToSqlType)\n                        .toArray();\n        this.query =\n                FieldNamedPreparedStatementImpl.parseNamedStatement(\n                        options.getDialect()\n                                .getSelectFromStatement(\n                                        options.getTableName(), fieldNames, keyNames),\n                        new HashMap<>());\n    }\n","date":"2021-07-12 18:56:17","endLine":124,"groupId":"10513","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"JdbcLookupFunction","params":"(JdbcConnectorOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@TypeInformation[]fieldTypes@String[]keyNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2f/5c43eda9c3d95dcecd83df5d80b87ed7bfb5cf.src","preCode":"    public JdbcLookupFunction(\n            JdbcOptions options,\n            JdbcLookupOptions lookupOptions,\n            String[] fieldNames,\n            TypeInformation[] fieldTypes,\n            String[] keyNames) {\n        this.connectionProvider = new SimpleJdbcConnectionProvider(options);\n        this.fieldNames = fieldNames;\n        this.fieldTypes = fieldTypes;\n        this.keyNames = keyNames;\n        List<String> nameList = Arrays.asList(fieldNames);\n        this.keyTypes =\n                Arrays.stream(keyNames)\n                        .map(\n                                s -> {\n                                    checkArgument(\n                                            nameList.contains(s),\n                                            \"keyName %s can't find in fieldNames %s.\",\n                                            s,\n                                            nameList);\n                                    return fieldTypes[nameList.indexOf(s)];\n                                })\n                        .toArray(TypeInformation[]::new);\n        this.cacheMaxSize = lookupOptions.getCacheMaxSize();\n        this.cacheExpireMs = lookupOptions.getCacheExpireMs();\n        this.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n        this.keySqlTypes =\n                Arrays.stream(keyTypes).mapToInt(JdbcTypeUtil::typeInformationToSqlType).toArray();\n        this.outputSqlTypes =\n                Arrays.stream(fieldTypes)\n                        .mapToInt(JdbcTypeUtil::typeInformationToSqlType)\n                        .toArray();\n        this.query =\n                FieldNamedPreparedStatementImpl.parseNamedStatement(\n                        options.getDialect()\n                                .getSelectFromStatement(\n                                        options.getTableName(), fieldNames, keyNames),\n                        new HashMap<>());\n    }\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"M"},{"authorDate":"2021-06-30 17:15:22","commitOrder":6,"curCode":"    public JdbcRowDataLookupFunction(\n            JdbcConnectorOptions options,\n            JdbcLookupOptions lookupOptions,\n            String[] fieldNames,\n            DataType[] fieldTypes,\n            String[] keyNames,\n            RowType rowType) {\n        checkNotNull(options, \"No JdbcOptions supplied.\");\n        checkNotNull(fieldNames, \"No fieldNames supplied.\");\n        checkNotNull(fieldTypes, \"No fieldTypes supplied.\");\n        checkNotNull(keyNames, \"No keyNames supplied.\");\n        this.connectionProvider = new SimpleJdbcConnectionProvider(options);\n        this.keyNames = keyNames;\n        List<String> nameList = Arrays.asList(fieldNames);\n        this.keyTypes =\n                Arrays.stream(keyNames)\n                        .map(\n                                s -> {\n                                    checkArgument(\n                                            nameList.contains(s),\n                                            \"keyName %s can't find in fieldNames %s.\",\n                                            s,\n                                            nameList);\n                                    return fieldTypes[nameList.indexOf(s)];\n                                })\n                        .toArray(DataType[]::new);\n        this.cacheMaxSize = lookupOptions.getCacheMaxSize();\n        this.cacheExpireMs = lookupOptions.getCacheExpireMs();\n        this.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n        this.query =\n                options.getDialect()\n                        .getSelectFromStatement(options.getTableName(), fieldNames, keyNames);\n        String dbURL = options.getDbURL();\n        this.jdbcDialect =\n                JdbcDialects.get(dbURL)\n                        .orElseThrow(\n                                () ->\n                                        new UnsupportedOperationException(\n                                                String.format(\"Unknown dbUrl:%s\", dbURL)));\n        this.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n        this.lookupKeyRowConverter =\n                jdbcDialect.getRowConverter(\n                        RowType.of(\n                                Arrays.stream(keyTypes)\n                                        .map(DataType::getLogicalType)\n                                        .toArray(LogicalType[]::new)));\n    }\n","date":"2021-07-12 18:56:17","endLine":124,"groupId":"10513","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"JdbcRowDataLookupFunction","params":"(JdbcConnectorOptionsoptions@JdbcLookupOptionslookupOptions@String[]fieldNames@DataType[]fieldTypes@String[]keyNames@RowTyperowType)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/67/391ece8e3a11a99a1cd61bccca37f21bb6af29.src","preCode":"    public JdbcRowDataLookupFunction(\n            JdbcOptions options,\n            JdbcLookupOptions lookupOptions,\n            String[] fieldNames,\n            DataType[] fieldTypes,\n            String[] keyNames,\n            RowType rowType) {\n        checkNotNull(options, \"No JdbcOptions supplied.\");\n        checkNotNull(fieldNames, \"No fieldNames supplied.\");\n        checkNotNull(fieldTypes, \"No fieldTypes supplied.\");\n        checkNotNull(keyNames, \"No keyNames supplied.\");\n        this.connectionProvider = new SimpleJdbcConnectionProvider(options);\n        this.keyNames = keyNames;\n        List<String> nameList = Arrays.asList(fieldNames);\n        this.keyTypes =\n                Arrays.stream(keyNames)\n                        .map(\n                                s -> {\n                                    checkArgument(\n                                            nameList.contains(s),\n                                            \"keyName %s can't find in fieldNames %s.\",\n                                            s,\n                                            nameList);\n                                    return fieldTypes[nameList.indexOf(s)];\n                                })\n                        .toArray(DataType[]::new);\n        this.cacheMaxSize = lookupOptions.getCacheMaxSize();\n        this.cacheExpireMs = lookupOptions.getCacheExpireMs();\n        this.maxRetryTimes = lookupOptions.getMaxRetryTimes();\n        this.query =\n                options.getDialect()\n                        .getSelectFromStatement(options.getTableName(), fieldNames, keyNames);\n        String dbURL = options.getDbURL();\n        this.jdbcDialect =\n                JdbcDialects.get(dbURL)\n                        .orElseThrow(\n                                () ->\n                                        new UnsupportedOperationException(\n                                                String.format(\"Unknown dbUrl:%s\", dbURL)));\n        this.jdbcRowConverter = jdbcDialect.getRowConverter(rowType);\n        this.lookupKeyRowConverter =\n                jdbcDialect.getRowConverter(\n                        RowType.of(\n                                Arrays.stream(keyTypes)\n                                        .map(DataType::getLogicalType)\n                                        .toArray(LogicalType[]::new)));\n    }\n","realPath":"flink-connectors/flink-connector-jdbc/src/main/java/org/apache/flink/connector/jdbc/table/JdbcRowDataLookupFunction.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"}],"commitId":"00f92ba924297cb7aec0d48367c47923f4f3be0f","commitMessage":"@@@[FLINK-23064][connector-jdbc] Create PublicEvolving JdbcOptions\n","date":"2021-07-12 18:56:17","modifiedFileCount":"22","status":"M","submitter":"Ingo B?rk"}]
