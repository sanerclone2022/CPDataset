[{"authorTime":"2020-03-20 00:35:24","codes":[{"authorDate":"2020-03-20 00:35:24","commitOrder":3,"curCode":"\tpublic void testUncaughtExceptionInAsynchronousCheckpointingOperation() throws Exception {\n\t\tfinal RuntimeException failingCause = new RuntimeException(\"Test exception\");\n\t\tFailingDummyEnvironment failingDummyEnvironment = new FailingDummyEnvironment(failingCause);\n\n\t\t\r\n\t\tOperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(\n\t\t\tExceptionallyDoneFuture.of(failingCause),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\n\t\tfinal TestingUncaughtExceptionHandler uncaughtExceptionHandler = new TestingUncaughtExceptionHandler();\n\n\t\tRunningTask<MockStreamTask> task = runTask(() -> new MockStreamTask(\n\t\t\tfailingDummyEnvironment,\n\t\t\toperatorChain(streamOperatorWithSnapshot(operatorSnapshotResult)),\n\t\t\tuncaughtExceptionHandler));\n\t\tMockStreamTask streamTask = task.streamTask;\n\n\t\twaitTaskIsRunning(streamTask, task.invocationFuture);\n\n\t\tstreamTask.triggerCheckpointAsync(\n\t\t\tnew CheckpointMetaData(42L, 1L),\n\t\t\tCheckpointOptions.forCheckpointWithDefaultLocation(),\n\t\t\tfalse);\n\n\t\tfinal Throwable uncaughtException = uncaughtExceptionHandler.waitForUncaughtException();\n\t\tassertThat(uncaughtException, is(failingCause));\n\n\t\tstreamTask.finishInput();\n\t\ttask.waitForTaskCompletion(false);\n\t}\n","date":"2020-04-08 20:45:23","endLine":536,"groupId":"31591","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUncaughtExceptionInAsynchronousCheckpointingOperation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b5/e8430f4d2472a8f8dcda7a06f22afc8b2ce257.src","preCode":"\tpublic void testUncaughtExceptionInAsynchronousCheckpointingOperation() throws Exception {\n\t\tfinal RuntimeException failingCause = new RuntimeException(\"Test exception\");\n\t\tFailingDummyEnvironment failingDummyEnvironment = new FailingDummyEnvironment(failingCause);\n\n\t\t\r\n\t\tOperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(\n\t\t\tExceptionallyDoneFuture.of(failingCause),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\n\t\tfinal TestingUncaughtExceptionHandler uncaughtExceptionHandler = new TestingUncaughtExceptionHandler();\n\n\t\tRunningTask<MockStreamTask> task = runTask(() -> new MockStreamTask(\n\t\t\tfailingDummyEnvironment,\n\t\t\toperatorChain(streamOperatorWithSnapshot(operatorSnapshotResult)),\n\t\t\tuncaughtExceptionHandler));\n\t\tMockStreamTask streamTask = task.streamTask;\n\n\t\twaitTaskIsRunning(streamTask, task.invocationFuture);\n\n\t\tstreamTask.triggerCheckpointAsync(\n\t\t\tnew CheckpointMetaData(42L, 1L),\n\t\t\tCheckpointOptions.forCheckpointWithDefaultLocation(),\n\t\t\tfalse);\n\n\t\tfinal Throwable uncaughtException = uncaughtExceptionHandler.waitForUncaughtException();\n\t\tassertThat(uncaughtException, is(failingCause));\n\n\t\tstreamTask.finishInput();\n\t\ttask.waitForTaskCompletion(false);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":503,"status":"MB"},{"authorDate":"2020-03-20 00:35:24","commitOrder":3,"curCode":"\tpublic OperatorSnapshotFutures() {\n\t\tthis(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\t}\n","date":"2020-04-08 20:45:23","endLine":73,"groupId":"31591","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"OperatorSnapshotFutures","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2a/e2d2538fd26f189eda0e29c8045319c6fea44c.src","preCode":"\tpublic OperatorSnapshotFutures() {\n\t\tthis(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/OperatorSnapshotFutures.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"B"}],"commitId":"d6982e6a61b586314a19c1551b4dc84f93d518b3","commitMessage":"@@@[FLINK-16513][checkpointing] add task channel state for unaligned checkpoints\n\nChanges:\n1. add channel state metadata to OperatorSubtaskState\n2. adjust StateAssignmentOperation\n3. adjust metadata serialization\n4. adjust related classes\n\nThis closes #11491.\n","date":"2020-04-08 20:45:23","modifiedFileCount":"35","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2020-03-20 00:35:24","codes":[{"authorDate":"2021-02-24 03:34:00","commitOrder":4,"curCode":"    public void testUncaughtExceptionInAsynchronousCheckpointingOperation() throws Exception {\n        final RuntimeException failingCause = new RuntimeException(\"Test exception\");\n        FailingDummyEnvironment failingDummyEnvironment = new FailingDummyEnvironment(failingCause);\n\n        \r\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(failingCause),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final TestingUncaughtExceptionHandler uncaughtExceptionHandler =\n                new TestingUncaughtExceptionHandler();\n\n        RunningTask<MockStreamTask> task =\n                runTask(\n                        () ->\n                                new MockStreamTask(\n                                        failingDummyEnvironment,\n                                        operatorChain(\n                                                streamOperatorWithSnapshot(operatorSnapshotResult)),\n                                        uncaughtExceptionHandler));\n        MockStreamTask streamTask = task.streamTask;\n\n        waitTaskIsRunning(streamTask, task.invocationFuture);\n\n        streamTask.triggerCheckpointAsync(\n                new CheckpointMetaData(42L, 1L),\n                CheckpointOptions.forCheckpointWithDefaultLocation());\n\n        final Throwable uncaughtException = uncaughtExceptionHandler.waitForUncaughtException();\n        assertThat(uncaughtException, is(failingCause));\n\n        streamTask.finishInput();\n        task.waitForTaskCompletion(false);\n    }\n","date":"2021-02-25 01:57:36","endLine":728,"groupId":"102481","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUncaughtExceptionInAsynchronousCheckpointingOperation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/96/43d1e8ba3636561bb93f248d46aec86f202d0a.src","preCode":"    public void testUncaughtExceptionInAsynchronousCheckpointingOperation() throws Exception {\n        final RuntimeException failingCause = new RuntimeException(\"Test exception\");\n        FailingDummyEnvironment failingDummyEnvironment = new FailingDummyEnvironment(failingCause);\n\n        \r\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(failingCause),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final TestingUncaughtExceptionHandler uncaughtExceptionHandler =\n                new TestingUncaughtExceptionHandler();\n\n        RunningTask<MockStreamTask> task =\n                runTask(\n                        () ->\n                                new MockStreamTask(\n                                        failingDummyEnvironment,\n                                        operatorChain(\n                                                streamOperatorWithSnapshot(operatorSnapshotResult)),\n                                        uncaughtExceptionHandler));\n        MockStreamTask streamTask = task.streamTask;\n\n        waitTaskIsRunning(streamTask, task.invocationFuture);\n\n        streamTask.triggerCheckpointAsync(\n                new CheckpointMetaData(42L, 1L),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                false);\n\n        final Throwable uncaughtException = uncaughtExceptionHandler.waitForUncaughtException();\n        assertThat(uncaughtException, is(failingCause));\n\n        streamTask.finishInput();\n        task.waitForTaskCompletion(false);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":690,"status":"M"},{"authorDate":"2020-03-20 00:35:24","commitOrder":4,"curCode":"\tpublic OperatorSnapshotFutures() {\n\t\tthis(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\t}\n","date":"2020-04-08 20:45:23","endLine":73,"groupId":"102481","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"OperatorSnapshotFutures","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2a/e2d2538fd26f189eda0e29c8045319c6fea44c.src","preCode":"\tpublic OperatorSnapshotFutures() {\n\t\tthis(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/OperatorSnapshotFutures.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"N"}],"commitId":"44e962715b9411b8a00a420d3043e0cc32a0f565","commitMessage":"@@@[FLINK-21453][checkpointing][refactor] Replace advanceToEndOfTime with new CheckpointType.SAVEPOINT_TERMINATE\n","date":"2021-02-25 01:57:36","modifiedFileCount":"63","status":"M","submitter":"Piotr Nowojski"}]
