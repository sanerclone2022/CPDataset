[{"authorTime":"2021-03-05 21:05:36","codes":[{"authorDate":"2021-03-05 21:05:36","commitOrder":1,"curCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","date":"2021-03-31 14:27:07","endLine":740,"groupId":"33046","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessCancellationBarrierAfterProcessBarrier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/59/e6237617a6bb2a59138dcbe4edc9d73e999f8a.src","preCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":717,"status":"B"},{"authorDate":"2021-03-05 21:05:36","commitOrder":1,"curCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition();\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","date":"2021-03-31 14:27:07","endLine":828,"groupId":"16257","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testEndOfStreamWithPendingCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/59/e6237617a6bb2a59138dcbe4edc9d73e999f8a.src","preCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition();\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":797,"status":"B"}],"commitId":"77bf1055a00a64b02e440355c993ffc9e221525c","commitMessage":"@@@[FLINK-19682][checkpoint] Actively timeout checkpoint barriers on inputs\n\nThis closes #15313\n","date":"2021-03-31 14:27:07","modifiedFileCount":"18","status":"B","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-06-26 15:42:11","codes":[{"authorDate":"2021-03-05 21:05:36","commitOrder":2,"curCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","date":"2021-03-31 14:27:07","endLine":740,"groupId":"33046","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessCancellationBarrierAfterProcessBarrier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/59/e6237617a6bb2a59138dcbe4edc9d73e999f8a.src","preCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":717,"status":"N"},{"authorDate":"2021-06-26 15:42:11","commitOrder":2,"curCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition(new InputChannelInfo(0, 0));\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","date":"2021-07-03 00:00:46","endLine":832,"groupId":"16257","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testEndOfStreamWithPendingCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/03/976b8a06750dd15f7e5d870f4b1b72a9c80016.src","preCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition();\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":801,"status":"M"}],"commitId":"6f21603cc2386ba08cbf6f7e33634d96f8bc4815","commitMessage":"@@@[FLINK-21086][runtime][checkpoint] Make CheckpointBarrierHandler supports alignment with finished channels\n","date":"2021-07-03 00:00:46","modifiedFileCount":"23","status":"M","submitter":"Yun Gao"},{"authorTime":"2021-07-15 19:40:11","codes":[{"authorDate":"2021-07-15 19:40:11","commitOrder":3,"curCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        true,\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","date":"2021-07-28 18:47:48","endLine":742,"groupId":"33046","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessCancellationBarrierAfterProcessBarrier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/93/4c6c06fa25e66ce08223292c9a2cf71ec49771.src","preCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":718,"status":"M"},{"authorDate":"2021-07-15 19:40:11","commitOrder":3,"curCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        false,\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition(new InputChannelInfo(0, 0));\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","date":"2021-07-28 18:47:48","endLine":835,"groupId":"16257","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testEndOfStreamWithPendingCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/93/4c6c06fa25e66ce08223292c9a2cf71ec49771.src","preCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition(new InputChannelInfo(0, 0));\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":803,"status":"M"}],"commitId":"7c902745fff13e70908d32084d2888a69e13fc8b","commitMessage":"@@@[FLINK-23460] Use a global feature flag in the CheckpointBarrierHandler\n","date":"2021-07-28 18:47:48","modifiedFileCount":"21","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-08-25 16:31:32","codes":[{"authorDate":"2021-08-25 16:31:32","commitOrder":4,"curCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        true,\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0), false);\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","date":"2021-08-26 11:20:47","endLine":742,"groupId":"102956","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testProcessCancellationBarrierAfterProcessBarrier","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c1/b348eb1e089a8f1e407b59775addd6ab05da0a.src","preCode":"    public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setNumberOfChannels(2)\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        true,\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n\n        testProcessCancellationBarrier(handler, invokable);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":718,"status":"M"},{"authorDate":"2021-08-25 16:31:32","commitOrder":4,"curCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        false,\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0), false);\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition(new InputChannelInfo(0, 0));\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","date":"2021-08-26 11:20:47","endLine":835,"groupId":"102956","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testEndOfStreamWithPendingCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c1/b348eb1e089a8f1e407b59775addd6ab05da0a.src","preCode":"    public void testEndOfStreamWithPendingCheckpoint() throws Exception {\n        final int numberOfChannels = 2;\n        final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n        final SingleInputGate inputGate =\n                new SingleInputGateBuilder()\n                        .setChannelFactory(InputChannelBuilder::buildLocalChannel)\n                        .setNumberOfChannels(numberOfChannels)\n                        .build();\n        final SingleCheckpointBarrierHandler handler =\n                SingleCheckpointBarrierHandler.createUnalignedCheckpointBarrierHandler(\n                        TestSubtaskCheckpointCoordinator.INSTANCE,\n                        \"test\",\n                        invokable,\n                        SystemClock.getInstance(),\n                        false,\n                        inputGate);\n\n        \r\n        handler.processBarrier(\n                buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));\n\n        assertTrue(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels, handler.getNumOpenChannels());\n\n        \r\n        handler.processEndOfPartition(new InputChannelInfo(0, 0));\n\n        assertFalse(handler.isCheckpointPending());\n        assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());\n        assertEquals(numberOfChannels - 1, handler.getNumOpenChannels());\n        assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/UnalignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":803,"status":"M"}],"commitId":"f57fc380b8d6ceb0ad11641367759097e0e1b36a","commitMessage":"@@@[FLINK-23938][checkpoint] Do not resume channels if the barrier is received via RPC\n\n This closes #16977.\n","date":"2021-08-26 11:20:47","modifiedFileCount":"17","status":"M","submitter":"Yun Gao"}]
