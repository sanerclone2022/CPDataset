[{"authorTime":"2021-03-05 21:05:36","codes":[{"authorDate":"2021-03-05 21:05:36","commitOrder":1,"curCode":"    public void testMultiChannelJumpingOverCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n             createBuffer(2),\n             createBuffer(0),\n             createBarrier(1, 1),\n             createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(1),\n             createBuffer(0),\n\n            \r\n             createBarrier(2, 1),\n             createBuffer(2),\n             createBarrier(2, 0),\n             createBuffer(2),\n             createBarrier(3, 2),\n             createBuffer(1),\n             createBuffer(0),\n             createBarrier(3, 0),\n             createBarrier(4, 1),\n             createBuffer(2),\n             createBuffer(0),\n             createEndOfPartition(0),\n             createBuffer(2),\n             createEndOfPartition(2),\n             createBuffer(1),\n             createEndOfPartition(1)\n        };\n        ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, handler);\n\n        handler.setNextExpectedCheckpointId(1L);\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(1L, inputGate.getLatestCheckpointId());\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(2L, inputGate.getLatestCheckpointId());\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 1));\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(3L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(2));\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(4L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(1, handler.getTriggeredCheckpointCounter());\n        assertEquals(3, handler.getAbortedCheckpointCounter());\n    }\n","date":"2021-03-31 14:27:07","endLine":439,"groupId":"8222","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiChannelJumpingOverCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6a/ebf946030aeb5ef08ed4299b5a480c54dcd0dd.src","preCode":"    public void testMultiChannelJumpingOverCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n             createBuffer(2),\n             createBuffer(0),\n             createBarrier(1, 1),\n             createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(1),\n             createBuffer(0),\n\n            \r\n             createBarrier(2, 1),\n             createBuffer(2),\n             createBarrier(2, 0),\n             createBuffer(2),\n             createBarrier(3, 2),\n             createBuffer(1),\n             createBuffer(0),\n             createBarrier(3, 0),\n             createBarrier(4, 1),\n             createBuffer(2),\n             createBuffer(0),\n             createEndOfPartition(0),\n             createBuffer(2),\n             createEndOfPartition(2),\n             createBuffer(1),\n             createEndOfPartition(1)\n        };\n        ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, handler);\n\n        handler.setNextExpectedCheckpointId(1L);\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(1L, inputGate.getLatestCheckpointId());\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(2L, inputGate.getLatestCheckpointId());\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 1));\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(3L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(2));\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(4L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(1, handler.getTriggeredCheckpointCounter());\n        assertEquals(3, handler.getAbortedCheckpointCounter());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":353,"status":"B"},{"authorDate":"2021-03-05 21:05:36","commitOrder":1,"curCode":"    public void testMultiChannelAbortCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n            createBuffer(2),\n            createBuffer(0),\n             createBarrier(1, 1),\n            createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(0),\n            createBuffer(2),\n\n            \r\n             createBarrier(2, 0),\n            createBarrier(2, 2),\n             createBuffer(1),\n             createCancellationBarrier(2, 1),\n\n            \r\n             createBuffer(2),\n            createBuffer(1),\n             createBarrier(3, 1),\n            createBarrier(3, 2),\n            createBarrier(3, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n             createCancellationBarrier(4, 1),\n            createBarrier(4, 2),\n             createBuffer(2),\n             createBarrier(4, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n            createBuffer(2),\n             createBarrier(5, 2),\n            createBarrier(5, 1),\n            createBarrier(5, 0),\n             createBuffer(0),\n            createBuffer(1),\n\n            \r\n             createCancellationBarrier(6, 1),\n            createCancellationBarrier(6, 2),\n             createBarrier(6, 0),\n\n             createBuffer(0)\n        };\n        ValidatingCheckpointHandler toNotify = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, toNotify);\n\n        long startTs;\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(1);\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1, 2));\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0));\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[12], inputGate.pollNext().get(), 0);\n        assertEquals(2, toNotify.getLastCanceledCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(3);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), 0);\n        assertEquals(4, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        \r\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(5);\n        check(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[29], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[32], inputGate.pollNext().get(), 0);\n        check(sequence[33], inputGate.pollNext().get(), 0);\n        assertEquals(6, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[34], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(3, toNotify.getTriggeredCheckpointCounter());\n        assertEquals(3, toNotify.getAbortedCheckpointCounter());\n    }\n","date":"2021-03-31 14:27:07","endLine":858,"groupId":"3315","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChannelAbortCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6a/ebf946030aeb5ef08ed4299b5a480c54dcd0dd.src","preCode":"    public void testMultiChannelAbortCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n            createBuffer(2),\n            createBuffer(0),\n             createBarrier(1, 1),\n            createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(0),\n            createBuffer(2),\n\n            \r\n             createBarrier(2, 0),\n            createBarrier(2, 2),\n             createBuffer(1),\n             createCancellationBarrier(2, 1),\n\n            \r\n             createBuffer(2),\n            createBuffer(1),\n             createBarrier(3, 1),\n            createBarrier(3, 2),\n            createBarrier(3, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n             createCancellationBarrier(4, 1),\n            createBarrier(4, 2),\n             createBuffer(2),\n             createBarrier(4, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n            createBuffer(2),\n             createBarrier(5, 2),\n            createBarrier(5, 1),\n            createBarrier(5, 0),\n             createBuffer(0),\n            createBuffer(1),\n\n            \r\n             createCancellationBarrier(6, 1),\n            createCancellationBarrier(6, 2),\n             createBarrier(6, 0),\n\n             createBuffer(0)\n        };\n        ValidatingCheckpointHandler toNotify = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, toNotify);\n\n        long startTs;\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(1);\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1, 2));\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0));\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[12], inputGate.pollNext().get(), 0);\n        assertEquals(2, toNotify.getLastCanceledCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(3);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), 0);\n        assertEquals(4, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        \r\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(5);\n        check(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[29], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[32], inputGate.pollNext().get(), 0);\n        check(sequence[33], inputGate.pollNext().get(), 0);\n        assertEquals(6, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[34], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(3, toNotify.getTriggeredCheckpointCounter());\n        assertEquals(3, toNotify.getAbortedCheckpointCounter());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":711,"status":"B"}],"commitId":"77bf1055a00a64b02e440355c993ffc9e221525c","commitMessage":"@@@[FLINK-19682][checkpoint] Actively timeout checkpoint barriers on inputs\n\nThis closes #15313\n","date":"2021-03-31 14:27:07","modifiedFileCount":"18","status":"B","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-03-05 21:05:36","codes":[{"authorDate":"2021-07-15 19:40:11","commitOrder":2,"curCode":"    public void testMultiChannelJumpingOverCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n             createBuffer(2),\n             createBuffer(0),\n             createBarrier(1, 1),\n             createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(1),\n             createBuffer(0),\n\n            \r\n             createBarrier(2, 1),\n             createBuffer(2),\n             createBarrier(2, 0),\n             createBuffer(2),\n             createBarrier(3, 2),\n             createBuffer(1),\n             createBuffer(0),\n             createBarrier(3, 0),\n             createBarrier(4, 1),\n             createBuffer(2),\n             createBuffer(0),\n             createEndOfPartition(0),\n             createBuffer(2),\n             createEndOfPartition(2),\n             createBuffer(1),\n             createEndOfPartition(1)\n        };\n        ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, handler, false);\n\n        handler.setNextExpectedCheckpointId(1L);\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(1L, inputGate.getLatestCheckpointId());\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(2L, inputGate.getLatestCheckpointId());\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 1));\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(3L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(2));\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(4L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(1, handler.getTriggeredCheckpointCounter());\n        assertEquals(3, handler.getAbortedCheckpointCounter());\n    }\n","date":"2021-07-28 18:47:48","endLine":458,"groupId":"102925","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testMultiChannelJumpingOverCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1b/6af2d63b76ba60086647712a6919691fac4b0f.src","preCode":"    public void testMultiChannelJumpingOverCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n             createBuffer(2),\n             createBuffer(0),\n             createBarrier(1, 1),\n             createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(1),\n             createBuffer(0),\n\n            \r\n             createBarrier(2, 1),\n             createBuffer(2),\n             createBarrier(2, 0),\n             createBuffer(2),\n             createBarrier(3, 2),\n             createBuffer(1),\n             createBuffer(0),\n             createBarrier(3, 0),\n             createBarrier(4, 1),\n             createBuffer(2),\n             createBuffer(0),\n             createEndOfPartition(0),\n             createBuffer(2),\n             createEndOfPartition(2),\n             createBuffer(1),\n             createEndOfPartition(1)\n        };\n        ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, handler);\n\n        handler.setNextExpectedCheckpointId(1L);\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(1L, inputGate.getLatestCheckpointId());\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(2L, inputGate.getLatestCheckpointId());\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 1));\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(3L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(2));\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        assertEquals(4L, inputGate.getLatestCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(1, handler.getTriggeredCheckpointCounter());\n        assertEquals(3, handler.getAbortedCheckpointCounter());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"},{"authorDate":"2021-03-05 21:05:36","commitOrder":2,"curCode":"    public void testMultiChannelAbortCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n            createBuffer(2),\n            createBuffer(0),\n             createBarrier(1, 1),\n            createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(0),\n            createBuffer(2),\n\n            \r\n             createBarrier(2, 0),\n            createBarrier(2, 2),\n             createBuffer(1),\n             createCancellationBarrier(2, 1),\n\n            \r\n             createBuffer(2),\n            createBuffer(1),\n             createBarrier(3, 1),\n            createBarrier(3, 2),\n            createBarrier(3, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n             createCancellationBarrier(4, 1),\n            createBarrier(4, 2),\n             createBuffer(2),\n             createBarrier(4, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n            createBuffer(2),\n             createBarrier(5, 2),\n            createBarrier(5, 1),\n            createBarrier(5, 0),\n             createBuffer(0),\n            createBuffer(1),\n\n            \r\n             createCancellationBarrier(6, 1),\n            createCancellationBarrier(6, 2),\n             createBarrier(6, 0),\n\n             createBuffer(0)\n        };\n        ValidatingCheckpointHandler toNotify = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, toNotify);\n\n        long startTs;\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(1);\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1, 2));\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0));\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[12], inputGate.pollNext().get(), 0);\n        assertEquals(2, toNotify.getLastCanceledCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(3);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), 0);\n        assertEquals(4, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        \r\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(5);\n        check(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[29], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[32], inputGate.pollNext().get(), 0);\n        check(sequence[33], inputGate.pollNext().get(), 0);\n        assertEquals(6, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[34], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(3, toNotify.getTriggeredCheckpointCounter());\n        assertEquals(3, toNotify.getAbortedCheckpointCounter());\n    }\n","date":"2021-03-31 14:27:07","endLine":858,"groupId":"102925","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultiChannelAbortCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6a/ebf946030aeb5ef08ed4299b5a480c54dcd0dd.src","preCode":"    public void testMultiChannelAbortCheckpoint() throws Exception {\n        BufferOrEvent[] sequence = {\n            \r\n             createBuffer(0),\n            createBuffer(2),\n            createBuffer(0),\n             createBarrier(1, 1),\n            createBarrier(1, 2),\n             createBuffer(0),\n             createBarrier(1, 0),\n             createBuffer(0),\n            createBuffer(2),\n\n            \r\n             createBarrier(2, 0),\n            createBarrier(2, 2),\n             createBuffer(1),\n             createCancellationBarrier(2, 1),\n\n            \r\n             createBuffer(2),\n            createBuffer(1),\n             createBarrier(3, 1),\n            createBarrier(3, 2),\n            createBarrier(3, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n             createCancellationBarrier(4, 1),\n            createBarrier(4, 2),\n             createBuffer(2),\n             createBarrier(4, 0),\n\n            \r\n             createBuffer(0),\n            createBuffer(1),\n            createBuffer(2),\n             createBarrier(5, 2),\n            createBarrier(5, 1),\n            createBarrier(5, 0),\n             createBuffer(0),\n            createBuffer(1),\n\n            \r\n             createCancellationBarrier(6, 1),\n            createCancellationBarrier(6, 2),\n             createBarrier(6, 0),\n\n             createBuffer(0)\n        };\n        ValidatingCheckpointHandler toNotify = new ValidatingCheckpointHandler();\n        inputGate = createCheckpointedInputGate(3, sequence, toNotify);\n\n        long startTs;\n\n        \r\n        check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(1);\n        check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1));\n        check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(1, 2));\n        check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0));\n        check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), containsInAnyOrder(0, 2));\n        check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[12], inputGate.pollNext().get(), 0);\n        assertEquals(2, toNotify.getLastCanceledCheckpointId());\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(3);\n        check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[20], inputGate.pollNext().get(), 0);\n        assertEquals(4, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n\n        \r\n        check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        startTs = System.nanoTime();\n        toNotify.setNextExpectedCheckpointId(5);\n        check(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[29], inputGate.pollNext().get(), PAGE_SIZE);\n        validateAlignmentTime(startTs, inputGate);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);\n        check(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);\n\n        \r\n        check(sequence[32], inputGate.pollNext().get(), 0);\n        check(sequence[33], inputGate.pollNext().get(), 0);\n        assertEquals(6, toNotify.getLastCanceledCheckpointId());\n        assertEquals(\n                CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER,\n                toNotify.getCheckpointFailureReason());\n        assertEquals(0L, inputGate.getAlignmentDurationNanos());\n        check(sequence[34], inputGate.pollNext().get(), PAGE_SIZE);\n        assertThat(mockInputGate.getBlockedChannels(), empty());\n        check(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);\n\n        assertEquals(3, toNotify.getTriggeredCheckpointCounter());\n        assertEquals(3, toNotify.getAbortedCheckpointCounter());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlignedCheckpointsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":711,"status":"N"}],"commitId":"7c902745fff13e70908d32084d2888a69e13fc8b","commitMessage":"@@@[FLINK-23460] Use a global feature flag in the CheckpointBarrierHandler\n","date":"2021-07-28 18:47:48","modifiedFileCount":"21","status":"M","submitter":"Dawid Wysakowicz"}]
