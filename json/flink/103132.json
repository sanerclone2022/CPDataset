[{"authorTime":"2020-09-29 23:15:26","codes":[{"authorDate":"2020-09-29 23:15:26","commitOrder":1,"curCode":"\tpublic void simpleFixedLengthKeySorting() throws Exception {\n\t\tCollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n\t\tList<StreamElement> elements = Arrays.asList(\n\t\t\tnew StreamRecord<>(1, 3),\n\t\t\tnew StreamRecord<>(1, 1),\n\t\t\tnew StreamRecord<>(2, 1),\n\t\t\tnew StreamRecord<>(2, 3),\n\t\t\tnew StreamRecord<>(1, 2),\n\t\t\tnew StreamRecord<>(2, 2),\n\t\t\tWatermark.MAX_WATERMARK\n\t\t);\n\t\tCollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n\t\tCollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n\t\tKeySelector<Integer, Integer> keySelector = value -> value;\n\t\ttry (MockEnvironment environment = MockEnvironment.builder().build()) {\n\t\t\tSelectableSortingInputs selectableSortingInputs = MultiInputSortingDataInput.wrapInputs(\n\t\t\t\tnew DummyInvokable(),\n\t\t\t\tnew StreamTaskInput[]{dataInput1, dataInput2},\n\t\t\t\tnew KeySelector[]{keySelector, keySelector},\n\t\t\t\tnew TypeSerializer[]{new IntSerializer(), new IntSerializer()},\n\t\t\t\tnew IntSerializer(),\n\t\t\t\tenvironment.getMemoryManager(),\n\t\t\t\tenvironment.getIOManager(),\n\t\t\t\ttrue,\n\t\t\t\t1.0,\n\t\t\t\tnew Configuration()\n\t\t\t);\n\n\t\t\tStreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortingInputs();\n\t\t\ttry (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n\t\t\t\t\tStreamTaskInput<Object> input2 = (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n\t\t\t\tMultipleInputSelectionHandler selectionHandler = new MultipleInputSelectionHandler(\n\t\t\t\t\tselectableSortingInputs.getInputSelectable(),\n\t\t\t\t\t2);\n\t\t\t\tStreamMultipleInputProcessor processor = new StreamMultipleInputProcessor(\n\t\t\t\t\tselectionHandler,\n\t\t\t\t\tnew StreamOneInputProcessor[]{\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput1,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput2,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tInputStatus inputStatus;\n\t\t\t\tdo {\n\t\t\t\t\tinputStatus = processor.processInput();\n\t\t\t\t} while (inputStatus != InputStatus.END_OF_INPUT);\n\t\t\t}\n\t\t}\n\n\t\tassertThat(collectingDataOutput.events, equalTo(\n\t\t\tArrays.asList(\n\t\t\t\tnew StreamRecord<>(1, 1),\n\t\t\t\tnew StreamRecord<>(1, 1),\n\t\t\t\tnew StreamRecord<>(1, 2),\n\t\t\t\tnew StreamRecord<>(1, 2),\n\t\t\t\tnew StreamRecord<>(1, 3),\n\t\t\t\tnew StreamRecord<>(1, 3),\n\t\t\t\tnew StreamRecord<>(2, 1),\n\t\t\t\tnew StreamRecord<>(2, 1),\n\t\t\t\tnew StreamRecord<>(2, 2),\n\t\t\t\tnew StreamRecord<>(2, 2),\n\t\t\t\tnew StreamRecord<>(2, 3),\n\t\t\t\tWatermark.MAX_WATERMARK, \r\n\t\t\t\tnew StreamRecord<>(2, 3),\n\t\t\t\tWatermark.MAX_WATERMARK \r\n\t\t\t)\n\t\t));\n\t}\n","date":"2020-10-12 23:40:56","endLine":128,"groupId":"47631","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"simpleFixedLengthKeySorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f5/ccf3445f38ab7a8a4e3bb7ea96eb892325f53f.src","preCode":"\tpublic void simpleFixedLengthKeySorting() throws Exception {\n\t\tCollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n\t\tList<StreamElement> elements = Arrays.asList(\n\t\t\tnew StreamRecord<>(1, 3),\n\t\t\tnew StreamRecord<>(1, 1),\n\t\t\tnew StreamRecord<>(2, 1),\n\t\t\tnew StreamRecord<>(2, 3),\n\t\t\tnew StreamRecord<>(1, 2),\n\t\t\tnew StreamRecord<>(2, 2),\n\t\t\tWatermark.MAX_WATERMARK\n\t\t);\n\t\tCollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n\t\tCollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n\t\tKeySelector<Integer, Integer> keySelector = value -> value;\n\t\ttry (MockEnvironment environment = MockEnvironment.builder().build()) {\n\t\t\tSelectableSortingInputs selectableSortingInputs = MultiInputSortingDataInput.wrapInputs(\n\t\t\t\tnew DummyInvokable(),\n\t\t\t\tnew StreamTaskInput[]{dataInput1, dataInput2},\n\t\t\t\tnew KeySelector[]{keySelector, keySelector},\n\t\t\t\tnew TypeSerializer[]{new IntSerializer(), new IntSerializer()},\n\t\t\t\tnew IntSerializer(),\n\t\t\t\tenvironment.getMemoryManager(),\n\t\t\t\tenvironment.getIOManager(),\n\t\t\t\ttrue,\n\t\t\t\t1.0,\n\t\t\t\tnew Configuration()\n\t\t\t);\n\n\t\t\tStreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortingInputs();\n\t\t\ttry (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n\t\t\t\t\tStreamTaskInput<Object> input2 = (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n\t\t\t\tMultipleInputSelectionHandler selectionHandler = new MultipleInputSelectionHandler(\n\t\t\t\t\tselectableSortingInputs.getInputSelectable(),\n\t\t\t\t\t2);\n\t\t\t\tStreamMultipleInputProcessor processor = new StreamMultipleInputProcessor(\n\t\t\t\t\tselectionHandler,\n\t\t\t\t\tnew StreamOneInputProcessor[]{\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput1,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput2,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tInputStatus inputStatus;\n\t\t\t\tdo {\n\t\t\t\t\tinputStatus = processor.processInput();\n\t\t\t\t} while (inputStatus != InputStatus.END_OF_INPUT);\n\t\t\t}\n\t\t}\n\n\t\tassertThat(collectingDataOutput.events, equalTo(\n\t\t\tArrays.asList(\n\t\t\t\tnew StreamRecord<>(1, 1),\n\t\t\t\tnew StreamRecord<>(1, 1),\n\t\t\t\tnew StreamRecord<>(1, 2),\n\t\t\t\tnew StreamRecord<>(1, 2),\n\t\t\t\tnew StreamRecord<>(1, 3),\n\t\t\t\tnew StreamRecord<>(1, 3),\n\t\t\t\tnew StreamRecord<>(2, 1),\n\t\t\t\tnew StreamRecord<>(2, 1),\n\t\t\t\tnew StreamRecord<>(2, 2),\n\t\t\t\tnew StreamRecord<>(2, 2),\n\t\t\t\tnew StreamRecord<>(2, 3),\n\t\t\t\tWatermark.MAX_WATERMARK, \r\n\t\t\t\tnew StreamRecord<>(2, 3),\n\t\t\t\tWatermark.MAX_WATERMARK \r\n\t\t\t)\n\t\t));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"B"},{"authorDate":"2020-09-29 23:15:26","commitOrder":1,"curCode":"\tpublic void watermarkPropagation() throws Exception {\n\t\tCollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n\t\tList<StreamElement> elements1 = Arrays.asList(\n\t\t\tnew StreamRecord<>(2, 3),\n\t\t\tnew Watermark(3),\n\t\t\tnew StreamRecord<>(3, 3),\n\t\t\tnew Watermark(7)\n\t\t);\n\t\tList<StreamElement> elements2 = Arrays.asList(\n\t\t\tnew StreamRecord<>(0, 3),\n\t\t\tnew Watermark(1),\n\t\t\tnew StreamRecord<>(1, 3),\n\t\t\tnew Watermark(3)\n\t\t);\n\t\tCollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n\t\tCollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n\t\tKeySelector<Integer, Integer> keySelector = value -> value;\n\t\ttry (MockEnvironment environment = MockEnvironment.builder().build()) {\n\t\t\tSelectableSortingInputs selectableSortingInputs = MultiInputSortingDataInput.wrapInputs(\n\t\t\t\tnew DummyInvokable(),\n\t\t\t\tnew StreamTaskInput[]{dataInput1, dataInput2},\n\t\t\t\tnew KeySelector[]{keySelector, keySelector},\n\t\t\t\tnew TypeSerializer[]{new IntSerializer(), new IntSerializer()},\n\t\t\t\tnew IntSerializer(),\n\t\t\t\tenvironment.getMemoryManager(),\n\t\t\t\tenvironment.getIOManager(),\n\t\t\t\ttrue,\n\t\t\t\t1.0,\n\t\t\t\tnew Configuration()\n\t\t\t);\n\n\t\t\tStreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortingInputs();\n\t\t\ttry (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n\t\t\t\t\tStreamTaskInput<Object> input2 = (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n\t\t\t\tMultipleInputSelectionHandler selectionHandler = new MultipleInputSelectionHandler(\n\t\t\t\t\tselectableSortingInputs.getInputSelectable(),\n\t\t\t\t\t2);\n\t\t\t\tStreamMultipleInputProcessor processor = new StreamMultipleInputProcessor(\n\t\t\t\t\tselectionHandler,\n\t\t\t\t\tnew StreamOneInputProcessor[]{\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput1,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput2,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tInputStatus inputStatus;\n\t\t\t\tdo {\n\t\t\t\t\tinputStatus = processor.processInput();\n\t\t\t\t} while (inputStatus != InputStatus.END_OF_INPUT);\n\t\t\t}\n\t\t}\n\n\t\tassertThat(collectingDataOutput.events, equalTo(\n\t\t\tArrays.asList(\n\t\t\t\tnew StreamRecord<>(0, 3),\n\t\t\t\tnew StreamRecord<>(1, 3),\n\t\t\t\tnew Watermark(3), \r\n\t\t\t\tnew StreamRecord<>(2, 3),\n\t\t\t\tnew StreamRecord<>(3, 3),\n\t\t\t\tnew Watermark(7) \r\n\t\t\t)\n\t\t));\n\t}\n","date":"2020-10-12 23:40:56","endLine":203,"groupId":"47631","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"watermarkPropagation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f5/ccf3445f38ab7a8a4e3bb7ea96eb892325f53f.src","preCode":"\tpublic void watermarkPropagation() throws Exception {\n\t\tCollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n\t\tList<StreamElement> elements1 = Arrays.asList(\n\t\t\tnew StreamRecord<>(2, 3),\n\t\t\tnew Watermark(3),\n\t\t\tnew StreamRecord<>(3, 3),\n\t\t\tnew Watermark(7)\n\t\t);\n\t\tList<StreamElement> elements2 = Arrays.asList(\n\t\t\tnew StreamRecord<>(0, 3),\n\t\t\tnew Watermark(1),\n\t\t\tnew StreamRecord<>(1, 3),\n\t\t\tnew Watermark(3)\n\t\t);\n\t\tCollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n\t\tCollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n\t\tKeySelector<Integer, Integer> keySelector = value -> value;\n\t\ttry (MockEnvironment environment = MockEnvironment.builder().build()) {\n\t\t\tSelectableSortingInputs selectableSortingInputs = MultiInputSortingDataInput.wrapInputs(\n\t\t\t\tnew DummyInvokable(),\n\t\t\t\tnew StreamTaskInput[]{dataInput1, dataInput2},\n\t\t\t\tnew KeySelector[]{keySelector, keySelector},\n\t\t\t\tnew TypeSerializer[]{new IntSerializer(), new IntSerializer()},\n\t\t\t\tnew IntSerializer(),\n\t\t\t\tenvironment.getMemoryManager(),\n\t\t\t\tenvironment.getIOManager(),\n\t\t\t\ttrue,\n\t\t\t\t1.0,\n\t\t\t\tnew Configuration()\n\t\t\t);\n\n\t\t\tStreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortingInputs();\n\t\t\ttry (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n\t\t\t\t\tStreamTaskInput<Object> input2 = (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n\t\t\t\tMultipleInputSelectionHandler selectionHandler = new MultipleInputSelectionHandler(\n\t\t\t\t\tselectableSortingInputs.getInputSelectable(),\n\t\t\t\t\t2);\n\t\t\t\tStreamMultipleInputProcessor processor = new StreamMultipleInputProcessor(\n\t\t\t\t\tselectionHandler,\n\t\t\t\t\tnew StreamOneInputProcessor[]{\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput1,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnew StreamOneInputProcessor<>(\n\t\t\t\t\t\t\tinput2,\n\t\t\t\t\t\t\tcollectingDataOutput,\n\t\t\t\t\t\t\tnew DummyOperatorChain()\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tInputStatus inputStatus;\n\t\t\t\tdo {\n\t\t\t\t\tinputStatus = processor.processInput();\n\t\t\t\t} while (inputStatus != InputStatus.END_OF_INPUT);\n\t\t\t}\n\t\t}\n\n\t\tassertThat(collectingDataOutput.events, equalTo(\n\t\t\tArrays.asList(\n\t\t\t\tnew StreamRecord<>(0, 3),\n\t\t\t\tnew StreamRecord<>(1, 3),\n\t\t\t\tnew Watermark(3), \r\n\t\t\t\tnew StreamRecord<>(2, 3),\n\t\t\t\tnew StreamRecord<>(3, 3),\n\t\t\t\tnew Watermark(7) \r\n\t\t\t)\n\t\t));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"B"}],"commitId":"fa43b75173e87624444a99105f46ae904038177e","commitMessage":"@@@[FLINK-19473] Implement multi inputs sorting DataInput\n\nI implement a MultiInputSortingDataInputs which is kind of a factory for\nmultiple.  related inputs. In case of sorting inputs of Two/Multiple\ninput operators not only the independent inputs should be sorted.  but\nalso records across different inputs. Therefore the produced inputs\nshare a common context to synchronize which input should emit records\nnext.\n\nThe coordination is done via inputs Availability. Only one of the\ninputs.  with the current smallest element.  is available at a time.\n","date":"2020-10-12 23:40:56","modifiedFileCount":"2","status":"B","submitter":"Dawid Wysakowicz"},{"authorTime":"2020-12-10 01:15:06","codes":[{"authorDate":"2020-12-10 01:15:06","commitOrder":2,"curCode":"    public void simpleFixedLengthKeySorting() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements =\n                Arrays.asList(\n                        new StreamRecord<>(1, 3),\n                        new StreamRecord<>(1, 1),\n                        new StreamRecord<>(2, 1),\n                        new StreamRecord<>(2, 3),\n                        new StreamRecord<>(1, 2),\n                        new StreamRecord<>(2, 2),\n                        Watermark.MAX_WATERMARK);\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                InputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != InputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK, \r\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK \r\n                                )));\n    }\n","date":"2021-01-07 19:11:44","endLine":223,"groupId":"47631","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"simpleFixedLengthKeySorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/15/fc0f4c39653b49e0abe70ad993aa45592a8d47.src","preCode":"    public void simpleFixedLengthKeySorting() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements =\n                Arrays.asList(\n                        new StreamRecord<>(1, 3),\n                        new StreamRecord<>(1, 1),\n                        new StreamRecord<>(2, 1),\n                        new StreamRecord<>(2, 3),\n                        new StreamRecord<>(1, 2),\n                        new StreamRecord<>(2, 2),\n                        Watermark.MAX_WATERMARK);\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortingInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                InputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != InputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK, \r\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK \r\n                                )));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"},{"authorDate":"2020-12-10 01:15:06","commitOrder":2,"curCode":"    public void watermarkPropagation() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements1 =\n                Arrays.asList(\n                        new StreamRecord<>(2, 3),\n                        new Watermark(3),\n                        new StreamRecord<>(3, 3),\n                        new Watermark(7));\n        List<StreamElement> elements2 =\n                Arrays.asList(\n                        new StreamRecord<>(0, 3),\n                        new Watermark(1),\n                        new StreamRecord<>(1, 3),\n                        new Watermark(3));\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                InputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != InputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(0, 3),\n                                new StreamRecord<>(1, 3),\n                                new Watermark(3), \r\n                                new StreamRecord<>(2, 3),\n                                new StreamRecord<>(3, 3),\n                                new Watermark(7) \r\n                                )));\n    }\n","date":"2021-01-07 19:11:44","endLine":295,"groupId":"17875","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"watermarkPropagation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/15/fc0f4c39653b49e0abe70ad993aa45592a8d47.src","preCode":"    public void watermarkPropagation() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements1 =\n                Arrays.asList(\n                        new StreamRecord<>(2, 3),\n                        new Watermark(3),\n                        new StreamRecord<>(3, 3),\n                        new Watermark(7));\n        List<StreamElement> elements2 =\n                Arrays.asList(\n                        new StreamRecord<>(0, 3),\n                        new Watermark(1),\n                        new StreamRecord<>(1, 3),\n                        new Watermark(3));\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortingInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                InputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != InputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(0, 3),\n                                new StreamRecord<>(1, 3),\n                                new Watermark(3), \r\n                                new StreamRecord<>(2, 3),\n                                new StreamRecord<>(3, 3),\n                                new Watermark(7) \r\n                                )));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"}],"commitId":"00f8de7ebc0951c78949a39352fd8e225dc98494","commitMessage":"@@@[FLINK-20491] Add preferred/pass-though inputs in MultiInputSortingDataInput\n\nThis will allow processing the broadcast side of a broadcast operator\nfirst.  before processing the keyed side that requires sorting for\nstateful BATCH execution.\n\nFor now.  the wiring from the API is not there.  this will be added in\nfollow-up changes.\n","date":"2021-01-07 19:11:44","modifiedFileCount":"5","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2021-07-23 19:45:47","codes":[{"authorDate":"2021-07-23 19:45:47","commitOrder":3,"curCode":"    public void simpleFixedLengthKeySorting() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements =\n                Arrays.asList(\n                        new StreamRecord<>(1, 3),\n                        new StreamRecord<>(1, 1),\n                        new StreamRecord<>(2, 1),\n                        new StreamRecord<>(2, 3),\n                        new StreamRecord<>(1, 2),\n                        new StreamRecord<>(2, 2),\n                        Watermark.MAX_WATERMARK);\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                DataInputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != DataInputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK, \r\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK \r\n                                )));\n    }\n","date":"2021-07-26 18:58:47","endLine":223,"groupId":"47631","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"simpleFixedLengthKeySorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ee/91bb70940c5de6d2892f45829c6f4e423c71a0.src","preCode":"    public void simpleFixedLengthKeySorting() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements =\n                Arrays.asList(\n                        new StreamRecord<>(1, 3),\n                        new StreamRecord<>(1, 1),\n                        new StreamRecord<>(2, 1),\n                        new StreamRecord<>(2, 3),\n                        new StreamRecord<>(1, 2),\n                        new StreamRecord<>(2, 2),\n                        Watermark.MAX_WATERMARK);\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                InputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != InputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK, \r\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK \r\n                                )));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"M"},{"authorDate":"2021-07-23 19:45:47","commitOrder":3,"curCode":"    public void watermarkPropagation() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements1 =\n                Arrays.asList(\n                        new StreamRecord<>(2, 3),\n                        new Watermark(3),\n                        new StreamRecord<>(3, 3),\n                        new Watermark(7));\n        List<StreamElement> elements2 =\n                Arrays.asList(\n                        new StreamRecord<>(0, 3),\n                        new Watermark(1),\n                        new StreamRecord<>(1, 3),\n                        new Watermark(3));\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                DataInputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != DataInputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(0, 3),\n                                new StreamRecord<>(1, 3),\n                                new Watermark(3), \r\n                                new StreamRecord<>(2, 3),\n                                new StreamRecord<>(3, 3),\n                                new Watermark(7) \r\n                                )));\n    }\n","date":"2021-07-26 18:58:47","endLine":295,"groupId":"17875","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"watermarkPropagation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ee/91bb70940c5de6d2892f45829c6f4e423c71a0.src","preCode":"    public void watermarkPropagation() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements1 =\n                Arrays.asList(\n                        new StreamRecord<>(2, 3),\n                        new Watermark(3),\n                        new StreamRecord<>(3, 3),\n                        new Watermark(7));\n        List<StreamElement> elements2 =\n                Arrays.asList(\n                        new StreamRecord<>(0, 3),\n                        new Watermark(1),\n                        new StreamRecord<>(1, 3),\n                        new Watermark(3));\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                InputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != InputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(0, 3),\n                                new StreamRecord<>(1, 3),\n                                new Watermark(3), \r\n                                new StreamRecord<>(2, 3),\n                                new StreamRecord<>(3, 3),\n                                new Watermark(7) \r\n                                )));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"}],"commitId":"684d56ebce83c9bf69a3bd070a8a0aefd3b380ff","commitMessage":"@@@[FLINK-23474] Extract internal version of InputStatus\n\nThis commit separates internal and user facing versions of InputStatus.\nUser sources should never return e.g. the END_OF_RECOVERY status and\nthus we need an internal status.\n","date":"2021-07-26 18:58:47","modifiedFileCount":"24","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-08-21 01:27:23","codes":[{"authorDate":"2021-08-21 01:27:23","commitOrder":4,"curCode":"    public void simpleFixedLengthKeySorting() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements =\n                Arrays.asList(\n                        new StreamRecord<>(1, 3),\n                        new StreamRecord<>(1, 1),\n                        new StreamRecord<>(2, 1),\n                        new StreamRecord<>(2, 3),\n                        new StreamRecord<>(1, 2),\n                        new StreamRecord<>(2, 2),\n                        Watermark.MAX_WATERMARK);\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration(),\n                            new ExecutionConfig());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                DataInputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != DataInputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK, \r\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK \r\n                                )));\n    }\n","date":"2021-08-26 18:54:21","endLine":226,"groupId":"103132","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"simpleFixedLengthKeySorting","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/11/368c22f448780b70f912ae59d5099fea1993c4.src","preCode":"    public void simpleFixedLengthKeySorting() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements =\n                Arrays.asList(\n                        new StreamRecord<>(1, 3),\n                        new StreamRecord<>(1, 1),\n                        new StreamRecord<>(2, 1),\n                        new StreamRecord<>(2, 3),\n                        new StreamRecord<>(1, 2),\n                        new StreamRecord<>(2, 2),\n                        Watermark.MAX_WATERMARK);\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                DataInputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != DataInputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 1),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 2),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(1, 3),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 1),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 2),\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK, \r\n                                new StreamRecord<>(2, 3),\n                                Watermark.MAX_WATERMARK \r\n                                )));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"},{"authorDate":"2021-08-21 01:27:23","commitOrder":4,"curCode":"    public void watermarkPropagation() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements1 =\n                Arrays.asList(\n                        new StreamRecord<>(2, 3),\n                        new Watermark(3),\n                        new StreamRecord<>(3, 3),\n                        new Watermark(7));\n        List<StreamElement> elements2 =\n                Arrays.asList(\n                        new StreamRecord<>(0, 3),\n                        new Watermark(1),\n                        new StreamRecord<>(1, 3),\n                        new Watermark(3));\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration(),\n                            new ExecutionConfig());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                DataInputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != DataInputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(0, 3),\n                                new StreamRecord<>(1, 3),\n                                new Watermark(3), \r\n                                new StreamRecord<>(2, 3),\n                                new StreamRecord<>(3, 3),\n                                new Watermark(7) \r\n                                )));\n    }\n","date":"2021-08-26 18:54:21","endLine":299,"groupId":"103132","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"watermarkPropagation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/11/368c22f448780b70f912ae59d5099fea1993c4.src","preCode":"    public void watermarkPropagation() throws Exception {\n        CollectingDataOutput<Object> collectingDataOutput = new CollectingDataOutput<>();\n        List<StreamElement> elements1 =\n                Arrays.asList(\n                        new StreamRecord<>(2, 3),\n                        new Watermark(3),\n                        new StreamRecord<>(3, 3),\n                        new Watermark(7));\n        List<StreamElement> elements2 =\n                Arrays.asList(\n                        new StreamRecord<>(0, 3),\n                        new Watermark(1),\n                        new StreamRecord<>(1, 3),\n                        new Watermark(3));\n        CollectionDataInput<Integer> dataInput1 = new CollectionDataInput<>(elements1, 0);\n        CollectionDataInput<Integer> dataInput2 = new CollectionDataInput<>(elements2, 1);\n        KeySelector<Integer, Integer> keySelector = value -> value;\n        try (MockEnvironment environment = MockEnvironment.builder().build()) {\n            SelectableSortingInputs selectableSortingInputs =\n                    MultiInputSortingDataInput.wrapInputs(\n                            new DummyInvokable(),\n                            new StreamTaskInput[] {dataInput1, dataInput2},\n                            new KeySelector[] {keySelector, keySelector},\n                            new TypeSerializer[] {new IntSerializer(), new IntSerializer()},\n                            new IntSerializer(),\n                            new StreamTaskInput[0],\n                            environment.getMemoryManager(),\n                            environment.getIOManager(),\n                            true,\n                            1.0,\n                            new Configuration());\n\n            StreamTaskInput<?>[] sortingDataInputs = selectableSortingInputs.getSortedInputs();\n            try (StreamTaskInput<Object> input1 = (StreamTaskInput<Object>) sortingDataInputs[0];\n                    StreamTaskInput<Object> input2 =\n                            (StreamTaskInput<Object>) sortingDataInputs[1]) {\n\n                MultipleInputSelectionHandler selectionHandler =\n                        new MultipleInputSelectionHandler(\n                                selectableSortingInputs.getInputSelectable(), 2);\n                StreamMultipleInputProcessor processor =\n                        new StreamMultipleInputProcessor(\n                                selectionHandler,\n                                new StreamOneInputProcessor[] {\n                                    new StreamOneInputProcessor<>(\n                                            input1, collectingDataOutput, new DummyOperatorChain()),\n                                    new StreamOneInputProcessor<>(\n                                            input2, collectingDataOutput, new DummyOperatorChain())\n                                });\n\n                DataInputStatus inputStatus;\n                do {\n                    inputStatus = processor.processInput();\n                } while (inputStatus != DataInputStatus.END_OF_INPUT);\n            }\n        }\n\n        assertThat(\n                collectingDataOutput.events,\n                equalTo(\n                        Arrays.asList(\n                                new StreamRecord<>(0, 3),\n                                new StreamRecord<>(1, 3),\n                                new Watermark(3), \r\n                                new StreamRecord<>(2, 3),\n                                new StreamRecord<>(3, 3),\n                                new Watermark(7) \r\n                                )));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/sort/MultiInputSortingDataInputsTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"a8ea3c3e81517f9c38f90b82c043136d8b56bf8b","commitMessage":"@@@[FLINK-23862][runtime] Replace usages of AbstractInvokable with interface\n\nA follow-up step after introduction of task interfaces to:\n- accept TaskInvokable in place of AbstractInvokable\n- make StreamTask implement the interfaces directly\n","date":"2021-08-26 18:54:21","modifiedFileCount":"29","status":"M","submitter":"Roman Khachatryan"}]
