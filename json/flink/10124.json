[{"authorTime":"2019-08-20 22:12:01","codes":[{"authorDate":"2019-08-20 22:12:01","commitOrder":1,"curCode":"\tstatic <K, N, S> void verifySnapshotWithoutTransform(\n\t\tMap<N, Map<K, S>> referenceStates,\n\t\t@Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n\t\tTypeSerializer<K> keySerializer,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<S> stateSerializer) throws IOException {\n\t\tByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n\t\tDataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n\t\tsnapshot.writeState(keySerializer, namespaceSerializer, stateSerializer, outputView, null);\n\n\t\tMap<N, Map<K, S>> actualStates = readStateFromSnapshot(\n\t\t\toutputStream.toByteArray(), keySerializer, namespaceSerializer, stateSerializer);\n\t\tassertEquals(referenceStates, actualStates);\n\t}\n","date":"2019-11-08 01:31:48","endLine":192,"groupId":"30435","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"verifySnapshotWithoutTransform","params":"(Map<N@Map<K@S>>referenceStates@@NonnullCopyOnWriteSkipListStateMapSnapshot<K@N@S>snapshot@TypeSerializer<K>keySerializer@TypeSerializer<N>namespaceSerializer@TypeSerializer<S>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ba/75241825c22df39da03fc9bf37dfbbe87bc9be.src","preCode":"\tstatic <K, N, S> void verifySnapshotWithoutTransform(\n\t\tMap<N, Map<K, S>> referenceStates,\n\t\t@Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n\t\tTypeSerializer<K> keySerializer,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<S> stateSerializer) throws IOException {\n\t\tByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n\t\tDataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n\t\tsnapshot.writeState(keySerializer, namespaceSerializer, stateSerializer, outputView, null);\n\n\t\tMap<N, Map<K, S>> actualStates = readStateFromSnapshot(\n\t\t\toutputStream.toByteArray(), keySerializer, namespaceSerializer, stateSerializer);\n\t\tassertEquals(referenceStates, actualStates);\n\t}\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapTestUtils.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"B"},{"authorDate":"2019-08-20 22:12:01","commitOrder":1,"curCode":"\tstatic <K, N, S> void verifySnapshotWithTransform(\n\t\t@Nonnull Map<N, Map<K, S>> referenceStates,\n\t\t@Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n\t\tStateSnapshotTransformer<S> transformer,\n\t\tTypeSerializer<K> keySerializer,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<S> stateSerializer) throws IOException {\n\t\tByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n\t\tDataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n\t\tsnapshot.writeState(keySerializer, namespaceSerializer, stateSerializer, outputView, transformer);\n\n\t\tMap<N, Map<K, S>> transformedStates = new HashMap<>();\n\t\tfor (Map.Entry<N, Map<K, S>> namespaceEntry : referenceStates.entrySet()) {\n\t\t\tfor (Map.Entry<K, S> keyEntry : namespaceEntry.getValue().entrySet()) {\n\t\t\t\tS state = transformer.filterOrTransform(keyEntry.getValue());\n\t\t\t\tif (state != null) {\n\t\t\t\t\ttransformedStates.computeIfAbsent(namespaceEntry.getKey(), (none) -> new HashMap<>())\n\t\t\t\t\t\t.put(keyEntry.getKey(), state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<N, Map<K, S>> actualStates = readStateFromSnapshot(\n\t\t\toutputStream.toByteArray(), keySerializer, namespaceSerializer, stateSerializer);\n\t\tassertEquals(transformedStates, actualStates);\n\t}\n","date":"2019-11-08 01:31:48","endLine":219,"groupId":"30435","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verifySnapshotWithTransform","params":"(@NonnullMap<N@Map<K@S>>referenceStates@@NonnullCopyOnWriteSkipListStateMapSnapshot<K@N@S>snapshot@StateSnapshotTransformer<S>transformer@TypeSerializer<K>keySerializer@TypeSerializer<N>namespaceSerializer@TypeSerializer<S>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ba/75241825c22df39da03fc9bf37dfbbe87bc9be.src","preCode":"\tstatic <K, N, S> void verifySnapshotWithTransform(\n\t\t@Nonnull Map<N, Map<K, S>> referenceStates,\n\t\t@Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n\t\tStateSnapshotTransformer<S> transformer,\n\t\tTypeSerializer<K> keySerializer,\n\t\tTypeSerializer<N> namespaceSerializer,\n\t\tTypeSerializer<S> stateSerializer) throws IOException {\n\t\tByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n\t\tDataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n\t\tsnapshot.writeState(keySerializer, namespaceSerializer, stateSerializer, outputView, transformer);\n\n\t\tMap<N, Map<K, S>> transformedStates = new HashMap<>();\n\t\tfor (Map.Entry<N, Map<K, S>> namespaceEntry : referenceStates.entrySet()) {\n\t\t\tfor (Map.Entry<K, S> keyEntry : namespaceEntry.getValue().entrySet()) {\n\t\t\t\tS state = transformer.filterOrTransform(keyEntry.getValue());\n\t\t\t\tif (state != null) {\n\t\t\t\t\ttransformedStates.computeIfAbsent(namespaceEntry.getKey(), (none) -> new HashMap<>())\n\t\t\t\t\t\t.put(keyEntry.getKey(), state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<N, Map<K, S>> actualStates = readStateFromSnapshot(\n\t\t\toutputStream.toByteArray(), keySerializer, namespaceSerializer, stateSerializer);\n\t\tassertEquals(transformedStates, actualStates);\n\t}\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapTestUtils.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"B"}],"commitId":"525f3c9c45f8534f1782986781140473909116a8","commitMessage":"@@@[FLINK-12697][state backends] Support on-disk state storage for spill-able heap backend\n","date":"2019-11-08 01:31:48","modifiedFileCount":"4","status":"B","submitter":"Yu Li"},{"authorTime":"2021-01-28 04:04:38","codes":[{"authorDate":"2021-01-28 04:04:38","commitOrder":2,"curCode":"    static <K, N, S> void verifySnapshotWithoutTransform(\n            Map<N, Map<K, S>> referenceStates,\n            @Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n            TypeSerializer<K> keySerializer,\n            TypeSerializer<N> namespaceSerializer,\n            TypeSerializer<S> stateSerializer,\n            SnapshotVerificationMode verificationMode)\n            throws IOException {\n        ByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n        DataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n        if (verificationMode == SnapshotVerificationMode.ITERATOR) {\n            Iterator<StateEntry<K, N, S>> iterator =\n                    snapshot.getIterator(keySerializer, namespaceSerializer, stateSerializer, null);\n            assertThat(() -> iterator, containsInAnyOrder(toMatchers(referenceStates)));\n        } else {\n            snapshot.writeState(\n                    keySerializer, namespaceSerializer, stateSerializer, outputView, null);\n\n            Map<N, Map<K, S>> actualStates =\n                    readStateFromSnapshot(\n                            outputStream.toByteArray(),\n                            keySerializer,\n                            namespaceSerializer,\n                            stateSerializer);\n            assertEquals(referenceStates, actualStates);\n        }\n    }\n","date":"2021-01-29 06:00:51","endLine":228,"groupId":"10124","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"verifySnapshotWithoutTransform","params":"(Map<N@Map<K@S>>referenceStates@@NonnullCopyOnWriteSkipListStateMapSnapshot<K@N@S>snapshot@TypeSerializer<K>keySerializer@TypeSerializer<N>namespaceSerializer@TypeSerializer<S>stateSerializer@SnapshotVerificationModeverificationMode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/62/7184c70d43fda9d340bb988fe647d3660d4fd3.src","preCode":"    static <K, N, S> void verifySnapshotWithoutTransform(\n            Map<N, Map<K, S>> referenceStates,\n            @Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n            TypeSerializer<K> keySerializer,\n            TypeSerializer<N> namespaceSerializer,\n            TypeSerializer<S> stateSerializer)\n            throws IOException {\n        ByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n        DataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n        snapshot.writeState(keySerializer, namespaceSerializer, stateSerializer, outputView, null);\n\n        Map<N, Map<K, S>> actualStates =\n                readStateFromSnapshot(\n                        outputStream.toByteArray(),\n                        keySerializer,\n                        namespaceSerializer,\n                        stateSerializer);\n        assertEquals(referenceStates, actualStates);\n    }\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapTestUtils.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"M"},{"authorDate":"2021-01-28 04:04:38","commitOrder":2,"curCode":"    static <K, N, S> void verifySnapshotWithTransform(\n            @Nonnull Map<N, Map<K, S>> referenceStates,\n            @Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n            StateSnapshotTransformer<S> transformer,\n            TypeSerializer<K> keySerializer,\n            TypeSerializer<N> namespaceSerializer,\n            TypeSerializer<S> stateSerializer,\n            SnapshotVerificationMode verificationMode)\n            throws IOException {\n        ByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n        DataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n\n        Map<N, Map<K, S>> transformedStates = new HashMap<>();\n        for (Map.Entry<N, Map<K, S>> namespaceEntry : referenceStates.entrySet()) {\n            for (Map.Entry<K, S> keyEntry : namespaceEntry.getValue().entrySet()) {\n                S state = transformer.filterOrTransform(keyEntry.getValue());\n                if (state != null) {\n                    transformedStates\n                            .computeIfAbsent(namespaceEntry.getKey(), (none) -> new HashMap<>())\n                            .put(keyEntry.getKey(), state);\n                }\n            }\n        }\n\n        if (verificationMode == SnapshotVerificationMode.SERIALIZED) {\n            snapshot.writeState(\n                    keySerializer, namespaceSerializer, stateSerializer, outputView, transformer);\n            Map<N, Map<K, S>> actualStates =\n                    readStateFromSnapshot(\n                            outputStream.toByteArray(),\n                            keySerializer,\n                            namespaceSerializer,\n                            stateSerializer);\n            assertEquals(transformedStates, actualStates);\n        } else {\n            Iterator<StateEntry<K, N, S>> iterator =\n                    snapshot.getIterator(keySerializer, namespaceSerializer, stateSerializer, null);\n            assertThat(() -> iterator, containsInAnyOrder(toMatchers(referenceStates)));\n        }\n    }\n","date":"2021-01-29 06:00:51","endLine":297,"groupId":"10124","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"verifySnapshotWithTransform","params":"(@NonnullMap<N@Map<K@S>>referenceStates@@NonnullCopyOnWriteSkipListStateMapSnapshot<K@N@S>snapshot@StateSnapshotTransformer<S>transformer@TypeSerializer<K>keySerializer@TypeSerializer<N>namespaceSerializer@TypeSerializer<S>stateSerializer@SnapshotVerificationModeverificationMode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/62/7184c70d43fda9d340bb988fe647d3660d4fd3.src","preCode":"    static <K, N, S> void verifySnapshotWithTransform(\n            @Nonnull Map<N, Map<K, S>> referenceStates,\n            @Nonnull CopyOnWriteSkipListStateMapSnapshot<K, N, S> snapshot,\n            StateSnapshotTransformer<S> transformer,\n            TypeSerializer<K> keySerializer,\n            TypeSerializer<N> namespaceSerializer,\n            TypeSerializer<S> stateSerializer)\n            throws IOException {\n        ByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos();\n        DataOutputView outputView = new DataOutputViewStreamWrapper(outputStream);\n        snapshot.writeState(\n                keySerializer, namespaceSerializer, stateSerializer, outputView, transformer);\n\n        Map<N, Map<K, S>> transformedStates = new HashMap<>();\n        for (Map.Entry<N, Map<K, S>> namespaceEntry : referenceStates.entrySet()) {\n            for (Map.Entry<K, S> keyEntry : namespaceEntry.getValue().entrySet()) {\n                S state = transformer.filterOrTransform(keyEntry.getValue());\n                if (state != null) {\n                    transformedStates\n                            .computeIfAbsent(namespaceEntry.getKey(), (none) -> new HashMap<>())\n                            .put(keyEntry.getKey(), state);\n                }\n            }\n        }\n\n        Map<N, Map<K, S>> actualStates =\n                readStateFromSnapshot(\n                        outputStream.toByteArray(),\n                        keySerializer,\n                        namespaceSerializer,\n                        stateSerializer);\n        assertEquals(transformedStates, actualStates);\n    }\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapTestUtils.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":258,"status":"M"}],"commitId":"351d6e924db155518113d21ab99c566740a0f194","commitMessage":"@@@[FLINK-21167] Make StateTable snapshots iterable\n\nIn order to implement an iterator required by a binary unified savepoint we need a way to iterate a snapshot.\n","date":"2021-01-29 06:00:51","modifiedFileCount":"9","status":"M","submitter":"Dawid Wysakowicz"}]
