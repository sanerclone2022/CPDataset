[{"authorTime":"2019-11-07 00:12:44","codes":[{"authorDate":"2019-11-07 00:12:44","commitOrder":10,"curCode":"\t<K> void testIteratorHelper(\n\t\tTypeSerializer<K> keySerializer,\n\t\tint maxKeyGroupNumber,\n\t\tFunction<Integer, K> getKeyFunc) throws Exception {\n\n\t\tString testStateName = \"aha\";\n\t\tString namespace = \"ns\";\n\n\t\ttry (RocksDBKeyedStateBackendTestFactory factory = new RocksDBKeyedStateBackendTestFactory()) {\n\t\t\tRocksDBKeyedStateBackend<K> keyedStateBackend = factory.create(tmp, keySerializer, maxKeyGroupNumber);\n\t\t\tValueState<String> testState = keyedStateBackend.getPartitionedState(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\tnew ValueStateDescriptor<>(testStateName, String.class));\n\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\tkeyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n\t\t\t\ttestState.update(String.valueOf(i));\n\t\t\t}\n\n\t\t\tDataOutputSerializer outputStream = new DataOutputSerializer(8);\n\t\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(keySerializer, StringSerializer.INSTANCE);\n\t\t\tRocksDBKeySerializationUtils.writeNameSpace(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\toutputStream,\n\t\t\t\tambiguousKeyPossible);\n\n\t\t\tbyte[] nameSpaceBytes = outputStream.getCopyOfBuffer();\n\n\t\t\t\r\n\t\t\tColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n\t\t\ttry (\n\t\t\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(keyedStateBackend.db, handle, keyedStateBackend.getReadOptions());\n\t\t\t\tRocksStateKeysIterator<K> iteratorWrapper =\n\t\t\t\t\tnew RocksStateKeysIterator<>(\n\t\t\t\t\t\titerator,\n\t\t\t\t\t\ttestStateName,\n\t\t\t\t\t\tkeySerializer,\n\t\t\t\t\t\tkeyedStateBackend.getKeyGroupPrefixBytes(),\n\t\t\t\t\t\tambiguousKeyPossible,\n\t\t\t\t\t\tnameSpaceBytes)) {\n\n\t\t\t\titerator.seekToFirst();\n\n\t\t\t\t\r\n\t\t\t\tList<Integer> fetchedKeys = new ArrayList<>(1000);\n\t\t\t\twhile (iteratorWrapper.hasNext()) {\n\t\t\t\t\tfetchedKeys.add(Integer.parseInt(iteratorWrapper.next().toString()));\n\t\t\t\t}\n\n\t\t\t\tfetchedKeys.sort(Comparator.comparingInt(a -> a));\n\t\t\t\tAssert.assertEquals(1000, fetchedKeys.size());\n\n\t\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\t\tAssert.assertEquals(i, fetchedKeys.get(i).intValue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-09-15 04:37:02","endLine":124,"groupId":"52505","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testIteratorHelper","params":"(TypeSerializer<K>keySerializer@intmaxKeyGroupNumber@Function<Integer@K>getKeyFunc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/12/9bb06a6e28a058430c555b1dc07967a648d42a.src","preCode":"\t<K> void testIteratorHelper(\n\t\tTypeSerializer<K> keySerializer,\n\t\tint maxKeyGroupNumber,\n\t\tFunction<Integer, K> getKeyFunc) throws Exception {\n\n\t\tString testStateName = \"aha\";\n\t\tString namespace = \"ns\";\n\n\t\ttry (RocksDBKeyedStateBackendTestFactory factory = new RocksDBKeyedStateBackendTestFactory()) {\n\t\t\tRocksDBKeyedStateBackend<K> keyedStateBackend = factory.create(tmp, keySerializer, maxKeyGroupNumber);\n\t\t\tValueState<String> testState = keyedStateBackend.getPartitionedState(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\tnew ValueStateDescriptor<>(testStateName, String.class));\n\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\tkeyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n\t\t\t\ttestState.update(String.valueOf(i));\n\t\t\t}\n\n\t\t\tDataOutputSerializer outputStream = new DataOutputSerializer(8);\n\t\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(keySerializer, StringSerializer.INSTANCE);\n\t\t\tRocksDBKeySerializationUtils.writeNameSpace(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\toutputStream,\n\t\t\t\tambiguousKeyPossible);\n\n\t\t\tbyte[] nameSpaceBytes = outputStream.getCopyOfBuffer();\n\n\t\t\t\r\n\t\t\tColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n\t\t\ttry (\n\t\t\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(keyedStateBackend.db, handle, keyedStateBackend.getReadOptions());\n\t\t\t\tRocksStateKeysIterator<K> iteratorWrapper =\n\t\t\t\t\tnew RocksStateKeysIterator<>(\n\t\t\t\t\t\titerator,\n\t\t\t\t\t\ttestStateName,\n\t\t\t\t\t\tkeySerializer,\n\t\t\t\t\t\tkeyedStateBackend.getKeyGroupPrefixBytes(),\n\t\t\t\t\t\tambiguousKeyPossible,\n\t\t\t\t\t\tnameSpaceBytes)) {\n\n\t\t\t\titerator.seekToFirst();\n\n\t\t\t\t\r\n\t\t\t\tList<Integer> fetchedKeys = new ArrayList<>(1000);\n\t\t\t\twhile (iteratorWrapper.hasNext()) {\n\t\t\t\t\tfetchedKeys.add(Integer.parseInt(iteratorWrapper.next().toString()));\n\t\t\t\t}\n\n\t\t\t\tfetchedKeys.sort(Comparator.comparingInt(a -> a));\n\t\t\t\tAssert.assertEquals(1000, fetchedKeys.size());\n\n\t\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\t\tAssert.assertEquals(i, fetchedKeys.get(i).intValue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksStateKeysIteratorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"MB"},{"authorDate":"2019-11-07 00:12:44","commitOrder":10,"curCode":"\t<K> void testIteratorHelper(\n\t\tTypeSerializer<K> keySerializer,\n\t\tint maxKeyGroupNumber,\n\t\tFunction<Integer, K> getKeyFunc) throws Exception {\n\n\t\tString testStateName = \"aha\";\n\t\tString namespace = \"ns\";\n\n\t\ttry (RocksDBKeyedStateBackendTestFactory factory = new RocksDBKeyedStateBackendTestFactory()) {\n\t\t\tRocksDBKeyedStateBackend<K> keyedStateBackend = factory.create(tmp, keySerializer, maxKeyGroupNumber);\n\n\t\t\tValueState<String> testState = keyedStateBackend.getPartitionedState(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\tnew ValueStateDescriptor<>(testStateName, String.class));\n\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\tkeyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n\t\t\t\ttestState.update(String.valueOf(i));\n\t\t\t}\n\n\t\t\tDataOutputSerializer outputStream = new DataOutputSerializer(8);\n\t\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(keySerializer, StringSerializer.INSTANCE);\n\t\t\tRocksDBKeySerializationUtils.writeNameSpace(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\toutputStream,\n\t\t\t\tambiguousKeyPossible);\n\n\t\t\t\r\n\t\t\tColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n\t\t\ttry (\n\t\t\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(keyedStateBackend.db, handle, keyedStateBackend.getReadOptions());\n\t\t\t\tRocksStateKeysAndNamespaceIterator<K, String> iteratorWrapper =\n\t\t\t\t\tnew RocksStateKeysAndNamespaceIterator<>(\n\t\t\t\t\t\titerator,\n\t\t\t\t\t\ttestStateName,\n\t\t\t\t\t\tkeySerializer,\n\t\t\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\t\t\tkeyedStateBackend.getKeyGroupPrefixBytes(),\n\t\t\t\t\t\tambiguousKeyPossible)) {\n\n\t\t\t\titerator.seekToFirst();\n\n\t\t\t\t\r\n\t\t\t\tList<Tuple2<Integer, String>> fetchedKeys = new ArrayList<>(1000);\n\t\t\t\twhile (iteratorWrapper.hasNext()) {\n\t\t\t\t\tTuple2 entry = iteratorWrapper.next();\n\t\t\t\t\tentry.f0 = Integer.parseInt(entry.f0.toString());\n\n\t\t\t\t\tfetchedKeys.add((Tuple2<Integer, String>) entry);\n\t\t\t\t}\n\n\t\t\t\tfetchedKeys.sort(Comparator.comparingInt(a -> a.f0));\n\t\t\t\tAssert.assertEquals(1000, fetchedKeys.size());\n\n\t\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\t\tAssert.assertEquals(i, fetchedKeys.get(i).f0.intValue());\n\t\t\t\t\tAssert.assertEquals(namespace, fetchedKeys.get(i).f1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-09-15 04:37:02","endLine":129,"groupId":"50883","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testIteratorHelper","params":"(TypeSerializer<K>keySerializer@intmaxKeyGroupNumber@Function<Integer@K>getKeyFunc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/de/0c64cfb94c2364a7a497d4bbfb5411688353b8.src","preCode":"\t<K> void testIteratorHelper(\n\t\tTypeSerializer<K> keySerializer,\n\t\tint maxKeyGroupNumber,\n\t\tFunction<Integer, K> getKeyFunc) throws Exception {\n\n\t\tString testStateName = \"aha\";\n\t\tString namespace = \"ns\";\n\n\t\ttry (RocksDBKeyedStateBackendTestFactory factory = new RocksDBKeyedStateBackendTestFactory()) {\n\t\t\tRocksDBKeyedStateBackend<K> keyedStateBackend = factory.create(tmp, keySerializer, maxKeyGroupNumber);\n\n\t\t\tValueState<String> testState = keyedStateBackend.getPartitionedState(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\tnew ValueStateDescriptor<>(testStateName, String.class));\n\n\t\t\t\r\n\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\tkeyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n\t\t\t\ttestState.update(String.valueOf(i));\n\t\t\t}\n\n\t\t\tDataOutputSerializer outputStream = new DataOutputSerializer(8);\n\t\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(keySerializer, StringSerializer.INSTANCE);\n\t\t\tRocksDBKeySerializationUtils.writeNameSpace(\n\t\t\t\tnamespace,\n\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\toutputStream,\n\t\t\t\tambiguousKeyPossible);\n\n\t\t\t\r\n\t\t\tColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n\t\t\ttry (\n\t\t\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(keyedStateBackend.db, handle, keyedStateBackend.getReadOptions());\n\t\t\t\tRocksStateKeysAndNamespaceIterator<K, String> iteratorWrapper =\n\t\t\t\t\tnew RocksStateKeysAndNamespaceIterator<>(\n\t\t\t\t\t\titerator,\n\t\t\t\t\t\ttestStateName,\n\t\t\t\t\t\tkeySerializer,\n\t\t\t\t\t\tStringSerializer.INSTANCE,\n\t\t\t\t\t\tkeyedStateBackend.getKeyGroupPrefixBytes(),\n\t\t\t\t\t\tambiguousKeyPossible)) {\n\n\t\t\t\titerator.seekToFirst();\n\n\t\t\t\t\r\n\t\t\t\tList<Tuple2<Integer, String>> fetchedKeys = new ArrayList<>(1000);\n\t\t\t\twhile (iteratorWrapper.hasNext()) {\n\t\t\t\t\tTuple2 entry = iteratorWrapper.next();\n\t\t\t\t\tentry.f0 = Integer.parseInt(entry.f0.toString());\n\n\t\t\t\t\tfetchedKeys.add((Tuple2<Integer, String>) entry);\n\t\t\t\t}\n\n\t\t\t\tfetchedKeys.sort(Comparator.comparingInt(a -> a.f0));\n\t\t\t\tAssert.assertEquals(1000, fetchedKeys.size());\n\n\t\t\t\tfor (int i = 0; i < 1000; ++i) {\n\t\t\t\t\tAssert.assertEquals(i, fetchedKeys.get(i).f0.intValue());\n\t\t\t\t\tAssert.assertEquals(namespace, fetchedKeys.get(i).f1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksStateKeysAndNamespacesIteratorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"B"}],"commitId":"cd81e9bbbd7456e6aedbff31054700cc4da70fa3","commitMessage":"@@@[FLINK-18978][state-backends] Support full table scan of key and namespace from statebackend\n\nThis closes #13179\n","date":"2020-09-15 04:37:02","modifiedFileCount":"8","status":"M","submitter":"Seth Wiesman"},{"authorTime":"2021-01-28 21:41:53","codes":[{"authorDate":"2021-01-28 21:41:53","commitOrder":11,"curCode":"    <K> void testIteratorHelper(\n            TypeSerializer<K> keySerializer, int maxKeyGroupNumber, Function<Integer, K> getKeyFunc)\n            throws Exception {\n\n        String testStateName = \"aha\";\n        String namespace = \"ns\";\n\n        try (RocksDBKeyedStateBackendTestFactory factory =\n                new RocksDBKeyedStateBackendTestFactory()) {\n            RocksDBKeyedStateBackend<K> keyedStateBackend =\n                    factory.create(tmp, keySerializer, maxKeyGroupNumber);\n            ValueState<String> testState =\n                    keyedStateBackend.getPartitionedState(\n                            namespace,\n                            StringSerializer.INSTANCE,\n                            new ValueStateDescriptor<>(testStateName, String.class));\n\n            \r\n            for (int i = 0; i < 1000; ++i) {\n                keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n                testState.update(String.valueOf(i));\n            }\n\n            DataOutputSerializer outputStream = new DataOutputSerializer(8);\n            boolean ambiguousKeyPossible =\n                    CompositeKeySerializationUtils.isAmbiguousKeyPossible(\n                            keySerializer, StringSerializer.INSTANCE);\n            CompositeKeySerializationUtils.writeNameSpace(\n                    namespace, StringSerializer.INSTANCE, outputStream, ambiguousKeyPossible);\n\n            byte[] nameSpaceBytes = outputStream.getCopyOfBuffer();\n\n            \r\n            ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n            try (RocksIteratorWrapper iterator =\n                            RocksDBOperationUtils.getRocksIterator(\n                                    keyedStateBackend.db,\n                                    handle,\n                                    keyedStateBackend.getReadOptions());\n                    RocksStateKeysIterator<K> iteratorWrapper =\n                            new RocksStateKeysIterator<>(\n                                    iterator,\n                                    testStateName,\n                                    keySerializer,\n                                    keyedStateBackend.getKeyGroupPrefixBytes(),\n                                    ambiguousKeyPossible,\n                                    nameSpaceBytes)) {\n\n                iterator.seekToFirst();\n\n                \r\n                List<Integer> fetchedKeys = new ArrayList<>(1000);\n                while (iteratorWrapper.hasNext()) {\n                    fetchedKeys.add(Integer.parseInt(iteratorWrapper.next().toString()));\n                }\n\n                fetchedKeys.sort(Comparator.comparingInt(a -> a));\n                Assert.assertEquals(1000, fetchedKeys.size());\n\n                for (int i = 0; i < 1000; ++i) {\n                    Assert.assertEquals(i, fetchedKeys.get(i).intValue());\n                }\n            }\n        }\n    }\n","date":"2021-02-06 01:38:46","endLine":126,"groupId":"1070","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testIteratorHelper","params":"(TypeSerializer<K>keySerializer@intmaxKeyGroupNumber@Function<Integer@K>getKeyFunc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6b/9e7a41356fcfe0f8406c732f58a77a6a2611d9.src","preCode":"    <K> void testIteratorHelper(\n            TypeSerializer<K> keySerializer, int maxKeyGroupNumber, Function<Integer, K> getKeyFunc)\n            throws Exception {\n\n        String testStateName = \"aha\";\n        String namespace = \"ns\";\n\n        try (RocksDBKeyedStateBackendTestFactory factory =\n                new RocksDBKeyedStateBackendTestFactory()) {\n            RocksDBKeyedStateBackend<K> keyedStateBackend =\n                    factory.create(tmp, keySerializer, maxKeyGroupNumber);\n            ValueState<String> testState =\n                    keyedStateBackend.getPartitionedState(\n                            namespace,\n                            StringSerializer.INSTANCE,\n                            new ValueStateDescriptor<>(testStateName, String.class));\n\n            \r\n            for (int i = 0; i < 1000; ++i) {\n                keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n                testState.update(String.valueOf(i));\n            }\n\n            DataOutputSerializer outputStream = new DataOutputSerializer(8);\n            boolean ambiguousKeyPossible =\n                    RocksDBKeySerializationUtils.isAmbiguousKeyPossible(\n                            keySerializer, StringSerializer.INSTANCE);\n            RocksDBKeySerializationUtils.writeNameSpace(\n                    namespace, StringSerializer.INSTANCE, outputStream, ambiguousKeyPossible);\n\n            byte[] nameSpaceBytes = outputStream.getCopyOfBuffer();\n\n            \r\n            ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n            try (RocksIteratorWrapper iterator =\n                            RocksDBOperationUtils.getRocksIterator(\n                                    keyedStateBackend.db,\n                                    handle,\n                                    keyedStateBackend.getReadOptions());\n                    RocksStateKeysIterator<K> iteratorWrapper =\n                            new RocksStateKeysIterator<>(\n                                    iterator,\n                                    testStateName,\n                                    keySerializer,\n                                    keyedStateBackend.getKeyGroupPrefixBytes(),\n                                    ambiguousKeyPossible,\n                                    nameSpaceBytes)) {\n\n                iterator.seekToFirst();\n\n                \r\n                List<Integer> fetchedKeys = new ArrayList<>(1000);\n                while (iteratorWrapper.hasNext()) {\n                    fetchedKeys.add(Integer.parseInt(iteratorWrapper.next().toString()));\n                }\n\n                fetchedKeys.sort(Comparator.comparingInt(a -> a));\n                Assert.assertEquals(1000, fetchedKeys.size());\n\n                for (int i = 0; i < 1000; ++i) {\n                    Assert.assertEquals(i, fetchedKeys.get(i).intValue());\n                }\n            }\n        }\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksStateKeysIteratorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2021-01-28 21:41:53","commitOrder":11,"curCode":"    <K> void testIteratorHelper(\n            TypeSerializer<K> keySerializer, int maxKeyGroupNumber, Function<Integer, K> getKeyFunc)\n            throws Exception {\n\n        String testStateName = \"aha\";\n        String namespace = \"ns\";\n\n        try (RocksDBKeyedStateBackendTestFactory factory =\n                new RocksDBKeyedStateBackendTestFactory()) {\n            RocksDBKeyedStateBackend<K> keyedStateBackend =\n                    factory.create(tmp, keySerializer, maxKeyGroupNumber);\n\n            ValueState<String> testState =\n                    keyedStateBackend.getPartitionedState(\n                            namespace,\n                            StringSerializer.INSTANCE,\n                            new ValueStateDescriptor<>(testStateName, String.class));\n\n            \r\n            for (int i = 0; i < 1000; ++i) {\n                keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n                testState.update(String.valueOf(i));\n            }\n\n            DataOutputSerializer outputStream = new DataOutputSerializer(8);\n            boolean ambiguousKeyPossible =\n                    CompositeKeySerializationUtils.isAmbiguousKeyPossible(\n                            keySerializer, StringSerializer.INSTANCE);\n            CompositeKeySerializationUtils.writeNameSpace(\n                    namespace, StringSerializer.INSTANCE, outputStream, ambiguousKeyPossible);\n\n            \r\n            ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n            try (RocksIteratorWrapper iterator =\n                            RocksDBOperationUtils.getRocksIterator(\n                                    keyedStateBackend.db,\n                                    handle,\n                                    keyedStateBackend.getReadOptions());\n                    RocksStateKeysAndNamespaceIterator<K, String> iteratorWrapper =\n                            new RocksStateKeysAndNamespaceIterator<>(\n                                    iterator,\n                                    testStateName,\n                                    keySerializer,\n                                    StringSerializer.INSTANCE,\n                                    keyedStateBackend.getKeyGroupPrefixBytes(),\n                                    ambiguousKeyPossible)) {\n\n                iterator.seekToFirst();\n\n                \r\n                List<Tuple2<Integer, String>> fetchedKeys = new ArrayList<>(1000);\n                while (iteratorWrapper.hasNext()) {\n                    Tuple2 entry = iteratorWrapper.next();\n                    entry.f0 = Integer.parseInt(entry.f0.toString());\n\n                    fetchedKeys.add((Tuple2<Integer, String>) entry);\n                }\n\n                fetchedKeys.sort(Comparator.comparingInt(a -> a.f0));\n                Assert.assertEquals(1000, fetchedKeys.size());\n\n                for (int i = 0; i < 1000; ++i) {\n                    Assert.assertEquals(i, fetchedKeys.get(i).f0.intValue());\n                    Assert.assertEquals(namespace, fetchedKeys.get(i).f1);\n                }\n            }\n        }\n    }\n","date":"2021-02-06 01:38:46","endLine":131,"groupId":"1070","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testIteratorHelper","params":"(TypeSerializer<K>keySerializer@intmaxKeyGroupNumber@Function<Integer@K>getKeyFunc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b6/2e689b3d6024665b4e28ca85241692ef53787b.src","preCode":"    <K> void testIteratorHelper(\n            TypeSerializer<K> keySerializer, int maxKeyGroupNumber, Function<Integer, K> getKeyFunc)\n            throws Exception {\n\n        String testStateName = \"aha\";\n        String namespace = \"ns\";\n\n        try (RocksDBKeyedStateBackendTestFactory factory =\n                new RocksDBKeyedStateBackendTestFactory()) {\n            RocksDBKeyedStateBackend<K> keyedStateBackend =\n                    factory.create(tmp, keySerializer, maxKeyGroupNumber);\n\n            ValueState<String> testState =\n                    keyedStateBackend.getPartitionedState(\n                            namespace,\n                            StringSerializer.INSTANCE,\n                            new ValueStateDescriptor<>(testStateName, String.class));\n\n            \r\n            for (int i = 0; i < 1000; ++i) {\n                keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));\n                testState.update(String.valueOf(i));\n            }\n\n            DataOutputSerializer outputStream = new DataOutputSerializer(8);\n            boolean ambiguousKeyPossible =\n                    RocksDBKeySerializationUtils.isAmbiguousKeyPossible(\n                            keySerializer, StringSerializer.INSTANCE);\n            RocksDBKeySerializationUtils.writeNameSpace(\n                    namespace, StringSerializer.INSTANCE, outputStream, ambiguousKeyPossible);\n\n            \r\n            ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);\n\n            try (RocksIteratorWrapper iterator =\n                            RocksDBOperationUtils.getRocksIterator(\n                                    keyedStateBackend.db,\n                                    handle,\n                                    keyedStateBackend.getReadOptions());\n                    RocksStateKeysAndNamespaceIterator<K, String> iteratorWrapper =\n                            new RocksStateKeysAndNamespaceIterator<>(\n                                    iterator,\n                                    testStateName,\n                                    keySerializer,\n                                    StringSerializer.INSTANCE,\n                                    keyedStateBackend.getKeyGroupPrefixBytes(),\n                                    ambiguousKeyPossible)) {\n\n                iterator.seekToFirst();\n\n                \r\n                List<Tuple2<Integer, String>> fetchedKeys = new ArrayList<>(1000);\n                while (iteratorWrapper.hasNext()) {\n                    Tuple2 entry = iteratorWrapper.next();\n                    entry.f0 = Integer.parseInt(entry.f0.toString());\n\n                    fetchedKeys.add((Tuple2<Integer, String>) entry);\n                }\n\n                fetchedKeys.sort(Comparator.comparingInt(a -> a.f0));\n                Assert.assertEquals(1000, fetchedKeys.size());\n\n                for (int i = 0; i < 1000; ++i) {\n                    Assert.assertEquals(i, fetchedKeys.get(i).f0.intValue());\n                    Assert.assertEquals(namespace, fetchedKeys.get(i).f1);\n                }\n            }\n        }\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksStateKeysAndNamespacesIteratorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"}],"commitId":"a3436cb67866fddec45c9ac1bd760c24732ca32b","commitMessage":"@@@[refactor] Move RocksDBCompositeKeyBuilder to a common package\n","date":"2021-02-06 01:38:46","modifiedFileCount":"13","status":"M","submitter":"Dawid Wysakowicz"}]
