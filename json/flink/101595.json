[{"authorTime":"2021-07-29 22:12:56","codes":[{"authorDate":"2021-07-29 22:12:56","commitOrder":1,"curCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-08-10 14:34:49","endLine":256,"groupId":"11083","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2e/5c9605b77f1ba9213eb8c6640556227accd085.src","preCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"B"},{"authorDate":"2021-07-29 22:12:56","commitOrder":1,"curCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException e) {\n                assertThat(\n                        e.getMessage(),\n                        CoreMatchers.startsWith(\n                                \"org.apache.flink.util.FlinkException: Inconsistent execution state\"\n                                        + \" after stopping with savepoint. At least one execution\"\n                                        + \" is still in one of the following states: FAILED. \"\n                                        + \"A global fail-over is triggered to recover the job\"));\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-08-10 14:34:49","endLine":755,"groupId":"11090","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2e/5c9605b77f1ba9213eb8c6640556227accd085.src","preCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException e) {\n                assertThat(\n                        e.getMessage(),\n                        CoreMatchers.startsWith(\n                                \"org.apache.flink.util.FlinkException: Inconsistent execution state\"\n                                        + \" after stopping with savepoint. At least one execution\"\n                                        + \" is still in one of the following states: FAILED. \"\n                                        + \"A global fail-over is triggered to recover the job\"));\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":714,"status":"B"}],"commitId":"e3010c16947ed8da2ecb7d89a3aa08dacecc524a","commitMessage":"@@@[FLINK-23408] Emit end of data for stop-with-savepoint --drain\n","date":"2021-08-10 14:34:49","modifiedFileCount":"23","status":"B","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-08-12 15:54:43","codes":[{"authorDate":"2021-07-29 22:12:56","commitOrder":2,"curCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-08-10 14:34:49","endLine":256,"groupId":"11083","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2e/5c9605b77f1ba9213eb8c6640556227accd085.src","preCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"N"},{"authorDate":"2021-08-12 15:54:43","commitOrder":2,"curCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException e) {\n                assertThrowable(\n                        e,\n                        ex ->\n                                ex.getMessage()\n                                        .startsWith(\n                                                \"org.apache.flink.util.FlinkException: Inconsistent execution state\"\n                                                        + \" after stopping with savepoint. At least one execution\"\n                                                        + \" is still in one of the following states: FAILED. \"\n                                                        + \"A global fail-over is triggered to recover the job\"));\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-08-12 19:12:04","endLine":744,"groupId":"11090","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fa/491dc21130d3fd9ffdd85f42f4ccb1cbfd07f0.src","preCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException e) {\n                assertThat(\n                        e.getMessage(),\n                        CoreMatchers.startsWith(\n                                \"org.apache.flink.util.FlinkException: Inconsistent execution state\"\n                                        + \" after stopping with savepoint. At least one execution\"\n                                        + \" is still in one of the following states: FAILED. \"\n                                        + \"A global fail-over is triggered to recover the job\"));\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":701,"status":"M"}],"commitId":"938cf8db710409431902cb6cc2825fec289b8e5b","commitMessage":"@@@[FLINK-23713][tests] Do not hide original exceptions in SavepointITCase\n","date":"2021-08-12 19:12:04","modifiedFileCount":"2","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-08-13 22:17:33","codes":[{"authorDate":"2021-08-13 22:17:33","commitOrder":3,"curCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .setParallelism(1)\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-08-15 23:13:45","endLine":255,"groupId":"24593","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/76/664725117cf5cb622aa8c4de11e08e88883e9b.src","preCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"M"},{"authorDate":"2021-08-13 22:17:33","commitOrder":3,"curCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        final int parallelism = 2;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(parallelism)\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(parallelism);\n        env.getConfig()\n                .setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0L));\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite test source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException ignored) {\n                \r\n            }\n\n            \r\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-08-15 23:13:45","endLine":743,"groupId":"24599","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/76/664725117cf5cb622aa8c4de11e08e88883e9b.src","preCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite Source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException e) {\n                assertThrowable(\n                        e,\n                        ex ->\n                                ex.getMessage()\n                                        .startsWith(\n                                                \"org.apache.flink.util.FlinkException: Inconsistent execution state\"\n                                                        + \" after stopping with savepoint. At least one execution\"\n                                                        + \" is still in one of the following states: FAILED. \"\n                                                        + \"A global fail-over is triggered to recover the job\"));\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":702,"status":"M"}],"commitId":"1848a886d8af1d4bf457d61031edb8fc8565efd0","commitMessage":"@@@[FLINK-23713][tests] Harden SavepointITCase.testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted\n\nThis commit makes the SavepointITCase.testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted no longer\nassert for an internal exception message that is an implementation detail of Flink. Instead the test now checks\nthat all tasks are running again after failing to write the savepoint.\n\nThis closes #16818.\n","date":"2021-08-15 23:13:45","modifiedFileCount":"1","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2021-09-01 18:39:53","codes":[{"authorDate":"2021-09-01 18:39:53","commitOrder":4,"curCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .setParallelism(1)\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestClusterClient(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-09-02 15:19:29","endLine":254,"groupId":"101595","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/16/0fea21910891ce857cf2efe3d32535a93c0684.src","preCode":"    public void testStopWithSavepointWithDrainCallsFinishBeforeSnapshotState() throws Exception {\n        int sinkParallelism = 5;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(sinkParallelism + 1)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.getConfig().setRestartStrategy(RestartStrategies.noRestart());\n        env.addSource(new InfiniteTestSource())\n                .setParallelism(1)\n                .name(\"Infinite Source\")\n                .addSink(new FinishingSink<>())\n                \r\n                .setParallelism(sinkParallelism);\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                    .get();\n            \r\n            \r\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"},{"authorDate":"2021-09-01 18:39:53","commitOrder":4,"curCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        final int parallelism = 2;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(parallelism)\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(parallelism);\n        env.getConfig()\n                .setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0L));\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite test source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestClusterClient(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException ignored) {\n                \r\n            }\n\n            \r\n            waitUntilAllTasksAreRunning(cluster.getRestClusterClient(), jobGraph.getJobID());\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-09-02 15:19:29","endLine":743,"groupId":"101595","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/16/0fea21910891ce857cf2efe3d32535a93c0684.src","preCode":"    public void testStopWithSavepointWithDrainGlobalFailoverIfSavepointAborted() throws Exception {\n        Configuration configuration = new Configuration();\n        configuration.setString(\n                HighAvailabilityOptions.HA_MODE, FailingSyncSavepointHAFactory.class.getName());\n        final int parallelism = 2;\n        MiniClusterWithClientResource cluster =\n                new MiniClusterWithClientResource(\n                        new MiniClusterResourceConfiguration.Builder()\n                                .setNumberSlotsPerTaskManager(parallelism)\n                                .setConfiguration(configuration)\n                                .build());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(parallelism);\n        env.getConfig()\n                .setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0L));\n        env.addSource(new InfiniteTestSource())\n                .name(\"Infinite test source\")\n                .addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n\n        cluster.before();\n        try {\n            ClusterClient<?> client = cluster.getClusterClient();\n            client.submitJob(jobGraph).get();\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n\n            try {\n                client.stopWithSavepoint(jobGraph.getJobID(), true, savepointDir.getAbsolutePath())\n                        .get();\n                fail(\"The future should fail exceptionally.\");\n            } catch (ExecutionException ignored) {\n                \r\n            }\n\n            \r\n            waitUntilAllTasksAreRunning(cluster.getRestAddres(), jobGraph.getJobID());\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":702,"status":"M"}],"commitId":"9aa70fefe2a5ef4629c55cf84d6b85b74d95b1b6","commitMessage":"@@@[FLINK-24047][tests] Retry if leader election is in progress\n","date":"2021-09-02 15:19:29","modifiedFileCount":"2","status":"M","submitter":"Chesnay Schepler"}]
