[{"authorTime":"2018-02-01 19:53:42","codes":[{"authorDate":"2018-02-01 19:53:42","commitOrder":3,"curCode":"\tpublic void testRestoreWithEmptyState() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\tShard shard = new Shard();\n\t\t\tshard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange sequenceNumberRange = new SequenceNumberRange();\n\t\t\tsequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tshard.setSequenceNumberRange(sequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), shard));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\tMigrationTestUtil.restoreFromSnapshot(\n\t\t\ttestHarness,\n\t\t\t\"src/test/resources/kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-empty-snapshot\", testMigrateVersion);\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertTrue(consumerFunction.getRestoredState().isEmpty());\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tKinesisStreamShardState restoredShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredShardState.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","date":"2018-02-07 02:58:58","endLine":172,"groupId":"5292","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreWithEmptyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/79/9739d616a8b5a3c45387d8b9da6c43c98f56a3.src","preCode":"\tpublic void testRestoreWithEmptyState() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\tShard shard = new Shard();\n\t\t\tshard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange sequenceNumberRange = new SequenceNumberRange();\n\t\t\tsequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tshard.setSequenceNumberRange(sequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), shard));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\tMigrationTestUtil.restoreFromSnapshot(\n\t\t\ttestHarness,\n\t\t\t\"src/test/resources/kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-empty-snapshot\", testMigrateVersion);\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertTrue(consumerFunction.getRestoredState().isEmpty());\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tKinesisStreamShardState restoredShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredShardState.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","realPath":"flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisConsumerMigrationTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"MB"},{"authorDate":"2018-02-01 19:53:42","commitOrder":3,"curCode":"\tpublic void testRestoreWithReshardedStream() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\t\r\n\t\t\tShard closedShard = new Shard();\n\t\t\tclosedShard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange closedSequenceNumberRange = new SequenceNumberRange();\n\t\t\tclosedSequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tclosedSequenceNumberRange.withEndingSequenceNumber(\"1087654321\"); \r\n\t\t\tclosedShard.setSequenceNumberRange(closedSequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), closedShard));\n\n\t\t\t\r\n\t\t\tShard newSplitShard1 = new Shard();\n\t\t\tnewSplitShard1.setShardId(KinesisShardIdGenerator.generateFromShardOrder(1));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange1 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange1.withStartingSequenceNumber(\"1087654322\");\n\t\t\tnewSplitShard1.setSequenceNumberRange(newSequenceNumberRange1);\n\n\t\t\tnewSplitShard1.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tShard newSplitShard2 = new Shard();\n\t\t\tnewSplitShard2.setShardId(KinesisShardIdGenerator.generateFromShardOrder(2));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange2 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange2.withStartingSequenceNumber(\"2087654322\");\n\t\t\tnewSplitShard2.setSequenceNumberRange(newSequenceNumberRange2);\n\n\t\t\tnewSplitShard2.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard1));\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard2));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator =\n\t\t\tnew StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\tMigrationTestUtil.restoreFromSnapshot(\n\t\t\ttestHarness,\n\t\t\t\"src/test/resources/kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-snapshot\", testMigrateVersion);\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertNotEquals(null, consumerFunction.getRestoredState());\n\t\tassertEquals(1, consumerFunction.getRestoredState().size());\n\t\tassertEquals(TEST_STATE, removeEquivalenceWrappers(consumerFunction.getRestoredState()));\n\n\t\t\r\n\t\tassertEquals(3, fetcher.getSubscribedShardsState().size());\n\n\t\tKinesisStreamShardState restoredClosedShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredClosedShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredClosedShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertTrue(restoredClosedShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(TEST_SEQUENCE_NUMBER, restoredClosedShardState.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard1 = fetcher.getSubscribedShardsState().get(1);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard1.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(1), restoredNewSplitShard1.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard1.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard1.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard2 = fetcher.getSubscribedShardsState().get(2);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard2.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(2), restoredNewSplitShard2.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard2.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard2.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","date":"2018-02-07 02:58:58","endLine":325,"groupId":"5292","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreWithReshardedStream","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/79/9739d616a8b5a3c45387d8b9da6c43c98f56a3.src","preCode":"\tpublic void testRestoreWithReshardedStream() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\t\r\n\t\t\tShard closedShard = new Shard();\n\t\t\tclosedShard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange closedSequenceNumberRange = new SequenceNumberRange();\n\t\t\tclosedSequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tclosedSequenceNumberRange.withEndingSequenceNumber(\"1087654321\"); \r\n\t\t\tclosedShard.setSequenceNumberRange(closedSequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), closedShard));\n\n\t\t\t\r\n\t\t\tShard newSplitShard1 = new Shard();\n\t\t\tnewSplitShard1.setShardId(KinesisShardIdGenerator.generateFromShardOrder(1));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange1 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange1.withStartingSequenceNumber(\"1087654322\");\n\t\t\tnewSplitShard1.setSequenceNumberRange(newSequenceNumberRange1);\n\n\t\t\tnewSplitShard1.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tShard newSplitShard2 = new Shard();\n\t\t\tnewSplitShard2.setShardId(KinesisShardIdGenerator.generateFromShardOrder(2));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange2 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange2.withStartingSequenceNumber(\"2087654322\");\n\t\t\tnewSplitShard2.setSequenceNumberRange(newSequenceNumberRange2);\n\n\t\t\tnewSplitShard2.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard1));\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard2));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator =\n\t\t\tnew StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\tMigrationTestUtil.restoreFromSnapshot(\n\t\t\ttestHarness,\n\t\t\t\"src/test/resources/kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-snapshot\", testMigrateVersion);\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertNotEquals(null, consumerFunction.getRestoredState());\n\t\tassertEquals(1, consumerFunction.getRestoredState().size());\n\t\tassertEquals(TEST_STATE, removeEquivalenceWrappers(consumerFunction.getRestoredState()));\n\n\t\t\r\n\t\tassertEquals(3, fetcher.getSubscribedShardsState().size());\n\n\t\tKinesisStreamShardState restoredClosedShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredClosedShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredClosedShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertTrue(restoredClosedShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(TEST_SEQUENCE_NUMBER, restoredClosedShardState.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard1 = fetcher.getSubscribedShardsState().get(1);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard1.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(1), restoredNewSplitShard1.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard1.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard1.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard2 = fetcher.getSubscribedShardsState().get(2);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard2.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(2), restoredNewSplitShard2.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard2.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard2.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","realPath":"flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisConsumerMigrationTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"B"}],"commitId":"140bb0c66257d5d09d61845731aef1dbdb90a0bd","commitMessage":"@@@[FLINK-8484] [kinesis] Use an equivalence wrapper around restored StreamShardMetadatas to bypass out-of-sync shard infos\n\nThis closes #5337.\n","date":"2018-02-07 02:58:58","modifiedFileCount":"5","status":"M","submitter":"Tzu-Li (Gordon) Tai"},{"authorTime":"2019-01-10 21:58:43","codes":[{"authorDate":"2019-01-10 21:58:43","commitOrder":4,"curCode":"\tpublic void testRestoreWithEmptyState() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\tShard shard = new Shard();\n\t\t\tshard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange sequenceNumberRange = new SequenceNumberRange();\n\t\t\tsequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tshard.setSequenceNumberRange(sequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), shard));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(\n\t\t\tOperatorSnapshotUtil.getResourceFilename(\n\t\t\t\t\"kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-empty-snapshot\"));\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertTrue(consumerFunction.getRestoredState().isEmpty());\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tKinesisStreamShardState restoredShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredShardState.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","date":"2019-01-17 19:52:14","endLine":171,"groupId":"10550","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRestoreWithEmptyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f3/6b661273a468f97bce5866df17a72f20c596f7.src","preCode":"\tpublic void testRestoreWithEmptyState() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\tShard shard = new Shard();\n\t\t\tshard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange sequenceNumberRange = new SequenceNumberRange();\n\t\t\tsequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tshard.setSequenceNumberRange(sequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), shard));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator = new StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\tMigrationTestUtil.restoreFromSnapshot(\n\t\t\ttestHarness,\n\t\t\t\"src/test/resources/kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-empty-snapshot\", testMigrateVersion);\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertTrue(consumerFunction.getRestoredState().isEmpty());\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tKinesisStreamShardState restoredShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredShardState.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","realPath":"flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisConsumerMigrationTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2019-01-10 21:58:43","commitOrder":4,"curCode":"\tpublic void testRestoreWithReshardedStream() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\t\r\n\t\t\tShard closedShard = new Shard();\n\t\t\tclosedShard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange closedSequenceNumberRange = new SequenceNumberRange();\n\t\t\tclosedSequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tclosedSequenceNumberRange.withEndingSequenceNumber(\"1087654321\"); \r\n\t\t\tclosedShard.setSequenceNumberRange(closedSequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), closedShard));\n\n\t\t\t\r\n\t\t\tShard newSplitShard1 = new Shard();\n\t\t\tnewSplitShard1.setShardId(KinesisShardIdGenerator.generateFromShardOrder(1));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange1 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange1.withStartingSequenceNumber(\"1087654322\");\n\t\t\tnewSplitShard1.setSequenceNumberRange(newSequenceNumberRange1);\n\n\t\t\tnewSplitShard1.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tShard newSplitShard2 = new Shard();\n\t\t\tnewSplitShard2.setShardId(KinesisShardIdGenerator.generateFromShardOrder(2));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange2 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange2.withStartingSequenceNumber(\"2087654322\");\n\t\t\tnewSplitShard2.setSequenceNumberRange(newSequenceNumberRange2);\n\n\t\t\tnewSplitShard2.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard1));\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard2));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator =\n\t\t\tnew StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\ttestHarness.initializeState(\n\t\t\tOperatorSnapshotUtil.getResourceFilename(\n\t\t\t\t\"kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-snapshot\"));\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertNotEquals(null, consumerFunction.getRestoredState());\n\t\tassertEquals(1, consumerFunction.getRestoredState().size());\n\t\tassertEquals(TEST_STATE, removeEquivalenceWrappers(consumerFunction.getRestoredState()));\n\n\t\t\r\n\t\tassertEquals(3, fetcher.getSubscribedShardsState().size());\n\n\t\tKinesisStreamShardState restoredClosedShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredClosedShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredClosedShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertTrue(restoredClosedShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(TEST_SEQUENCE_NUMBER, restoredClosedShardState.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard1 = fetcher.getSubscribedShardsState().get(1);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard1.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(1), restoredNewSplitShard1.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard1.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard1.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard2 = fetcher.getSubscribedShardsState().get(2);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard2.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(2), restoredNewSplitShard2.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard2.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard2.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","date":"2019-01-17 19:52:14","endLine":324,"groupId":"10550","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRestoreWithReshardedStream","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f3/6b661273a468f97bce5866df17a72f20c596f7.src","preCode":"\tpublic void testRestoreWithReshardedStream() throws Exception {\n\t\tfinal List<StreamShardHandle> initialDiscoveryShards = new ArrayList<>(TEST_STATE.size());\n\t\tfor (StreamShardMetadata shardMetadata : TEST_STATE.keySet()) {\n\t\t\t\r\n\t\t\tShard closedShard = new Shard();\n\t\t\tclosedShard.setShardId(shardMetadata.getShardId());\n\n\t\t\tSequenceNumberRange closedSequenceNumberRange = new SequenceNumberRange();\n\t\t\tclosedSequenceNumberRange.withStartingSequenceNumber(\"1\");\n\t\t\tclosedSequenceNumberRange.withEndingSequenceNumber(\"1087654321\"); \r\n\t\t\tclosedShard.setSequenceNumberRange(closedSequenceNumberRange);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), closedShard));\n\n\t\t\t\r\n\t\t\tShard newSplitShard1 = new Shard();\n\t\t\tnewSplitShard1.setShardId(KinesisShardIdGenerator.generateFromShardOrder(1));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange1 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange1.withStartingSequenceNumber(\"1087654322\");\n\t\t\tnewSplitShard1.setSequenceNumberRange(newSequenceNumberRange1);\n\n\t\t\tnewSplitShard1.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tShard newSplitShard2 = new Shard();\n\t\t\tnewSplitShard2.setShardId(KinesisShardIdGenerator.generateFromShardOrder(2));\n\n\t\t\tSequenceNumberRange newSequenceNumberRange2 = new SequenceNumberRange();\n\t\t\tnewSequenceNumberRange2.withStartingSequenceNumber(\"2087654322\");\n\t\t\tnewSplitShard2.setSequenceNumberRange(newSequenceNumberRange2);\n\n\t\t\tnewSplitShard2.setParentShardId(TEST_SHARD_ID);\n\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard1));\n\t\t\tinitialDiscoveryShards.add(new StreamShardHandle(shardMetadata.getStreamName(), newSplitShard2));\n\t\t}\n\n\t\tfinal TestFetcher<String> fetcher = new TestFetcher<>(\n\t\t\tCollections.singletonList(TEST_STREAM_NAME),\n\t\t\tnew TestSourceContext<>(),\n\t\t\tnew TestRuntimeContext(true, 1, 0),\n\t\t\tTestUtils.getStandardProperties(),\n\t\t\tnew KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()),\n\t\t\tnull,\n\t\t\tinitialDiscoveryShards);\n\n\t\tfinal DummyFlinkKinesisConsumer<String> consumerFunction = new DummyFlinkKinesisConsumer<>(\n\t\t\tfetcher, new KinesisDeserializationSchemaWrapper<>(new SimpleStringSchema()));\n\n\t\tStreamSource<String, DummyFlinkKinesisConsumer<String>> consumerOperator =\n\t\t\tnew StreamSource<>(consumerFunction);\n\n\t\tfinal AbstractStreamOperatorTestHarness<String> testHarness =\n\t\t\tnew AbstractStreamOperatorTestHarness<>(consumerOperator, 1, 1, 0);\n\n\t\ttestHarness.setup();\n\t\tMigrationTestUtil.restoreFromSnapshot(\n\t\t\ttestHarness,\n\t\t\t\"src/test/resources/kinesis-consumer-migration-test-flink\" + testMigrateVersion + \"-snapshot\", testMigrateVersion);\n\t\ttestHarness.open();\n\n\t\tconsumerFunction.run(new TestSourceContext<>());\n\n\t\t\r\n\t\tassertNotEquals(null, consumerFunction.getRestoredState());\n\t\tassertEquals(1, consumerFunction.getRestoredState().size());\n\t\tassertEquals(TEST_STATE, removeEquivalenceWrappers(consumerFunction.getRestoredState()));\n\n\t\t\r\n\t\tassertEquals(3, fetcher.getSubscribedShardsState().size());\n\n\t\tKinesisStreamShardState restoredClosedShardState = fetcher.getSubscribedShardsState().get(0);\n\t\tassertEquals(TEST_STREAM_NAME, restoredClosedShardState.getStreamShardHandle().getStreamName());\n\t\tassertEquals(TEST_SHARD_ID, restoredClosedShardState.getStreamShardHandle().getShard().getShardId());\n\t\tassertTrue(restoredClosedShardState.getStreamShardHandle().isClosed());\n\t\tassertEquals(TEST_SEQUENCE_NUMBER, restoredClosedShardState.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard1 = fetcher.getSubscribedShardsState().get(1);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard1.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(1), restoredNewSplitShard1.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard1.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard1.getLastProcessedSequenceNum());\n\n\t\tKinesisStreamShardState restoredNewSplitShard2 = fetcher.getSubscribedShardsState().get(2);\n\t\tassertEquals(TEST_STREAM_NAME, restoredNewSplitShard2.getStreamShardHandle().getStreamName());\n\t\tassertEquals(KinesisShardIdGenerator.generateFromShardOrder(2), restoredNewSplitShard2.getStreamShardHandle().getShard().getShardId());\n\t\tassertFalse(restoredNewSplitShard2.getStreamShardHandle().isClosed());\n\t\t\r\n\t\tassertEquals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get(), restoredNewSplitShard2.getLastProcessedSequenceNum());\n\n\t\tconsumerOperator.close();\n\t\tconsumerOperator.cancel();\n\t}\n","realPath":"flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisConsumerMigrationTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"}],"commitId":"b30adb0ce90d8f81f8028aeb5d541a3a67e6543d","commitMessage":"@@@[hotfix] [tests] Remove unfruitful MigrationTestUtil class\n\nThat utility class had a single helper method.  restoreFromSnapshot. \nwhich accepts the target snapshot's Flink version. This was useful\nbefore.  because the way to restore snapshots was a bit different for\nFlink <= 1.1 and newer versions.\n\nSince we now no longer support compatibility for 1.1 versions and\nbelow.  this helper method is simply forwarding the restore operation\nto the test harness.\n\nThis commit refactors this have equivalent behaviour directly in the\nAbstractStreamOperatorTestHarness class.\n","date":"2019-01-17 19:52:14","modifiedFileCount":"9","status":"M","submitter":"Tzu-Li (Gordon) Tai"}]
