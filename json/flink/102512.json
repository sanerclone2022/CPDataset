[{"authorTime":"2017-08-30 00:24:00","codes":[{"authorDate":"2017-08-30 00:24:00","commitOrder":21,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tstateSnapshot,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tnew UnregisteredTaskMetricsGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2017-12-13 00:01:14","endLine":279,"groupId":"43175","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ea/cded6dc5dcb02c4e5a676ad6b9ad12699c5ba9.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tstateSnapshot,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tnew UnregisteredTaskMetricsGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"MB"},{"authorDate":"2017-08-30 00:24:00","commitOrder":21,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tnew UnregisteredTaskMetricsGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2017-12-13 00:01:14","endLine":251,"groupId":"21484","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@AbstractStateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/1b95d47b5f99cb43f4fac004673623f17df2f2.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tnew UnregisteredTaskMetricsGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"MB"}],"commitId":"175e1b3871b13fee3e423aef87cb45ceed409783","commitMessage":"@@@[FLINK-7748][network] Properly use the TaskEventDispatcher for subscribing to events\n\nPreviously.  the ResultPartitionWriter implemented the EventListener interface\nand was used for event registration.  although event publishing was already\nhandled via the TaskEventDispatcher. Now.  we use the TaskEventDispatcher for\nboth.  event registration and publishing.\n\nIt also adds the TaskEventDispatcher to the Environment information for a task\nto be able to work with it (only IterationHeadTask so far).\n\nThis closes #4761.\n","date":"2017-12-13 00:01:14","modifiedFileCount":"19","status":"M","submitter":"Nico Kruber"},{"authorTime":"2017-12-06 21:39:15","codes":[{"authorDate":"2017-12-06 21:39:15","commitOrder":22,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tstateSnapshot,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2017-12-13 02:09:16","endLine":279,"groupId":"43175","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0a/f1471a09a20508267c8abc3420a6c6cf37a850.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tstateSnapshot,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tnew UnregisteredTaskMetricsGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"M"},{"authorDate":"2017-12-06 21:39:15","commitOrder":22,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2017-12-13 02:09:16","endLine":251,"groupId":"21484","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@AbstractStateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b1/127d5be07db2ae32f50092ccf4951b01251e56.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tnew UnregisteredTaskMetricsGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"M"}],"commitId":"0bf0fdc26ea86020929fa64d083dce02ba2a2ae2","commitMessage":"@@@[FLINK-8213][metrics] Improve fallback behaviors\n\nThis closes #8213.\n","date":"2017-12-13 02:09:16","modifiedFileCount":"50","status":"M","submitter":"zentol"},{"authorTime":"2017-12-06 21:39:15","codes":[{"authorDate":"2017-08-21 20:31:38","commitOrder":23,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\ttaskRestore,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2018-01-22 21:06:17","endLine":283,"groupId":"9133","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5f/faa29d976e0e7244a0a8c59c1cc1e83697da9f.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tstateSnapshot,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"M"},{"authorDate":"2017-12-06 21:39:15","commitOrder":23,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2017-12-13 02:09:16","endLine":251,"groupId":"21484","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@AbstractStateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b1/127d5be07db2ae32f50092ccf4951b01251e56.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":182,"status":"N"}],"commitId":"402a2e30c750e1bcb753643ed66c6df0dd861112","commitMessage":"@@@[FLINK-7719] [checkpoints] Send checkpoint id to task as part of deployment descriptor when resuming\n","date":"2018-01-22 21:06:17","modifiedFileCount":"15","status":"M","submitter":"Stefan Richter"},{"authorTime":"2017-09-27 21:10:52","codes":[{"authorDate":"2017-09-27 21:10:52","commitOrder":24,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2018-01-22 21:06:37","endLine":291,"groupId":"9133","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/49/9dfb1647fd2e34d38792110be757a145d58e36.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\ttaskRestore,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"},{"authorDate":"2017-09-27 21:10:52","commitOrder":24,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2018-01-22 21:06:37","endLine":252,"groupId":"51076","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@AbstractStateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/3da62163e64165fb9a90b8a8d1afe70be17866.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":183,"status":"M"}],"commitId":"517b3f87214168a445b5751cda210ecf3a292fd6","commitMessage":"@@@[FLINK-7720] [checkpoints] Centralize creation of backends and state related resources\n\nThis closes #4745.\n","date":"2018-01-22 21:06:37","modifiedFileCount":"69","status":"M","submitter":"Stefan Richter"},{"authorTime":"2018-01-11 00:14:06","codes":[{"authorDate":"2017-09-27 21:10:52","commitOrder":25,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2018-01-22 21:06:37","endLine":291,"groupId":"9133","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/49/9dfb1647fd2e34d38792110be757a145d58e36.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"N"},{"authorDate":"2018-01-11 00:14:06","commitOrder":25,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2018-02-01 20:54:55","endLine":256,"groupId":"51076","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/f33b7edd5d61b6e89e1ff97d41474083ef4c5a.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tAbstractStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"1887187f6b5c210d2091c69ef14fa8b8a5cae82c","commitMessage":"@@@[FLINK-8531] [checkpoints] (part 6) Tasks resolve CheckpointStreamFactory from CheckpointStorage and Checkpoint Location Reference to persist checkpoint data.\n","date":"2018-02-01 20:54:55","modifiedFileCount":"39","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2018-01-11 00:14:06","codes":[{"authorDate":"2018-02-06 21:44:01","commitOrder":26,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2018-02-25 22:14:21","endLine":293,"groupId":"24225","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/84/bcf5a690811f8aee335cc6ef99eb04983ec15c.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\toperatorStateBackend,\n\t\t\toperatorStateStream,\n\t\t\tkeyedStateFromBackend,\n\t\t\tkeyedStateFromStream);\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2018-01-11 00:14:06","commitOrder":26,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2018-02-01 20:54:55","endLine":256,"groupId":"51076","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/f33b7edd5d61b6e89e1ff97d41474083ef4c5a.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"N"}],"commitId":"df3e6bb7627db03635febd48eff4c10032b668ef","commitMessage":"@@@[FLINK-8360][checkpointing] Implement state storage for local recovery and integrate with task lifecycle\n","date":"2018-02-25 22:14:21","modifiedFileCount":"107","status":"M","submitter":"Stefan Richter"},{"authorTime":"2018-02-07 23:21:42","codes":[{"authorDate":"2018-02-07 23:21:42","commitOrder":27,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2018-05-04 15:56:44","endLine":294,"groupId":"24225","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/be/ed46df3995a8b5fc2bdd3bd7163baace9d4f78.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2018-02-07 23:21:42","commitOrder":27,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2018-05-04 15:56:44","endLine":259,"groupId":"51076","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d8/f577d69764daa2050648e2d7ac658b400fcbcc.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"}],"commitId":"e0146f8ac525e5e3e9e49fb590d5c149773efc9f","commitMessage":"@@@[FLINK-8620] Enable shipping custom files to BlobStore and accessing them through DistributedCache\n\nThis closes #5580\n","date":"2018-05-04 15:56:44","modifiedFileCount":"30","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2018-10-22 14:38:09","codes":[{"authorDate":"2018-10-22 14:38:09","commitOrder":28,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2018-10-22 19:28:29","endLine":294,"groupId":"24225","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d3/ef2b286b385d406730e350a140b1b2807f0d65.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2018-10-22 14:38:09","commitOrder":28,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2018-10-22 19:28:29","endLine":260,"groupId":"51076","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/51/c15afeca9e8ee239218b160c6252ebceead4fc.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tmock(ResultPartitionConsumableNotifier.class),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"7311f01e0ca89429016bddbe3daff16b6202fc6a","commitMessage":"@@@[FLINK-10607][network][test] Unify to remove duplicated NoOpResultPartitionConsumableNotifier\n","date":"2018-10-22 19:28:29","modifiedFileCount":"11","status":"M","submitter":"Zhijiang"},{"authorTime":"2019-02-17 09:28:53","codes":[{"authorDate":"2019-02-17 09:28:53","commitOrder":29,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-02-17 09:28:53","endLine":296,"groupId":"24225","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0c/31184691e9eade5245ee3a7ed866331771ee7f.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2019-02-17 09:28:53","commitOrder":29,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-02-17 09:28:53","endLine":262,"groupId":"51076","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/56/64a99ef02f866ddedadf6804fa9b3b0cb8eb63.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"}],"commitId":"32c822af7d8f600b24acafea78b2a3a9d19391b3","commitMessage":"@@@[FLINK-10887] [jobmaster] Add global aggregate tracking to the JobMaster (#7099)\n\nThis adds a JobMaster RPC endpoint that is used to share information across source subtasks.\n\nThis will be used implement things like event time source synchronization across sources.  This functionality can be accessed from user code via the StreamingRuntimeEnvironment.\n\n","date":"2019-02-17 09:28:53","modifiedFileCount":"23","status":"M","submitter":"Jamie Grier"},{"authorTime":"2019-03-29 17:04:24","codes":[{"authorDate":"2019-03-29 17:04:24","commitOrder":30,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-03-29 17:04:24","endLine":295,"groupId":"24225","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d8/0db71ed95b7694f0039d1d04185b01e4a7a06b.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class)))\n\t\t\t\t.thenReturn(mock(TaskKvStateRegistry.class));\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2019-03-29 17:04:24","commitOrder":30,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-03-29 17:04:24","endLine":266,"groupId":"0","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/eb/faac56797323b522e36749cdb447f6f47462bf.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class);\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"}],"commitId":"c4aa3ad5f706aedc12f884905a20d96de3977d31","commitMessage":"@@@[FLINK-11723][network] Remove KvState related components from NetworkEnvironment\n\n","date":"2019-03-29 17:04:24","modifiedFileCount":"14","status":"M","submitter":"zhijiang"},{"authorTime":"2019-04-03 23:45:01","codes":[{"authorDate":"2019-04-03 23:45:01","commitOrder":31,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-04-03 23:45:01","endLine":293,"groupId":"24225","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9e/1e793213994b72d69ee0975d886d91e24e4ec8.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\t\twhen(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2019-04-03 23:45:01","commitOrder":31,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-04-03 23:45:01","endLine":264,"groupId":"29720","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/67/338581947bc248b53748d9c0e8befea82b2179.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tTaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher();\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\t\twhen(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"}],"commitId":"d6be68670e661091d94a3c65a2704d52fc0e827c","commitMessage":"@@@[FLINK-12078][network] Abstract TaskEventPublisher interface for simplifying NetworkEnvironment\n\n","date":"2019-04-03 23:45:01","modifiedFileCount":"24","status":"M","submitter":"zhijiang"},{"authorTime":"2019-04-25 17:05:21","codes":[{"authorDate":"2019-04-25 17:05:21","commitOrder":32,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tNetworkEnvironment networkEnvironment = new NetworkEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-05-08 21:29:31","endLine":294,"groupId":"24225","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/b1047aa0dbad1d58afce028c71001df366122e.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tNetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class);\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2019-04-25 17:05:21","commitOrder":32,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tNetworkEnvironment network = new NetworkEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-05-08 21:29:31","endLine":265,"groupId":"29720","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/4c8aa3795ff7503f1295b66a1b6526c92b60a9.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tNetworkEnvironment network = mock(NetworkEnvironment.class);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"}],"commitId":"f392616f404a6471d99d64eeab5dd1dd3da1a4a0","commitMessage":"@@@[hotfix][tests] Avoid mock NetworkEnvironment in tests\n","date":"2019-05-08 21:29:31","modifiedFileCount":"9","status":"M","submitter":"Zhijiang"},{"authorTime":"2019-05-30 21:16:16","codes":[{"authorDate":"2019-05-30 21:16:16","commitOrder":33,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment shuffleEnvironment = new NetworkEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-06-11 18:03:41","endLine":294,"groupId":"24225","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e0/f3b52efeb797397979e69c9739e738db21304d.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tNetworkEnvironment networkEnvironment = new NetworkEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tnetworkEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2019-05-30 21:16:16","commitOrder":33,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NetworkEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-06-11 18:03:41","endLine":265,"groupId":"49253","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9f/91a0035198414fc168318721fc1ea89e8d54bb.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tNetworkEnvironment network = new NetworkEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tnetwork,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"}],"commitId":"6349db7df4576eaa637d449ee45d76d7232c48ca","commitMessage":"@@@[FLINK-11392][network] Introduce ShuffleEnvironment interface\n","date":"2019-06-11 18:03:41","modifiedFileCount":"26","status":"M","submitter":"Andrey Zagrebin"},{"authorTime":"2019-05-30 21:16:16","codes":[{"authorDate":"2019-05-30 21:16:16","commitOrder":34,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-06-11 18:03:41","endLine":294,"groupId":"24225","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/62/ab1d4fa86397dd013ff2465d35092e2a466334.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment shuffleEnvironment = new NetworkEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2019-05-30 21:16:16","commitOrder":34,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-06-11 18:03:41","endLine":265,"groupId":"49253","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/2ff99bab64b1f2d1f73ca893dac9eb129baacb.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NetworkEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"}],"commitId":"c104dafd26f32d939461cb880ddfc881a8d14d5f","commitMessage":"@@@[FLINK-11392][network] Rename NetworkEnviroment to NettyShuffleEnviroment\n\nThis closes #8608.\n","date":"2019-06-11 18:03:41","modifiedFileCount":"45","status":"M","submitter":"Andrey Zagrebin"},{"authorTime":"2019-05-30 21:16:16","codes":[{"authorDate":"2019-06-14 17:27:18","commitOrder":35,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-06-25 19:15:42","endLine":294,"groupId":"24225","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5d/a1250ccc540330821c0c9f38ea8a593b55642f.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2019-05-30 21:16:16","commitOrder":35,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-06-11 18:03:41","endLine":265,"groupId":"49253","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder@booleanfailOnCheckpointErrors)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/2ff99bab64b1f2d1f73ca893dac9eb129baacb.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"N"}],"commitId":"7cb42f40eff443b127fabcef5b92b663a1b8af89","commitMessage":"@@@[hotfix][network] Fix raw type usages\n","date":"2019-06-25 19:15:42","modifiedFileCount":"8","status":"M","submitter":"Chesnay Schepler"},{"authorTime":"2019-06-27 19:40:59","codes":[{"authorDate":"2019-06-14 17:27:18","commitOrder":36,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2019-06-25 19:15:42","endLine":294,"groupId":"24225","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5d/a1250ccc540330821c0c9f38ea8a593b55642f.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"N"},{"authorDate":"2019-06-27 19:40:59","commitOrder":36,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2019-06-27 19:40:59","endLine":233,"groupId":"49253","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/58/9b64c5f836f3d4213a8504aed0721df4f65721.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder,\n\t\tboolean failOnCheckpointErrors) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\t\texecutionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"b760d556ca3757f3d0d1b8c81e5182b1bcc3dba3","commitMessage":"@@@[FLINK-11662] Disable task to fail on checkpoint errors\n\nThis closes #8745.\n","date":"2019-06-27 19:40:59","modifiedFileCount":"13","status":"M","submitter":"Yun Tang"},{"authorTime":"2019-11-15 20:12:14","codes":[{"authorDate":"2019-11-15 20:12:14","commitOrder":37,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2020-02-14 16:07:42","endLine":296,"groupId":"24225","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a4/850110f94836aa05342369e52a441bfd72afe1.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"M"},{"authorDate":"2019-11-15 20:12:14","commitOrder":37,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2020-02-14 16:07:42","endLine":236,"groupId":"49253","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f8/7e0e493f4f1afcee5e5ec7aa9a51f724b31b60.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"M"}],"commitId":"41b6bfa62c61bfe758ce67b06cbf32b3cc937691","commitMessage":"@@@[FLINK-15099][runtime] Add Operator Coordinators and Events\n\nOperator Coordinators are instances that exist once per operator. While the operators run on the TaskManagers.  the\ncoordinator runs on the JobManager. The coordinator communicates via events with the operators.  typicalls to\nassign work.\n\nThe first user for those coordinators would be the new source interface.\nFurther users we envision are sinks (for coordinated commits of metadata).  or iterations (gather progress and\nsteer supersteps) as well as simple approximate alignments between streams (event time alignment).\n","date":"2020-02-14 16:07:42","modifiedFileCount":"38","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2020-04-29 21:37:27","codes":[{"authorDate":"2020-04-29 21:37:27","commitOrder":38,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tVoidPermanentBlobService.INSTANCE,\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2020-05-07 21:19:08","endLine":290,"groupId":"51742","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d0/66275a6f8c0963c4b0a249662b00434e24ca5f.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tblobService,\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2020-04-29 21:37:27","commitOrder":38,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE,\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2020-05-07 21:19:08","endLine":231,"groupId":"46520","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/04/7f9087f235adaaf59e9c3aa15bd367058f9187.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tBlobCacheService blobService =\n\t\t\tnew BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tblobService,\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tblobService.getPermanentBlobService(),\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tblobService.getPermanentBlobService()),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"M"}],"commitId":"11f5c7fafea649e429022576becb35f871471587","commitMessage":"@@@[FLINK-16408] Bind job blob lifecycle to JobTable.Job\n\nThe PermanentBlobCache#registerJob method registers the use of job-related Blobs. Similarly.  PermanentBlobCache#releaseJob will release all job-related blobs which makes them eligible for cleanup by the periodic clean up task.\n\nSince tasks belonging to the same job should be able to share blobs (e.g. jar blobs for the common user code class loader).  the PermanentBlobCache#registerJob and PermanentBlobCache#releaseJob should be bound to the job lifecycle instead of the Task lifecycle. This is what this commit achieves by moving the #registerJob and #releaseJob calls from the Task to the JobTable.Job. Whenever we create new JobTable.Job.  we will also call PermanentBlobCache#registerJob. We will only call PermanentBlobCache#releaseJob when we close JobTable.Job.\n","date":"2020-05-07 21:19:08","modifiedFileCount":"13","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2020-05-01 00:00:50","codes":[{"authorDate":"2020-05-01 00:00:50","commitOrder":39,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2020-05-07 21:20:54","endLine":286,"groupId":"51742","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/35/a49366aca97071e30bdbeb418616ff3a307d6c.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\tVoidPermanentBlobService.INSTANCE,\n\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\tnew String[0]),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2020-05-01 00:00:50","commitOrder":39,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2020-05-07 21:20:54","endLine":227,"groupId":"46520","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ad/b305471a5bd315dece12383067a75db715da12.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tnew BlobLibraryCacheManager(\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE,\n\t\t\t\t\tFlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,\n\t\t\t\t\tnew String[0]),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"M"}],"commitId":"7f503f21d27a31a02c7577fa3d39d27dc4e181c6","commitMessage":"@@@[FLINK-16408] Bind user code class loader to lifetime of Job on TaskExecutor\n\nThis commit binds the user code class loader to the lifetime of a JobTable.Job on the TaskExecutor. This means that the TaskExecutor will not release the user code class loader as long as it contains an allocated slot for the respective job. This will ensure that a TaskExecutor can reuse the user code class loader across failovers (task and JM failovers). By reusing user code class loaders Flink will avoid to reload classes and.  thus.  decrease the pressure it puts on the JVM's metaspace. This will significantly improve situations where a class leak exists because Flink won't deplete the JVM's metaspace under recoveries.\n\nIn order to achieve this.  the LibraryCacheManager has been changed. The LibraryCacheManager only supports to register a LibraryCacheManager.ClassLoaderLease for a given job. As long as there is a single valid ClassLoaderLease.  the LibraryCacheManager will not release the associated user code class loader. A LibraryCacheManger.ClassLoaderLease needs to be resolved in order to create and then obtain the user code class loader. This is done via LibraryCacheManager.ClassLoaderHandle#getOrResolveClassLoader. Upon calling this method the first time.  one specifies the set of jars and class paths the user code class loader should be started with. Every subsequent call to this method will ensure that the underlying class loader contains the set of specified jars and class paths. If this is not the case.  then this method will fail. Differently said.  the system only supports one user code class loader per job at the moment.\n\nOnce the owner of the LibraryCacheManager.ClassLoaderLease no longer needs the user code class loader.  it should call LibraryCacheManager.ClassLoaderLease#close in order to invalidate the lease. Once all leases for a given job are invalidate.  the LibraryCacheManager will release the underlying user code class loader.\n\nAt the moment.  there is only a single lease per job which is owned by the JobTable.Job and will be created when the JobTable.Job will be created. That way we ensure that the user code class loader lives as long as the JobTable.Job.\n\nIn order to ensure that we reuse the user code class loader as long as the TaskExecutor has allocated slots for a given job.  TaskExecutorSlotLifetimeTest#testUserCodeClassLoaderIsBoundToSlot has been added.\n","date":"2020-05-07 21:20:54","modifiedFileCount":"24","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2020-04-24 12:06:24","codes":[{"authorDate":"2020-04-24 12:06:24","commitOrder":40,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2020-05-17 23:33:04","endLine":288,"groupId":"51742","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d7/0092093607918060652ffc8f37ae65f17e2902.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2020-04-24 12:06:24","commitOrder":40,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2020-05-17 23:33:04","endLine":232,"groupId":"46520","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4d/8f3a7bc9e4116a0179d9f030eec626cdedd9e2.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"}],"commitId":"22112f12b07d20aed43705776cf93fbdc115ed23","commitMessage":"@@@[FLINK-17407] Instatiate and pass ExternalResourceInfoProvider to RuntimeContext\n","date":"2020-05-17 23:33:04","modifiedFileCount":"41","status":"M","submitter":"Yangze Guo"},{"authorTime":"2020-04-24 12:06:24","codes":[{"authorDate":"2020-10-22 06:30:26","commitOrder":41,"curCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = OperatorSubtaskState.builder()\n\t\t\t.setManagedOperatorState(new StateObjectCollection<>(operatorStateBackend))\n\t\t\t.setRawOperatorState(new StateObjectCollection<>(operatorStateStream))\n\t\t\t.setManagedKeyedState(new StateObjectCollection<>(keyedStateFromBackend))\n\t\t\t.setRawKeyedState(new StateObjectCollection<>(keyedStateFromStream))\n\t\t\t.build();\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","date":"2020-11-06 15:03:57","endLine":290,"groupId":"1202","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/61/50fad4937dcdbfbefc05ee122b5b3d8474ce73.src","preCode":"\tprivate static Task createTask(\n\t\t\tStreamConfig streamConfig,\n\t\t\tConfiguration taskConfig,\n\t\t\tStreamStateHandle state,\n\t\t\tint mode) throws IOException {\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\tCollection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n\t\tCollection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n\t\tCollection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n\t\tMap<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n\t\tOperatorStateHandle.StateMetaInfo metaInfo =\n\t\t\t\tnew OperatorStateHandle.StateMetaInfo(new long[]{0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n\t\toperatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n\t\tKeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n\t\tCollection<OperatorStateHandle> operatorStateHandles =\n\t\t\t\tCollections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n\t\tList<KeyedStateHandle> keyedStateHandles =\n\t\t\t\tCollections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n\t\tswitch (mode) {\n\t\t\tcase OPERATOR_MANAGED:\n\t\t\t\toperatorStateBackend = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase OPERATOR_RAW:\n\t\t\t\toperatorStateStream = operatorStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_MANAGED:\n\t\t\t\tkeyedStateFromBackend = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tcase KEYED_RAW:\n\t\t\t\tkeyedStateFromStream = keyedStateHandles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tOperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(\n\t\t\tnew StateObjectCollection<>(operatorStateBackend),\n\t\t\tnew StateObjectCollection<>(operatorStateStream),\n\t\t\tnew StateObjectCollection<>(keyedStateFromBackend),\n\t\t\tnew StateObjectCollection<>(keyedStateFromStream));\n\n\t\tJobVertexID jobVertexID = new JobVertexID();\n\t\tOperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n\t\tstreamConfig.setOperatorID(operatorID);\n\t\tTaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n\t\tstateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n\t\tJobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\tnew JobID(),\n\t\t\t\"test job name\",\n\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n\t\t\tnew Configuration(),\n\t\t\tCollections.emptyList(),\n\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\tjobVertexID,\n\t\t\t\"test task name\",\n\t\t\t1,\n\t\t\t1,\n\t\t\tSourceStreamTask.class.getName(),\n\t\t\ttaskConfig);\n\n\t\tTestTaskStateManager taskStateManager = new TestTaskStateManager();\n\t\ttaskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n\t\ttaskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n\t\t\tCollections.singletonMap(\n\t\t\t\ttaskRestore.getRestoreCheckpointId(),\n\t\t\t\ttaskRestore.getTaskStateSnapshot()));\n\n\t\treturn new Task(\n\t\t\tjobInformation,\n\t\t\ttaskInformation,\n\t\t\tnew ExecutionAttemptID(),\n\t\t\tnew AllocationID(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t0,\n\t\t\tmock(MemoryManager.class),\n\t\t\tmock(IOManager.class),\n\t\t\tshuffleEnvironment,\n\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\tmock(BroadcastVariableManager.class),\n\t\t\tnew TaskEventDispatcher(),\n\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n\t\t\ttaskStateManager,\n\t\t\tmock(TaskManagerActions.class),\n\t\t\tmock(InputSplitProvider.class),\n\t\t\tmock(CheckpointResponder.class),\n\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\tnew TestGlobalAggregateManager(),\n\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\tmock(Executor.class));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2020-04-24 12:06:24","commitOrder":41,"curCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","date":"2020-05-17 23:33:04","endLine":232,"groupId":"46520","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4d/8f3a7bc9e4116a0179d9f030eec626cdedd9e2.src","preCode":"\tprivate static Task createTask(\n\t\tStreamOperator<?> op,\n\t\tStateBackend backend,\n\t\tCheckpointResponder checkpointResponder) throws IOException {\n\n\t\tConfiguration taskConfig = new Configuration();\n\t\tStreamConfig cfg = new StreamConfig(taskConfig);\n\t\tcfg.setStreamOperator(op);\n\t\tcfg.setOperatorID(new OperatorID());\n\t\tcfg.setStateBackend(backend);\n\n\t\tExecutionConfig executionConfig = new ExecutionConfig();\n\n\t\tJobInformation jobInformation = new JobInformation(\n\t\t\t\tnew JobID(),\n\t\t\t\t\"test job name\",\n\t\t\t\tnew SerializedValue<>(executionConfig),\n\t\t\t\tnew Configuration(),\n\t\t\t\tCollections.emptyList(),\n\t\t\t\tCollections.emptyList());\n\n\t\tTaskInformation taskInformation = new TaskInformation(\n\t\t\t\tnew JobVertexID(),\n\t\t\t\t\"test task name\",\n\t\t\t\t1,\n\t\t\t\t11,\n\t\t\t\tTestStreamTask.class.getName(),\n\t\t\t\ttaskConfig);\n\n\t\tShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n\t\treturn new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\tnew ExecutionAttemptID(),\n\t\t\t\tnew AllocationID(),\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tCollections.<ResultPartitionDeploymentDescriptor>emptyList(),\n\t\t\t\tCollections.<InputGateDeploymentDescriptor>emptyList(),\n\t\t\t\t0,\n\t\t\t\tmock(MemoryManager.class),\n\t\t\t\tmock(IOManager.class),\n\t\t\t\tshuffleEnvironment,\n\t\t\t\tnew KvStateService(new KvStateRegistry(), null, null),\n\t\t\t\tmock(BroadcastVariableManager.class),\n\t\t\t\tnew TaskEventDispatcher(),\n\t\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n\t\t\t\tnew TestTaskStateManager(),\n\t\t\t\tmock(TaskManagerActions.class),\n\t\t\t\tmock(InputSplitProvider.class),\n\t\t\t\tcheckpointResponder,\n\t\t\t\tnew NoOpTaskOperatorEventGateway(),\n\t\t\t\tnew TestGlobalAggregateManager(),\n\t\t\t\tTestingClassLoaderLease.newBuilder().build(),\n\t\t\t\tnew FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() },\n\t\t\t\t\tVoidPermanentBlobService.INSTANCE),\n\t\t\t\tnew TestingTaskManagerRuntimeInfo(),\n\t\t\t\tUnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n\t\t\t\tnew NoOpResultPartitionConsumableNotifier(),\n\t\t\t\tmock(PartitionProducerStateChecker.class),\n\t\t\t\tExecutors.directExecutor());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"N"}],"commitId":"32a2dedba276fcc270b236ea8343746c5b733a44","commitMessage":"@@@[FLINK-19533][checkpoint] Introduce builder for OperatorSubtaskState.\n\nThe builder will make it easier to add more fields to OperatorSubtaskState in future commits.\n","date":"2020-11-06 15:03:57","modifiedFileCount":"38","status":"M","submitter":"Arvid Heise"},{"authorTime":"2021-02-08 18:39:08","codes":[{"authorDate":"2021-02-08 18:39:08","commitOrder":42,"curCode":"    private static Task createTask(\n            StreamConfig streamConfig, Configuration taskConfig, StreamStateHandle state, int mode)\n            throws IOException {\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        Collection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n        Collection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n        Map<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n        OperatorStateHandle.StateMetaInfo metaInfo =\n                new OperatorStateHandle.StateMetaInfo(\n                        new long[] {0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n        operatorStateMetadata.put(\n                DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n        KeyGroupRangeOffsets keyGroupRangeOffsets =\n                new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n        Collection<OperatorStateHandle> operatorStateHandles =\n                Collections.singletonList(\n                        new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n        List<KeyedStateHandle> keyedStateHandles =\n                Collections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n        switch (mode) {\n            case OPERATOR_MANAGED:\n                operatorStateBackend = operatorStateHandles;\n                break;\n            case OPERATOR_RAW:\n                operatorStateStream = operatorStateHandles;\n                break;\n            case KEYED_MANAGED:\n                keyedStateFromBackend = keyedStateHandles;\n                break;\n            case KEYED_RAW:\n                keyedStateFromStream = keyedStateHandles;\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(new StateObjectCollection<>(operatorStateBackend))\n                        .setRawOperatorState(new StateObjectCollection<>(operatorStateStream))\n                        .setManagedKeyedState(new StateObjectCollection<>(keyedStateFromBackend))\n                        .setRawKeyedState(new StateObjectCollection<>(keyedStateFromStream))\n                        .build();\n\n        JobVertexID jobVertexID = new JobVertexID();\n        OperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n        streamConfig.setOperatorID(operatorID);\n        TaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n        stateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(new ExecutionConfig()),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        jobVertexID,\n                        \"test task name\",\n                        1,\n                        1,\n                        SourceStreamTask.class.getName(),\n                        taskConfig);\n\n        TestTaskStateManager taskStateManager = new TestTaskStateManager();\n        taskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n        taskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n                Collections.singletonMap(\n                        taskRestore.getRestoreCheckpointId(), taskRestore.getTaskStateSnapshot()));\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                taskStateManager,\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                mock(CheckpointResponder.class),\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                mock(Executor.class));\n    }\n","date":"2021-02-08 18:39:08","endLine":294,"groupId":"1202","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c8/8229e221d646ef049d328f042ed5ccffb3e086.src","preCode":"    private static Task createTask(\n            StreamConfig streamConfig, Configuration taskConfig, StreamStateHandle state, int mode)\n            throws IOException {\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        Collection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n        Collection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n        Map<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n        OperatorStateHandle.StateMetaInfo metaInfo =\n                new OperatorStateHandle.StateMetaInfo(\n                        new long[] {0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n        operatorStateMetadata.put(\n                DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n        KeyGroupRangeOffsets keyGroupRangeOffsets =\n                new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n        Collection<OperatorStateHandle> operatorStateHandles =\n                Collections.singletonList(\n                        new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n        List<KeyedStateHandle> keyedStateHandles =\n                Collections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n        switch (mode) {\n            case OPERATOR_MANAGED:\n                operatorStateBackend = operatorStateHandles;\n                break;\n            case OPERATOR_RAW:\n                operatorStateStream = operatorStateHandles;\n                break;\n            case KEYED_MANAGED:\n                keyedStateFromBackend = keyedStateHandles;\n                break;\n            case KEYED_RAW:\n                keyedStateFromStream = keyedStateHandles;\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(new StateObjectCollection<>(operatorStateBackend))\n                        .setRawOperatorState(new StateObjectCollection<>(operatorStateStream))\n                        .setManagedKeyedState(new StateObjectCollection<>(keyedStateFromBackend))\n                        .setRawKeyedState(new StateObjectCollection<>(keyedStateFromStream))\n                        .build();\n\n        JobVertexID jobVertexID = new JobVertexID();\n        OperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n        streamConfig.setOperatorID(operatorID);\n        TaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n        stateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(new ExecutionConfig()),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        jobVertexID,\n                        \"test task name\",\n                        1,\n                        1,\n                        SourceStreamTask.class.getName(),\n                        taskConfig);\n\n        TestTaskStateManager taskStateManager = new TestTaskStateManager();\n        taskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n        taskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n                Collections.singletonMap(\n                        taskRestore.getRestoreCheckpointId(), taskRestore.getTaskStateSnapshot()));\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                0,\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                taskStateManager,\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                mock(CheckpointResponder.class),\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                mock(Executor.class));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2021-02-08 18:39:08","commitOrder":42,"curCode":"    private static Task createTask(\n            StreamOperator<?> op, StateBackend backend, CheckpointResponder checkpointResponder)\n            throws IOException {\n\n        Configuration taskConfig = new Configuration();\n        StreamConfig cfg = new StreamConfig(taskConfig);\n        cfg.setStreamOperator(op);\n        cfg.setOperatorID(new OperatorID());\n        cfg.setStateBackend(backend);\n\n        ExecutionConfig executionConfig = new ExecutionConfig();\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(executionConfig),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        new JobVertexID(),\n                        \"test task name\",\n                        1,\n                        11,\n                        TestStreamTask.class.getName(),\n                        taskConfig);\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                new TestTaskStateManager(),\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                checkpointResponder,\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                Executors.directExecutor());\n    }\n","date":"2021-02-08 18:39:08","endLine":247,"groupId":"49516","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/01/d53b13afe8f5e67102a768b018af6faea79c8d.src","preCode":"    private static Task createTask(\n            StreamOperator<?> op, StateBackend backend, CheckpointResponder checkpointResponder)\n            throws IOException {\n\n        Configuration taskConfig = new Configuration();\n        StreamConfig cfg = new StreamConfig(taskConfig);\n        cfg.setStreamOperator(op);\n        cfg.setOperatorID(new OperatorID());\n        cfg.setStateBackend(backend);\n\n        ExecutionConfig executionConfig = new ExecutionConfig();\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(executionConfig),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        new JobVertexID(),\n                        \"test task name\",\n                        1,\n                        11,\n                        TestStreamTask.class.getName(),\n                        taskConfig);\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                0,\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                new TestTaskStateManager(),\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                checkpointResponder,\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                Executors.directExecutor());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":184,"status":"M"}],"commitId":"7ea786ac6af7286eb147449729316418b38cdafe","commitMessage":"@@@[FLINK-21303][coordination] Remove LogicalSlot#getPhysicalSlotNumber\n\n","date":"2021-02-08 18:39:08","modifiedFileCount":"25","status":"M","submitter":"SteNicholas"},{"authorTime":"2021-02-08 18:39:08","codes":[{"authorDate":"2021-07-13 00:15:01","commitOrder":43,"curCode":"    private static Task createTask(\n            StreamConfig streamConfig, Configuration taskConfig, StreamStateHandle state, int mode)\n            throws IOException {\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        Collection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n        Collection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n        Map<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n        OperatorStateHandle.StateMetaInfo metaInfo =\n                new OperatorStateHandle.StateMetaInfo(\n                        new long[] {0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n        operatorStateMetadata.put(\n                DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n        KeyGroupRangeOffsets keyGroupRangeOffsets =\n                new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n        Collection<OperatorStateHandle> operatorStateHandles =\n                Collections.singletonList(\n                        new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n        List<KeyedStateHandle> keyedStateHandles =\n                Collections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n        switch (mode) {\n            case OPERATOR_MANAGED:\n                operatorStateBackend = operatorStateHandles;\n                break;\n            case OPERATOR_RAW:\n                operatorStateStream = operatorStateHandles;\n                break;\n            case KEYED_MANAGED:\n                keyedStateFromBackend = keyedStateHandles;\n                break;\n            case KEYED_RAW:\n                keyedStateFromStream = keyedStateHandles;\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(new StateObjectCollection<>(operatorStateBackend))\n                        .setRawOperatorState(new StateObjectCollection<>(operatorStateStream))\n                        .setManagedKeyedState(new StateObjectCollection<>(keyedStateFromBackend))\n                        .setRawKeyedState(new StateObjectCollection<>(keyedStateFromStream))\n                        .build();\n\n        JobVertexID jobVertexID = new JobVertexID();\n        OperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n        streamConfig.setOperatorID(operatorID);\n        TaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n        stateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(new ExecutionConfig()),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        jobVertexID,\n                        \"test task name\",\n                        1,\n                        1,\n                        SourceStreamTask.class.getName(),\n                        taskConfig);\n\n        TestTaskStateManager taskStateManager =\n                TestTaskStateManager.builder()\n                        .setReportedCheckpointId(taskRestore.getRestoreCheckpointId())\n                        .setJobManagerTaskStateSnapshotsByCheckpointId(\n                                Collections.singletonMap(\n                                        taskRestore.getRestoreCheckpointId(),\n                                        taskRestore.getTaskStateSnapshot()))\n                        .build();\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                taskStateManager,\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                mock(CheckpointResponder.class),\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                mock(Executor.class));\n    }\n","date":"2021-07-28 19:06:56","endLine":297,"groupId":"102512","id":45,"instanceNumber":1,"isCurCommit":1,"methodName":"createTask","params":"(StreamConfigstreamConfig@ConfigurationtaskConfig@StreamStateHandlestate@intmode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/97/6a07e78c152e0bf8b383fd30a4de5e2db5f8d2.src","preCode":"    private static Task createTask(\n            StreamConfig streamConfig, Configuration taskConfig, StreamStateHandle state, int mode)\n            throws IOException {\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        Collection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList();\n        Collection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateBackend = Collections.emptyList();\n        Collection<OperatorStateHandle> operatorStateStream = Collections.emptyList();\n\n        Map<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1);\n        OperatorStateHandle.StateMetaInfo metaInfo =\n                new OperatorStateHandle.StateMetaInfo(\n                        new long[] {0}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE);\n        operatorStateMetadata.put(\n                DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo);\n\n        KeyGroupRangeOffsets keyGroupRangeOffsets =\n                new KeyGroupRangeOffsets(new KeyGroupRange(0, 0));\n\n        Collection<OperatorStateHandle> operatorStateHandles =\n                Collections.singletonList(\n                        new OperatorStreamStateHandle(operatorStateMetadata, state));\n\n        List<KeyedStateHandle> keyedStateHandles =\n                Collections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state));\n\n        switch (mode) {\n            case OPERATOR_MANAGED:\n                operatorStateBackend = operatorStateHandles;\n                break;\n            case OPERATOR_RAW:\n                operatorStateStream = operatorStateHandles;\n                break;\n            case KEYED_MANAGED:\n                keyedStateFromBackend = keyedStateHandles;\n                break;\n            case KEYED_RAW:\n                keyedStateFromStream = keyedStateHandles;\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n\n        OperatorSubtaskState operatorSubtaskState =\n                OperatorSubtaskState.builder()\n                        .setManagedOperatorState(new StateObjectCollection<>(operatorStateBackend))\n                        .setRawOperatorState(new StateObjectCollection<>(operatorStateStream))\n                        .setManagedKeyedState(new StateObjectCollection<>(keyedStateFromBackend))\n                        .setRawKeyedState(new StateObjectCollection<>(keyedStateFromStream))\n                        .build();\n\n        JobVertexID jobVertexID = new JobVertexID();\n        OperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID);\n        streamConfig.setOperatorID(operatorID);\n        TaskStateSnapshot stateSnapshot = new TaskStateSnapshot();\n        stateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState);\n\n        JobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot);\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(new ExecutionConfig()),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        jobVertexID,\n                        \"test task name\",\n                        1,\n                        1,\n                        SourceStreamTask.class.getName(),\n                        taskConfig);\n\n        TestTaskStateManager taskStateManager = new TestTaskStateManager();\n        taskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId());\n        taskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(\n                Collections.singletonMap(\n                        taskRestore.getRestoreCheckpointId(), taskRestore.getTaskStateSnapshot()));\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                taskStateManager,\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                mock(CheckpointResponder.class),\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                mock(Executor.class));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2021-02-08 18:39:08","commitOrder":43,"curCode":"    private static Task createTask(\n            StreamOperator<?> op, StateBackend backend, CheckpointResponder checkpointResponder)\n            throws IOException {\n\n        Configuration taskConfig = new Configuration();\n        StreamConfig cfg = new StreamConfig(taskConfig);\n        cfg.setStreamOperator(op);\n        cfg.setOperatorID(new OperatorID());\n        cfg.setStateBackend(backend);\n\n        ExecutionConfig executionConfig = new ExecutionConfig();\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(executionConfig),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        new JobVertexID(),\n                        \"test task name\",\n                        1,\n                        11,\n                        TestStreamTask.class.getName(),\n                        taskConfig);\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                new TestTaskStateManager(),\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                checkpointResponder,\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                Executors.directExecutor());\n    }\n","date":"2021-02-08 18:39:08","endLine":247,"groupId":"102512","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"createTask","params":"(StreamOperator<?>op@StateBackendbackend@CheckpointRespondercheckpointResponder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/01/d53b13afe8f5e67102a768b018af6faea79c8d.src","preCode":"    private static Task createTask(\n            StreamOperator<?> op, StateBackend backend, CheckpointResponder checkpointResponder)\n            throws IOException {\n\n        Configuration taskConfig = new Configuration();\n        StreamConfig cfg = new StreamConfig(taskConfig);\n        cfg.setStreamOperator(op);\n        cfg.setOperatorID(new OperatorID());\n        cfg.setStateBackend(backend);\n\n        ExecutionConfig executionConfig = new ExecutionConfig();\n\n        JobInformation jobInformation =\n                new JobInformation(\n                        new JobID(),\n                        \"test job name\",\n                        new SerializedValue<>(executionConfig),\n                        new Configuration(),\n                        Collections.emptyList(),\n                        Collections.emptyList());\n\n        TaskInformation taskInformation =\n                new TaskInformation(\n                        new JobVertexID(),\n                        \"test task name\",\n                        1,\n                        11,\n                        TestStreamTask.class.getName(),\n                        taskConfig);\n\n        ShuffleEnvironment<?, ?> shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();\n\n        return new Task(\n                jobInformation,\n                taskInformation,\n                new ExecutionAttemptID(),\n                new AllocationID(),\n                0,\n                0,\n                Collections.<ResultPartitionDeploymentDescriptor>emptyList(),\n                Collections.<InputGateDeploymentDescriptor>emptyList(),\n                mock(MemoryManager.class),\n                mock(IOManager.class),\n                shuffleEnvironment,\n                new KvStateService(new KvStateRegistry(), null, null),\n                mock(BroadcastVariableManager.class),\n                new TaskEventDispatcher(),\n                ExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n                new TestTaskStateManager(),\n                mock(TaskManagerActions.class),\n                mock(InputSplitProvider.class),\n                checkpointResponder,\n                new NoOpTaskOperatorEventGateway(),\n                new TestGlobalAggregateManager(),\n                TestingClassLoaderLease.newBuilder().build(),\n                new FileCache(\n                        new String[] {EnvironmentInformation.getTemporaryFileDirectory()},\n                        VoidPermanentBlobService.INSTANCE),\n                new TestingTaskManagerRuntimeInfo(),\n                UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                new NoOpResultPartitionConsumableNotifier(),\n                mock(PartitionProducerStateChecker.class),\n                Executors.directExecutor());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":184,"status":"N"}],"commitId":"e653487c2b33c3abfc2d5130522f87f99b7a857c","commitMessage":"@@@[hotfix][tests] Introduce TestTaskStateManagerBuilder\n\nMotivation: allow to customize StateChangelogStorageFactory\nwithout resorting to mutable state.\n","date":"2021-07-28 19:06:56","modifiedFileCount":"10","status":"M","submitter":"Roman Khachatryan"}]
