[{"authorTime":"2016-07-18 17:37:06","codes":[{"authorDate":"2016-06-27 19:56:27","commitOrder":3,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-06-27 23:16:12","endLine":993,"groupId":"36061","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8b/a6da2719624c02e200afe1c4624b14a2e89e35.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":935,"status":"NB"},{"authorDate":"2016-07-18 17:37:06","commitOrder":3,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2016-07-27 03:12:05","endLine":2112,"groupId":"36069","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/62/266c432742594aedef6440ff50d2c2c4203be6.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2066,"status":"B"}],"commitId":"12bf7c1a0b81d199085fe874c64763c51a93b3bf","commitMessage":"@@@[FLINK-4207] WindowOperator becomes very slow with allowed lateness\n","date":"2016-07-27 03:12:05","modifiedFileCount":"16","status":"M","submitter":"kl0u"},{"authorTime":"2016-08-11 00:44:50","codes":[{"authorDate":"2016-08-11 00:44:50","commitOrder":4,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-09-01 01:10:01","endLine":999,"groupId":"36061","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/67/a6f556796c5e88af3f93de8d4445e42b02169d.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":943,"status":"M"},{"authorDate":"2016-08-11 00:44:50","commitOrder":4,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2016-09-01 01:10:01","endLine":2085,"groupId":"23886","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/67/a6f556796c5e88af3f93de8d4445e42b02169d.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2041,"status":"M"}],"commitId":"4809f5367b08a9734fc1bd4875be51a9f3bb65aa","commitMessage":"@@@[FLINK-3761] Refactor State Backends/Make Keyed State Key-Group Aware\n\nThe biggest change in this is that functionality that used to be in\nAbstractStateBackend is now moved to CheckpointStreamFactory and\nKeyedStateBackend. The former is responsible for providing streams that\ncan be used to checkpoint data while the latter is responsible for\nkeeping keyed state. A keyed backend can checkpoint the state that it\nkeeps by using a CheckpointStreamFactory.\n\nThis also refactors how asynchronous keyed state snapshots work. They\nare not implemented using a Future/RunnableFuture.\n\nAlso.  this changes the keyed state backends to be key-group aware and to\nsnapshot the state in key-groups with an index for restoring.\n","date":"2016-09-01 01:10:01","modifiedFileCount":"100","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-10-05 05:49:54","commitOrder":5,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":971,"groupId":"30562","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\t\toperator.setInputType(TypeInfoParser.<Tuple2<String, Integer>>parse(\"Tuple2<String, Integer>\"), new ExecutionConfig());\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":916,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":5,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":2036,"groupId":"32611","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1993,"status":"M"}],"commitId":"1cd8d4f418a707790c091fed2428627eae9da423","commitMessage":"@@@[hotfix] [streaming api] Remove obsolete and unused InputTypeSerializer from WindowOperator\n","date":"2016-10-06 02:04:34","modifiedFileCount":"4","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-09-26 02:58:16","commitOrder":6,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestProcessingTimeService testTimeProvider = new TestProcessingTimeService();\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-22 01:03:04","endLine":966,"groupId":"0","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/38/f077894a7c8e13d085b7916dc63d9f9100e6ca.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestTimeServiceProvider testTimeProvider = new TestTimeServiceProvider();\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":911,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":6,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":2036,"groupId":"32611","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1993,"status":"N"}],"commitId":"e112a63208006b4e348d75f3df84d2fd4b091797","commitMessage":"@@@[FLINK-4877] Rename TimeServiceProvider to ProcessingTimeService\n\nThe name is clashing with the soon-to-be-added\nTimerService/InternalTimerService which is meant as an interface for\ndealing with both processing time and event time.\n\nTimeServiceProvider is renamed to ProcessingTimeService to reflect the\nfact that it is a low-level utility that only deals with \"physical\"\nprocessing-time trigger tasks.\n","date":"2016-10-22 01:03:04","modifiedFileCount":"29","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-09-28 22:43:40","commitOrder":7,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-22 01:03:04","endLine":898,"groupId":"38889","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b8/a764ef999e1f9a5b24622df721608984f1c2d8.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tTestProcessingTimeService testTimeProvider = new TestProcessingTimeService();\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), testTimeProvider, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestTimeProvider.setCurrentTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestTimeProvider.setCurrentTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":845,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":7,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":2036,"groupId":"32611","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1993,"status":"N"}],"commitId":"30554758897842ad851dc9b6e1758d452f7d702f","commitMessage":"@@@[FLINK-4877] Refactor OperatorTestHarness to always use TestProcessingTimeService\n\nBefore.  this would allow handing in a custom ProcessingTimeService but\nthis was in reality always TestProcessingTimeService.\n","date":"2016-10-22 01:03:04","modifiedFileCount":"9","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-10-26 18:19:25","commitOrder":8,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-27 05:26:28","endLine":969,"groupId":"38889","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e5/a5e216386159c1a6fc942df1e4acf8ac7f64b0.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new ExecutionConfig(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":916,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":8,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":2036,"groupId":"32611","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cd/a6524b4be41e76bc2250e273e2598685f8f6ee.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1993,"status":"N"}],"commitId":"fe1654c680cad692e19ce262c402fd9756e8602a","commitMessage":"@@@[FLINK-4924] Simplify Operator Test Harness Constructors\n","date":"2016-10-27 05:26:28","modifiedFileCount":"19","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-01-13 22:17:09","codes":[{"authorDate":"2016-10-26 18:19:25","commitOrder":9,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-27 05:26:28","endLine":969,"groupId":"38889","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e5/a5e216386159c1a6fc942df1e4acf8ac7f64b0.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":916,"status":"N"},{"authorDate":"2017-01-13 22:17:09","commitOrder":9,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2017-01-23 04:53:39","endLine":2032,"groupId":"38889","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2f/aa506e95bc097a8c6bad4fa787b3a2cdd9b91d.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO); ;\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1989,"status":"M"}],"commitId":"3b97128f05bacfb80afe4a2a49741c31ff306cd2","commitMessage":"@@@[FLINK-5590] [runtime] Add proper internal state hierarchy\n\nThis introduces an internal state hierarchy that mirrors the external state hierarchy. \nbut gives the runtime access to methods that should not be part of the user facing API. \nsuch as:\n  - setting namespaces\n  - accessing raw values\n  - merging namespaces\n","date":"2017-01-23 04:53:39","modifiedFileCount":"38","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2017-03-01 22:36:17","commitOrder":10,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":1135,"groupId":"38889","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/8cb2e5ab2d2a952536d4a8fcb6d0fb155beb81.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(), 0);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1080,"status":"M"},{"authorDate":"2017-03-01 22:36:17","commitOrder":10,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":2253,"groupId":"38889","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/8cb2e5ab2d2a952536d4a8fcb6d0fb155beb81.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS);\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2209,"status":"M"}],"commitId":"07a15d0e1647c79ae010ca6df5b1830a4087dd56","commitMessage":"@@@[FLINK-4460] Provide late-data output for window operations\n\nWe use side outputs to emit dropped late data.\n","date":"2017-03-18 14:44:17","modifiedFileCount":"8","status":"M","submitter":"Chen Qin"},{"authorTime":"2017-05-17 20:01:04","codes":[{"authorDate":"2017-05-17 20:01:04","commitOrder":11,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-05-23 04:22:24","endLine":1094,"groupId":"38889","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/c6c6f9aeb78646d1c634a18d5b21eaf608a346.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int WINDOW_SIZE = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1039,"status":"M"},{"authorDate":"2017-05-17 20:01:04","commitOrder":11,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int windowSize = 2;\n\t\tfinal long lateness = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2017-05-23 04:22:24","endLine":2214,"groupId":"38889","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/42/c6c6f9aeb78646d1c634a18d5b21eaf608a346.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int WINDOW_SIZE = 2;\n\t\tfinal long LATENESS = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tLATENESS,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2170,"status":"M"}],"commitId":"12b4185c6c09101b64e12a84c33dc4d28f95cff9","commitMessage":"@@@[FLINK-6603] [streaming] Enable checkstyle on test sources\n\nUpdates / reverts the import order by sections:\n- org.apache.flink.*\n- all other imports\n- javax.*\n- java.*\n- static imports\n\nAdds EmptyLineSeparator to enforce an extra newline (not enforced\nbetween field or local variable declarations).\n\nThis closes #3941\n","date":"2017-05-23 04:22:24","modifiedFileCount":"395","status":"M","submitter":"Greg Hogan"},{"authorTime":"2017-12-20 19:27:56","codes":[{"authorDate":"2017-12-20 19:27:56","commitOrder":12,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":1117,"groupId":"38889","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1062,"status":"M"},{"authorDate":"2017-12-20 19:27:56","commitOrder":12,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int windowSize = 2;\n\t\tfinal long lateness = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2018-01-06 12:30:12","endLine":2237,"groupId":"38889","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c0/3207e7f1634926b7c5327931ad5fb6f82d91d2.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int windowSize = 2;\n\t\tfinal long lateness = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2193,"status":"M"}],"commitId":"091a37052b7045b3ed28c68bfea109024a5d1871","commitMessage":"@@@[FLINK-8298][tests] Properly shutdown MockEnvironment to release resources\n\nThis closes #5193.\n","date":"2018-01-06 12:30:12","modifiedFileCount":"9","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2018-05-04 23:15:51","codes":[{"authorDate":"2018-05-04 23:15:51","commitOrder":13,"curCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int windowSize = 3;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-05-05 00:48:16","endLine":1090,"groupId":"102608","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testProcessingTimeTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4c/28e4057503dad900453e1a33a86d3f5303b660.src","preCode":"\tpublic void testProcessingTimeTumblingWindows() throws Throwable {\n\t\tfinal int windowSize = 3;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\t\tnew SumReducer(),\n\t\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(\n\t\t\t\tTumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tProcessingTimeTrigger.create(),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tcreateTestHarness(operator);\n\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\ttestHarness.setProcessingTime(3);\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), Long.MAX_VALUE));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 7000));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(5000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 3), 2999));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), 2999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), 7000));\n\n\t\ttestHarness.setProcessingTime(7000);\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 3), 5999));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1037,"status":"M"},{"authorDate":"2018-05-04 23:15:51","commitOrder":13,"curCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int windowSize = 2;\n\t\tfinal long lateness = 1;\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tSTRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","date":"2018-05-05 00:48:16","endLine":2347,"groupId":"102608","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testCleanupTimerWithEmptyReduceStateForTumblingWindows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4c/28e4057503dad900453e1a33a86d3f5303b660.src","preCode":"\tpublic void testCleanupTimerWithEmptyReduceStateForTumblingWindows() throws Exception {\n\t\tfinal int windowSize = 2;\n\t\tfinal long lateness = 1;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\tReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>(\"window-contents\",\n\t\t\tnew SumReducer(),\n\t\t\tinputType.createSerializer(new ExecutionConfig()));\n\n\t\tWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator =\n\t\t\tnew WindowOperator<>(\n\t\t\t\tTumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)),\n\t\t\t\tnew TimeWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()),\n\t\t\t\tEventTimeTrigger.create(),\n\t\t\t\tlateness,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tcreateTestHarness(operator);\n\n\t\ttestHarness.open();\n\n\t\tConcurrentLinkedQueue<Object> expected = new ConcurrentLinkedQueue<>();\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1000));\n\t\ttestHarness.processWatermark(new Watermark(1599));\n\t\ttestHarness.processWatermark(new Watermark(1999));\n\t\ttestHarness.processWatermark(new Watermark(2000));\n\t\ttestHarness.processWatermark(new Watermark(5000));\n\n\t\texpected.add(new Watermark(1599));\n\t\texpected.add(new StreamRecord<>(new Tuple2<>(\"key2\", 1), 1999));\n\t\texpected.add(new Watermark(1999)); \r\n\t\texpected.add(new Watermark(2000)); \r\n\t\texpected.add(new Watermark(5000));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expected, testHarness.getOutput(), new Tuple2ResultSortComparator());\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":2305,"status":"M"}],"commitId":"c8fa8d025684c2225824c54a7285bbfdec7cfddc","commitMessage":"@@@[FLINK-9292] [core] Remove TypeInfoParser (part 1)\n","date":"2018-05-05 00:48:16","modifiedFileCount":"26","status":"M","submitter":"Stephan Ewen"}]
