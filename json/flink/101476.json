[{"authorTime":"2016-06-11 08:14:07","codes":[{"authorDate":"2016-06-11 08:14:07","commitOrder":1,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2016-07-05 21:51:06","endLine":551,"groupId":"35083","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/9c140cdf7d2a582682abc077338a1342c3c192.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":499,"status":"B"},{"authorDate":"2016-06-11 08:14:07","commitOrder":1,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\t\t\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2016-07-05 21:51:06","endLine":610,"groupId":"35083","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/9c140cdf7d2a582682abc077338a1342c3c192.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\t\t\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":559,"status":"B"}],"commitId":"b9f42e91c9415dd6063079df00c142334b74e636","commitMessage":"@@@[FLINK-3995] [build] flink-test-utils also contains the streaming test utilities.\n\nTest utilities include the StreamingMultipleProgramsTestBase and StreamingTestEnvironment.\n\nThis moves the ITCases for streaming into 'flink-tests' to achieve that.\n\nThis closes #2092\n","date":"2016-07-05 21:51:06","modifiedFileCount":"12","status":"B","submitter":"Stephan Ewen"},{"authorTime":"2017-03-17 00:03:03","codes":[{"authorDate":"2017-03-17 00:03:03","commitOrder":2,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2017-05-05 17:06:07","endLine":554,"groupId":"35083","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/686ef9bf50b05bc7903d837cf49625258932f9.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":502,"status":"M"},{"authorDate":"2017-03-17 00:03:03","commitOrder":2,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\t\t\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2017-05-05 17:06:07","endLine":613,"groupId":"35083","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/686ef9bf50b05bc7903d837cf49625258932f9.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\t\t\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":562,"status":"M"}],"commitId":"ddd6a99a95b56c52ea5b5153b7270b578f5479bc","commitMessage":"@@@[FLINK-6078] Remove CuratorFramework#close calls from ZooKeeper based HA services\n\nRemove client less factory methods from ZooKeeperUtils\n\nIntroduce default job id\n\nThis closes #3781.\n","date":"2017-05-05 17:06:07","modifiedFileCount":"114","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2017-05-31 03:40:47","codes":[{"authorDate":"2017-05-31 03:40:47","commitOrder":3,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2017-07-13 06:37:47","endLine":540,"groupId":"44047","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/1dd2a277e4a23e23754ab815593c797239a170.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":490,"status":"M"},{"authorDate":"2017-05-31 03:40:47","commitOrder":3,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2017-07-13 06:37:47","endLine":599,"groupId":"44047","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/1dd2a277e4a23e23754ab815593c797239a170.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index-2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\t\t\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":548,"status":"M"}],"commitId":"9bd491e05120915cbde36d4452e3982fe5d0975f","commitMessage":"@@@[FLINK-6731] [tests] Activate strict checkstyle for flink-tests\n\nThis closes #4295\n","date":"2017-07-13 06:37:47","modifiedFileCount":"185","status":"M","submitter":"Greg Hogan"},{"authorTime":"2019-08-21 16:38:00","codes":[{"authorDate":"2019-08-21 16:38:00","commitOrder":4,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2019-08-27 20:27:23","endLine":529,"groupId":"44047","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/effd746caff206ca3fec2db008e387c615e52a.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"M"},{"authorDate":"2019-08-21 16:38:00","commitOrder":4,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2019-08-27 20:27:23","endLine":587,"groupId":"44047","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/effd746caff206ca3fec2db008e387c615e52a.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":537,"status":"M"}],"commitId":"c30e84fb8df9cb6ab6a38cde40b9c3b83c4e8954","commitMessage":"@@@[FLINK-13794][client] Remove unused logic of printStatusDuringExecution\n","date":"2019-08-27 20:27:23","modifiedFileCount":"67","status":"M","submitter":"tison"},{"authorTime":"2020-09-29 02:16:11","codes":[{"authorDate":"2020-09-29 02:16:11","commitOrder":5,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2020-10-01 23:03:45","endLine":523,"groupId":"101476","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/0570f50a3e909fdb2676b5e0aafaeea094d100.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(2);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":475,"status":"M"},{"authorDate":"2020-09-29 02:16:11","commitOrder":5,"curCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","date":"2020-10-01 23:03:45","endLine":580,"groupId":"101476","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithLongMaxWatermarkFromSource2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/0570f50a3e909fdb2676b5e0aafaeea094d100.src","preCode":"\tpublic void testTimestampExtractorWithLongMaxWatermarkFromSource2() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment\n\t\t\t\t.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(2);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collectWithTimestamp(index, index);\n\t\t\t\t\tctx.collectWithTimestamp(index - 1, index - 1);\n\t\t\t\t\tindex++;\n\t\t\t\t\tctx.emitWatermark(new Watermark(index - 2));\n\t\t\t\t}\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t\tctx.emitWatermark(new Watermark(Long.MAX_VALUE));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPeriodicWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark getCurrentWatermark() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true));\n\n\t\tenv.execute();\n\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].size() == 1);\n\t\tAssert.assertTrue(CustomOperator.finalWatermarks[0].get(0).getTimestamp() == Long.MAX_VALUE);\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":531,"status":"M"}],"commitId":"cb4de07a4004b46702edf7809f8a556866fe3da1","commitMessage":"@@@[FLINK-19317] Remove unnecessary calls to setStreamTimeCharacteristic (java)\n\nI'm just removing calls the set EventTime because that's the new default\nnow.\n\nI'm also removing most calls to set ProcessingTime because it's not\nneeded for making processing-time timers/windows work. I only left it\nfor some tests that check specific failure behavior.\n\nI removed calls to set IngestionTime and replaced them by an explicit\nIngestionTimeWatermarkStrategy. I duplicated the same\nIngestionTimeWatermarkStrategy in all the examples/tests because I\nexplicitly didn't want to add an IngestionTimeWatermarkStrategy in one\nof the core packages so that it is not discoverable because I think we\nshouldn't encourage users to use ingestion time.\n","date":"2020-10-01 23:03:45","modifiedFileCount":"30","status":"M","submitter":"Aljoscha Krettek"}]
