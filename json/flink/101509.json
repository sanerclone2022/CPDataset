[{"authorTime":"2016-06-11 08:14:07","codes":[{"authorDate":"2016-06-11 08:14:07","commitOrder":1,"curCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(NoOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(NoOpIntMap).name(\"IterRebalanceMap\").setParallelism(DEFAULT_PARALLELISM / 2);\n\t\tDataStream<Integer> head2 = iter1.map(NoOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(NoOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(NoOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(NoOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2016-07-05 21:51:06","endLine":286,"groupId":"27822","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testmultipleHeadsTailsSimple","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/bebd0c4aa96504514cb4b58a742e68f802575d.src","preCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(NoOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(NoOpIntMap).name(\"IterRebalanceMap\").setParallelism(DEFAULT_PARALLELISM / 2);\n\t\tDataStream<Integer> head2 = iter1.map(NoOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(NoOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(NoOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(NoOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"B"},{"authorDate":"2016-06-11 08:14:07","commitOrder":1,"curCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(NoOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(NoOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(NoOpIntMap)\n\t\t\t\t.setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(NoOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(NoOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(NoOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(NoOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2016-07-05 21:51:06","endLine":373,"groupId":"26267","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testmultipleHeadsTailsWithTailPartitioning","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1f/bebd0c4aa96504514cb4b58a742e68f802575d.src","preCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(NoOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(NoOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(NoOpIntMap)\n\t\t\t\t.setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(NoOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(NoOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(NoOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(NoOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"B"}],"commitId":"b9f42e91c9415dd6063079df00c142334b74e636","commitMessage":"@@@[FLINK-3995] [build] flink-test-utils also contains the streaming test utilities.\n\nTest utilities include the StreamingMultipleProgramsTestBase and StreamingTestEnvironment.\n\nThis moves the ITCases for streaming into 'flink-tests' to achieve that.\n\nThis closes #2092\n","date":"2016-07-05 21:51:06","modifiedFileCount":"12","status":"B","submitter":"Stephan Ewen"},{"authorTime":"2017-05-31 03:40:47","codes":[{"authorDate":"2017-05-31 03:40:47","commitOrder":2,"curCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(DEFAULT_PARALLELISM / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2017-07-13 06:37:47","endLine":282,"groupId":"27822","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testmultipleHeadsTailsSimple","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0f/6b2bcb7bca5793e4f5f8547c1801c1fe816774.src","preCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(NoOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(NoOpIntMap).name(\"IterRebalanceMap\").setParallelism(DEFAULT_PARALLELISM / 2);\n\t\tDataStream<Integer> head2 = iter1.map(NoOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(NoOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(NoOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(NoOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"M"},{"authorDate":"2017-05-31 03:40:47","commitOrder":2,"curCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2017-07-13 06:37:47","endLine":368,"groupId":"26267","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testmultipleHeadsTailsWithTailPartitioning","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0f/6b2bcb7bca5793e4f5f8547c1801c1fe816774.src","preCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(NoOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(NoOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(NoOpIntMap)\n\t\t\t\t.setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(NoOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(NoOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(NoOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(NoOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(NoOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":285,"status":"M"}],"commitId":"9bd491e05120915cbde36d4452e3982fe5d0975f","commitMessage":"@@@[FLINK-6731] [tests] Activate strict checkstyle for flink-tests\n\nThis closes #4295\n","date":"2017-07-13 06:37:47","modifiedFileCount":"185","status":"M","submitter":"Greg Hogan"},{"authorTime":"2017-10-24 22:20:15","codes":[{"authorDate":"2017-10-24 22:20:15","commitOrder":3,"curCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(parallelism / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2018-01-09 15:05:51","endLine":284,"groupId":"27822","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testmultipleHeadsTailsSimple","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8e/dbe734d53e95c3e5918494fbfa3764f9d07caf.src","preCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(DEFAULT_PARALLELISM / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2017-10-24 22:20:15","commitOrder":3,"curCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(parallelism / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2018-01-09 15:05:51","endLine":370,"groupId":"26267","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testmultipleHeadsTailsWithTailPartitioning","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8e/dbe734d53e95c3e5918494fbfa3764f9d07caf.src","preCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(DEFAULT_PARALLELISM / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"M"}],"commitId":"b90210e3712a54ad85a33dfc308a03e0c4a2a250","commitMessage":"@@@[FLINK-7909] Replace StreamingMultipleProgramsTestBase by AbstractTestBase\n\nThe AbstractTestBase fully subsumes the functionality of the\nStreamingMultipleProgramsTestBase since it now is the most general test base\nfor streaming and batch jobs. As a consequence.  we can safely remove the\nStreamingMultipleProgramsTestBase and let all corresponding tests extend from\nAbstractTestBase.\n\nThis closes #4896.\n","date":"2018-01-09 15:05:51","modifiedFileCount":"38","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2019-01-03 16:37:21","codes":[{"authorDate":"2019-01-03 16:37:21","commitOrder":4,"curCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(parallelism / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (graph.getTargetVertex(edge).getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (graph.getTargetVertex(edge).getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2019-01-19 21:51:26","endLine":286,"groupId":"27822","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testmultipleHeadsTailsSimple","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/33/2584de0389376ff3a142b67a940439083656fe.src","preCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(parallelism / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"},{"authorDate":"2019-01-03 16:37:21","commitOrder":4,"curCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(parallelism / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (graph.getTargetVertex(edge).getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, graph.getTargetVertex(edge).getParallelism());\n\t\t\t} else if (graph.getTargetVertex(edge).getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, graph.getTargetVertex(edge).getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = graph.getSourceVertex(edge).getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2019-01-19 21:51:26","endLine":372,"groupId":"42665","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testmultipleHeadsTailsWithTailPartitioning","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/33/2584de0389376ff3a142b67a940439083656fe.src","preCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(parallelism / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (edge.getTargetVertex().getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, edge.getTargetVertex().getParallelism());\n\t\t\t} else if (edge.getTargetVertex().getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, edge.getTargetVertex().getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = edge.getSourceVertex().getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"M"}],"commitId":"a7eb845e812ab0355854d3cf26843179a5a8b597","commitMessage":"@@@[FLINK-11256][Streaming] Improve StreamEdge to reduce the sizes of JobGraph\n\nThis closes #7403\n","date":"2019-01-19 21:51:26","modifiedFileCount":"6","status":"M","submitter":"sunhaibotb"},{"authorTime":"2020-09-04 17:37:47","codes":[{"authorDate":"2020-09-04 17:37:47","commitOrder":5,"curCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(parallelism / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tOutputTag<Integer> even = new OutputTag<Integer>(\"even\") {};\n\t\tOutputTag<Integer> odd = new OutputTag<Integer>(\"odd\") {};\n\t\tSingleOutputStreamOperator<Object> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.process(new ProcessFunction<Integer, Object>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void processElement(\n\t\t\t\t\t\tInteger value,\n\t\t\t\t\t\tContext ctx,\n\t\t\t\t\t\tCollector<Object> out) throws Exception {\n\t\t\t\t\t\tif (value % 2 == 0) {\n\t\t\t\t\t\t\tctx.output(even, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.output(odd, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\titer1.closeWith(source3.getSideOutput(even).union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (graph.getTargetVertex(edge).getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (graph.getTargetVertex(edge).getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2020-09-14 23:24:39","endLine":300,"groupId":"101509","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testmultipleHeadsTailsSimple","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/bc/9980fdf133eb7ca2b710ae6013a5aa3346d305.src","preCode":"\tpublic void testmultipleHeadsTailsSimple() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapShuffle\");\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"ParallelizeMapRebalance\");\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"IterRebalanceMap\").setParallelism(parallelism / 2);\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap).name(\"IterForwardMap\");\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2).addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap).name(\"EvenOddSourceMap\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(source3.select(\"even\").union(\n\t\t\t\thead1.rebalance().map(noOpIntMap).broadcast(), head2.shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (graph.getTargetVertex(edge).getOperatorName().equals(\"IterRebalanceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t} else if (graph.getTargetVertex(edge).getOperatorName().equals(\"IterForwardMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapShuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"ParallelizeMapForward\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t}\n\n\t\t\tif (graph.getStreamNode(edge.getSourceId()).getOperatorName().equals(\"EvenOddSourceMap\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\n\t\t\t\titSink1 = vertex;\n\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":210,"status":"M"},{"authorDate":"2020-09-04 17:37:47","commitOrder":5,"curCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(parallelism / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tOutputTag<Integer> even = new OutputTag<Integer>(\"even\") {};\n\t\tOutputTag<Integer> odd = new OutputTag<Integer>(\"odd\") {};\n\t\tSingleOutputStreamOperator<Object> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.process(new ProcessFunction<Integer, Object>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void processElement(\n\t\t\t\t\t\t\tInteger value,\n\t\t\t\t\t\t\tContext ctx,\n\t\t\t\t\t\t\tCollector<Object> out) throws Exception {\n\t\t\t\t\t\tif (value % 2 == 0) {\n\t\t\t\t\t\t\tctx.output(even, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.output(odd, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.getSideOutput(even).union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (graph.getTargetVertex(edge).getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, graph.getTargetVertex(edge).getParallelism());\n\t\t\t} else if (graph.getTargetVertex(edge).getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, graph.getTargetVertex(edge).getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = graph.getSourceVertex(edge).getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","date":"2020-09-14 23:24:39","endLine":399,"groupId":"101509","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testmultipleHeadsTailsWithTailPartitioning","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/bc/9980fdf133eb7ca2b710ae6013a5aa3346d305.src","preCode":"\tpublic void testmultipleHeadsTailsWithTailPartitioning() {\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tDataStream<Integer> source1 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.shuffle()\n\t\t\t\t.map(noOpIntMap);\n\n\t\tDataStream<Integer> source2 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap);\n\n\t\tIterativeStream<Integer> iter1 = source1.union(source2).iterate();\n\n\t\tDataStream<Integer> head1 = iter1.map(noOpIntMap).name(\"map1\");\n\t\tDataStream<Integer> head2 = iter1.map(noOpIntMap)\n\t\t\t\t.setParallelism(parallelism / 2)\n\t\t\t\t.name(\"shuffle\").rebalance();\n\t\tDataStreamSink<Integer> head3 = iter1.map(noOpIntMap).setParallelism(parallelism / 2)\n\t\t\t\t.addSink(new ReceiveCheckNoOpSink<Integer>());\n\t\tDataStreamSink<Integer> head4 = iter1.map(noOpIntMap).addSink(new ReceiveCheckNoOpSink<Integer>());\n\n\t\tSplitStream<Integer> source3 = env.fromElements(1, 2, 3, 4, 5)\n\t\t\t\t.map(noOpIntMap)\n\t\t\t\t.name(\"split\")\n\t\t\t\t.split(new EvenOddOutputSelector());\n\n\t\titer1.closeWith(\n\t\t\t\tsource3.select(\"even\").union(\n\t\t\t\t\t\thead1.map(noOpIntMap).name(\"bc\").broadcast(),\n\t\t\t\t\t\thead2.map(noOpIntMap).shuffle()));\n\n\t\tStreamGraph graph = env.getStreamGraph();\n\n\t\tJobGraph jg = graph.getJobGraph();\n\n\t\tassertEquals(1, graph.getIterationSourceSinkPairs().size());\n\n\t\tTuple2<StreamNode, StreamNode> sourceSinkPair = graph.getIterationSourceSinkPairs().iterator().next();\n\t\tStreamNode itSource = sourceSinkPair.f0;\n\t\tStreamNode itSink = sourceSinkPair.f1;\n\n\t\tassertEquals(4, itSource.getOutEdges().size());\n\t\tassertEquals(3, itSink.getInEdges().size());\n\n\t\tassertEquals(itSource.getParallelism(), itSink.getParallelism());\n\n\t\tfor (StreamEdge edge : itSource.getOutEdges()) {\n\t\t\tif (graph.getTargetVertex(edge).getOperatorName().equals(\"map1\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertEquals(4, graph.getTargetVertex(edge).getParallelism());\n\t\t\t} else if (graph.getTargetVertex(edge).getOperatorName().equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof RebalancePartitioner);\n\t\t\t\tassertEquals(2, graph.getTargetVertex(edge).getParallelism());\n\t\t\t}\n\t\t}\n\t\tfor (StreamEdge edge : itSink.getInEdges()) {\n\t\t\tString tailName = graph.getSourceVertex(edge).getOperatorName();\n\t\t\tif (tailName.equals(\"split\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ForwardPartitioner);\n\t\t\t\tassertTrue(edge.getSelectedNames().contains(\"even\"));\n\t\t\t} else if (tailName.equals(\"bc\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof BroadcastPartitioner);\n\t\t\t} else if (tailName.equals(\"shuffle\")) {\n\t\t\t\tassertTrue(edge.getPartitioner() instanceof ShufflePartitioner);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\n\t\tJobVertex itSource1 = null;\n\t\tJobVertex itSink1 = null;\n\n\t\tfor (JobVertex vertex : jg.getVertices()) {\n\t\t\tif (vertex.getName().contains(\"IterationSource\")) {\n\t\t\t\titSource1 = vertex;\n\t\t\t} else if (vertex.getName().contains(\"IterationSink\")) {\n\t\t\t\titSink1 = vertex;\n\t\t\t}\n\t\t}\n\n\t\tassertTrue(itSource1.getCoLocationGroup() != null);\n\t\tassertTrue(itSink1.getCoLocationGroup() != null);\n\n\t\tassertEquals(itSource1.getCoLocationGroup(), itSink1.getCoLocationGroup());\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/IterateITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":303,"status":"M"}],"commitId":"1a08548a209167cafeeba1ce602fe8d542994be5","commitMessage":"@@@[FLINK-19083] Remove deprecated DataStream#split\n\nThis closes #13343\n","date":"2020-09-14 23:24:39","modifiedFileCount":"21","status":"M","submitter":"Dawid Wysakowicz"}]
