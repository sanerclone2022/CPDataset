[{"authorTime":"2018-10-13 14:43:28","codes":[{"authorDate":"2018-10-13 14:43:28","commitOrder":1,"curCode":"\tprotected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.resumeTransaction(transaction.producerId, transaction.epoch);\n\t\t\t\t\tproducer.commitTransaction();\n\t\t\t\t}\n\t\t\t\tcatch (InvalidTxnStateException | ProducerFencedException ex) {\n\t\t\t\t\t\r\n\t\t\t\t\tLOG.warn(\"Encountered error {} while recovering transaction {}. \" +\n\t\t\t\t\t\t\t\"Presumably this transaction has been already committed before\",\n\t\t\t\t\t\tex,\n\t\t\t\t\t\ttransaction);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","date":"2018-10-16 23:41:13","endLine":753,"groupId":"13945","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"recoverAndCommit","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0a/c2f906bde5383cbff6727d65afc7b0335fdf12.src","preCode":"\tprotected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.resumeTransaction(transaction.producerId, transaction.epoch);\n\t\t\t\t\tproducer.commitTransaction();\n\t\t\t\t}\n\t\t\t\tcatch (InvalidTxnStateException | ProducerFencedException ex) {\n\t\t\t\t\t\r\n\t\t\t\t\tLOG.warn(\"Encountered error {} while recovering transaction {}. \" +\n\t\t\t\t\t\t\t\"Presumably this transaction has been already committed before\",\n\t\t\t\t\t\tex,\n\t\t\t\t\t\ttransaction);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":731,"status":"B"},{"authorDate":"2018-10-13 14:43:28","commitOrder":1,"curCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.initTransactions();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","date":"2018-10-16 23:41:13","endLine":785,"groupId":"50211","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"recoverAndAbort","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0a/c2f906bde5383cbff6727d65afc7b0335fdf12.src","preCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.initTransactions();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":771,"status":"B"}],"commitId":"2e3e820571145463ad01a86cd68b0ce844dcd3a2","commitMessage":"@@@[FLINK-9697] Add new kafka connector module\n","date":"2018-10-16 23:41:13","modifiedFileCount":"1","status":"B","submitter":"yanghua"},{"authorTime":"2018-10-13 14:43:28","codes":[{"authorDate":"2018-11-02 18:48:46","commitOrder":2,"curCode":"\tprotected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tif (transaction.isTransactional()) {\n\t\t\ttry (\n\t\t\t\tFlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\tproducer.resumeTransaction(transaction.producerId, transaction.epoch);\n\t\t\t\tproducer.commitTransaction();\n\t\t\t} catch (InvalidTxnStateException | ProducerFencedException ex) {\n\t\t\t\t\r\n\t\t\t\tLOG.warn(\"Encountered error {} while recovering transaction {}. \" +\n\t\t\t\t\t\t\"Presumably this transaction has been already committed before\",\n\t\t\t\t\tex,\n\t\t\t\t\ttransaction);\n\t\t\t}\n\t\t}\n\t}\n","date":"2018-11-07 18:38:50","endLine":739,"groupId":"13945","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"recoverAndCommit","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/df/1a4b5727f91d57cefb1449a7a994bedbe156d0.src","preCode":"\tprotected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.resumeTransaction(transaction.producerId, transaction.epoch);\n\t\t\t\t\tproducer.commitTransaction();\n\t\t\t\t}\n\t\t\t\tcatch (InvalidTxnStateException | ProducerFencedException ex) {\n\t\t\t\t\t\r\n\t\t\t\t\tLOG.warn(\"Encountered error {} while recovering transaction {}. \" +\n\t\t\t\t\t\t\t\"Presumably this transaction has been already committed before\",\n\t\t\t\t\t\tex,\n\t\t\t\t\t\ttransaction);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":724,"status":"M"},{"authorDate":"2018-10-13 14:43:28","commitOrder":2,"curCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.initTransactions();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","date":"2018-10-16 23:41:13","endLine":785,"groupId":"50211","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"recoverAndAbort","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0a/c2f906bde5383cbff6727d65afc7b0335fdf12.src","preCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.initTransactions();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":771,"status":"N"}],"commitId":"85f895b0836c19e4c0e56246aa9af10df8dee09b","commitMessage":"@@@[FLINK-10353][kafka] Support change of transactional semantics in Kafka Producer with existing state\n\nThis closes #7010.\n","date":"2018-11-07 18:38:50","modifiedFileCount":"7","status":"M","submitter":"Stefan Richter"},{"authorTime":"2020-05-11 17:32:37","codes":[{"authorDate":"2020-05-11 17:32:37","commitOrder":3,"curCode":"\tprotected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tif (transaction.isTransactional()) {\n\t\t\tFlinkKafkaInternalProducer<byte[], byte[]> producer = null;\n\t\t\ttry {\n\t\t\t\tproducer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false);\n\t\t\t\tproducer.resumeTransaction(transaction.producerId, transaction.epoch);\n\t\t\t\tproducer.commitTransaction();\n\t\t\t} catch (InvalidTxnStateException | ProducerFencedException ex) {\n\t\t\t\t\r\n\t\t\t\tLOG.warn(\"Encountered error {} while recovering transaction {}. \" +\n\t\t\t\t\t\t\"Presumably this transaction has been already committed before\",\n\t\t\t\t\tex,\n\t\t\t\t\ttransaction);\n\t\t\t} finally {\n\t\t\t\tif (producer != null) {\n\t\t\t\t\tproducer.close(0, TimeUnit.SECONDS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-06-16 00:53:46","endLine":981,"groupId":"16173","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"recoverAndCommit","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/82/a3facdb49b62111650bdebb606a648947b9f19.src","preCode":"\tprotected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tif (transaction.isTransactional()) {\n\t\t\ttry (\n\t\t\t\tFlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\tproducer.resumeTransaction(transaction.producerId, transaction.epoch);\n\t\t\t\tproducer.commitTransaction();\n\t\t\t} catch (InvalidTxnStateException | ProducerFencedException ex) {\n\t\t\t\t\r\n\t\t\t\tLOG.warn(\"Encountered error {} while recovering transaction {}. \" +\n\t\t\t\t\t\t\"Presumably this transaction has been already committed before\",\n\t\t\t\t\tex,\n\t\t\t\t\ttransaction);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":961,"status":"M"},{"authorDate":"2020-05-11 17:32:37","commitOrder":3,"curCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tif (transaction.isTransactional()) {\n\t\t\tFlinkKafkaInternalProducer<byte[], byte[]> producer = null;\n\t\t\ttry {\n\t\t\t\tproducer =\n\t\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false);\n\t\t\t\tproducer.initTransactions();\n\t\t\t} finally {\n\t\t\t\tif (producer != null) {\n\t\t\t\t\tproducer.close(0, TimeUnit.SECONDS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-06-16 00:53:46","endLine":1005,"groupId":"16175","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"recoverAndAbort","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/82/a3facdb49b62111650bdebb606a648947b9f19.src","preCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tswitch (semantic) {\n\t\t\tcase EXACTLY_ONCE:\n\t\t\t\ttry (FlinkKafkaInternalProducer<byte[], byte[]> producer =\n\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false)) {\n\t\t\t\t\tproducer.initTransactions();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AT_LEAST_ONCE:\n\t\t\tcase NONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not implemented semantic\");\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":992,"status":"M"}],"commitId":"711f619d3f61b7cf37b13fefb820edff2199b19d","commitMessage":"@@@[FLINK-17327] Always use close() with zero timeout in exactly-once Kafka Producer\n\nNOTE: This fix does not work without also bumping the Kafka version to\nsth > 2.4 (2.3 might work as well). Because of KAFKA-6635/KAFKA-7763.\n\nCalling close() without timeout is equivalent to calling\nclose(Long.MAX_VALUE). This will leave lingering Kafka threads on\nshutdown.  which eventually cause the Task Manager to be killed by the\nFlink Task watchdog.\n\nWe also forbid calling close() without a timeout on our internal\nProducer.  which means that we have to change some code that uses\ntry-with-resources.  because this calls close() without a timeout.\n\nWe need to call close with a zero timeout to prevent in-flight\ntransactions from being aborted by the KafkaProducer/sender. This would\nbreak how we use transactions in our Kafka Producer.\n\nWe don't update FlinkKafkaProducerBase.  which is used for\nnon-exactly-once Kafka Producers.\n","date":"2020-06-16 00:53:46","modifiedFileCount":"4","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2020-05-11 17:32:37","codes":[{"authorDate":"2021-09-06 18:45:35","commitOrder":4,"curCode":"    protected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n        if (transaction.isTransactional()) {\n            FlinkKafkaInternalProducer<byte[], byte[]> producer = null;\n            try {\n                producer = initTransactionalProducer(transaction.transactionalId, false);\n                producer.resumeTransaction(transaction.producerId, transaction.epoch);\n                producer.commitTransaction();\n            } catch (InvalidTxnStateException e) {\n                LOG.warn(\n                        \"Unable to commit recovered transaction ({}) because it's in an invalid state. \"\n                                + \"Most likely the transaction has been aborted for some reason. Please check the Kafka logs for more details.\",\n                        transaction,\n                        e);\n            } catch (ProducerFencedException e) {\n                LOG.warn(\n                        \"Unable to commit recovered transaction ({}) because its producer is already fenced.\"\n                                + \" This means that you either have a different producer with the same '{}' or\"\n                                + \" recovery took longer than '{}' ({}ms). In both cases this most likely signals data loss,\"\n                                + \" please consult the Flink documentation for more details.\",\n                        transaction,\n                        ProducerConfig.TRANSACTIONAL_ID_CONFIG,\n                        ProducerConfig.TRANSACTION_TIMEOUT_CONFIG,\n                        getTransactionTimeout(producerConfig),\n                        e);\n            } finally {\n                if (producer != null) {\n                    producer.close(0, TimeUnit.SECONDS);\n                }\n            }\n        }\n    }\n","date":"2021-09-06 18:45:35","endLine":1066,"groupId":"10334","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"recoverAndCommit","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/59/70158b0fc34241cbf9477f3c7c8e1fac9617bb.src","preCode":"    protected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) {\n        if (transaction.isTransactional()) {\n            FlinkKafkaInternalProducer<byte[], byte[]> producer = null;\n            try {\n                producer = initTransactionalProducer(transaction.transactionalId, false);\n                producer.resumeTransaction(transaction.producerId, transaction.epoch);\n                producer.commitTransaction();\n            } catch (InvalidTxnStateException | ProducerFencedException ex) {\n                \r\n                LOG.warn(\n                        \"Encountered error {} while recovering transaction {}. \"\n                                + \"Presumably this transaction has been already committed before\",\n                        ex,\n                        transaction);\n            } finally {\n                if (producer != null) {\n                    producer.close(0, TimeUnit.SECONDS);\n                }\n            }\n        }\n    }\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":1036,"status":"M"},{"authorDate":"2020-05-11 17:32:37","commitOrder":4,"curCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tif (transaction.isTransactional()) {\n\t\t\tFlinkKafkaInternalProducer<byte[], byte[]> producer = null;\n\t\t\ttry {\n\t\t\t\tproducer =\n\t\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false);\n\t\t\t\tproducer.initTransactions();\n\t\t\t} finally {\n\t\t\t\tif (producer != null) {\n\t\t\t\t\tproducer.close(0, TimeUnit.SECONDS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2020-06-16 00:53:46","endLine":1005,"groupId":"10334","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"recoverAndAbort","params":"(FlinkKafkaProducer.KafkaTransactionStatetransaction)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/82/a3facdb49b62111650bdebb606a648947b9f19.src","preCode":"\tprotected void recoverAndAbort(FlinkKafkaProducer.KafkaTransactionState transaction) {\n\t\tif (transaction.isTransactional()) {\n\t\t\tFlinkKafkaInternalProducer<byte[], byte[]> producer = null;\n\t\t\ttry {\n\t\t\t\tproducer =\n\t\t\t\t\t\tinitTransactionalProducer(transaction.transactionalId, false);\n\t\t\t\tproducer.initTransactions();\n\t\t\t} finally {\n\t\t\t\tif (producer != null) {\n\t\t\t\t\tproducer.close(0, TimeUnit.SECONDS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-connectors/flink-connector-kafka/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducer.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":992,"status":"N"}],"commitId":"73bb9d3b40178b001f1b9920b52a0db0b459af70","commitMessage":"@@@[FLINK-23839][kafka] Improve warnings on InvalidTxnState-/ProducerFencedException\n\n","date":"2021-09-06 18:45:35","modifiedFileCount":"2","status":"M","submitter":"David Moravek"}]
