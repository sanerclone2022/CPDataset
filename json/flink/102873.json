[{"authorTime":"2016-01-25 19:34:05","codes":[{"authorDate":"2016-01-25 19:34:05","commitOrder":2,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-02-04 03:27:51","endLine":121,"groupId":"22200","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2f/1dce5567dea6ae473d075389bd1cd7ce47ac37.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"MB"},{"authorDate":"2016-01-25 19:34:05","commitOrder":2,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew RichSumReducer<GlobalWindow>(closeCalled),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2016-02-04 03:27:51","endLine":194,"groupId":"22200","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2f/1dce5567dea6ae473d075389bd1cd7ce47ac37.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew RichSumReducer<GlobalWindow>(closeCalled),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"B"}],"commitId":"67ca4a436daf8de1a6e0329b4b30342e77d26087","commitMessage":"@@@[FLINK-3200] Use Partitioned State in WindowOperator\n\nThis changes window operator to use the new partitioned state\nabstraction for keeping window contents instead of custom internal\nstate and the checkpointed interface.\n\nFor now.  timers are still kept as custom checkpointed state.  however.\n\nWindowOperator now expects a StateIdentifier for MergingState.  this can\neither be for ReducingState or ListState but WindowOperator is agnostic\nto the type of State. Also the signature of WindowFunction is changed to\ninclude the type of intermediate input. For example.  if a ReducingState\nis used the input of the WindowFunction is T (where T is the input\ntype). If using a ListState the input of the WindowFunction would be of\ntype Iterable[T].\n","date":"2016-02-04 03:27:51","modifiedFileCount":"40","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-02-26 22:19:50","codes":[{"authorDate":"2016-02-26 22:19:50","commitOrder":3,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-02-27 07:07:05","endLine":122,"groupId":"22200","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6a/f7ac4ce1f440f92840af9b284a85e02a2150ba.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer()),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"},{"authorDate":"2016-02-26 22:19:50","commitOrder":3,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2016-02-27 07:07:05","endLine":195,"groupId":"22200","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6a/f7ac4ce1f440f92840af9b284a85e02a2150ba.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew RichSumReducer<GlobalWindow>(closeCalled),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"}],"commitId":"27b5c49e76f58992fd5575959a7dea7088505e12","commitMessage":"@@@[FLINK-3521] Make Iterable part of method signature for WindowFunction\n\nThis closes #1723\n","date":"2016-02-27 07:07:05","modifiedFileCount":"32","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-05-31 23:13:58","codes":[{"authorDate":"2016-05-31 23:13:58","commitOrder":4,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-06-21 18:14:06","endLine":128,"groupId":"22200","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dc/714403ad18ba6e1e1eb4ebecae61190fd9d400.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2016-05-31 23:13:58","commitOrder":4,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2016-06-21 18:14:06","endLine":202,"groupId":"22200","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dc/714403ad18ba6e1e1eb4ebecae61190fd9d400.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE));\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"34a8b03d2ad40db7dc00fa47923b96374c289838","commitMessage":"@@@[FLINK-3714] Add Support for \"Allowed Lateness\"\n\nHandle late elements and take care\nof cleaning the window state.\n","date":"2016-06-21 18:14:06","modifiedFileCount":"16","status":"M","submitter":"kl0u"},{"authorTime":"2016-08-11 00:44:50","codes":[{"authorDate":"2016-08-11 00:44:50","commitOrder":5,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-09-01 01:10:01","endLine":127,"groupId":"22200","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/68/1a334d688e3afca4d4d86f051e239424730390.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2016-08-11 00:44:50","commitOrder":5,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2016-09-01 01:10:01","endLine":199,"groupId":"22200","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/68/1a334d688e3afca4d4d86f051e239424730390.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\tnew OneInputStreamOperatorTestHarness<>(operator);\n\n\t\ttestHarness.configureForKeyedStream(new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"M"}],"commitId":"4809f5367b08a9734fc1bd4875be51a9f3bb65aa","commitMessage":"@@@[FLINK-3761] Refactor State Backends/Make Keyed State Key-Group Aware\n\nThe biggest change in this is that functionality that used to be in\nAbstractStateBackend is now moved to CheckpointStreamFactory and\nKeyedStateBackend. The former is responsible for providing streams that\ncan be used to checkpoint data while the latter is responsible for\nkeeping keyed state. A keyed backend can checkpoint the state that it\nkeeps by using a CheckpointStreamFactory.\n\nThis also refactors how asynchronous keyed state snapshots work. They\nare not implemented using a Future/RunnableFuture.\n\nAlso.  this changes the keyed state backends to be key-group aware and to\nsnapshot the state in key-groups with an index for restoring.\n","date":"2016-09-01 01:10:01","modifiedFileCount":"100","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-10-05 05:49:54","codes":[{"authorDate":"2016-10-05 05:49:54","commitOrder":6,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-06 02:04:34","endLine":125,"groupId":"22200","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8f/3af15247c734bacf2c0ff0752dd208eb4b84d2.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2016-10-05 05:49:54","commitOrder":6,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2016-10-06 02:04:34","endLine":195,"groupId":"22200","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8f/3af15247c734bacf2c0ff0752dd208eb4b84d2.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\t\toperator.setInputType(inputType, new ExecutionConfig());\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"}],"commitId":"1cd8d4f418a707790c091fed2428627eae9da423","commitMessage":"@@@[hotfix] [streaming api] Remove obsolete and unused InputTypeSerializer from WindowOperator\n","date":"2016-10-06 02:04:34","modifiedFileCount":"4","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2016-10-19 00:32:17","codes":[{"authorDate":"2016-10-19 00:32:17","commitOrder":7,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2016-10-22 00:10:48","endLine":129,"groupId":"22200","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2e/3d09081c02f2fdcfd77fa47ec9aeec3154f9d8.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2016-10-19 00:32:17","commitOrder":7,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2016-10-22 00:10:48","endLine":203,"groupId":"22200","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2e/3d09081c02f2fdcfd77fa47ec9aeec3154f9d8.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>(\"window-contents\",\n\t\t\tnew StreamRecordSerializer<>(inputType.createSerializer(new ExecutionConfig())));\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"}],"commitId":"71d2e3ef1e42174822709aa8217088f2a489975a","commitMessage":"@@@[FLINK-4852] Remove Non-Multiplexing StreamRecordSerializer\n\nThis also renames MultiplexingStreamRecordSerializer to\nStreamElementSerializer.\n","date":"2016-10-22 00:10:48","modifiedFileCount":"15","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2017-03-01 22:36:17","commitOrder":8,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-03-18 14:44:17","endLine":595,"groupId":"22200","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/d63de69bbeae0402a9a2e8bb8f21a76e8fff02.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":528,"status":"M"},{"authorDate":"2017-03-01 22:36:17","commitOrder":8,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0,\n\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2017-03-18 14:44:17","endLine":670,"groupId":"22200","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/d63de69bbeae0402a9a2e8bb8f21a76e8fff02.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0);\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":599,"status":"M"}],"commitId":"07a15d0e1647c79ae010ca6df5b1830a4087dd56","commitMessage":"@@@[FLINK-4460] Provide late-data output for window operations\n\nWe use side outputs to emit dropped late data.\n","date":"2017-03-18 14:44:17","modifiedFileCount":"8","status":"M","submitter":"Chen Qin"},{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2017-03-19 18:21:17","commitOrder":9,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(\n\t\t\t\t\t\tnew ReduceApplyWindowFunction<>(\n\t\t\t\t\t\t\t\tnew SumReducer(),\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-04-26 16:36:50","endLine":600,"groupId":"22200","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e5/d3ef02a5fe9c4d8f6c9e9b19dd8f801ef5212c.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(new ReduceIterableWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>(new SumReducer())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":529,"status":"M"},{"authorDate":"2017-03-01 22:36:17","commitOrder":9,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0,\n\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2017-03-18 14:44:17","endLine":670,"groupId":"22200","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/d63de69bbeae0402a9a2e8bb8f21a76e8fff02.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0,\n\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":599,"status":"N"}],"commitId":"2581a7b88baf777c5cdd1cccbffb861ac1e454fa","commitMessage":"@@@[FLINK-6107] Enable Javadoc checks in streaming checkstyle\n","date":"2017-04-26 16:36:50","modifiedFileCount":"194","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-05-17 20:01:04","codes":[{"authorDate":"2017-05-17 20:01:04","commitOrder":10,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int windowSize = 4;\n\t\tfinal int windowSlide = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(\n\t\t\t\t\t\tnew ReduceApplyWindowFunction<>(\n\t\t\t\t\t\t\t\tnew SumReducer(),\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>())),\n\t\t\t\tCountTrigger.of(windowSlide),\n\t\t\t\tCountEvictor.of(windowSize),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2017-05-23 04:22:24","endLine":572,"groupId":"22200","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8d/65bb4bac1ae5467b1737fae6b31ddf06c0f2dd.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(\n\t\t\t\t\t\tnew ReduceApplyWindowFunction<>(\n\t\t\t\t\t\t\t\tnew SumReducer(),\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>())),\n\t\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":505,"status":"M"},{"authorDate":"2017-05-17 20:01:04","commitOrder":10,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int windowSize = 4;\n\t\tfinal int windowSlide = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(windowSlide),\n\t\t\tCountEvictor.of(windowSize),\n\t\t\t0,\n\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2017-05-23 04:22:24","endLine":642,"groupId":"22200","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8d/65bb4bac1ae5467b1737fae6b31ddf06c0f2dd.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int WINDOW_SIZE = 4;\n\t\tfinal int WINDOW_SLIDE = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(WINDOW_SLIDE),\n\t\t\tCountEvictor.of(WINDOW_SIZE),\n\t\t\t0,\n\t\t\tnull );\n\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":576,"status":"M"}],"commitId":"12b4185c6c09101b64e12a84c33dc4d28f95cff9","commitMessage":"@@@[FLINK-6603] [streaming] Enable checkstyle on test sources\n\nUpdates / reverts the import order by sections:\n- org.apache.flink.*\n- all other imports\n- javax.*\n- java.*\n- static imports\n\nAdds EmptyLineSeparator to enforce an extra newline (not enforced\nbetween field or local variable declarations).\n\nThis closes #3941\n","date":"2017-05-23 04:22:24","modifiedFileCount":"395","status":"M","submitter":"Greg Hogan"},{"authorTime":"2018-05-04 23:15:51","codes":[{"authorDate":"2018-05-04 23:15:51","commitOrder":11,"curCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int windowSize = 4;\n\t\tfinal int windowSlide = 2;\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(\n\t\t\t\t\t\tnew ReduceApplyWindowFunction<>(\n\t\t\t\t\t\t\t\tnew SumReducer(),\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>())),\n\t\t\t\tCountTrigger.of(windowSlide),\n\t\t\t\tCountEvictor.of(windowSize),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","date":"2018-05-05 00:48:16","endLine":555,"groupId":"102873","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testCountTrigger","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/71/0c0b4629735a8654fd44cbb5a4e9cbb9a8f324.src","preCode":"\tpublic void testCountTrigger() throws Exception {\n\n\t\tfinal int windowSize = 4;\n\t\tfinal int windowSlide = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\t\tGlobalWindows.create(),\n\t\t\t\tnew GlobalWindow.Serializer(),\n\t\t\t\tnew TupleKeySelector(),\n\t\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\t\tstateDesc,\n\t\t\t\tnew InternalIterableWindowFunction<>(\n\t\t\t\t\t\tnew ReduceApplyWindowFunction<>(\n\t\t\t\t\t\t\t\tnew SumReducer(),\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tnew PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>())),\n\t\t\t\tCountTrigger.of(windowSlide),\n\t\t\t\tCountEvictor.of(windowSize),\n\t\t\t\t0,\n\t\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":490,"status":"M"},{"authorDate":"2018-05-04 23:15:51","commitOrder":11,"curCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int windowSize = 4;\n\t\tfinal int windowSlide = 2;\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(windowSlide),\n\t\t\tCountEvictor.of(windowSize),\n\t\t\t0,\n\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","date":"2018-05-05 00:48:16","endLine":623,"groupId":"102873","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testCountTriggerWithApply","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/71/0c0b4629735a8654fd44cbb5a4e9cbb9a8f324.src","preCode":"\tpublic void testCountTriggerWithApply() throws Exception {\n\t\tAtomicInteger closeCalled = new AtomicInteger(0);\n\n\t\tfinal int windowSize = 4;\n\t\tfinal int windowSlide = 2;\n\n\t\tTypeInformation<Tuple2<String, Integer>> inputType = TypeInfoParser.parse(\"Tuple2<String, Integer>\");\n\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tTypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer =\n\t\t\t\t(TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(inputType.createSerializer(new ExecutionConfig()));\n\n\t\tListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc =\n\t\t\t\tnew ListStateDescriptor<>(\"window-contents\", streamRecordSerializer);\n\n\t\tEvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(\n\t\t\tGlobalWindows.create(),\n\t\t\tnew GlobalWindow.Serializer(),\n\t\t\tnew TupleKeySelector(),\n\t\t\tBasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()),\n\t\t\tstateDesc,\n\t\t\tnew InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)),\n\t\t\tCountTrigger.of(windowSlide),\n\t\t\tCountEvictor.of(windowSize),\n\t\t\t0,\n\t\t\tnull );\n\n\t\tOneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness =\n\t\t\t\tnew KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);\n\n\t\tlong initialTime = 0L;\n\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n\n\t\ttestHarness.open();\n\n\t\t\r\n\n\t\t\r\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3000));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 3999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 20));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 999));\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1998));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 2), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 2), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key1\", 1), initialTime + 10999));\n\t\ttestHarness.processElement(new StreamRecord<>(new Tuple2<>(\"key2\", 1), initialTime + 1000));\n\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key1\", 4), Long.MAX_VALUE));\n\t\texpectedOutput.add(new StreamRecord<>(new Tuple2<>(\"key2\", 4), Long.MAX_VALUE));\n\n\t\tTestHarnessUtil.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput(), new ResultSortComparator());\n\n\t\ttestHarness.close();\n\n\t\tAssert.assertEquals(\"Close was not called.\", 1, closeCalled.get());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":559,"status":"M"}],"commitId":"c8fa8d025684c2225824c54a7285bbfdec7cfddc","commitMessage":"@@@[FLINK-9292] [core] Remove TypeInfoParser (part 1)\n","date":"2018-05-05 00:48:16","modifiedFileCount":"26","status":"M","submitter":"Stephan Ewen"}]
