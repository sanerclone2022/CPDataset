[{"authorTime":"2019-11-07 00:12:44","codes":[{"authorDate":"2020-06-05 01:16:27","commitOrder":15,"curCode":"\tpublic <N> Stream<K> getKeys(String state, N namespace) {\n\t\tRocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n\t\tif (columnInfo == null || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n\t\t\treturn Stream.empty();\n\t\t}\n\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n\t\t\t(RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n\t\tfinal TypeSerializer<N> namespaceSerializer = registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n\t\tfinal DataOutputSerializer namespaceOutputView = new DataOutputSerializer(8);\n\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(getKeySerializer(), namespaceSerializer);\n\t\tfinal byte[] nameSpaceBytes;\n\t\ttry {\n\t\t\tRocksDBKeySerializationUtils.writeNameSpace(\n\t\t\t\tnamespace,\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnamespaceOutputView,\n\t\t\t\tambiguousKeyPossible);\n\t\t\tnameSpaceBytes = namespaceOutputView.getCopyOfBuffer();\n\t\t} catch (IOException ex) {\n\t\t\tthrow new FlinkRuntimeException(\"Failed to get keys from RocksDB state backend.\", ex);\n\t\t}\n\n\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, columnInfo.columnFamilyHandle, readOptions);\n\t\titerator.seekToFirst();\n\n\t\tfinal RocksStateKeysIterator<K> iteratorWrapper = new RocksStateKeysIterator<>(iterator, state, getKeySerializer(), keyGroupPrefixBytes,\n\t\t\tambiguousKeyPossible, nameSpaceBytes);\n\n\t\tStream<K> targetStream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED), false);\n\t\treturn targetStream.onClose(iteratorWrapper::close);\n\t}\n","date":"2020-06-26 22:24:49","endLine":311,"groupId":"49567","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getKeys","params":"(Stringstate@Nnamespace)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f0/cce0b2ffd7ad2f5ef6fb8fa73a89c8fc0abf0f.src","preCode":"\tpublic <N> Stream<K> getKeys(String state, N namespace) {\n\t\tRocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n\t\tif (columnInfo == null || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n\t\t\treturn Stream.empty();\n\t\t}\n\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n\t\t\t(RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n\t\tfinal TypeSerializer<N> namespaceSerializer = registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n\t\tfinal DataOutputSerializer namespaceOutputView = new DataOutputSerializer(8);\n\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(getKeySerializer(), namespaceSerializer);\n\t\tfinal byte[] nameSpaceBytes;\n\t\ttry {\n\t\t\tRocksDBKeySerializationUtils.writeNameSpace(\n\t\t\t\tnamespace,\n\t\t\t\tnamespaceSerializer,\n\t\t\t\tnamespaceOutputView,\n\t\t\t\tambiguousKeyPossible);\n\t\t\tnameSpaceBytes = namespaceOutputView.getCopyOfBuffer();\n\t\t} catch (IOException ex) {\n\t\t\tthrow new FlinkRuntimeException(\"Failed to get keys from RocksDB state backend.\", ex);\n\t\t}\n\n\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, columnInfo.columnFamilyHandle, readOptions);\n\t\titerator.seekToFirst();\n\n\t\tfinal RocksStateKeysIterator<K> iteratorWrapper = new RocksStateKeysIterator<>(iterator, state, getKeySerializer(), keyGroupPrefixBytes,\n\t\t\tambiguousKeyPossible, nameSpaceBytes);\n\n\t\tStream<K> targetStream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED), false);\n\t\treturn targetStream.onClose(iteratorWrapper::close);\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":279,"status":"NB"},{"authorDate":"2019-11-07 00:12:44","commitOrder":15,"curCode":"\tpublic <N> Stream<Tuple2<K, N>> getKeysAndNamespaces(String state) {\n\t\tRocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n\t\tif (columnInfo == null || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n\t\t\treturn Stream.empty();\n\t\t}\n\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n\t\t\t(RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n\t\tfinal TypeSerializer<N> namespaceSerializer = registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(getKeySerializer(), namespaceSerializer);\n\n\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, columnInfo.columnFamilyHandle, readOptions);\n\t\titerator.seekToFirst();\n\n\t\tfinal RocksStateKeysAndNamespaceIterator<K, N> iteratorWrapper = new RocksStateKeysAndNamespaceIterator<>(\n\t\t\titerator, state, getKeySerializer(), namespaceSerializer, keyGroupPrefixBytes, ambiguousKeyPossible);\n\n\t\tStream<Tuple2<K, N>> targetStream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED), false);\n\t\treturn targetStream.onClose(iteratorWrapper::close);\n\t}\n","date":"2020-09-15 04:37:02","endLine":331,"groupId":"49566","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getKeysAndNamespaces","params":"(Stringstate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3f/b3ed17219b512faeffbf6a411d81844dab5cb5.src","preCode":"\tpublic <N> Stream<Tuple2<K, N>> getKeysAndNamespaces(String state) {\n\t\tRocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n\t\tif (columnInfo == null || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n\t\t\treturn Stream.empty();\n\t\t}\n\n\t\tRegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n\t\t\t(RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n\t\tfinal TypeSerializer<N> namespaceSerializer = registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n\t\tboolean ambiguousKeyPossible = RocksDBKeySerializationUtils.isAmbiguousKeyPossible(getKeySerializer(), namespaceSerializer);\n\n\t\tRocksIteratorWrapper iterator = RocksDBOperationUtils.getRocksIterator(db, columnInfo.columnFamilyHandle, readOptions);\n\t\titerator.seekToFirst();\n\n\t\tfinal RocksStateKeysAndNamespaceIterator<K, N> iteratorWrapper = new RocksStateKeysAndNamespaceIterator<>(\n\t\t\titerator, state, getKeySerializer(), namespaceSerializer, keyGroupPrefixBytes, ambiguousKeyPossible);\n\n\t\tStream<Tuple2<K, N>> targetStream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED), false);\n\t\treturn targetStream.onClose(iteratorWrapper::close);\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"B"}],"commitId":"cd81e9bbbd7456e6aedbff31054700cc4da70fa3","commitMessage":"@@@[FLINK-18978][state-backends] Support full table scan of key and namespace from statebackend\n\nThis closes #13179\n","date":"2020-09-15 04:37:02","modifiedFileCount":"8","status":"M","submitter":"Seth Wiesman"},{"authorTime":"2021-01-28 21:41:53","codes":[{"authorDate":"2021-01-28 21:41:53","commitOrder":16,"curCode":"    public <N> Stream<K> getKeys(String state, N namespace) {\n        RocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n        if (columnInfo == null\n                || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n            return Stream.empty();\n        }\n\n        RegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n                (RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n        final TypeSerializer<N> namespaceSerializer =\n                registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n        final DataOutputSerializer namespaceOutputView = new DataOutputSerializer(8);\n        boolean ambiguousKeyPossible =\n                CompositeKeySerializationUtils.isAmbiguousKeyPossible(\n                        getKeySerializer(), namespaceSerializer);\n        final byte[] nameSpaceBytes;\n        try {\n            CompositeKeySerializationUtils.writeNameSpace(\n                    namespace, namespaceSerializer, namespaceOutputView, ambiguousKeyPossible);\n            nameSpaceBytes = namespaceOutputView.getCopyOfBuffer();\n        } catch (IOException ex) {\n            throw new FlinkRuntimeException(\"Failed to get keys from RocksDB state backend.\", ex);\n        }\n\n        RocksIteratorWrapper iterator =\n                RocksDBOperationUtils.getRocksIterator(\n                        db, columnInfo.columnFamilyHandle, readOptions);\n        iterator.seekToFirst();\n\n        final RocksStateKeysIterator<K> iteratorWrapper =\n                new RocksStateKeysIterator<>(\n                        iterator,\n                        state,\n                        getKeySerializer(),\n                        keyGroupPrefixBytes,\n                        ambiguousKeyPossible,\n                        nameSpaceBytes);\n\n        Stream<K> targetStream =\n                StreamSupport.stream(\n                        Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED),\n                        false);\n        return targetStream.onClose(iteratorWrapper::close);\n    }\n","date":"2021-02-06 01:38:46","endLine":341,"groupId":"1088","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getKeys","params":"(Stringstate@Nnamespace)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/c7cff6886014f4a2bc5cce941fc09804affb67.src","preCode":"    public <N> Stream<K> getKeys(String state, N namespace) {\n        RocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n        if (columnInfo == null\n                || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n            return Stream.empty();\n        }\n\n        RegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n                (RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n        final TypeSerializer<N> namespaceSerializer =\n                registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n        final DataOutputSerializer namespaceOutputView = new DataOutputSerializer(8);\n        boolean ambiguousKeyPossible =\n                RocksDBKeySerializationUtils.isAmbiguousKeyPossible(\n                        getKeySerializer(), namespaceSerializer);\n        final byte[] nameSpaceBytes;\n        try {\n            RocksDBKeySerializationUtils.writeNameSpace(\n                    namespace, namespaceSerializer, namespaceOutputView, ambiguousKeyPossible);\n            nameSpaceBytes = namespaceOutputView.getCopyOfBuffer();\n        } catch (IOException ex) {\n            throw new FlinkRuntimeException(\"Failed to get keys from RocksDB state backend.\", ex);\n        }\n\n        RocksIteratorWrapper iterator =\n                RocksDBOperationUtils.getRocksIterator(\n                        db, columnInfo.columnFamilyHandle, readOptions);\n        iterator.seekToFirst();\n\n        final RocksStateKeysIterator<K> iteratorWrapper =\n                new RocksStateKeysIterator<>(\n                        iterator,\n                        state,\n                        getKeySerializer(),\n                        keyGroupPrefixBytes,\n                        ambiguousKeyPossible,\n                        nameSpaceBytes);\n\n        Stream<K> targetStream =\n                StreamSupport.stream(\n                        Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED),\n                        false);\n        return targetStream.onClose(iteratorWrapper::close);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":297,"status":"M"},{"authorDate":"2021-01-28 21:41:53","commitOrder":16,"curCode":"    public <N> Stream<Tuple2<K, N>> getKeysAndNamespaces(String state) {\n        RocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n        if (columnInfo == null\n                || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n            return Stream.empty();\n        }\n\n        RegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n                (RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n        final TypeSerializer<N> namespaceSerializer =\n                registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n        boolean ambiguousKeyPossible =\n                CompositeKeySerializationUtils.isAmbiguousKeyPossible(\n                        getKeySerializer(), namespaceSerializer);\n\n        RocksIteratorWrapper iterator =\n                RocksDBOperationUtils.getRocksIterator(\n                        db, columnInfo.columnFamilyHandle, readOptions);\n        iterator.seekToFirst();\n\n        final RocksStateKeysAndNamespaceIterator<K, N> iteratorWrapper =\n                new RocksStateKeysAndNamespaceIterator<>(\n                        iterator,\n                        state,\n                        getKeySerializer(),\n                        namespaceSerializer,\n                        keyGroupPrefixBytes,\n                        ambiguousKeyPossible);\n\n        Stream<Tuple2<K, N>> targetStream =\n                StreamSupport.stream(\n                        Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED),\n                        false);\n        return targetStream.onClose(iteratorWrapper::close);\n    }\n","date":"2021-02-06 01:38:46","endLine":379,"groupId":"1088","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getKeysAndNamespaces","params":"(Stringstate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/c7cff6886014f4a2bc5cce941fc09804affb67.src","preCode":"    public <N> Stream<Tuple2<K, N>> getKeysAndNamespaces(String state) {\n        RocksDbKvStateInfo columnInfo = kvStateInformation.get(state);\n        if (columnInfo == null\n                || !(columnInfo.metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo)) {\n            return Stream.empty();\n        }\n\n        RegisteredKeyValueStateBackendMetaInfo<N, ?> registeredKeyValueStateBackendMetaInfo =\n                (RegisteredKeyValueStateBackendMetaInfo<N, ?>) columnInfo.metaInfo;\n\n        final TypeSerializer<N> namespaceSerializer =\n                registeredKeyValueStateBackendMetaInfo.getNamespaceSerializer();\n        boolean ambiguousKeyPossible =\n                RocksDBKeySerializationUtils.isAmbiguousKeyPossible(\n                        getKeySerializer(), namespaceSerializer);\n\n        RocksIteratorWrapper iterator =\n                RocksDBOperationUtils.getRocksIterator(\n                        db, columnInfo.columnFamilyHandle, readOptions);\n        iterator.seekToFirst();\n\n        final RocksStateKeysAndNamespaceIterator<K, N> iteratorWrapper =\n                new RocksStateKeysAndNamespaceIterator<>(\n                        iterator,\n                        state,\n                        getKeySerializer(),\n                        namespaceSerializer,\n                        keyGroupPrefixBytes,\n                        ambiguousKeyPossible);\n\n        Stream<Tuple2<K, N>> targetStream =\n                StreamSupport.stream(\n                        Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED),\n                        false);\n        return targetStream.onClose(iteratorWrapper::close);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"M"}],"commitId":"a3436cb67866fddec45c9ac1bd760c24732ca32b","commitMessage":"@@@[refactor] Move RocksDBCompositeKeyBuilder to a common package\n","date":"2021-02-06 01:38:46","modifiedFileCount":"13","status":"M","submitter":"Dawid Wysakowicz"}]
