[{"authorTime":"2020-05-13 20:55:49","codes":[{"authorDate":"2020-05-13 20:55:49","commitOrder":1,"curCode":"\tpublic void testMaxRetry() throws Exception {\n\t\tformat = JdbcBatchingOutputFormat.builder()\n\t\t\t.setOptions(JdbcOptions.builder()\n\t\t\t\t.setDBUrl(getDbMetadata().getUrl())\n\t\t\t\t.setTableName(OUTPUT_TABLE)\n\t\t\t\t.build())\n\t\t\t.setFieldNames(fieldNames)\n\t\t\t.setKeyFields(null)\n\t\t\t.build();\n\t\tRuntimeContext context = Mockito.mock(RuntimeContext.class);\n\t\tExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n\t\tdoReturn(config).when(context).getExecutionConfig();\n\t\tdoReturn(true).when(config).isObjectReuseEnabled();\n\t\tformat.setRuntimeContext(context);\n\t\tformat.open(0, 1);\n\n\t\t\r\n\t\talterTable();\n\t\tfor (TestEntry entry : TEST_DATA) {\n\t\t\tformat.writeRecord(Tuple2.of(true, toRow(entry)));\n\t\t}\n\n\t\t\r\n\t\tformat.flush();\n\t}\n","date":"2020-05-13 20:55:49","endLine":84,"groupId":"50805","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaxRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c6/82ee59f13c9d68d1c1cab3ba6bd889b959abd4.src","preCode":"\tpublic void testMaxRetry() throws Exception {\n\t\tformat = JdbcBatchingOutputFormat.builder()\n\t\t\t.setOptions(JdbcOptions.builder()\n\t\t\t\t.setDBUrl(getDbMetadata().getUrl())\n\t\t\t\t.setTableName(OUTPUT_TABLE)\n\t\t\t\t.build())\n\t\t\t.setFieldNames(fieldNames)\n\t\t\t.setKeyFields(null)\n\t\t\t.build();\n\t\tRuntimeContext context = Mockito.mock(RuntimeContext.class);\n\t\tExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n\t\tdoReturn(config).when(context).getExecutionConfig();\n\t\tdoReturn(true).when(config).isObjectReuseEnabled();\n\t\tformat.setRuntimeContext(context);\n\t\tformat.open(0, 1);\n\n\t\t\r\n\t\talterTable();\n\t\tfor (TestEntry entry : TEST_DATA) {\n\t\t\tformat.writeRecord(Tuple2.of(true, toRow(entry)));\n\t\t}\n\n\t\t\r\n\t\tformat.flush();\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/test/java/org/apache/flink/connector/jdbc/table/JdbcAppendOnlyWriterTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"B"},{"authorDate":"2020-05-13 20:55:49","commitOrder":1,"curCode":"\tpublic void testJdbcOutputFormat() throws Exception {\n\t\tJdbcOptions options = JdbcOptions.builder()\n\t\t\t\t.setDBUrl(getDbMetadata().getUrl())\n\t\t\t\t.setTableName(OUTPUT_TABLE)\n\t\t\t\t.build();\n\t\tJdbcDmlOptions dmlOptions = JdbcDmlOptions.builder()\n\t\t\t\t.withTableName(options.getTableName()).withDialect(options.getDialect())\n\t\t\t\t.withFieldNames(fieldNames).withKeyFields(keyFields).build();\n\t\tformat = new TableJdbcUpsertOutputFormat(new SimpleJdbcConnectionProvider(options), dmlOptions, JdbcExecutionOptions.defaults());\n\t\tRuntimeContext context = Mockito.mock(RuntimeContext.class);\n\t\tExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n\t\tdoReturn(config).when(context).getExecutionConfig();\n\t\tdoReturn(true).when(config).isObjectReuseEnabled();\n\t\tformat.setRuntimeContext(context);\n\t\tformat.open(0, 1);\n\n\t\tfor (TestEntry entry : TEST_DATA) {\n\t\t\tformat.writeRecord(Tuple2.of(true, toRow(entry)));\n\t\t}\n\t\tformat.flush();\n\t\tcheck(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n\t\t\r\n\t\tfor (TestEntry entry : TEST_DATA) {\n\t\t\tformat.writeRecord(Tuple2.of(true, toRow(entry)));\n\t\t}\n\t\tformat.flush();\n\t\tcheck(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n\t\t\r\n\t\tfor (int i = 0; i < TEST_DATA.length / 2; i++) {\n\t\t\tformat.writeRecord(Tuple2.of(false, toRow(TEST_DATA[i])));\n\t\t}\n\t\tRow[] expected = new Row[TEST_DATA.length - TEST_DATA.length / 2];\n\t\tfor (int i = TEST_DATA.length / 2; i < TEST_DATA.length; i++) {\n\t\t\texpected[i - TEST_DATA.length / 2] = toRow(TEST_DATA[i]);\n\t\t}\n\t\tformat.flush();\n\t\tcheck(expected);\n\t}\n","date":"2020-05-13 20:55:49","endLine":107,"groupId":"6477","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJdbcOutputFormat","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2d/67a4de1f9fe28b6995cfa3cedfb168a8d31e6e.src","preCode":"\tpublic void testJdbcOutputFormat() throws Exception {\n\t\tJdbcOptions options = JdbcOptions.builder()\n\t\t\t\t.setDBUrl(getDbMetadata().getUrl())\n\t\t\t\t.setTableName(OUTPUT_TABLE)\n\t\t\t\t.build();\n\t\tJdbcDmlOptions dmlOptions = JdbcDmlOptions.builder()\n\t\t\t\t.withTableName(options.getTableName()).withDialect(options.getDialect())\n\t\t\t\t.withFieldNames(fieldNames).withKeyFields(keyFields).build();\n\t\tformat = new TableJdbcUpsertOutputFormat(new SimpleJdbcConnectionProvider(options), dmlOptions, JdbcExecutionOptions.defaults());\n\t\tRuntimeContext context = Mockito.mock(RuntimeContext.class);\n\t\tExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n\t\tdoReturn(config).when(context).getExecutionConfig();\n\t\tdoReturn(true).when(config).isObjectReuseEnabled();\n\t\tformat.setRuntimeContext(context);\n\t\tformat.open(0, 1);\n\n\t\tfor (TestEntry entry : TEST_DATA) {\n\t\t\tformat.writeRecord(Tuple2.of(true, toRow(entry)));\n\t\t}\n\t\tformat.flush();\n\t\tcheck(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n\t\t\r\n\t\tfor (TestEntry entry : TEST_DATA) {\n\t\t\tformat.writeRecord(Tuple2.of(true, toRow(entry)));\n\t\t}\n\t\tformat.flush();\n\t\tcheck(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n\t\t\r\n\t\tfor (int i = 0; i < TEST_DATA.length / 2; i++) {\n\t\t\tformat.writeRecord(Tuple2.of(false, toRow(TEST_DATA[i])));\n\t\t}\n\t\tRow[] expected = new Row[TEST_DATA.length - TEST_DATA.length / 2];\n\t\tfor (int i = TEST_DATA.length / 2; i < TEST_DATA.length; i++) {\n\t\t\texpected[i - TEST_DATA.length / 2] = toRow(TEST_DATA[i]);\n\t\t}\n\t\tformat.flush();\n\t\tcheck(expected);\n\t}\n","realPath":"flink-connectors/flink-connector-jdbc/src/test/java/org/apache/flink/connector/jdbc/internal/JdbcTableOutputFormatTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"B"}],"commitId":"6a6a439517b99d939758ef9275d40f88f5700c4a","commitMessage":"@@@[FLINK-17537][jdbc] Refactor flink-jdbc connector structure\n\n(1) Use Jdbc instead of JDBC.\n(2) Move interfaces and classes to org.apache.flink.connector.jdbc.\n(3) Keep ancient JDBCOutputFormat.  JDBCInputFormat and ParameterValuesProvider in old package.\n(4) Add tests/ITCase for ancient Classes and new classes.\n(5) rename flink-jdbc module to flink-connector-jdbc.\n(6) update docs.\n\nThis closes #12036","date":"2020-05-13 20:55:49","modifiedFileCount":"0","status":"B","submitter":"Leonard Xu"},{"authorTime":"2021-06-30 17:15:22","codes":[{"authorDate":"2021-06-30 17:15:22","commitOrder":2,"curCode":"    public void testMaxRetry() throws Exception {\n        format =\n                JdbcBatchingOutputFormat.builder()\n                        .setOptions(\n                                JdbcConnectorOptions.builder()\n                                        .setDBUrl(getDbMetadata().getUrl())\n                                        .setTableName(OUTPUT_TABLE)\n                                        .build())\n                        .setFieldNames(fieldNames)\n                        .setKeyFields(null)\n                        .build();\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        \r\n        alterTable();\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n\n        \r\n        format.flush();\n    }\n","date":"2021-07-12 18:56:17","endLine":84,"groupId":"50805","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMaxRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/4243e3668b5ac729db497da5a8c5cf8be05616.src","preCode":"    public void testMaxRetry() throws Exception {\n        format =\n                JdbcBatchingOutputFormat.builder()\n                        .setOptions(\n                                JdbcOptions.builder()\n                                        .setDBUrl(getDbMetadata().getUrl())\n                                        .setTableName(OUTPUT_TABLE)\n                                        .build())\n                        .setFieldNames(fieldNames)\n                        .setKeyFields(null)\n                        .build();\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        \r\n        alterTable();\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n\n        \r\n        format.flush();\n    }\n","realPath":"flink-connectors/flink-connector-jdbc/src/test/java/org/apache/flink/connector/jdbc/table/JdbcAppendOnlyWriterTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2021-06-30 17:15:22","commitOrder":2,"curCode":"    public void testJdbcOutputFormat() throws Exception {\n        JdbcConnectorOptions options =\n                JdbcConnectorOptions.builder()\n                        .setDBUrl(getDbMetadata().getUrl())\n                        .setTableName(OUTPUT_TABLE)\n                        .build();\n        JdbcDmlOptions dmlOptions =\n                JdbcDmlOptions.builder()\n                        .withTableName(options.getTableName())\n                        .withDialect(options.getDialect())\n                        .withFieldNames(fieldNames)\n                        .withKeyFields(keyFields)\n                        .build();\n        format =\n                new TableJdbcUpsertOutputFormat(\n                        new SimpleJdbcConnectionProvider(options),\n                        dmlOptions,\n                        JdbcExecutionOptions.defaults());\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (int i = 0; i < TEST_DATA.length / 2; i++) {\n            format.writeRecord(Tuple2.of(false, toRow(TEST_DATA[i])));\n        }\n        Row[] expected = new Row[TEST_DATA.length - TEST_DATA.length / 2];\n        for (int i = TEST_DATA.length / 2; i < TEST_DATA.length; i++) {\n            expected[i - TEST_DATA.length / 2] = toRow(TEST_DATA[i]);\n        }\n        format.flush();\n        check(expected);\n    }\n","date":"2021-07-12 18:56:17","endLine":137,"groupId":"6477","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testJdbcOutputFormat","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9c/1212d7e4e0ad708ad0d464cf4c7c7aafb8de17.src","preCode":"    public void testJdbcOutputFormat() throws Exception {\n        JdbcOptions options =\n                JdbcOptions.builder()\n                        .setDBUrl(getDbMetadata().getUrl())\n                        .setTableName(OUTPUT_TABLE)\n                        .build();\n        JdbcDmlOptions dmlOptions =\n                JdbcDmlOptions.builder()\n                        .withTableName(options.getTableName())\n                        .withDialect(options.getDialect())\n                        .withFieldNames(fieldNames)\n                        .withKeyFields(keyFields)\n                        .build();\n        format =\n                new TableJdbcUpsertOutputFormat(\n                        new SimpleJdbcConnectionProvider(options),\n                        dmlOptions,\n                        JdbcExecutionOptions.defaults());\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (int i = 0; i < TEST_DATA.length / 2; i++) {\n            format.writeRecord(Tuple2.of(false, toRow(TEST_DATA[i])));\n        }\n        Row[] expected = new Row[TEST_DATA.length - TEST_DATA.length / 2];\n        for (int i = TEST_DATA.length / 2; i < TEST_DATA.length; i++) {\n            expected[i - TEST_DATA.length / 2] = toRow(TEST_DATA[i]);\n        }\n        format.flush();\n        check(expected);\n    }\n","realPath":"flink-connectors/flink-connector-jdbc/src/test/java/org/apache/flink/connector/jdbc/internal/JdbcTableOutputFormatTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"M"}],"commitId":"00f92ba924297cb7aec0d48367c47923f4f3be0f","commitMessage":"@@@[FLINK-23064][connector-jdbc] Create PublicEvolving JdbcOptions\n","date":"2021-07-12 18:56:17","modifiedFileCount":"22","status":"M","submitter":"Ingo B?rk"},{"authorTime":"2021-06-30 17:15:22","codes":[{"authorDate":"2021-07-18 21:31:13","commitOrder":3,"curCode":"    public void testMaxRetry() throws Exception {\n        format =\n                JdbcOutputFormat.builder()\n                        .setOptions(\n                                JdbcConnectorOptions.builder()\n                                        .setDBUrl(getDbMetadata().getUrl())\n                                        .setTableName(OUTPUT_TABLE)\n                                        .build())\n                        .setFieldNames(fieldNames)\n                        .setKeyFields(null)\n                        .build();\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        \r\n        alterTable();\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n\n        \r\n        format.flush();\n    }\n","date":"2021-07-20 21:29:54","endLine":84,"groupId":"10419","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testMaxRetry","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/26/17832bbc81f9dcc4253eedf237353ba7fcd26d.src","preCode":"    public void testMaxRetry() throws Exception {\n        format =\n                JdbcBatchingOutputFormat.builder()\n                        .setOptions(\n                                JdbcConnectorOptions.builder()\n                                        .setDBUrl(getDbMetadata().getUrl())\n                                        .setTableName(OUTPUT_TABLE)\n                                        .build())\n                        .setFieldNames(fieldNames)\n                        .setKeyFields(null)\n                        .build();\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        \r\n        alterTable();\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n\n        \r\n        format.flush();\n    }\n","realPath":"flink-connectors/flink-connector-jdbc/src/test/java/org/apache/flink/connector/jdbc/table/JdbcAppendOnlyWriterTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2021-06-30 17:15:22","commitOrder":3,"curCode":"    public void testJdbcOutputFormat() throws Exception {\n        JdbcConnectorOptions options =\n                JdbcConnectorOptions.builder()\n                        .setDBUrl(getDbMetadata().getUrl())\n                        .setTableName(OUTPUT_TABLE)\n                        .build();\n        JdbcDmlOptions dmlOptions =\n                JdbcDmlOptions.builder()\n                        .withTableName(options.getTableName())\n                        .withDialect(options.getDialect())\n                        .withFieldNames(fieldNames)\n                        .withKeyFields(keyFields)\n                        .build();\n        format =\n                new TableJdbcUpsertOutputFormat(\n                        new SimpleJdbcConnectionProvider(options),\n                        dmlOptions,\n                        JdbcExecutionOptions.defaults());\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (int i = 0; i < TEST_DATA.length / 2; i++) {\n            format.writeRecord(Tuple2.of(false, toRow(TEST_DATA[i])));\n        }\n        Row[] expected = new Row[TEST_DATA.length - TEST_DATA.length / 2];\n        for (int i = TEST_DATA.length / 2; i < TEST_DATA.length; i++) {\n            expected[i - TEST_DATA.length / 2] = toRow(TEST_DATA[i]);\n        }\n        format.flush();\n        check(expected);\n    }\n","date":"2021-07-12 18:56:17","endLine":137,"groupId":"10419","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testJdbcOutputFormat","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9c/1212d7e4e0ad708ad0d464cf4c7c7aafb8de17.src","preCode":"    public void testJdbcOutputFormat() throws Exception {\n        JdbcConnectorOptions options =\n                JdbcConnectorOptions.builder()\n                        .setDBUrl(getDbMetadata().getUrl())\n                        .setTableName(OUTPUT_TABLE)\n                        .build();\n        JdbcDmlOptions dmlOptions =\n                JdbcDmlOptions.builder()\n                        .withTableName(options.getTableName())\n                        .withDialect(options.getDialect())\n                        .withFieldNames(fieldNames)\n                        .withKeyFields(keyFields)\n                        .build();\n        format =\n                new TableJdbcUpsertOutputFormat(\n                        new SimpleJdbcConnectionProvider(options),\n                        dmlOptions,\n                        JdbcExecutionOptions.defaults());\n        RuntimeContext context = Mockito.mock(RuntimeContext.class);\n        ExecutionConfig config = Mockito.mock(ExecutionConfig.class);\n        doReturn(config).when(context).getExecutionConfig();\n        doReturn(true).when(config).isObjectReuseEnabled();\n        format.setRuntimeContext(context);\n        format.open(0, 1);\n\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (TestEntry entry : TEST_DATA) {\n            format.writeRecord(Tuple2.of(true, toRow(entry)));\n        }\n        format.flush();\n        check(Arrays.stream(TEST_DATA).map(JdbcDataTestBase::toRow).toArray(Row[]::new));\n\n        \r\n        for (int i = 0; i < TEST_DATA.length / 2; i++) {\n            format.writeRecord(Tuple2.of(false, toRow(TEST_DATA[i])));\n        }\n        Row[] expected = new Row[TEST_DATA.length - TEST_DATA.length / 2];\n        for (int i = TEST_DATA.length / 2; i < TEST_DATA.length; i++) {\n            expected[i - TEST_DATA.length / 2] = toRow(TEST_DATA[i]);\n        }\n        format.flush();\n        check(expected);\n    }\n","realPath":"flink-connectors/flink-connector-jdbc/src/test/java/org/apache/flink/connector/jdbc/internal/JdbcTableOutputFormatTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"N"}],"commitId":"2702691aacb297421fc1b9f9ef7af90008bf4677","commitMessage":"@@@[hotfix][connectors/jdbc] Merge Batching and Abstract into JdbcOutputFormat\n\nCurrently.  AbstractJdbcOutputFormat is only extended by\nJdbcBatchingOutputFormat making support of object reuse\nmore complex than it could be (added in a subsequent\ncommit).\n","date":"2021-07-20 21:29:54","modifiedFileCount":"13","status":"M","submitter":"Roman Khachatryan"}]
