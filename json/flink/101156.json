[{"authorTime":"2021-03-17 21:56:01","codes":[{"authorDate":"2021-04-09 20:17:59","commitOrder":11,"curCode":"    private void setUpJobGraph(\n            final Class<? extends AbstractInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-04-12 20:34:25","endLine":310,"groupId":"17684","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpJobGraph","params":"(finalClass<?extendsAbstractInvokable>invokable@finalRestartStrategies.RestartStrategyConfigurationrestartStrategy)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b3/ac2c573224b72c4f81c856c4161f5f3d61e445.src","preCode":"    private void setUpJobGraph(\n            final Class<? extends AbstractInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterStopWithSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":257,"status":"B"},{"authorDate":"2021-03-17 21:56:01","commitOrder":11,"curCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-03-25 14:22:58","endLine":123,"groupId":"28651","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setUpWithCheckpointInterval","params":"(longcheckpointInterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/39/ea86225a88f17646066853b3c66d9b49fcd561.src","preCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTriggerSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"NB"}],"commitId":"30baa74b012ffa5e5e9ca149b18691467fc4911c","commitMessage":"@@@[FLINK-21031][checkpoint] Reenable JobMasterStopWithSavepointIT\n","date":"2021-04-12 20:34:25","modifiedFileCount":"0","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-05-19 23:32:09","codes":[{"authorDate":"2021-05-19 23:32:09","commitOrder":12,"curCode":"    private void setUpJobGraph(\n            final Class<? extends AbstractInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-05-26 06:21:03","endLine":314,"groupId":"17684","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpJobGraph","params":"(finalClass<?extendsAbstractInvokable>invokable@finalRestartStrategies.RestartStrategyConfigurationrestartStrategy)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/97/c8f017cdf92f3e879adbd744ce9d2c5e626f19.src","preCode":"    private void setUpJobGraph(\n            final Class<? extends AbstractInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterStopWithSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":260,"status":"M"},{"authorDate":"2021-05-19 23:32:09","commitOrder":12,"curCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-05-26 06:21:03","endLine":124,"groupId":"28651","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setUpWithCheckpointInterval","params":"(longcheckpointInterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6c/b55a44c71a1f765ed37608cdf15af480c1c67f.src","preCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTriggerSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"}],"commitId":"11f59bf60a0bab9f921cce9b43f75e57fb099a47","commitMessage":"@@@[FLINK-22684][runtime] Added ability to ignore in-flight data during the recovery\n","date":"2021-05-26 06:21:03","modifiedFileCount":"21","status":"M","submitter":"Anton Kalashnikov"},{"authorTime":"2021-05-19 23:32:09","codes":[{"authorDate":"2021-08-21 01:27:23","commitOrder":13,"curCode":"    private void setUpJobGraph(\n            final Class<? extends TaskInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-08-26 18:54:21","endLine":307,"groupId":"17684","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"setUpJobGraph","params":"(finalClass<?extendsTaskInvokable>invokable@finalRestartStrategies.RestartStrategyConfigurationrestartStrategy)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5a/98d140c927d7ef470d13bd087b94865fdf8ff4.src","preCode":"    private void setUpJobGraph(\n            final Class<? extends AbstractInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterStopWithSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"},{"authorDate":"2021-05-19 23:32:09","commitOrder":13,"curCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-05-26 06:21:03","endLine":124,"groupId":"28651","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setUpWithCheckpointInterval","params":"(longcheckpointInterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6c/b55a44c71a1f765ed37608cdf15af480c1c67f.src","preCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTriggerSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"a8ea3c3e81517f9c38f90b82c043136d8b56bf8b","commitMessage":"@@@[FLINK-23862][runtime] Replace usages of AbstractInvokable with interface\n\nA follow-up step after introduction of task interfaces to:\n- accept TaskInvokable in place of AbstractInvokable\n- make StreamTask implement the interfaces directly\n","date":"2021-08-26 18:54:21","modifiedFileCount":"29","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2021-08-31 13:32:19","codes":[{"authorDate":"2021-08-31 13:32:19","commitOrder":14,"curCode":"    private void setUpJobGraph(\n            final Class<? extends TaskInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-09-03 17:04:01","endLine":306,"groupId":"101156","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"setUpJobGraph","params":"(finalClass<?extendsTaskInvokable>invokable@finalRestartStrategies.RestartStrategyConfigurationrestartStrategy)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/21/64968dca27413e76b8f436b0184911e497ed49.src","preCode":"    private void setUpJobGraph(\n            final Class<? extends TaskInvokable> invokable,\n            final RestartStrategies.RestartStrategyConfiguration restartStrategy)\n            throws Exception {\n\n        finishingLatch = new OneShotLatch();\n\n        invokeLatch = new CountDownLatch(PARALLELISM);\n\n        numberOfRestarts = new CountDownLatch(2);\n        checkpointsToWaitFor = new CountDownLatch(10);\n\n        syncSavepointId.set(-1);\n\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final ExecutionConfig config = new ExecutionConfig();\n        config.setRestartStrategy(restartStrategy);\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(invokable);\n        vertex.setParallelism(PARALLELISM);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                CHECKPOINT_INTERVAL,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .setExecutionConfig(config)\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterStopWithSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"},{"authorDate":"2021-08-31 13:32:19","commitOrder":14,"curCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","date":"2021-09-03 17:04:01","endLine":123,"groupId":"101156","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"setUpWithCheckpointInterval","params":"(longcheckpointInterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0e/3e7543b6836a21ade16ea1327a1bcbe51bbcc6.src","preCode":"    private void setUpWithCheckpointInterval(long checkpointInterval) throws Exception {\n        invokeLatch = new CountDownLatch(1);\n        triggerCheckpointLatch = new CountDownLatch(1);\n        savepointDirectory = temporaryFolder.newFolder().toPath();\n\n        Assume.assumeTrue(\n                \"ClusterClient is not an instance of MiniClusterClient\",\n                miniClusterResource.getClusterClient() instanceof MiniClusterClient);\n\n        clusterClient = (MiniClusterClient) miniClusterResource.getClusterClient();\n\n        final JobVertex vertex = new JobVertex(\"testVertex\");\n        vertex.setInvokableClass(NoOpBlockingInvokable.class);\n        vertex.setParallelism(1);\n\n        final JobCheckpointingSettings jobCheckpointingSettings =\n                new JobCheckpointingSettings(\n                        new CheckpointCoordinatorConfiguration(\n                                checkpointInterval,\n                                60_000,\n                                10,\n                                1,\n                                CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,\n                                true,\n                                false,\n                                false,\n                                0,\n                                0),\n                        null);\n\n        jobGraph =\n                JobGraphBuilder.newStreamingJobGraphBuilder()\n                        .addJobVertex(vertex)\n                        .setJobCheckpointingSettings(jobCheckpointingSettings)\n                        .build();\n\n        clusterClient.submitJob(jobGraph).get();\n        assertTrue(invokeLatch.await(60, TimeUnit.SECONDS));\n        waitForJob();\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTriggerSavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"}],"commitId":"eb8c21c12d60db2e579d88e465df0cdbeccba74b","commitMessage":"@@@[FLINK-20427] Remove configuration option to prefer checkpoints over newer savepoints\n","date":"2021-09-03 17:04:01","modifiedFileCount":"29","status":"M","submitter":"Nicolaus Weidner"}]
