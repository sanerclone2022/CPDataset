[{"authorTime":"2021-01-21 19:45:02","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":4,"curCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","date":"2020-12-28 21:35:13","endLine":177,"groupId":"2964","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createCheckpointStreamSupplier","params":"(longcheckpointId@CheckpointStreamFactoryprimaryStreamFactory@CheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/b31e1537f63941472408e10ab3dcc938d8eb2c.src","preCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/snapshot/RocksFullSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"NB"},{"authorDate":"2021-01-21 19:45:02","commitOrder":4,"curCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","date":"2021-01-26 18:40:06","endLine":214,"groupId":"2964","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"asyncSnapshot","params":"(HeapSnapshotResourcessyncPartResource@longcheckpointId@longtimestamp@@NonnullCheckpointStreamFactorystreamFactory@@NonnullCheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/bc/9923a523f4261b8105aa1cf723b50f047baa98.src","preCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"B"}],"commitId":"8778f56a469108cf3a3424a3ae5180b95fb2cfa3","commitMessage":"@@@[FLINK-21072] Refactor the SnapshotStrategy hierarchy\n\n1. The refactoring simplifies the snapshot strategy hierarchy a bit.\n\n2. It extracts the synchronous/asynchronous execution out of the SnapshotStrategy to a separate SnapshotStrategyRunner. Prior to those changes the logic was duplicated in most of the strategies.\n\n3. It introduces the concept of SnapshotResources for the synchronous part which can be later on used for introducing a common SavepointSnapshotResources.\n\nThis closes #14719\n","date":"2021-01-26 18:40:06","modifiedFileCount":"17","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-01-14 00:24:32","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":5,"curCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","date":"2020-12-28 21:35:13","endLine":177,"groupId":"2964","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createCheckpointStreamSupplier","params":"(longcheckpointId@CheckpointStreamFactoryprimaryStreamFactory@CheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/b31e1537f63941472408e10ab3dcc938d8eb2c.src","preCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/snapshot/RocksFullSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"N"},{"authorDate":"2021-01-14 00:24:32","commitOrder":5,"curCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","date":"2021-02-06 01:38:47","endLine":215,"groupId":"2964","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"asyncSnapshot","params":"(HeapSnapshotResourcessyncPartResource@longcheckpointId@longtimestamp@@NonnullCheckpointStreamFactorystreamFactory@@NonnullCheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fe/48c9076f2635cec422c37a76af47a309ab5754.src","preCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"M"}],"commitId":"6d1e386e808ddbd211bc2b0daaa441c82e2cd1ae","commitMessage":"@@@[FLINK-20978] Implement SavepointKeyedStateHandle\n\nIntroduce a marker SavepointKeyedStateHandle interface for state handles that describe savepoints. Based on the interface we can later decide which strategy to use when restoring from the handle.\n","date":"2021-02-06 01:38:47","modifiedFileCount":"7","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-01-27 19:34:27","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":6,"curCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","date":"2020-12-28 21:35:13","endLine":177,"groupId":"2964","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createCheckpointStreamSupplier","params":"(longcheckpointId@CheckpointStreamFactoryprimaryStreamFactory@CheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/b31e1537f63941472408e10ab3dcc938d8eb2c.src","preCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/snapshot/RocksFullSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"N"},{"authorDate":"2021-01-27 19:34:27","commitOrder":6,"curCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources<K> syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        syncPartResource.getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","date":"2021-02-10 01:34:42","endLine":183,"groupId":"2964","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"asyncSnapshot","params":"(HeapSnapshotResources<K>syncPartResource@longcheckpointId@longtimestamp@@NonnullCheckpointStreamFactorystreamFactory@@NonnullCheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/78/b96e5e507a7d7e37c458b42bda1c59d3fcdf6c.src","preCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"}],"commitId":"fc995d3af957941e0e16e56e6830ef97acbadfd1","commitMessage":"@@@[FLINK-21206] Write savepoints in unified format from HeapStateBackend\n\nThis closes #14809\n","date":"2021-02-10 01:34:42","modifiedFileCount":"4","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-02-10 23:31:06","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":7,"curCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","date":"2020-12-28 21:35:13","endLine":177,"groupId":"2964","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"createCheckpointStreamSupplier","params":"(longcheckpointId@CheckpointStreamFactoryprimaryStreamFactory@CheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/b31e1537f63941472408e10ab3dcc938d8eb2c.src","preCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/snapshot/RocksFullSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"N"},{"authorDate":"2021-02-10 23:31:06","commitOrder":7,"curCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","date":"2021-02-10 23:31:06","endLine":215,"groupId":"2964","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"asyncSnapshot","params":"(HeapSnapshotResourcessyncPartResource@longcheckpointId@longtimestamp@@NonnullCheckpointStreamFactorystreamFactory@@NonnullCheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fe/48c9076f2635cec422c37a76af47a309ab5754.src","preCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources<K> syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        syncPartResource.getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"M"}],"commitId":"3187c3431039c261b81fd641a157c6fb1e37a4bb","commitMessage":"@@@Revert \"[FLINK-21206] Write savepoints in unified format from HeapStateBackend\"\n\nThis reverts commit fc995d3af957941e0e16e56e6830ef97acbadfd1.\n","date":"2021-02-10 23:31:06","modifiedFileCount":"4","status":"M","submitter":"Dawid Wysakowicz"},{"authorTime":"2021-01-27 19:34:27","codes":[{"authorDate":"2020-12-28 21:30:59","commitOrder":8,"curCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","date":"2020-12-28 21:35:13","endLine":177,"groupId":"1098","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"createCheckpointStreamSupplier","params":"(longcheckpointId@CheckpointStreamFactoryprimaryStreamFactory@CheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6d/b31e1537f63941472408e10ab3dcc938d8eb2c.src","preCode":"            createCheckpointStreamSupplier(\n                    long checkpointId,\n                    CheckpointStreamFactory primaryStreamFactory,\n                    CheckpointOptions checkpointOptions) {\n\n        return localRecoveryConfig.isLocalRecoveryEnabled()\n                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                ? () ->\n                        CheckpointStreamWithResultProvider.createDuplicatingStream(\n                                checkpointId,\n                                CheckpointedStateScope.EXCLUSIVE,\n                                primaryStreamFactory,\n                                localRecoveryConfig.getLocalStateDirectoryProvider())\n                : () ->\n                        CheckpointStreamWithResultProvider.createSimpleStream(\n                                CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory);\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/snapshot/RocksFullSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"N"},{"authorDate":"2021-01-27 19:34:27","commitOrder":8,"curCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources<K> syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        syncPartResource.getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","date":"2021-02-22 18:44:11","endLine":183,"groupId":"1098","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"asyncSnapshot","params":"(HeapSnapshotResources<K>syncPartResource@longcheckpointId@longtimestamp@@NonnullCheckpointStreamFactorystreamFactory@@NonnullCheckpointOptionscheckpointOptions)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/78/b96e5e507a7d7e37c458b42bda1c59d3fcdf6c.src","preCode":"    public SnapshotResultSupplier<KeyedStateHandle> asyncSnapshot(\n            HeapSnapshotResources syncPartResource,\n            long checkpointId,\n            long timestamp,\n            @Nonnull CheckpointStreamFactory streamFactory,\n            @Nonnull CheckpointOptions checkpointOptions) {\n\n        List<StateMetaInfoSnapshot> metaInfoSnapshots = syncPartResource.getMetaInfoSnapshots();\n        if (metaInfoSnapshots.isEmpty()) {\n            return snapshotCloseableRegistry -> SnapshotResult.empty();\n        }\n\n        final KeyedBackendSerializationProxy<K> serializationProxy =\n                new KeyedBackendSerializationProxy<>(\n                        \r\n                        \r\n                        \r\n                        getKeySerializer(),\n                        metaInfoSnapshots,\n                        !Objects.equals(\n                                UncompressedStreamCompressionDecorator.INSTANCE,\n                                keyGroupCompressionDecorator));\n\n        final SupplierWithException<CheckpointStreamWithResultProvider, Exception>\n                checkpointStreamSupplier =\n                        localRecoveryConfig.isLocalRecoveryEnabled()\n                                        && !checkpointOptions.getCheckpointType().isSavepoint()\n                                ? () ->\n                                        createDuplicatingStream(\n                                                checkpointId,\n                                                CheckpointedStateScope.EXCLUSIVE,\n                                                streamFactory,\n                                                localRecoveryConfig\n                                                        .getLocalStateDirectoryProvider())\n                                : () ->\n                                        createSimpleStream(\n                                                CheckpointedStateScope.EXCLUSIVE, streamFactory);\n\n        return (snapshotCloseableRegistry) -> {\n            final Map<StateUID, Integer> stateNamesToId = syncPartResource.getStateNamesToId();\n            final Map<StateUID, StateSnapshot> cowStateStableSnapshots =\n                    syncPartResource.getCowStateStableSnapshots();\n            final CheckpointStreamWithResultProvider streamWithResultProvider =\n                    checkpointStreamSupplier.get();\n\n            snapshotCloseableRegistry.registerCloseable(streamWithResultProvider);\n\n            final CheckpointStreamFactory.CheckpointStateOutputStream localStream =\n                    streamWithResultProvider.getCheckpointOutputStream();\n\n            final DataOutputViewStreamWrapper outView =\n                    new DataOutputViewStreamWrapper(localStream);\n            serializationProxy.write(outView);\n\n            final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()];\n\n            for (int keyGroupPos = 0;\n                    keyGroupPos < keyGroupRange.getNumberOfKeyGroups();\n                    ++keyGroupPos) {\n                int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n                keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n                outView.writeInt(keyGroupId);\n\n                for (Map.Entry<StateUID, StateSnapshot> stateSnapshot :\n                        cowStateStableSnapshots.entrySet()) {\n                    StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                            stateSnapshot.getValue().getKeyGroupWriter();\n                    try (OutputStream kgCompressionOut =\n                            keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n                        DataOutputViewStreamWrapper kgCompressionView =\n                                new DataOutputViewStreamWrapper(kgCompressionOut);\n                        kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n                        partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n                    } \r\n                }\n            }\n\n            if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {\n                KeyGroupRangeOffsets kgOffs =\n                        new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets);\n                SnapshotResult<StreamStateHandle> result =\n                        streamWithResultProvider.closeAndFinalizeCheckpointStreamResult();\n                return toKeyedStateHandleSnapshotResult(result, kgOffs, KeyGroupsStateHandle::new);\n            } else {\n                throw new IOException(\"Stream already unregistered.\");\n            }\n        };\n    }\n","realPath":"flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapSnapshotStrategy.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"}],"commitId":"7564c810e55f952ea7014a707c9487b777131c2d","commitMessage":"@@@[FLINK-21206] Write savepoints in unified format from HeapStateBackend\n\nThis closes #14925\n","date":"2021-02-22 18:44:11","modifiedFileCount":"4","status":"M","submitter":"Dawid Wysakowicz"}]
