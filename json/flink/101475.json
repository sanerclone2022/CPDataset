[{"authorTime":"2016-06-11 08:14:07","codes":[{"authorDate":"2016-06-11 08:14:07","commitOrder":1,"curCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2016-07-05 21:51:06","endLine":430,"groupId":"13828","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/9c140cdf7d2a582682abc077338a1342c3c192.src","preCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"B"},{"authorDate":"2016-06-11 08:14:07","commitOrder":1,"curCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2016-07-05 21:51:06","endLine":493,"groupId":"13829","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithDecreasingCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/9c140cdf7d2a582682abc077338a1342c3c192.src","preCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":437,"status":"B"}],"commitId":"b9f42e91c9415dd6063079df00c142334b74e636","commitMessage":"@@@[FLINK-3995] [build] flink-test-utils also contains the streaming test utilities.\n\nTest utilities include the StreamingMultipleProgramsTestBase and StreamingTestEnvironment.\n\nThis moves the ITCases for streaming into 'flink-tests' to achieve that.\n\nThis closes #2092\n","date":"2016-07-05 21:51:06","modifiedFileCount":"12","status":"B","submitter":"Stephan Ewen"},{"authorTime":"2017-03-17 00:03:03","codes":[{"authorDate":"2017-03-17 00:03:03","commitOrder":2,"curCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2017-05-05 17:06:07","endLine":433,"groupId":"13828","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/686ef9bf50b05bc7903d837cf49625258932f9.src","preCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":378,"status":"M"},{"authorDate":"2017-03-17 00:03:03","commitOrder":2,"curCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2017-05-05 17:06:07","endLine":496,"groupId":"13829","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithDecreasingCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/686ef9bf50b05bc7903d837cf49625258932f9.src","preCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment(\"localhost\", cluster.getLeaderRPCPort());\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":440,"status":"M"}],"commitId":"ddd6a99a95b56c52ea5b5153b7270b578f5479bc","commitMessage":"@@@[FLINK-6078] Remove CuratorFramework#close calls from ZooKeeper based HA services\n\nRemove client less factory methods from ZooKeeperUtils\n\nIntroduce default job id\n\nThis closes #3781.\n","date":"2017-05-05 17:06:07","modifiedFileCount":"114","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2017-05-31 03:40:47","codes":[{"authorDate":"2017-05-31 03:40:47","commitOrder":3,"curCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2017-07-13 06:37:47","endLine":424,"groupId":"13828","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/1dd2a277e4a23e23754ab815593c797239a170.src","preCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"M"},{"authorDate":"2017-05-31 03:40:47","commitOrder":3,"curCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2017-07-13 06:37:47","endLine":484,"groupId":"13829","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithDecreasingCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/1dd2a277e4a23e23754ab815593c797239a170.src","preCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int NUM_ELEMENTS = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= NUM_ELEMENTS) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < NUM_ELEMENTS; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":430,"status":"M"}],"commitId":"9bd491e05120915cbde36d4452e3982fe5d0975f","commitMessage":"@@@[FLINK-6731] [tests] Activate strict checkstyle for flink-tests\n\nThis closes #4295\n","date":"2017-07-13 06:37:47","modifiedFileCount":"185","status":"M","submitter":"Greg Hogan"},{"authorTime":"2019-08-21 16:38:00","codes":[{"authorDate":"2019-08-21 16:38:00","commitOrder":4,"curCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2019-08-27 20:27:23","endLine":415,"groupId":"13828","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/effd746caff206ca3fec2db008e387c615e52a.src","preCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":363,"status":"M"},{"authorDate":"2019-08-21 16:38:00","commitOrder":4,"curCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2019-08-27 20:27:23","endLine":474,"groupId":"13829","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithDecreasingCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/effd746caff206ca3fec2db008e387c615e52a.src","preCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\t\tenv.getConfig().disableSysoutLogging();\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":421,"status":"M"}],"commitId":"c30e84fb8df9cb6ab6a38cde40b9c3b83c4e8954","commitMessage":"@@@[FLINK-13794][client] Remove unused logic of printStatusDuringExecution\n","date":"2019-08-27 20:27:23","modifiedFileCount":"67","status":"M","submitter":"tison"},{"authorTime":"2020-09-29 02:16:11","codes":[{"authorDate":"2020-09-29 02:16:11","commitOrder":5,"curCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2020-10-01 23:03:45","endLine":411,"groupId":"101475","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testTimestampExtractorWithCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/0570f50a3e909fdb2676b5e0aafaeea094d100.src","preCode":"\tpublic void testTimestampExtractorWithCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(10);\n\t\tenv.setParallelism(1);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long currentTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"M"},{"authorDate":"2020-09-29 02:16:11","commitOrder":5,"curCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","date":"2020-10-01 23:03:45","endLine":469,"groupId":"101475","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testTimestampExtractorWithDecreasingCustomWatermarkEmit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d6/0570f50a3e909fdb2676b5e0aafaeea094d100.src","preCode":"\tpublic void testTimestampExtractorWithDecreasingCustomWatermarkEmit() throws Exception {\n\t\tfinal int numElements = 10;\n\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n\t\tenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\t\tenv.getConfig().setAutoWatermarkInterval(1);\n\t\tenv.setParallelism(1);\n\n\t\tDataStream<Integer> source1 = env.addSource(new SourceFunction<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void run(SourceContext<Integer> ctx) throws Exception {\n\t\t\t\tint index = 1;\n\t\t\t\twhile (index <= numElements) {\n\t\t\t\t\tctx.collect(index);\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\tctx.collect(index - 1);\n\t\t\t\t\tlatch.await();\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void cancel() {}\n\t\t});\n\n\t\tsource1\n\t\t\t\t.assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks<Integer>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long extractTimestamp(Integer element, long previousTimestamp) {\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Watermark checkAndGetNextWatermark(Integer element, long extractedTimestamp) {\n\t\t\t\t\t\treturn new Watermark(extractedTimestamp - 1);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.transform(\"Watermark Check\", BasicTypeInfo.INT_TYPE_INFO, new CustomOperator(true))\n\t\t\t\t.transform(\"Timestamp Check\", BasicTypeInfo.INT_TYPE_INFO, new TimestampCheckingOperator());\n\n\t\tenv.execute();\n\n\t\t\r\n\t\tfor (int j = 0; j < numElements; j++) {\n\t\t\tif (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j))) {\n\t\t\t\tAssert.fail(\"Wrong watermark.\");\n\t\t\t}\n\t\t}\n\t\t\r\n\t\tassertEquals(Watermark.MAX_WATERMARK,\n\t\t\t\tCustomOperator.finalWatermarks[0].get(CustomOperator.finalWatermarks[0].size() - 1));\n\t}\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/TimestampITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"}],"commitId":"cb4de07a4004b46702edf7809f8a556866fe3da1","commitMessage":"@@@[FLINK-19317] Remove unnecessary calls to setStreamTimeCharacteristic (java)\n\nI'm just removing calls the set EventTime because that's the new default\nnow.\n\nI'm also removing most calls to set ProcessingTime because it's not\nneeded for making processing-time timers/windows work. I only left it\nfor some tests that check specific failure behavior.\n\nI removed calls to set IngestionTime and replaced them by an explicit\nIngestionTimeWatermarkStrategy. I duplicated the same\nIngestionTimeWatermarkStrategy in all the examples/tests because I\nexplicitly didn't want to add an IngestionTimeWatermarkStrategy in one\nof the core packages so that it is not discoverable because I think we\nshouldn't encourage users to use ingestion time.\n","date":"2020-10-01 23:03:45","modifiedFileCount":"30","status":"M","submitter":"Aljoscha Krettek"}]
