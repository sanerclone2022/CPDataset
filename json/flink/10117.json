[{"authorTime":"2019-08-20 22:12:01","codes":[{"authorDate":"2019-08-20 22:12:01","commitOrder":1,"curCode":"\tpublic void testPhysicallyRemoveDuringSyncPartOfSnapshot() throws IOException {\n\t\tTestAllocator spaceAllocator = new TestAllocator(256);\n\t\t\r\n\t\tCopyOnWriteSkipListStateMap<Integer, Long, String> stateMap =\n\t\t\tcreateEmptyStateMap(0, 0.0f, spaceAllocator);\n\n\t\t\r\n\t\tMap<Long, Map<Integer, String>> referenceStates = new HashMap<>();\n\t\tint totalStateSize = 0;\n\t\tint totalSizeIncludingLogicallyRemovedStates = 0;\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\ttotalStateSize++;\n\t\t\ttotalSizeIncludingLogicallyRemovedStates++;\n\t\t\tstateMap.put(i, (long) i, String.valueOf(i));\n\t\t\taddToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tassertEquals(totalStateSize * 2, spaceAllocator.getTotalSpaceNumber());\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot1 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\ttotalStateSize--;\n\t\t\tstateMap.remove(i, (long) i);\n\t\t\tremoveFromReferenceState(referenceStates, i, (long) i);\n\t\t}\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n\t\tassertEquals(0, totalStateSize);\n\t\tassertEquals(totalStateSize, stateMap.size());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates, stateMap.totalSize());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates, stateMap.getLogicallyRemovedNodes().size());\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot1.release();\n\n\t\t\r\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot2 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot2 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tint totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot = 0;\n\t\tassertEquals(totalStateSize, stateMap.totalSize());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot, stateMap.totalSize());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot,\n\t\t\tstateMap.getLogicallyRemovedNodes().size());\n\t\tassertEquals(0, spaceAllocator.getTotalSpaceNumber());\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot2, snapshot2, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot2.release();\n\n\t\tassertEquals(0, stateMap.size());\n\t\tassertEquals(0, stateMap.totalSize());\n\t\tassertEquals(0, spaceAllocator.getTotalSpaceNumber());\n\t\tassertFalse(stateMap.iterator().hasNext());\n\n\t\tstateMap.close();\n\t}\n","date":"2019-11-08 01:31:48","endLine":590,"groupId":"4332","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testPhysicallyRemoveDuringSyncPartOfSnapshot","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/6fe49197aabf19fb64d830832a29536d6afe99.src","preCode":"\tpublic void testPhysicallyRemoveDuringSyncPartOfSnapshot() throws IOException {\n\t\tTestAllocator spaceAllocator = new TestAllocator(256);\n\t\t\r\n\t\tCopyOnWriteSkipListStateMap<Integer, Long, String> stateMap =\n\t\t\tcreateEmptyStateMap(0, 0.0f, spaceAllocator);\n\n\t\t\r\n\t\tMap<Long, Map<Integer, String>> referenceStates = new HashMap<>();\n\t\tint totalStateSize = 0;\n\t\tint totalSizeIncludingLogicallyRemovedStates = 0;\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\ttotalStateSize++;\n\t\t\ttotalSizeIncludingLogicallyRemovedStates++;\n\t\t\tstateMap.put(i, (long) i, String.valueOf(i));\n\t\t\taddToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tassertEquals(totalStateSize * 2, spaceAllocator.getTotalSpaceNumber());\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot1 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\ttotalStateSize--;\n\t\t\tstateMap.remove(i, (long) i);\n\t\t\tremoveFromReferenceState(referenceStates, i, (long) i);\n\t\t}\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n\t\tassertEquals(0, totalStateSize);\n\t\tassertEquals(totalStateSize, stateMap.size());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates, stateMap.totalSize());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates, stateMap.getLogicallyRemovedNodes().size());\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot1.release();\n\n\t\t\r\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot2 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot2 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tint totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot = 0;\n\t\tassertEquals(totalStateSize, stateMap.totalSize());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot, stateMap.totalSize());\n\t\tassertEquals(totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot,\n\t\t\tstateMap.getLogicallyRemovedNodes().size());\n\t\tassertEquals(0, spaceAllocator.getTotalSpaceNumber());\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot2, snapshot2, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot2.release();\n\n\t\tassertEquals(0, stateMap.size());\n\t\tassertEquals(0, stateMap.totalSize());\n\t\tassertEquals(0, spaceAllocator.getTotalSpaceNumber());\n\t\tassertFalse(stateMap.iterator().hasNext());\n\n\t\tstateMap.close();\n\t}\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapComplexOpTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":523,"status":"B"},{"authorDate":"2019-08-20 22:12:01","commitOrder":1,"curCode":"\tprivate void prepareLogicallyRemovedStates(\n\t\tMap<Long, Map<Integer, String>> referenceStates,\n\t\tCopyOnWriteSkipListStateMap<Integer, Long, String> stateMap,\n\t\tTypeSerializer<Integer> keySerializer,\n\t\tTypeSerializer<Long> namespaceSerializer,\n\t\tTypeSerializer<String> stateSerializer) throws IOException {\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.put(i, (long) i, String.valueOf(i));\n\t\t\taddToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot1 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.remove(i, (long) i);\n\t\t\tremoveFromReferenceState(referenceStates, i, (long) i);\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot1.release();\n\t}\n","date":"2019-11-08 01:31:48","endLine":848,"groupId":"25305","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"prepareLogicallyRemovedStates","params":"(Map<Long@Map<Integer@String>>referenceStates@CopyOnWriteSkipListStateMap<Integer@Long@String>stateMap@TypeSerializer<Integer>keySerializer@TypeSerializer<Long>namespaceSerializer@TypeSerializer<String>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/6fe49197aabf19fb64d830832a29536d6afe99.src","preCode":"\tprivate void prepareLogicallyRemovedStates(\n\t\tMap<Long, Map<Integer, String>> referenceStates,\n\t\tCopyOnWriteSkipListStateMap<Integer, Long, String> stateMap,\n\t\tTypeSerializer<Integer> keySerializer,\n\t\tTypeSerializer<Long> namespaceSerializer,\n\t\tTypeSerializer<String> stateSerializer) throws IOException {\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.put(i, (long) i, String.valueOf(i));\n\t\t\taddToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot1 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.remove(i, (long) i);\n\t\t\tremoveFromReferenceState(referenceStates, i, (long) i);\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot1.release();\n\t}\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapComplexOpTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":822,"status":"B"}],"commitId":"525f3c9c45f8534f1782986781140473909116a8","commitMessage":"@@@[FLINK-12697][state backends] Support on-disk state storage for spill-able heap backend\n","date":"2019-11-08 01:31:48","modifiedFileCount":"4","status":"B","submitter":"Yu Li"},{"authorTime":"2019-08-20 22:12:01","codes":[{"authorDate":"2021-01-28 04:04:38","commitOrder":2,"curCode":"    private void testPhysicallyRemoveDuringSyncPartOfSnapshot(\n            SnapshotVerificationMode verificationMode) throws IOException {\n        TestAllocator spaceAllocator = new TestAllocator(256);\n        \r\n        \r\n        CopyOnWriteSkipListStateMap<Integer, Long, String> stateMap =\n                createEmptyStateMap(0, 0.0f, spaceAllocator);\n\n        \r\n        Map<Long, Map<Integer, String>> referenceStates = new HashMap<>();\n        int totalStateSize = 0;\n        int totalSizeIncludingLogicallyRemovedStates = 0;\n\n        \r\n        for (int i = 1; i <= 100; i++) {\n            totalStateSize++;\n            totalSizeIncludingLogicallyRemovedStates++;\n            stateMap.put(i, (long) i, String.valueOf(i));\n            addToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n        }\n        verifyState(referenceStates, stateMap);\n\n        assertEquals(totalStateSize * 2, spaceAllocator.getTotalSpaceNumber());\n\n        Map<Long, Map<Integer, String>> expectedSnapshot1 =\n                snapshotReferenceStates(referenceStates);\n        CopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 =\n                stateMap.stateSnapshot();\n\n        \r\n        for (int i = 1; i <= 100; i++) {\n            totalStateSize--;\n            stateMap.remove(i, (long) i);\n            removeFromReferenceState(referenceStates, i, (long) i);\n        }\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n        assertEquals(0, totalStateSize);\n        assertEquals(totalStateSize, stateMap.size());\n        assertEquals(totalSizeIncludingLogicallyRemovedStates, stateMap.totalSize());\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStates,\n                stateMap.getLogicallyRemovedNodes().size());\n        verifyState(referenceStates, stateMap);\n\n        verifySnapshotWithoutTransform(\n                expectedSnapshot1,\n                snapshot1,\n                keySerializer,\n                namespaceSerializer,\n                stateSerializer,\n                verificationMode);\n        snapshot1.release();\n\n        \r\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n        verifyState(referenceStates, stateMap);\n\n        Map<Long, Map<Integer, String>> expectedSnapshot2 =\n                snapshotReferenceStates(referenceStates);\n        CopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot2 =\n                stateMap.stateSnapshot();\n\n        \r\n        int totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot = 0;\n        assertEquals(totalStateSize, stateMap.totalSize());\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot, stateMap.totalSize());\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot,\n                stateMap.getLogicallyRemovedNodes().size());\n        assertEquals(0, spaceAllocator.getTotalSpaceNumber());\n\n        verifySnapshotWithoutTransform(\n                expectedSnapshot2,\n                snapshot2,\n                keySerializer,\n                namespaceSerializer,\n                stateSerializer,\n                verificationMode);\n        snapshot2.release();\n\n        assertEquals(0, stateMap.size());\n        assertEquals(0, stateMap.totalSize());\n        assertEquals(0, spaceAllocator.getTotalSpaceNumber());\n        assertFalse(stateMap.iterator().hasNext());\n\n        stateMap.close();\n    }\n","date":"2021-01-29 06:00:51","endLine":643,"groupId":"10117","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testPhysicallyRemoveDuringSyncPartOfSnapshot","params":"(SnapshotVerificationModeverificationMode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/76/d909fb1f700354c8aff028d9ac6fe80ab0ee8d.src","preCode":"    public void testPhysicallyRemoveDuringSyncPartOfSnapshot() throws IOException {\n        TestAllocator spaceAllocator = new TestAllocator(256);\n        \r\n        \r\n        CopyOnWriteSkipListStateMap<Integer, Long, String> stateMap =\n                createEmptyStateMap(0, 0.0f, spaceAllocator);\n\n        \r\n        Map<Long, Map<Integer, String>> referenceStates = new HashMap<>();\n        int totalStateSize = 0;\n        int totalSizeIncludingLogicallyRemovedStates = 0;\n\n        \r\n        for (int i = 1; i <= 100; i++) {\n            totalStateSize++;\n            totalSizeIncludingLogicallyRemovedStates++;\n            stateMap.put(i, (long) i, String.valueOf(i));\n            addToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n        }\n        verifyState(referenceStates, stateMap);\n\n        assertEquals(totalStateSize * 2, spaceAllocator.getTotalSpaceNumber());\n\n        Map<Long, Map<Integer, String>> expectedSnapshot1 =\n                snapshotReferenceStates(referenceStates);\n        CopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 =\n                stateMap.stateSnapshot();\n\n        \r\n        for (int i = 1; i <= 100; i++) {\n            totalStateSize--;\n            stateMap.remove(i, (long) i);\n            removeFromReferenceState(referenceStates, i, (long) i);\n        }\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n        assertEquals(0, totalStateSize);\n        assertEquals(totalStateSize, stateMap.size());\n        assertEquals(totalSizeIncludingLogicallyRemovedStates, stateMap.totalSize());\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStates,\n                stateMap.getLogicallyRemovedNodes().size());\n        verifyState(referenceStates, stateMap);\n\n        verifySnapshotWithoutTransform(\n                expectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n        snapshot1.release();\n\n        \r\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStates * 3, spaceAllocator.getTotalSpaceNumber());\n        verifyState(referenceStates, stateMap);\n\n        Map<Long, Map<Integer, String>> expectedSnapshot2 =\n                snapshotReferenceStates(referenceStates);\n        CopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot2 =\n                stateMap.stateSnapshot();\n\n        \r\n        int totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot = 0;\n        assertEquals(totalStateSize, stateMap.totalSize());\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot, stateMap.totalSize());\n        assertEquals(\n                totalSizeIncludingLogicallyRemovedStatesAfterSecondSnapshot,\n                stateMap.getLogicallyRemovedNodes().size());\n        assertEquals(0, spaceAllocator.getTotalSpaceNumber());\n\n        verifySnapshotWithoutTransform(\n                expectedSnapshot2, snapshot2, keySerializer, namespaceSerializer, stateSerializer);\n        snapshot2.release();\n\n        assertEquals(0, stateMap.size());\n        assertEquals(0, stateMap.totalSize());\n        assertEquals(0, spaceAllocator.getTotalSpaceNumber());\n        assertFalse(stateMap.iterator().hasNext());\n\n        stateMap.close();\n    }\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapComplexOpTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":554,"status":"M"},{"authorDate":"2019-08-20 22:12:01","commitOrder":2,"curCode":"\tprivate void prepareLogicallyRemovedStates(\n\t\tMap<Long, Map<Integer, String>> referenceStates,\n\t\tCopyOnWriteSkipListStateMap<Integer, Long, String> stateMap,\n\t\tTypeSerializer<Integer> keySerializer,\n\t\tTypeSerializer<Long> namespaceSerializer,\n\t\tTypeSerializer<String> stateSerializer) throws IOException {\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.put(i, (long) i, String.valueOf(i));\n\t\t\taddToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot1 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.remove(i, (long) i);\n\t\t\tremoveFromReferenceState(referenceStates, i, (long) i);\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot1.release();\n\t}\n","date":"2019-11-08 01:31:48","endLine":848,"groupId":"10117","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"prepareLogicallyRemovedStates","params":"(Map<Long@Map<Integer@String>>referenceStates@CopyOnWriteSkipListStateMap<Integer@Long@String>stateMap@TypeSerializer<Integer>keySerializer@TypeSerializer<Long>namespaceSerializer@TypeSerializer<String>stateSerializer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/6fe49197aabf19fb64d830832a29536d6afe99.src","preCode":"\tprivate void prepareLogicallyRemovedStates(\n\t\tMap<Long, Map<Integer, String>> referenceStates,\n\t\tCopyOnWriteSkipListStateMap<Integer, Long, String> stateMap,\n\t\tTypeSerializer<Integer> keySerializer,\n\t\tTypeSerializer<Long> namespaceSerializer,\n\t\tTypeSerializer<String> stateSerializer) throws IOException {\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.put(i, (long) i, String.valueOf(i));\n\t\t\taddToReferenceState(referenceStates, i, (long) i, String.valueOf(i));\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tMap<Long, Map<Integer, String>> expectedSnapshot1 = snapshotReferenceStates(referenceStates);\n\t\tCopyOnWriteSkipListStateMapSnapshot<Integer, Long, String> snapshot1 = stateMap.stateSnapshot();\n\n\t\t\r\n\t\tfor (int i = 1; i <= 100; i += 2) {\n\t\t\tstateMap.remove(i, (long) i);\n\t\t\tremoveFromReferenceState(referenceStates, i, (long) i);\n\t\t}\n\t\tverifyState(referenceStates, stateMap);\n\n\t\tverifySnapshotWithoutTransform(\n\t\t\texpectedSnapshot1, snapshot1, keySerializer, namespaceSerializer, stateSerializer);\n\t\tsnapshot1.release();\n\t}\n","realPath":"flink-state-backends/flink-statebackend-heap-spillable/src/test/java/org/apache/flink/runtime/state/heap/CopyOnWriteSkipListStateMapComplexOpTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":822,"status":"N"}],"commitId":"351d6e924db155518113d21ab99c566740a0f194","commitMessage":"@@@[FLINK-21167] Make StateTable snapshots iterable\n\nIn order to implement an iterator required by a binary unified savepoint we need a way to iterate a snapshot.\n","date":"2021-01-29 06:00:51","modifiedFileCount":"9","status":"M","submitter":"Dawid Wysakowicz"}]
