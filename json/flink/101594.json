[{"authorTime":"2021-02-03 02:16:53","codes":[{"authorDate":"2021-03-29 16:06:31","commitOrder":4,"curCode":"    private void testStopWithSavepointForFlip27Source(boolean drain) throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        final MiniClusterResourceFactory clusterFactory =\n                new MiniClusterResourceFactory(\n                        numTaskManagers, numSlotsPerTaskManager, getFileBasedCheckpointsConfig());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n\n        BoundedPassThroughOperator<Long> operator =\n                new BoundedPassThroughOperator<>(ChainingStrategy.ALWAYS);\n        DataStream<Long> stream =\n                env.fromSequence(0, Long.MAX_VALUE)\n                        .transform(\"pass-through\", BasicTypeInfo.LONG_TYPE_INFO, operator);\n        stream.addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n        final JobID jobId = jobGraph.getJobID();\n\n        MiniClusterWithClientResource cluster = clusterFactory.get();\n        cluster.before();\n        ClusterClient<?> client = cluster.getClusterClient();\n\n        try {\n            BoundedPassThroughOperator.resetForTest(1, true);\n\n            client.submitJob(jobGraph).get();\n\n            BoundedPassThroughOperator.getProgressLatch().await();\n\n            client.stopWithSavepoint(jobId, drain, null).get();\n\n            if (drain) {\n                Assert.assertTrue(BoundedPassThroughOperator.inputEnded);\n            } else {\n                Assert.assertFalse(BoundedPassThroughOperator.inputEnded);\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-04-06 12:40:28","endLine":209,"groupId":"9156","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testStopWithSavepointForFlip27Source","params":"(booleandrain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fa/3709d8cde5151580da79e77502ec6057919e7c.src","preCode":"    private void testStopWithSavepointForFlip27Source(boolean drain) throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        final MiniClusterResourceFactory clusterFactory =\n                new MiniClusterResourceFactory(\n                        numTaskManagers, numSlotsPerTaskManager, getFileBasedCheckpointsConfig());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n\n        BoundedPassThroughOperator<Long> operator =\n                new BoundedPassThroughOperator<>(ChainingStrategy.ALWAYS);\n        DataStream<Long> stream =\n                env.fromSequence(0, Long.MAX_VALUE)\n                        .transform(\"pass-through\", BasicTypeInfo.LONG_TYPE_INFO, operator);\n        stream.addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n        final JobID jobId = jobGraph.getJobID();\n\n        MiniClusterWithClientResource cluster = clusterFactory.get();\n        cluster.before();\n        ClusterClient<?> client = cluster.getClusterClient();\n\n        try {\n            BoundedPassThroughOperator.resetForTest(1, true);\n\n            client.submitJob(jobGraph).get();\n\n            BoundedPassThroughOperator.getProgressLatch().await();\n\n            client.stopWithSavepoint(jobId, drain, null).get();\n\n            if (drain) {\n                Assert.assertTrue(BoundedPassThroughOperator.inputEnded);\n            } else {\n                Assert.assertFalse(BoundedPassThroughOperator.inputEnded);\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"B"},{"authorDate":"2021-02-03 02:16:53","commitOrder":4,"curCode":"    public void testStopSavepointWithBoundedInput() throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        for (ChainingStrategy chainingStrategy : ChainingStrategy.values()) {\n            final MiniClusterResourceFactory clusterFactory =\n                    new MiniClusterResourceFactory(\n                            numTaskManagers,\n                            numSlotsPerTaskManager,\n                            getFileBasedCheckpointsConfig());\n\n            StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n            env.setParallelism(1);\n\n            BoundedPassThroughOperator<Integer> operator =\n                    new BoundedPassThroughOperator<>(chainingStrategy);\n            DataStream<Integer> stream =\n                    env.addSource(new InfiniteTestSource())\n                            .transform(\"pass-through\", BasicTypeInfo.INT_TYPE_INFO, operator);\n\n            stream.addSink(new DiscardingSink<>());\n\n            final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n            final JobID jobId = jobGraph.getJobID();\n\n            MiniClusterWithClientResource cluster = clusterFactory.get();\n            cluster.before();\n            ClusterClient<?> client = cluster.getClusterClient();\n\n            try {\n                BoundedPassThroughOperator.resetForTest(1, true);\n\n                client.submitJob(jobGraph).get();\n\n                BoundedPassThroughOperator.getProgressLatch().await();\n\n                client.stopWithSavepoint(jobId, false, null).get();\n\n                Assert.assertFalse(\n                        \"input ended with chainingStrategy \" + chainingStrategy,\n                        BoundedPassThroughOperator.inputEnded);\n            } finally {\n                cluster.after();\n            }\n        }\n    }\n","date":"2021-02-04 03:54:53","endLine":549,"groupId":"35779","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testStopSavepointWithBoundedInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/62/15dd3fa1a5d6335fed99076346348f1c1a3afd.src","preCode":"    public void testStopSavepointWithBoundedInput() throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        for (ChainingStrategy chainingStrategy : ChainingStrategy.values()) {\n            final MiniClusterResourceFactory clusterFactory =\n                    new MiniClusterResourceFactory(\n                            numTaskManagers,\n                            numSlotsPerTaskManager,\n                            getFileBasedCheckpointsConfig());\n\n            StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n            env.setParallelism(1);\n\n            BoundedPassThroughOperator<Integer> operator =\n                    new BoundedPassThroughOperator<>(chainingStrategy);\n            DataStream<Integer> stream =\n                    env.addSource(new InfiniteTestSource())\n                            .transform(\"pass-through\", BasicTypeInfo.INT_TYPE_INFO, operator);\n\n            stream.addSink(new DiscardingSink<>());\n\n            final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n            final JobID jobId = jobGraph.getJobID();\n\n            MiniClusterWithClientResource cluster = clusterFactory.get();\n            cluster.before();\n            ClusterClient<?> client = cluster.getClusterClient();\n\n            try {\n                BoundedPassThroughOperator.resetForTest(1, true);\n\n                client.submitJob(jobGraph).get();\n\n                BoundedPassThroughOperator.getProgressLatch().await();\n\n                client.stopWithSavepoint(jobId, false, null).get();\n\n                Assert.assertFalse(\n                        \"input ended with chainingStrategy \" + chainingStrategy,\n                        BoundedPassThroughOperator.inputEnded);\n            } finally {\n                cluster.after();\n            }\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":504,"status":"NB"}],"commitId":"a9cf18b4d25f130e0bd24d51b128bbcf71892b45","commitMessage":"@@@[FLINK-21133][connector/checkpoint] Fix the stop-with-savepoint case in FLIP-27 source by stopping the mailbox loop in SourceOperatorStreamTask#finishTask().\n","date":"2021-04-06 12:40:28","modifiedFileCount":"2","status":"M","submitter":"Jiangjie (Becket) Qin"},{"authorTime":"2021-08-31 23:14:47","codes":[{"authorDate":"2021-08-31 23:14:47","commitOrder":5,"curCode":"    private void testStopWithSavepointForFlip27Source(boolean drain) throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        final MiniClusterResourceFactory clusterFactory =\n                new MiniClusterResourceFactory(\n                        numTaskManagers, numSlotsPerTaskManager, getFileBasedCheckpointsConfig());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n\n        BoundedPassThroughOperator<Long> operator =\n                new BoundedPassThroughOperator<>(ChainingStrategy.ALWAYS);\n        DataStream<Long> stream =\n                env.fromSequence(0, Long.MAX_VALUE)\n                        .transform(\"pass-through\", BasicTypeInfo.LONG_TYPE_INFO, operator);\n        stream.addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n        final JobID jobId = jobGraph.getJobID();\n\n        MiniClusterWithClientResource cluster = clusterFactory.get();\n        cluster.before();\n        ClusterClient<?> client = cluster.getClusterClient();\n\n        try {\n            BoundedPassThroughOperator.resetForTest(1, true);\n\n            client.submitJob(jobGraph).get();\n\n            BoundedPassThroughOperator.getProgressLatch().await();\n            waitForAllTaskRunning(cluster.getMiniCluster(), jobId, false);\n\n            client.stopWithSavepoint(jobId, drain, null).get();\n\n            if (drain) {\n                Assert.assertTrue(BoundedPassThroughOperator.inputEnded);\n            } else {\n                Assert.assertFalse(BoundedPassThroughOperator.inputEnded);\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","date":"2021-09-01 22:23:38","endLine":221,"groupId":"101594","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testStopWithSavepointForFlip27Source","params":"(booleandrain)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/75/d1161992362d1ca0f452c48d9b0c4b193ea809.src","preCode":"    private void testStopWithSavepointForFlip27Source(boolean drain) throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        final MiniClusterResourceFactory clusterFactory =\n                new MiniClusterResourceFactory(\n                        numTaskManagers, numSlotsPerTaskManager, getFileBasedCheckpointsConfig());\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(1);\n\n        BoundedPassThroughOperator<Long> operator =\n                new BoundedPassThroughOperator<>(ChainingStrategy.ALWAYS);\n        DataStream<Long> stream =\n                env.fromSequence(0, Long.MAX_VALUE)\n                        .transform(\"pass-through\", BasicTypeInfo.LONG_TYPE_INFO, operator);\n        stream.addSink(new DiscardingSink<>());\n\n        final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n        final JobID jobId = jobGraph.getJobID();\n\n        MiniClusterWithClientResource cluster = clusterFactory.get();\n        cluster.before();\n        ClusterClient<?> client = cluster.getClusterClient();\n\n        try {\n            BoundedPassThroughOperator.resetForTest(1, true);\n\n            client.submitJob(jobGraph).get();\n\n            BoundedPassThroughOperator.getProgressLatch().await();\n\n            client.stopWithSavepoint(jobId, drain, null).get();\n\n            if (drain) {\n                Assert.assertTrue(BoundedPassThroughOperator.inputEnded);\n            } else {\n                Assert.assertFalse(BoundedPassThroughOperator.inputEnded);\n            }\n        } finally {\n            cluster.after();\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2021-08-31 23:14:47","commitOrder":5,"curCode":"    public void testStopSavepointWithBoundedInput() throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        for (ChainingStrategy chainingStrategy : ChainingStrategy.values()) {\n            final MiniClusterResourceFactory clusterFactory =\n                    new MiniClusterResourceFactory(\n                            numTaskManagers,\n                            numSlotsPerTaskManager,\n                            getFileBasedCheckpointsConfig());\n\n            StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n            env.setParallelism(1);\n\n            BoundedPassThroughOperator<Integer> operator =\n                    new BoundedPassThroughOperator<>(chainingStrategy);\n            DataStream<Integer> stream =\n                    env.addSource(new InfiniteTestSource())\n                            .transform(\"pass-through\", BasicTypeInfo.INT_TYPE_INFO, operator);\n\n            stream.addSink(new DiscardingSink<>());\n\n            final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n            final JobID jobId = jobGraph.getJobID();\n\n            MiniClusterWithClientResource cluster = clusterFactory.get();\n            cluster.before();\n            ClusterClient<?> client = cluster.getClusterClient();\n\n            try {\n                BoundedPassThroughOperator.resetForTest(1, true);\n\n                client.submitJob(jobGraph).get();\n\n                BoundedPassThroughOperator.getProgressLatch().await();\n                waitForAllTaskRunning(cluster.getMiniCluster(), jobId, false);\n\n                client.stopWithSavepoint(jobId, false, null).get();\n\n                Assert.assertFalse(\n                        \"input ended with chainingStrategy \" + chainingStrategy,\n                        BoundedPassThroughOperator.inputEnded);\n            } finally {\n                cluster.after();\n            }\n        }\n    }\n","date":"2021-09-01 22:23:38","endLine":623,"groupId":"101594","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testStopSavepointWithBoundedInput","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/75/d1161992362d1ca0f452c48d9b0c4b193ea809.src","preCode":"    public void testStopSavepointWithBoundedInput() throws Exception {\n        final int numTaskManagers = 2;\n        final int numSlotsPerTaskManager = 2;\n\n        for (ChainingStrategy chainingStrategy : ChainingStrategy.values()) {\n            final MiniClusterResourceFactory clusterFactory =\n                    new MiniClusterResourceFactory(\n                            numTaskManagers,\n                            numSlotsPerTaskManager,\n                            getFileBasedCheckpointsConfig());\n\n            StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n            env.setParallelism(1);\n\n            BoundedPassThroughOperator<Integer> operator =\n                    new BoundedPassThroughOperator<>(chainingStrategy);\n            DataStream<Integer> stream =\n                    env.addSource(new InfiniteTestSource())\n                            .transform(\"pass-through\", BasicTypeInfo.INT_TYPE_INFO, operator);\n\n            stream.addSink(new DiscardingSink<>());\n\n            final JobGraph jobGraph = env.getStreamGraph().getJobGraph();\n            final JobID jobId = jobGraph.getJobID();\n\n            MiniClusterWithClientResource cluster = clusterFactory.get();\n            cluster.before();\n            ClusterClient<?> client = cluster.getClusterClient();\n\n            try {\n                BoundedPassThroughOperator.resetForTest(1, true);\n\n                client.submitJob(jobGraph).get();\n\n                BoundedPassThroughOperator.getProgressLatch().await();\n\n                client.stopWithSavepoint(jobId, false, null).get();\n\n                Assert.assertFalse(\n                        \"input ended with chainingStrategy \" + chainingStrategy,\n                        BoundedPassThroughOperator.inputEnded);\n            } finally {\n                cluster.after();\n            }\n        }\n    }\n","realPath":"flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":577,"status":"M"}],"commitId":"c7bf8b37ef195cac8e892eaf7c087d9ef8a21708","commitMessage":"@@@[FLINK-23797][tests] Wait for all task running before savepoint for all tests in SavepointITCase\n","date":"2021-09-01 22:23:38","modifiedFileCount":"1","status":"M","submitter":"Anton Kalashnikov"}]
