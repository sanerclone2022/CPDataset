[{"authorTime":"2020-09-24 17:38:56","codes":[{"authorDate":"2020-09-24 17:38:56","commitOrder":1,"curCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertEquals(GlobalDataExchangeMode.ALL_EDGES_PIPELINED, graph.getGlobalDataExchangeMode());\n\t\tassertEquals(ScheduleMode.EAGER, graph.getScheduleMode());\n\t\tassertTrue(graph.isAllVerticesInSameSlotSharingGroupByDefault());\n\t}\n","date":"2020-10-01 15:19:34","endLine":75,"groupId":"39671","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2c/06eb72e6bced25ad4228f0644996f71818ef19.src","preCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertEquals(GlobalDataExchangeMode.ALL_EDGES_PIPELINED, graph.getGlobalDataExchangeMode());\n\t\tassertEquals(ScheduleMode.EAGER, graph.getScheduleMode());\n\t\tassertTrue(graph.isAllVerticesInSameSlotSharingGroupByDefault());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"B"},{"authorDate":"2020-09-24 17:38:56","commitOrder":1,"curCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertEquals(GlobalDataExchangeMode.ALL_EDGES_PIPELINED, graph.getGlobalDataExchangeMode());\n\t\tassertEquals(ScheduleMode.EAGER, graph.getScheduleMode());\n\t\tassertTrue(graph.isAllVerticesInSameSlotSharingGroupByDefault());\n\t}\n","date":"2020-10-01 15:19:34","endLine":99,"groupId":"39672","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/2c/06eb72e6bced25ad4228f0644996f71818ef19.src","preCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertEquals(GlobalDataExchangeMode.ALL_EDGES_PIPELINED, graph.getGlobalDataExchangeMode());\n\t\tassertEquals(ScheduleMode.EAGER, graph.getScheduleMode());\n\t\tassertTrue(graph.isAllVerticesInSameSlotSharingGroupByDefault());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"B"}],"commitId":"c2e3399200010527e06e698b191bd5290f1d2ce4","commitMessage":"@@@[FLINK-19392] Detect runtime execution mode based on boundedness of sources\n\nThis option.  when exposed to the user.  it will allow to specify\nthe mode in which the pipeline is going to be executed.  as\ndescribed in FLIP-134.\n\nThis closes #13502.\n","date":"2020-10-01 15:19:34","modifiedFileCount":"8","status":"B","submitter":"Kostas Kloudas"},{"authorTime":"2020-10-14 21:22:29","codes":[{"authorDate":"2020-10-14 21:22:29","commitOrder":2,"curCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue));\n\t}\n","date":"2020-10-17 02:43:18","endLine":172,"groupId":"39671","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4d/0688a5cb380596506bc1bb7d48db3a1364156c.src","preCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertEquals(GlobalDataExchangeMode.ALL_EDGES_PIPELINED, graph.getGlobalDataExchangeMode());\n\t\tassertEquals(ScheduleMode.EAGER, graph.getScheduleMode());\n\t\tassertTrue(graph.isAllVerticesInSameSlotSharingGroupByDefault());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"},{"authorDate":"2020-10-14 21:22:29","commitOrder":2,"curCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue));\n\t}\n","date":"2020-10-17 02:43:18","endLine":202,"groupId":"39672","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4d/0688a5cb380596506bc1bb7d48db3a1364156c.src","preCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertEquals(GlobalDataExchangeMode.ALL_EDGES_PIPELINED, graph.getGlobalDataExchangeMode());\n\t\tassertEquals(ScheduleMode.EAGER, graph.getScheduleMode());\n\t\tassertTrue(graph.isAllVerticesInSameSlotSharingGroupByDefault());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"b3fd487986f3807dfc9f718c0121a0539348042d","commitMessage":"@@@[FLINK-19583] Expose the execution.runtime-mode to users\n\nAs part of FLIP-134.  this PR exposes the 'execution.runtime-mode'\nto the users. This options allows users to specify.  among other\nthings.  the task scheduling.  network shuffle behavior.  and the\ntime semantics.\n\nThis closes #13656\n","date":"2020-10-17 02:43:18","modifiedFileCount":"5","status":"M","submitter":"Kostas Kloudas"},{"authorTime":"2020-10-20 15:36:22","codes":[{"authorDate":"2020-10-20 15:36:22","commitOrder":3,"curCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","date":"2020-10-21 02:07:22","endLine":185,"groupId":"39671","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3c/7f52662225f1d8a2f13a32c6699f50eb8049ad.src","preCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"},{"authorDate":"2020-10-20 15:36:22","commitOrder":3,"curCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","date":"2020-10-21 02:07:22","endLine":217,"groupId":"39672","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3c/7f52662225f1d8a2f13a32c6699f50eb8049ad.src","preCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"}],"commitId":"8fee135e7951eabfd9701f062721e969440fc7f7","commitMessage":"@@@[FLINK-19732] Disable checkpointing in BATCH mode\n\nWhen a pipeline is executed in BATCH mode.  its tasks\nare scheduled in independent regions and not all tasks\nare present throughout the execution. In this cases\ncheckpointing should be disabled.\n\nThis closes #13698\n","date":"2020-10-21 02:07:22","modifiedFileCount":"3","status":"M","submitter":"Kostas Kloudas"},{"authorTime":"2020-10-27 21:24:59","codes":[{"authorDate":"2020-10-27 21:24:59","commitOrder":4,"curCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer, ?, ?> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer, ?, ?> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","date":"2020-10-30 19:38:25","endLine":184,"groupId":"39671","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f8/db1a9f48267290d88ac9a87c25c5d9ace35716.src","preCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"},{"authorDate":"2020-10-27 21:24:59","commitOrder":4,"curCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer, ?, ?> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","date":"2020-10-30 19:38:25","endLine":216,"groupId":"39672","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f8/db1a9f48267290d88ac9a87c25c5d9ace35716.src","preCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"}],"commitId":"ba9ebcfe75eb38c91adebd1e972ef0df3f33e8ba","commitMessage":"@@@[FLINK-19835] Turn SourceTransformation into a logical Transformation\n\nBefore.  SourceTransformation was a PhysicalTransformation where the\noperator was directly instantiated from the API. Now.  we only create the\noperator when we need to and when we know whether we're executing in\nBATCH or STREAMING mode.\n","date":"2020-10-30 19:38:25","modifiedFileCount":"5","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2020-11-05 19:13:47","codes":[{"authorDate":"2020-11-05 19:13:47","commitOrder":5,"curCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer, ?, ?> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer, ?, ?> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\tfalse));\n\t}\n","date":"2020-11-06 18:01:28","endLine":180,"groupId":"39671","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/58/2a82a3af706b48f052d9facf9db58e0ebf56c5.src","preCode":"\tpublic void testDetectionThroughTransitivePredecessors() {\n\t\tfinal SourceTransformation<Integer, ?, ?> bounded =\n\t\t\t\tgetSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n\t\tassertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n\t\tfinal SourceTransformation<Integer, ?, ?> unbounded = getSourceTransformation(\n\t\t\t\t\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal TwoInputTransformation<Integer, Integer, Integer> resultTransform = new TwoInputTransformation<>(\n\t\t\t\tbounded,\n\t\t\t\tunbounded,\n\t\t\t\t\"Test Two Input Transformation\",\n\t\t\t\tSimpleOperatorFactory.of(new StreamGraphGeneratorTest.OutputTypeConfigurableOperationWithTwoInputs()),\n\t\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n\t\t\t\t1);\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"},{"authorDate":"2020-11-05 19:13:47","commitOrder":5,"curCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer, ?, ?> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\tfalse));\n\t}\n","date":"2020-11-06 18:01:28","endLine":210,"groupId":"39672","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/58/2a82a3af706b48f052d9facf9db58e0ebf56c5.src","preCode":"\tpublic void testUnboundedDetection() {\n\t\tfinal SourceTransformation<Integer, ?, ?> unbounded =\n\t\t\t\tgetSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n\t\tassertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n\t\tfinal StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n\t\tassertThat(\n\t\t\t\tgraph,\n\t\t\t\thasProperties(\n\t\t\t\t\t\tGlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n\t\t\t\t\t\tScheduleMode.EAGER,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse));\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"}],"commitId":"1fa0447dc6e9485c081d81122283fcee31068341","commitMessage":"@@@[FLINK-20001] Don't use setAllVerticesInSameSlotSharingGroupByDefault in StreamGraphGenerator\n\nI think the default of having all vertices in the same slot sharing\ngroup should be good for both BATCH and STREAMING right now. We can\nreconsider actually setting this flag in the future.\n\nBackground information: this is a special setting that was introduced\nfor the Table API Blink runner/planner.  which does special things with\nslot sharing (or lack thereof) and is more aware of memory requirements\nand such. For general DataStream/DataSet programs changing the setting\ndoesn't make sense.\n","date":"2020-11-06 18:01:28","modifiedFileCount":"2","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2021-03-03 18:37:49","codes":[{"authorDate":"2021-03-03 18:37:49","commitOrder":6,"curCode":"    public void testDetectionThroughTransitivePredecessors() {\n        final SourceTransformation<Integer, ?, ?> bounded =\n                getSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n        assertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final TwoInputTransformation<Integer, Integer, Integer> resultTransform =\n                new TwoInputTransformation<>(\n                        bounded,\n                        unbounded,\n                        \"Test Two Input Transformation\",\n                        SimpleOperatorFactory.of(\n                                new StreamGraphGeneratorTest\n                                        .OutputTypeConfigurableOperationWithTwoInputs()),\n                        BasicTypeInfo.INT_TYPE_INFO,\n                        1);\n\n        final StreamGraph graph =\n                generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED, JobType.STREAMING, false));\n    }\n","date":"2021-03-04 21:15:28","endLine":174,"groupId":"39671","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d0/dea2eccd1e561ba5e92eb6b388ec6f14d83ddb.src","preCode":"    public void testDetectionThroughTransitivePredecessors() {\n        final SourceTransformation<Integer, ?, ?> bounded =\n                getSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n        assertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final TwoInputTransformation<Integer, Integer, Integer> resultTransform =\n                new TwoInputTransformation<>(\n                        bounded,\n                        unbounded,\n                        \"Test Two Input Transformation\",\n                        SimpleOperatorFactory.of(\n                                new StreamGraphGeneratorTest\n                                        .OutputTypeConfigurableOperationWithTwoInputs()),\n                        BasicTypeInfo.INT_TYPE_INFO,\n                        1);\n\n        final StreamGraph graph =\n                generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED, ScheduleMode.EAGER, false));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"},{"authorDate":"2021-03-03 18:37:49","commitOrder":6,"curCode":"    public void testUnboundedDetection() {\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED, JobType.STREAMING, false));\n    }\n","date":"2021-03-04 21:15:28","endLine":200,"groupId":"39672","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d0/dea2eccd1e561ba5e92eb6b388ec6f14d83ddb.src","preCode":"    public void testUnboundedDetection() {\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED, ScheduleMode.EAGER, false));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"872ad09fa530a345fff5202d985309f8bec586ca","commitMessage":"@@@[FLINK-21580] Remove ScheduleMode from JobGraph and its test\n\nThe JobGraph's JobType replaces the ScheduleMode. Before we always configured the\nScheduleMode in accordance with the JobType. Now.  only the JobType defines which\ntype of scheduling is selected.\n\n* JobType.STREAMING: The whole job must be deployed at the same time\n* JobType.BATCH: The job can be executed in steps\n\nThis closes #15076.\n","date":"2021-03-04 21:15:28","modifiedFileCount":"23","status":"M","submitter":"Till Rohrmann"},{"authorTime":"2021-07-15 16:34:07","codes":[{"authorDate":"2021-07-15 16:34:07","commitOrder":7,"curCode":"    public void testDetectionThroughTransitivePredecessors() {\n        final SourceTransformation<Integer, ?, ?> bounded =\n                getSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n        assertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final TwoInputTransformation<Integer, Integer, Integer> resultTransform =\n                new TwoInputTransformation<>(\n                        bounded,\n                        unbounded,\n                        \"Test Two Input Transformation\",\n                        SimpleOperatorFactory.of(\n                                new StreamGraphGeneratorTest\n                                        .OutputTypeConfigurableOperationWithTwoInputs()),\n                        BasicTypeInfo.INT_TYPE_INFO,\n                        1);\n\n        final StreamGraph graph =\n                generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n                        JobType.STREAMING,\n                        false,\n                        true));\n    }\n","date":"2021-07-15 21:20:51","endLine":184,"groupId":"39671","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cb/83685afaccd6fa06aa96c946204c80ad545a95.src","preCode":"    public void testDetectionThroughTransitivePredecessors() {\n        final SourceTransformation<Integer, ?, ?> bounded =\n                getSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n        assertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final TwoInputTransformation<Integer, Integer, Integer> resultTransform =\n                new TwoInputTransformation<>(\n                        bounded,\n                        unbounded,\n                        \"Test Two Input Transformation\",\n                        SimpleOperatorFactory.of(\n                                new StreamGraphGeneratorTest\n                                        .OutputTypeConfigurableOperationWithTwoInputs()),\n                        BasicTypeInfo.INT_TYPE_INFO,\n                        1);\n\n        final StreamGraph graph =\n                generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED, JobType.STREAMING, false));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"},{"authorDate":"2021-07-15 16:34:07","commitOrder":7,"curCode":"    public void testUnboundedDetection() {\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n                        JobType.STREAMING,\n                        false,\n                        true));\n    }\n","date":"2021-07-15 21:20:51","endLine":216,"groupId":"39672","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/cb/83685afaccd6fa06aa96c946204c80ad545a95.src","preCode":"    public void testUnboundedDetection() {\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED, JobType.STREAMING, false));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"}],"commitId":"d8b1a6fd3686de6fc3e7ab83795dd701ebec7621","commitMessage":"@@@[FLINK-23372][streaming-java] Disable AllVerticesInSameSlotSharingGroupByDefault in batch mode\n\nThis ensures consistency in terms of slot behavior between Table API batch mode and DataStream\nAPI batch mode. It should lead to better resource utilization when running complex pipelines\nwith data dependencies between regions.\n\nThis closes #16499.\n","date":"2021-07-15 21:20:51","modifiedFileCount":"2","status":"M","submitter":"Timo Walther"},{"authorTime":"2021-07-19 22:14:51","codes":[{"authorDate":"2021-07-19 22:14:51","commitOrder":8,"curCode":"    public void testDetectionThroughTransitivePredecessors() {\n        final SourceTransformation<Integer, ?, ?> bounded =\n                getSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n        assertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final TwoInputTransformation<Integer, Integer, Integer> resultTransform =\n                new TwoInputTransformation<>(\n                        bounded,\n                        unbounded,\n                        \"Test Two Input Transformation\",\n                        SimpleOperatorFactory.of(\n                                new StreamGraphGeneratorTest\n                                        .OutputTypeConfigurableOperationWithTwoInputs()),\n                        BasicTypeInfo.INT_TYPE_INFO,\n                        1);\n\n        final StreamGraph graph =\n                generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalStreamExchangeMode.ALL_EDGES_PIPELINED,\n                        JobType.STREAMING,\n                        false,\n                        true));\n    }\n","date":"2021-07-21 21:38:20","endLine":187,"groupId":"103029","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testDetectionThroughTransitivePredecessors","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4e/96ec7328383ed6cdf04fa2b2dd36a72c8554b5.src","preCode":"    public void testDetectionThroughTransitivePredecessors() {\n        final SourceTransformation<Integer, ?, ?> bounded =\n                getSourceTransformation(\"Bounded Source\", Boundedness.BOUNDED);\n        assertEquals(Boundedness.BOUNDED, bounded.getBoundedness());\n\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final TwoInputTransformation<Integer, Integer, Integer> resultTransform =\n                new TwoInputTransformation<>(\n                        bounded,\n                        unbounded,\n                        \"Test Two Input Transformation\",\n                        SimpleOperatorFactory.of(\n                                new StreamGraphGeneratorTest\n                                        .OutputTypeConfigurableOperationWithTwoInputs()),\n                        BasicTypeInfo.INT_TYPE_INFO,\n                        1);\n\n        final StreamGraph graph =\n                generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, resultTransform);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n                        JobType.STREAMING,\n                        false,\n                        true));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":158,"status":"M"},{"authorDate":"2021-07-19 22:14:51","commitOrder":8,"curCode":"    public void testUnboundedDetection() {\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalStreamExchangeMode.ALL_EDGES_PIPELINED,\n                        JobType.STREAMING,\n                        false,\n                        true));\n    }\n","date":"2021-07-21 21:38:20","endLine":219,"groupId":"103029","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnboundedDetection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/4e/96ec7328383ed6cdf04fa2b2dd36a72c8554b5.src","preCode":"    public void testUnboundedDetection() {\n        final SourceTransformation<Integer, ?, ?> unbounded =\n                getSourceTransformation(\"Unbounded Source\", Boundedness.CONTINUOUS_UNBOUNDED);\n        assertEquals(Boundedness.CONTINUOUS_UNBOUNDED, unbounded.getBoundedness());\n\n        final StreamGraph graph = generateStreamGraph(RuntimeExecutionMode.AUTOMATIC, unbounded);\n        assertThat(\n                graph,\n                hasProperties(\n                        GlobalDataExchangeMode.ALL_EDGES_PIPELINED,\n                        JobType.STREAMING,\n                        false,\n                        true));\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorExecutionModeDetectionTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"156f517d387202ac292bde5bfac423a23908b7a2","commitMessage":"@@@[FLINK-23402][streaming-java] Refactor GlobalDataExchangeMode to GlobalStreamExchangeMode\n","date":"2021-07-21 21:38:20","modifiedFileCount":"11","status":"M","submitter":"Timo Walther"}]
