[{"authorTime":"2020-05-11 13:45:45","codes":[{"authorDate":"2020-10-13 14:09:20","commitOrder":2,"curCode":"\tpublic void testAsyncCheckpointException() {\n\t\tfinal Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n\t\tsnapshotsInProgress.put(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew OperatorSnapshotFutures(\n\t\t\t\t\t\tExceptionallyDoneFuture.of(new RuntimeException(\"Async Checkpoint Exception\")),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty())));\n\n\t\tfinal TestEnvironment environment = new TestEnvironment();\n\t\tfinal AsyncCheckpointRunnable runnable = new AsyncCheckpointRunnable(\n\t\t\t\tsnapshotsInProgress,\n\t\t\t\tnew CheckpointMetaData(1, 1L),\n\t\t\t\tnew CheckpointMetrics(),\n\t\t\t\t1L,\n\t\t\t\t\"Task Name\",\n\t\t\t\tr -> {},\n\t\t\t\tr -> {},\n\t\t\t\tenvironment,\n\t\t\t\t(msg, ex) -> {});\n\t\trunnable.run();\n\n\t\tAssert.assertTrue(environment.getCause() instanceof CheckpointException);\n\t\tAssert.assertSame(((CheckpointException) environment.getCause())\n\t\t\t\t.getCheckpointFailureReason(), CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n\t}\n","date":"2020-10-13 14:09:20","endLine":75,"groupId":"9544","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/30/e8e80e5aaf4943cb3baf5aa3fedac6fd32beef.src","preCode":"\tpublic void testAsyncCheckpointException() {\n\t\tfinal Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n\t\tsnapshotsInProgress.put(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew OperatorSnapshotFutures(\n\t\t\t\t\t\tExceptionallyDoneFuture.of(new RuntimeException(\"Async Checkpoint Exception\")),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty())));\n\n\t\tfinal TestEnvironment environment = new TestEnvironment();\n\t\tfinal AsyncCheckpointRunnable runnable = new AsyncCheckpointRunnable(\n\t\t\t\tsnapshotsInProgress,\n\t\t\t\tnew CheckpointMetaData(1, 1L),\n\t\t\t\tnew CheckpointMetrics(),\n\t\t\t\t1L,\n\t\t\t\t\"Task Name\",\n\t\t\t\tr -> {},\n\t\t\t\tr -> {},\n\t\t\t\tenvironment,\n\t\t\t\t(msg, ex) -> {});\n\t\trunnable.run();\n\n\t\tAssert.assertTrue(environment.getCause() instanceof CheckpointException);\n\t\tAssert.assertSame(((CheckpointException) environment.getCause())\n\t\t\t\t.getCheckpointFailureReason(), CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"B"},{"authorDate":"2020-05-11 13:45:45","commitOrder":2,"curCode":"\tpublic void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n\t\tMockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\t\tSubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator = (SubtaskCheckpointCoordinatorImpl) new MockSubtaskCheckpointCoordinatorBuilder()\n\t\t\t.setEnvironment(mockEnvironment)\n\t\t\t.setExecutor(Executors.newSingleThreadExecutor())\n\t\t\t.setUnalignedCheckpointEnabled(true)\n\t\t\t.build();\n\n\t\tfinal BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n\t\tOperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\trawKeyedStateHandleFuture,\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\n\t\tfinal OperatorChain<String, AbstractStreamOperator<String>> operatorChain = operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n\t\tlong checkpointId = 42L;\n\t\tsubtaskCheckpointCoordinator.getChannelStateWriter().start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n\t\tsubtaskCheckpointCoordinator.checkpointState(\n\t\t\tnew CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n\t\t\tCheckpointOptions.forCheckpointWithDefaultLocation(),\n\t\t\tnew CheckpointMetrics(),\n\t\t\toperatorChain,\n\t\t\t() -> true);\n\t\trawKeyedStateHandleFuture.awaitRun();\n\t\tassertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t\tassertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n\t\tsubtaskCheckpointCoordinator.notifyCheckpointAborted(checkpointId, operatorChain, () -> true);\n\t\tassertTrue(rawKeyedStateHandleFuture.isCancelled());\n\t\tassertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t}\n","date":"2020-05-20 14:58:00","endLine":192,"groupId":"31591","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/94/bb92f37ea1e89b040cd2f1ee048b932bbfedeb.src","preCode":"\tpublic void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n\t\tMockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\t\tSubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator = (SubtaskCheckpointCoordinatorImpl) new MockSubtaskCheckpointCoordinatorBuilder()\n\t\t\t.setEnvironment(mockEnvironment)\n\t\t\t.setExecutor(Executors.newSingleThreadExecutor())\n\t\t\t.setUnalignedCheckpointEnabled(true)\n\t\t\t.build();\n\n\t\tfinal BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n\t\tOperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\trawKeyedStateHandleFuture,\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\n\t\tfinal OperatorChain<String, AbstractStreamOperator<String>> operatorChain = operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n\t\tlong checkpointId = 42L;\n\t\tsubtaskCheckpointCoordinator.getChannelStateWriter().start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n\t\tsubtaskCheckpointCoordinator.checkpointState(\n\t\t\tnew CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n\t\t\tCheckpointOptions.forCheckpointWithDefaultLocation(),\n\t\t\tnew CheckpointMetrics(),\n\t\t\toperatorChain,\n\t\t\t() -> true);\n\t\trawKeyedStateHandleFuture.awaitRun();\n\t\tassertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t\tassertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n\t\tsubtaskCheckpointCoordinator.notifyCheckpointAborted(checkpointId, operatorChain, () -> true);\n\t\tassertTrue(rawKeyedStateHandleFuture.isCancelled());\n\t\tassertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":158,"status":"NB"}],"commitId":"a1b1dc95210e99e6c23069415283fce4ec3793a5","commitMessage":"@@@[FLINK-16753][checkpointing] Use CheckpointException to wrap exceptions thrown from AsyncCheckpointRunnable\n\nThis closes #11509.","date":"2020-10-13 14:09:20","modifiedFileCount":"3","status":"M","submitter":"Jiayi Liao"},{"authorTime":"2020-10-05 21:22:14","codes":[{"authorDate":"2020-10-05 21:22:14","commitOrder":3,"curCode":"\tpublic void testAsyncCheckpointException() {\n\t\tfinal Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n\t\tsnapshotsInProgress.put(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew OperatorSnapshotFutures(\n\t\t\t\t\t\tExceptionallyDoneFuture.of(new RuntimeException(\"Async Checkpoint Exception\")),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty())));\n\n\t\tfinal TestEnvironment environment = new TestEnvironment();\n\t\tfinal AsyncCheckpointRunnable runnable = new AsyncCheckpointRunnable(\n\t\t\t\tsnapshotsInProgress,\n\t\t\t\tnew CheckpointMetaData(1, 1L),\n\t\t\t\tnew CheckpointMetricsBuilder(),\n\t\t\t\t1L,\n\t\t\t\t\"Task Name\",\n\t\t\t\tr -> {},\n\t\t\t\tr -> {},\n\t\t\t\tenvironment,\n\t\t\t\t(msg, ex) -> {});\n\t\trunnable.run();\n\n\t\tAssert.assertTrue(environment.getCause() instanceof CheckpointException);\n\t\tAssert.assertSame(((CheckpointException) environment.getCause())\n\t\t\t\t.getCheckpointFailureReason(), CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n\t}\n","date":"2020-10-13 23:09:23","endLine":75,"groupId":"9544","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/aa64113a301e2d7c8b48d26f8c2727d562ac02.src","preCode":"\tpublic void testAsyncCheckpointException() {\n\t\tfinal Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n\t\tsnapshotsInProgress.put(\n\t\t\t\tnew OperatorID(),\n\t\t\t\tnew OperatorSnapshotFutures(\n\t\t\t\t\t\tExceptionallyDoneFuture.of(new RuntimeException(\"Async Checkpoint Exception\")),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\t\t\t\tDoneFuture.of(SnapshotResult.empty())));\n\n\t\tfinal TestEnvironment environment = new TestEnvironment();\n\t\tfinal AsyncCheckpointRunnable runnable = new AsyncCheckpointRunnable(\n\t\t\t\tsnapshotsInProgress,\n\t\t\t\tnew CheckpointMetaData(1, 1L),\n\t\t\t\tnew CheckpointMetrics(),\n\t\t\t\t1L,\n\t\t\t\t\"Task Name\",\n\t\t\t\tr -> {},\n\t\t\t\tr -> {},\n\t\t\t\tenvironment,\n\t\t\t\t(msg, ex) -> {});\n\t\trunnable.run();\n\n\t\tAssert.assertTrue(environment.getCause() instanceof CheckpointException);\n\t\tAssert.assertSame(((CheckpointException) environment.getCause())\n\t\t\t\t.getCheckpointFailureReason(), CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2020-10-05 21:22:14","commitOrder":3,"curCode":"\tpublic void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n\t\tMockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\t\tSubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator = (SubtaskCheckpointCoordinatorImpl) new MockSubtaskCheckpointCoordinatorBuilder()\n\t\t\t.setEnvironment(mockEnvironment)\n\t\t\t.setExecutor(Executors.newSingleThreadExecutor())\n\t\t\t.setUnalignedCheckpointEnabled(true)\n\t\t\t.build();\n\n\t\tfinal BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n\t\tOperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\trawKeyedStateHandleFuture,\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\n\t\tfinal OperatorChain<String, AbstractStreamOperator<String>> operatorChain = operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n\t\tlong checkpointId = 42L;\n\t\tsubtaskCheckpointCoordinator.getChannelStateWriter().start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n\t\tsubtaskCheckpointCoordinator.checkpointState(\n\t\t\tnew CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n\t\t\tCheckpointOptions.forCheckpointWithDefaultLocation(),\n\t\t\tnew CheckpointMetricsBuilder(),\n\t\t\toperatorChain,\n\t\t\t() -> true);\n\t\trawKeyedStateHandleFuture.awaitRun();\n\t\tassertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t\tassertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n\t\tsubtaskCheckpointCoordinator.notifyCheckpointAborted(checkpointId, operatorChain, () -> true);\n\t\tassertTrue(rawKeyedStateHandleFuture.isCancelled());\n\t\tassertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t}\n","date":"2020-10-13 23:09:23","endLine":329,"groupId":"31591","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/bd/6e929baf1d2cc8fa3f2991dd76a4d2cf27299d.src","preCode":"\tpublic void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n\t\tMockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\t\tSubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator = (SubtaskCheckpointCoordinatorImpl) new MockSubtaskCheckpointCoordinatorBuilder()\n\t\t\t.setEnvironment(mockEnvironment)\n\t\t\t.setExecutor(Executors.newSingleThreadExecutor())\n\t\t\t.setUnalignedCheckpointEnabled(true)\n\t\t\t.build();\n\n\t\tfinal BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n\t\tOperatorSnapshotFutures operatorSnapshotResult = new OperatorSnapshotFutures(\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\trawKeyedStateHandleFuture,\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()),\n\t\t\tDoneFuture.of(SnapshotResult.empty()));\n\n\t\tfinal OperatorChain<String, AbstractStreamOperator<String>> operatorChain = operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n\t\tlong checkpointId = 42L;\n\t\tsubtaskCheckpointCoordinator.getChannelStateWriter().start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n\t\tsubtaskCheckpointCoordinator.checkpointState(\n\t\t\tnew CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n\t\t\tCheckpointOptions.forCheckpointWithDefaultLocation(),\n\t\t\tnew CheckpointMetrics(),\n\t\t\toperatorChain,\n\t\t\t() -> true);\n\t\trawKeyedStateHandleFuture.awaitRun();\n\t\tassertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t\tassertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n\t\tsubtaskCheckpointCoordinator.notifyCheckpointAborted(checkpointId, operatorChain, () -> true);\n\t\tassertTrue(rawKeyedStateHandleFuture.isCancelled());\n\t\tassertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n\t}\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"}],"commitId":"f86c9591a4f041cb34f2e966d77108ce817b563e","commitMessage":"@@@[FLINK-18662][task] Introduce CheckpointMetricsBuilder\n\nThis will later allow to solve in a hopefully elegant way the issue.  that\nsome checkpoint metrics are calculated after AsyncCheckpointRunnable's construction.\nCheckpointMetricsBuilder will be able to collect those additional metrics via CompletableFuture's\nwhile CheckpointMetrics class will remain a serializable class used in the RPC.\n","date":"2020-10-13 23:09:23","modifiedFileCount":"22","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-01-25 00:57:44","codes":[{"authorDate":"2021-01-25 00:57:44","commitOrder":4,"curCode":"    private void testAsyncCheckpointException(Supplier<Boolean> isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                new AsyncCheckpointRunnable(\n                        snapshotsInProgress,\n                        new CheckpointMetaData(1, 1L),\n                        new CheckpointMetricsBuilder(),\n                        1L,\n                        \"Task Name\",\n                        r -> {},\n                        r -> {},\n                        environment,\n                        (msg, ex) -> {},\n                        isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning.get()) {\n            Assert.assertTrue(environment.getCause() instanceof CheckpointException);\n            Assert.assertSame(\n                    ((CheckpointException) environment.getCause()).getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","date":"2021-01-28 18:01:53","endLine":91,"groupId":"9544","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"(Supplier<Boolean>isTaskRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8c/7bbc7a68a7104d3f813ac2bbb2a43f91ab208b.src","preCode":"    public void testAsyncCheckpointException() {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                new AsyncCheckpointRunnable(\n                        snapshotsInProgress,\n                        new CheckpointMetaData(1, 1L),\n                        new CheckpointMetricsBuilder(),\n                        1L,\n                        \"Task Name\",\n                        r -> {},\n                        r -> {},\n                        environment,\n                        (msg, ex) -> {});\n        runnable.run();\n\n        Assert.assertTrue(environment.getCause() instanceof CheckpointException);\n        Assert.assertSame(\n                ((CheckpointException) environment.getCause()).getCheckpointFailureReason(),\n                CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2021-01-25 00:57:44","commitOrder":4,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","date":"2021-01-28 18:01:53","endLine":367,"groupId":"31591","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dc/3fc4e1f1bbd41897c61bf46e000626486b0cc5.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> true);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":326,"status":"M"}],"commitId":"be6eb95af5eaa866ead85ebfa89bdbc7c57c6edc","commitMessage":"@@@[FLINK-20675][checkpointing] Only decline async checkpoint failure when task is still running\n","date":"2021-01-28 18:01:53","modifiedFileCount":"8","status":"M","submitter":"Yun Tang"},{"authorTime":"2021-01-25 00:57:44","codes":[{"authorDate":"2021-01-15 16:38:03","commitOrder":5,"curCode":"    private void testAsyncCheckpointException(Supplier<Boolean> isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                new AsyncCheckpointRunnable(\n                        snapshotsInProgress,\n                        new CheckpointMetaData(1, 1L),\n                        new CheckpointMetricsBuilder(),\n                        1L,\n                        \"Task Name\",\n                        r -> {},\n                        r -> {},\n                        environment,\n                        (msg, ex) -> {},\n                        isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning.get()) {\n            Assert.assertSame(\n                    (environment.getCause()).getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","date":"2021-01-28 18:02:02","endLine":90,"groupId":"9544","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"(Supplier<Boolean>isTaskRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/50/551f1769a7ed1deed7340096efbc840ff8b5c8.src","preCode":"    private void testAsyncCheckpointException(Supplier<Boolean> isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                new AsyncCheckpointRunnable(\n                        snapshotsInProgress,\n                        new CheckpointMetaData(1, 1L),\n                        new CheckpointMetricsBuilder(),\n                        1L,\n                        \"Task Name\",\n                        r -> {},\n                        r -> {},\n                        environment,\n                        (msg, ex) -> {},\n                        isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning.get()) {\n            Assert.assertTrue(environment.getCause() instanceof CheckpointException);\n            Assert.assertSame(\n                    ((CheckpointException) environment.getCause()).getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2021-01-25 00:57:44","commitOrder":5,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","date":"2021-01-28 18:01:53","endLine":367,"groupId":"31591","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dc/3fc4e1f1bbd41897c61bf46e000626486b0cc5.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":326,"status":"N"}],"commitId":"f421c6f72b91b7897ff2246bdf4f408e3609f6f0","commitMessage":"@@@[FLINK-20675][checkpointing] Refactor interfaces to decline checkpoint with CheckpointException\n","date":"2021-01-28 18:02:02","modifiedFileCount":"28","status":"M","submitter":"Yun Tang"},{"authorTime":"2021-01-25 00:57:44","codes":[{"authorDate":"2021-02-01 16:52:30","commitOrder":6,"curCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","date":"2021-02-02 01:06:27","endLine":79,"groupId":"31591","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"(booleanisTaskRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0e/4642ecfa153f66a047b9c6f54cba0bb97d6a44.src","preCode":"    private void testAsyncCheckpointException(Supplier<Boolean> isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                new AsyncCheckpointRunnable(\n                        snapshotsInProgress,\n                        new CheckpointMetaData(1, 1L),\n                        new CheckpointMetricsBuilder(),\n                        1L,\n                        \"Task Name\",\n                        r -> {},\n                        r -> {},\n                        environment,\n                        (msg, ex) -> {},\n                        isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning.get()) {\n            Assert.assertSame(\n                    (environment.getCause()).getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2021-01-25 00:57:44","commitOrder":6,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","date":"2021-01-28 18:01:53","endLine":367,"groupId":"31591","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dc/3fc4e1f1bbd41897c61bf46e000626486b0cc5.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":326,"status":"N"}],"commitId":"37a6e514d3c7653a8dd799a1f633f29501931169","commitMessage":"@@@[FLINK-21215][task] Do not overwrite the original CheckpointFailureReason in AsyncCheckpointRunnable\n\nBefore this change.  original failure reason would be hidden and replaced with CHECKPOINT_ASYNC_EXCEPTION\n","date":"2021-02-02 01:06:27","modifiedFileCount":"2","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-04-07 17:48:02","codes":[{"authorDate":"2021-02-01 16:52:30","commitOrder":7,"curCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","date":"2021-02-02 01:06:27","endLine":79,"groupId":"31591","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"(booleanisTaskRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0e/4642ecfa153f66a047b9c6f54cba0bb97d6a44.src","preCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"N"},{"authorDate":"2021-04-07 17:48:02","commitOrder":7,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","date":"2021-04-07 23:53:17","endLine":425,"groupId":"31591","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e0/49e68ded01d5f2c0e83abf65862fca77bdba45.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":383,"status":"M"}],"commitId":"3cf8597cf3bcccc847519fa12925a2b984e80304","commitMessage":"@@@[hotfix][tests] Close SubtaskCheckpointCoordinator in tests\n\nThis is to reveal any async failures occurring for\nexample when writing channel state.\n","date":"2021-04-07 23:53:17","modifiedFileCount":"1","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2021-04-07 17:48:02","codes":[{"authorDate":"2021-07-13 17:33:11","commitOrder":8,"curCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, false, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","date":"2021-07-19 14:44:28","endLine":104,"groupId":"31591","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"(booleanisTaskRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/04/36dbc612dcf538f0d05dee00439336808ce6e7.src","preCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2021-04-07 17:48:02","commitOrder":8,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","date":"2021-04-07 23:53:17","endLine":425,"groupId":"31591","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e0/49e68ded01d5f2c0e83abf65862fca77bdba45.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":383,"status":"N"}],"commitId":"d9cc268be61c1789e5cb32d0897d962721be9c01","commitMessage":"@@@[FLINK-21084][runtime][checkpoint] Task reports finished snapshot on checkpoint if it is finished on restore\n","date":"2021-07-19 14:44:28","modifiedFileCount":"5","status":"M","submitter":"Yun Gao"},{"authorTime":"2021-07-28 13:46:47","codes":[{"authorDate":"2021-07-13 17:33:11","commitOrder":9,"curCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, false, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","date":"2021-07-19 14:44:28","endLine":104,"groupId":"102475","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testAsyncCheckpointException","params":"(booleanisTaskRunning)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/04/36dbc612dcf538f0d05dee00439336808ce6e7.src","preCode":"    private void testAsyncCheckpointException(boolean isTaskRunning) {\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        ExceptionallyDoneFuture.of(\n                                new RuntimeException(\"Async Checkpoint Exception\")),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, false, isTaskRunning);\n        runnable.run();\n\n        if (isTaskRunning) {\n            Assert.assertSame(\n                    environment.getCause().getCheckpointFailureReason(),\n                    CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION);\n        } else {\n            Assert.assertNull(environment.getCause());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"N"},{"authorDate":"2021-07-28 13:46:47","commitOrder":9,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    false,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","date":"2021-08-03 19:19:41","endLine":437,"groupId":"102475","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b4/43a36d04a16e5fb3ea17fff0d95d1560fd7c79.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":394,"status":"M"}],"commitId":"66bf4e6891a0cb271ca940d3814db83ca51164d5","commitMessage":"@@@[FLINK-21080][runtime][checkpoint] The task reports whether it has called operators' finish method\n","date":"2021-08-03 19:19:41","modifiedFileCount":"12","status":"M","submitter":"Yun Gao"}]
