[{"authorTime":"2020-11-05 15:00:31","codes":[{"authorDate":"2020-11-05 15:00:31","commitOrder":1,"curCode":"\tpublic void testAddAlreadyExistingKey() throws Exception {\n\t\tnew Context() {{\n\t\t\trunTest(\n\t\t\t\t() -> {\n\t\t\t\t\tleaderCallbackGrantLeadership();\n\n\t\t\t\t\tgetLeaderConfigMap().getData().put(key, \"existing data\");\n\n\t\t\t\t\tfinal KubernetesStateHandleStore<Long> store = new KubernetesStateHandleStore<>(\n\t\t\t\t\t\tflinkKubeClient, LEADER_CONFIGMAP_NAME, longStateStorage, filter, LOCK_IDENTITY);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstore.addAndLock(key, state);\n\t\t\t\t\t\tfail(\"Exception should be thrown.\");\n\t\t\t\t\t} catch (StateHandleStore.AlreadyExistException ex) {\n\t\t\t\t\t\tfinal String msg = String.format(\n\t\t\t\t\t\t\t\"%s already exists in ConfigMap %s\", key, LEADER_CONFIGMAP_NAME);\n\t\t\t\t\t\tassertThat(ex, FlinkMatchers.containsMessage(msg));\n\t\t\t\t\t}\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().size(), is(1));\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().get(0).getNumberOfDiscardCalls(), is(1));\n\t\t\t\t});\n\t\t}};\n\t}\n","date":"2020-11-08 00:54:31","endLine":104,"groupId":"35116","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAddAlreadyExistingKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ed/9c1ae9a7df6f18f65843464b5390fe36f7bdad.src","preCode":"\tpublic void testAddAlreadyExistingKey() throws Exception {\n\t\tnew Context() {{\n\t\t\trunTest(\n\t\t\t\t() -> {\n\t\t\t\t\tleaderCallbackGrantLeadership();\n\n\t\t\t\t\tgetLeaderConfigMap().getData().put(key, \"existing data\");\n\n\t\t\t\t\tfinal KubernetesStateHandleStore<Long> store = new KubernetesStateHandleStore<>(\n\t\t\t\t\t\tflinkKubeClient, LEADER_CONFIGMAP_NAME, longStateStorage, filter, LOCK_IDENTITY);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstore.addAndLock(key, state);\n\t\t\t\t\t\tfail(\"Exception should be thrown.\");\n\t\t\t\t\t} catch (StateHandleStore.AlreadyExistException ex) {\n\t\t\t\t\t\tfinal String msg = String.format(\n\t\t\t\t\t\t\t\"%s already exists in ConfigMap %s\", key, LEADER_CONFIGMAP_NAME);\n\t\t\t\t\t\tassertThat(ex, FlinkMatchers.containsMessage(msg));\n\t\t\t\t\t}\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().size(), is(1));\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().get(0).getNumberOfDiscardCalls(), is(1));\n\t\t\t\t});\n\t\t}};\n\t}\n","realPath":"flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"B"},{"authorDate":"2020-11-05 15:00:31","commitOrder":1,"curCode":"\tpublic void testAddFailedWhenConfigMapNotExistAndDiscardState() throws Exception {\n\t\tnew Context() {{\n\t\t\trunTest(\n\t\t\t\t() -> {\n\t\t\t\t\tfinal KubernetesStateHandleStore<Long> store = new KubernetesStateHandleStore<>(\n\t\t\t\t\t\tflinkKubeClient, LEADER_CONFIGMAP_NAME, longStateStorage, filter, LOCK_IDENTITY);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstore.addAndLock(key, state);\n\t\t\t\t\t\tfail(\"Exception should be thrown.\");\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tfinal String msg = String.format(\"ConfigMap %s does not exist.\", LEADER_CONFIGMAP_NAME);\n\t\t\t\t\t\tassertThat(ex, FlinkMatchers.containsMessage(msg));\n\t\t\t\t\t}\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().size(), is(1));\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().get(0).getNumberOfDiscardCalls(), is(1));\n\t\t\t\t});\n\t\t}};\n\t}\n","date":"2020-11-08 00:54:31","endLine":125,"groupId":"35116","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testAddFailedWhenConfigMapNotExistAndDiscardState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ed/9c1ae9a7df6f18f65843464b5390fe36f7bdad.src","preCode":"\tpublic void testAddFailedWhenConfigMapNotExistAndDiscardState() throws Exception {\n\t\tnew Context() {{\n\t\t\trunTest(\n\t\t\t\t() -> {\n\t\t\t\t\tfinal KubernetesStateHandleStore<Long> store = new KubernetesStateHandleStore<>(\n\t\t\t\t\t\tflinkKubeClient, LEADER_CONFIGMAP_NAME, longStateStorage, filter, LOCK_IDENTITY);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstore.addAndLock(key, state);\n\t\t\t\t\t\tfail(\"Exception should be thrown.\");\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tfinal String msg = String.format(\"ConfigMap %s does not exist.\", LEADER_CONFIGMAP_NAME);\n\t\t\t\t\t\tassertThat(ex, FlinkMatchers.containsMessage(msg));\n\t\t\t\t\t}\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().size(), is(1));\n\t\t\t\t\tassertThat(longStateStorage.getStateHandles().get(0).getNumberOfDiscardCalls(), is(1));\n\t\t\t\t});\n\t\t}};\n\t}\n","realPath":"flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"B"}],"commitId":"8b4f28b334af4cb2e36d6f46805f9631ce34e091","commitMessage":"@@@[FLINK-19543][k8s] Implement KubernetesStateHandleStore based on Kubernetes API\n","date":"2020-11-08 00:54:31","modifiedFileCount":"2","status":"B","submitter":"wangyang0918"},{"authorTime":"2021-05-04 19:08:07","codes":[{"authorDate":"2021-05-04 19:08:07","commitOrder":2,"curCode":"    public void testAddAlreadyExistingKey() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            leaderCallbackGrantLeadership();\n\n                            getLeaderConfigMap().getData().put(key, \"existing data\");\n\n                            final KubernetesStateHandleStore<\n                                            TestingLongStateHandleHelper.LongStateHandle>\n                                    store =\n                                            new KubernetesStateHandleStore<>(\n                                                    flinkKubeClient,\n                                                    LEADER_CONFIGMAP_NAME,\n                                                    longStateStorage,\n                                                    filter,\n                                                    LOCK_IDENTITY);\n\n                            try {\n                                store.addAndLock(key, state);\n                                fail(\"Exception should be thrown.\");\n                            } catch (StateHandleStore.AlreadyExistException ex) {\n                                final String msg =\n                                        String.format(\n                                                \"%s already exists in ConfigMap %s\",\n                                                key, LEADER_CONFIGMAP_NAME);\n                                assertThat(ex, FlinkMatchers.containsMessage(msg));\n                            }\n                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(1));\n                            assertThat(\n                                    TestingLongStateHandleHelper\n                                            .getDiscardCallCountForStateHandleByIndex(0),\n                                    is(1));\n                        });\n            }\n        };\n    }\n","date":"2021-05-18 16:58:42","endLine":127,"groupId":"102342","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAddAlreadyExistingKey","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6e/230f5250fabfd320d3c09968b016e6446942f6.src","preCode":"    public void testAddAlreadyExistingKey() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            leaderCallbackGrantLeadership();\n\n                            getLeaderConfigMap().getData().put(key, \"existing data\");\n\n                            final KubernetesStateHandleStore<Long> store =\n                                    new KubernetesStateHandleStore<>(\n                                            flinkKubeClient,\n                                            LEADER_CONFIGMAP_NAME,\n                                            longStateStorage,\n                                            filter,\n                                            LOCK_IDENTITY);\n\n                            try {\n                                store.addAndLock(key, state);\n                                fail(\"Exception should be thrown.\");\n                            } catch (StateHandleStore.AlreadyExistException ex) {\n                                final String msg =\n                                        String.format(\n                                                \"%s already exists in ConfigMap %s\",\n                                                key, LEADER_CONFIGMAP_NAME);\n                                assertThat(ex, FlinkMatchers.containsMessage(msg));\n                            }\n                            assertThat(longStateStorage.getStateHandles().size(), is(1));\n                            assertThat(\n                                    longStateStorage\n                                            .getStateHandles()\n                                            .get(0)\n                                            .getNumberOfDiscardCalls(),\n                                    is(1));\n                        });\n            }\n        };\n    }\n","realPath":"flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"M"},{"authorDate":"2021-05-04 19:08:07","commitOrder":2,"curCode":"    public void testAddFailedWhenConfigMapNotExistAndDiscardState() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            final KubernetesStateHandleStore<\n                                            TestingLongStateHandleHelper.LongStateHandle>\n                                    store =\n                                            new KubernetesStateHandleStore<>(\n                                                    flinkKubeClient,\n                                                    LEADER_CONFIGMAP_NAME,\n                                                    longStateStorage,\n                                                    filter,\n                                                    LOCK_IDENTITY);\n\n                            try {\n                                store.addAndLock(key, state);\n                                fail(\"Exception should be thrown.\");\n                            } catch (Exception ex) {\n                                final String msg =\n                                        String.format(\n                                                \"ConfigMap %s does not exist.\",\n                                                LEADER_CONFIGMAP_NAME);\n                                assertThat(ex, FlinkMatchers.containsMessage(msg));\n                            }\n                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(1));\n                            assertThat(\n                                    TestingLongStateHandleHelper\n                                            .getDiscardCallCountForStateHandleByIndex(0),\n                                    is(1));\n                        });\n            }\n        };\n    }\n","date":"2021-05-18 16:58:42","endLine":163,"groupId":"102342","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testAddFailedWhenConfigMapNotExistAndDiscardState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/6e/230f5250fabfd320d3c09968b016e6446942f6.src","preCode":"    public void testAddFailedWhenConfigMapNotExistAndDiscardState() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            final KubernetesStateHandleStore<Long> store =\n                                    new KubernetesStateHandleStore<>(\n                                            flinkKubeClient,\n                                            LEADER_CONFIGMAP_NAME,\n                                            longStateStorage,\n                                            filter,\n                                            LOCK_IDENTITY);\n\n                            try {\n                                store.addAndLock(key, state);\n                                fail(\"Exception should be thrown.\");\n                            } catch (Exception ex) {\n                                final String msg =\n                                        String.format(\n                                                \"ConfigMap %s does not exist.\",\n                                                LEADER_CONFIGMAP_NAME);\n                                assertThat(ex, FlinkMatchers.containsMessage(msg));\n                            }\n                            assertThat(longStateStorage.getStateHandles().size(), is(1));\n                            assertThat(\n                                    longStateStorage\n                                            .getStateHandles()\n                                            .get(0)\n                                            .getNumberOfDiscardCalls(),\n                                    is(1));\n                        });\n            }\n        };\n    }\n","realPath":"flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"}],"commitId":"cc59ad5e62a6183fccbe1d429c608a727f00b307","commitMessage":"@@@[FLINK-22494][ha] Refactors TestingLongStateHandleHelper to operate on references\n\nThe previous implementation stored the state in the StateHandle. This causes\nproblems when deserializing the state creating a new instance that does not\npoint to the actual state but is a copy of this state.\n\nThis refactoring introduces LongStateHandle handling the actual state and\nLongRetrievableStateHandle referencing this handle.\n","date":"2021-05-18 16:58:42","modifiedFileCount":"4","status":"M","submitter":"Matthias Pohl"}]
