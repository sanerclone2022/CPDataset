[{"authorTime":"2021-01-25 00:57:44","codes":[{"authorDate":"2021-02-01 16:52:30","commitOrder":4,"curCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","date":"2021-02-02 01:06:27","endLine":103,"groupId":"31591","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeclineAsyncCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0e/4642ecfa153f66a047b9c6f54cba0bb97d6a44.src","preCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"B"},{"authorDate":"2021-01-25 00:57:44","commitOrder":4,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","date":"2021-01-28 18:01:53","endLine":367,"groupId":"31591","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/dc/3fc4e1f1bbd41897c61bf46e000626486b0cc5.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":326,"status":"NB"}],"commitId":"37a6e514d3c7653a8dd799a1f633f29501931169","commitMessage":"@@@[FLINK-21215][task] Do not overwrite the original CheckpointFailureReason in AsyncCheckpointRunnable\n\nBefore this change.  original failure reason would be hidden and replaced with CHECKPOINT_ASYNC_EXCEPTION\n","date":"2021-02-02 01:06:27","modifiedFileCount":"2","status":"M","submitter":"Piotr Nowojski"},{"authorTime":"2021-04-07 17:48:02","codes":[{"authorDate":"2021-02-01 16:52:30","commitOrder":5,"curCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","date":"2021-02-02 01:06:27","endLine":103,"groupId":"31591","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeclineAsyncCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/0e/4642ecfa153f66a047b9c6f54cba0bb97d6a44.src","preCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"N"},{"authorDate":"2021-04-07 17:48:02","commitOrder":5,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","date":"2021-04-07 23:53:17","endLine":425,"groupId":"31591","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e0/49e68ded01d5f2c0e83abf65862fca77bdba45.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n        SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build();\n\n        final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n        OperatorSnapshotFutures operatorSnapshotResult =\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        rawKeyedStateHandleFuture,\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()));\n\n        final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n        long checkpointId = 42L;\n        subtaskCheckpointCoordinator\n                .getChannelStateWriter()\n                .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n        subtaskCheckpointCoordinator.checkpointState(\n                new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                CheckpointOptions.forCheckpointWithDefaultLocation(),\n                new CheckpointMetricsBuilder(),\n                operatorChain,\n                () -> false);\n        rawKeyedStateHandleFuture.awaitRun();\n        assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n        subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                checkpointId, operatorChain, () -> true);\n        assertTrue(rawKeyedStateHandleFuture.isCancelled());\n        assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":383,"status":"M"}],"commitId":"3cf8597cf3bcccc847519fa12925a2b984e80304","commitMessage":"@@@[hotfix][tests] Close SubtaskCheckpointCoordinator in tests\n\nThis is to reveal any async failures occurring for\nexample when writing channel state.\n","date":"2021-04-07 23:53:17","modifiedFileCount":"1","status":"M","submitter":"Roman Khachatryan"},{"authorTime":"2021-04-07 17:48:02","codes":[{"authorDate":"2021-07-13 17:33:11","commitOrder":6,"curCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, false, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","date":"2021-07-19 14:44:28","endLine":128,"groupId":"31591","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeclineAsyncCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/04/36dbc612dcf538f0d05dee00439336808ce6e7.src","preCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"M"},{"authorDate":"2021-04-07 17:48:02","commitOrder":6,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","date":"2021-04-07 23:53:17","endLine":425,"groupId":"31591","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e0/49e68ded01d5f2c0e83abf65862fca77bdba45.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":383,"status":"N"}],"commitId":"d9cc268be61c1789e5cb32d0897d962721be9c01","commitMessage":"@@@[FLINK-21084][runtime][checkpoint] Task reports finished snapshot on checkpoint if it is finished on restore\n","date":"2021-07-19 14:44:28","modifiedFileCount":"5","status":"M","submitter":"Yun Gao"},{"authorTime":"2021-07-28 13:46:47","codes":[{"authorDate":"2021-07-13 17:33:11","commitOrder":7,"curCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, false, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","date":"2021-07-19 14:44:28","endLine":128,"groupId":"102478","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testDeclineAsyncCheckpoint","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/04/36dbc612dcf538f0d05dee00439336808ce6e7.src","preCode":"    public void testDeclineAsyncCheckpoint() {\n        CheckpointFailureReason originalReason =\n                CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM;\n\n        final Map<OperatorID, OperatorSnapshotFutures> snapshotsInProgress = new HashMap<>();\n        snapshotsInProgress.put(\n                new OperatorID(),\n                new OperatorSnapshotFutures(\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        DoneFuture.of(SnapshotResult.empty()),\n                        ExceptionallyDoneFuture.of(new CheckpointException(originalReason)),\n                        DoneFuture.of(SnapshotResult.empty())));\n\n        final TestEnvironment environment = new TestEnvironment();\n        final AsyncCheckpointRunnable runnable =\n                createAsyncRunnable(snapshotsInProgress, environment, false, true);\n        runnable.run();\n\n        Assert.assertSame(environment.getCause().getCheckpointFailureReason(), originalReason);\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AsyncCheckpointRunnableTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"N"},{"authorDate":"2021-07-28 13:46:47","commitOrder":7,"curCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    false,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","date":"2021-08-03 19:19:41","endLine":437,"groupId":"102478","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testNotifyCheckpointAbortedDuringAsyncPhase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b4/43a36d04a16e5fb3ea17fff0d95d1560fd7c79.src","preCode":"    public void testNotifyCheckpointAbortedDuringAsyncPhase() throws Exception {\n        MockEnvironment mockEnvironment = MockEnvironment.builder().build();\n\n        try (SubtaskCheckpointCoordinatorImpl subtaskCheckpointCoordinator =\n                (SubtaskCheckpointCoordinatorImpl)\n                        new MockSubtaskCheckpointCoordinatorBuilder()\n                                .setEnvironment(mockEnvironment)\n                                .setExecutor(Executors.newSingleThreadExecutor())\n                                .setUnalignedCheckpointEnabled(true)\n                                .build()) {\n            final BlockingRunnableFuture rawKeyedStateHandleFuture = new BlockingRunnableFuture();\n            OperatorSnapshotFutures operatorSnapshotResult =\n                    new OperatorSnapshotFutures(\n                            DoneFuture.of(SnapshotResult.empty()),\n                            rawKeyedStateHandleFuture,\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()),\n                            DoneFuture.of(SnapshotResult.empty()));\n\n            final OperatorChain<String, AbstractStreamOperator<String>> operatorChain =\n                    operatorChain(new CheckpointOperator(operatorSnapshotResult));\n\n            long checkpointId = 42L;\n            subtaskCheckpointCoordinator\n                    .getChannelStateWriter()\n                    .start(checkpointId, CheckpointOptions.forCheckpointWithDefaultLocation());\n            subtaskCheckpointCoordinator.checkpointState(\n                    new CheckpointMetaData(checkpointId, System.currentTimeMillis()),\n                    CheckpointOptions.forCheckpointWithDefaultLocation(),\n                    new CheckpointMetricsBuilder(),\n                    operatorChain,\n                    () -> false);\n            rawKeyedStateHandleFuture.awaitRun();\n            assertEquals(1, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n            assertFalse(rawKeyedStateHandleFuture.isCancelled());\n\n            subtaskCheckpointCoordinator.notifyCheckpointAborted(\n                    checkpointId, operatorChain, () -> true);\n            assertTrue(rawKeyedStateHandleFuture.isCancelled());\n            assertEquals(0, subtaskCheckpointCoordinator.getAsyncCheckpointRunnableSize());\n        }\n    }\n","realPath":"flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":394,"status":"M"}],"commitId":"66bf4e6891a0cb271ca940d3814db83ca51164d5","commitMessage":"@@@[FLINK-21080][runtime][checkpoint] The task reports whether it has called operators' finish method\n","date":"2021-08-03 19:19:41","modifiedFileCount":"12","status":"M","submitter":"Yun Gao"}]
