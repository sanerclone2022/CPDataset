[{"authorTime":"2016-01-25 19:34:05","codes":[{"authorDate":"2016-01-25 19:34:05","commitOrder":4,"curCode":"\tpublic final void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTrigger.TriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-04 03:27:51","endLine":94,"groupId":"9661","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f1/63de18067657d856321eca3394be89fef71979.src","preCode":"\tpublic final void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTrigger.TriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"},{"authorDate":"2016-01-25 19:34:05","commitOrder":4,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tif (setProcessingTime) {\n\t\t\telement.replace(element.getValue(), System.currentTimeMillis());\n\t\t}\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTrigger.TriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-04 03:27:51","endLine":250,"groupId":"22798","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/51/09dae4d15d82a7604b6b6da74adda9cdceb494.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tif (setProcessingTime) {\n\t\t\telement.replace(element.getValue(), System.currentTimeMillis());\n\t\t}\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTrigger.TriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"MB"}],"commitId":"67ca4a436daf8de1a6e0329b4b30342e77d26087","commitMessage":"@@@[FLINK-3200] Use Partitioned State in WindowOperator\n\nThis changes window operator to use the new partitioned state\nabstraction for keeping window contents instead of custom internal\nstate and the checkpointed interface.\n\nFor now.  timers are still kept as custom checkpointed state.  however.\n\nWindowOperator now expects a StateIdentifier for MergingState.  this can\neither be for ReducingState or ListState but WindowOperator is agnostic\nto the type of State. Also the signature of WindowFunction is changed to\ninclude the type of intermediate input. For example.  if a ReducingState\nis used the input of the WindowFunction is T (where T is the input\ntype). If using a ListState the input of the WindowFunction would be of\ntype Iterable[T].\n","date":"2016-02-04 03:27:51","modifiedFileCount":"40","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-02-08 04:46:16","codes":[{"authorDate":"2016-02-08 04:46:16","commitOrder":5,"curCode":"\tpublic final void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-11 05:15:31","endLine":95,"groupId":"9661","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a9/60ac431ec59f850e9ae502cd1fb5d7b83f1ddf.src","preCode":"\tpublic final void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTrigger.TriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2016-02-08 04:46:16","commitOrder":5,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tif (setProcessingTime) {\n\t\t\telement.replace(element.getValue(), System.currentTimeMillis());\n\t\t}\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-11 05:15:31","endLine":252,"groupId":"22798","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/5f/c89e8b2459fc74e1e3d7f1b2e175496db75063.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tif (setProcessingTime) {\n\t\t\telement.replace(element.getValue(), System.currentTimeMillis());\n\t\t}\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTrigger.TriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"50bd65a574776817a03dd32fd438cb2327447109","commitMessage":"@@@[FLINK-3371] [api-breaking] Move TriggerResult and TriggerContext to dedicated classes\n\nThis closes #1603\n","date":"2016-02-11 05:15:31","modifiedFileCount":"13","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2016-01-16 00:05:12","codes":[{"authorDate":"2016-01-16 00:05:12","commitOrder":6,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-17 17:57:44","endLine":96,"groupId":"9661","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/daa1831b41fa98546c67d624c853d2b7948a24.src","preCode":"\tpublic final void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"},{"authorDate":"2016-01-16 00:05:12","commitOrder":6,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-17 17:57:44","endLine":243,"groupId":"22798","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/91/5950abc2009a9db59abbcd61a44f67ac9747e1.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tif (setProcessingTime) {\n\t\t\telement.replace(element.getValue(), System.currentTimeMillis());\n\t\t}\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"M"}],"commitId":"ce8f966c821ceab47c5041ac46f11a55ff3321f0","commitMessage":"@@@[FLINK-3243] Fix Interplay of TimeCharacteristic and Time Windows\n\nThis adds dedicated WindowAssigners for processing time and event time.\ntimeWindow() and timeWindowAll() respect the TimeCharacteristic set\non the StreamExecutionEnvironment.\n\nThis will make the easy stuff easy.  i.e. using time windows and quickly\nswitching the time characteristic. Users will then have the flexibility\nto mix different kinds of window assigners in their job.\n\nThis also expands the translation tests to verify that the correct\nwindow operators are instantiated.\n","date":"2016-02-17 17:57:44","modifiedFileCount":"13","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2015-12-16 00:37:48","codes":[{"authorDate":"2016-01-16 00:05:12","commitOrder":7,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","date":"2016-02-17 17:57:44","endLine":96,"groupId":"9661","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/e9/daa1831b41fa98546c67d624c853d2b7948a24.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"N"},{"authorDate":"2015-12-16 00:37:48","commitOrder":7,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n\t\t\tif (mergingWindows == null) {\n\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n\t\t\t}\n\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-04-05 23:18:58","endLine":304,"groupId":"34444","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7c/4ef7f9add4ce013ff92dc676f6ea4017acfb19.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tMergingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element.getValue());\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"M"}],"commitId":"6cd8ceb10c841827cf89b74ecf5a0495a6933d53","commitMessage":"@@@[FLINK-3174] Add MergingWindowAssigner and SessionWindows\n\nThis introduces MergingWindowAssigner.  an extension of WindowAssigner\nthat can merge windows. When using a MergingWindowAssigner the\nWindowOperator eagerly merges windows when processing elements.\n\nFor keeping track of in-flight windows and for merging windows this adds\nMergingWindowSet.  this keeps track of windows per key.\n\nOnly when using a MergingWindowAssigners is the more costly merging\nlogic used in the WindowOperator.\n\nFor triggers there is a new method Trigger.onMerge() that notifies the\ntrigger of the new merged window. This allows the trigger to set a timer\nfor the newly merged window. Only triggers that return true\nfrom Trigger.canMerge() can be used with MergingWindowAssigner. Trigger\nhas default implementations for canMerge() and onMerge().  we return\nfalse and onMerge() throws an Exception.\n\nThis also adds AbstractStateBackend.mergePartitionedStates for merging\nstate of several source namespaces into a target namespace. This is only\npossible for the newly introduced MergingState which is an extension of\nAppendingState. Only ReducingState and ListState are MergingState while\nFoldingState is now an AppendingState.\n\nThis enables proper support for session windows.\n\nThis also adds the EventTimeSessionWindows and ProcessingTimeSessionWindows\nwindow assigners and adapts an existing session example and adds test cases.\n","date":"2016-04-05 23:18:58","modifiedFileCount":"21","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2015-12-16 00:37:48","codes":[{"authorDate":"2016-04-07 00:12:34","commitOrder":8,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n\t\t\t\telement.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n\t\t\tif (mergingWindows == null) {\n\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n\t\t\t}\n\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(stateWindow,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n\t\t\t\t\t\tmergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-04-07 16:35:24","endLine":163,"groupId":"34444","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/1e/4e453a4372f74ba02c294ec32de00afb254301.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tfor (W window: elementWindows) {\n\n\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\twindowStateDescriptor);\n\n\t\t\twindowState.add(element);\n\n\t\t\tcontext.key = key;\n\t\t\tcontext.window = window;\n\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2015-12-16 00:37:48","commitOrder":8,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n\t\t\tif (mergingWindows == null) {\n\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n\t\t\t}\n\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-04-05 23:18:58","endLine":304,"groupId":"34444","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/7c/4ef7f9add4ce013ff92dc676f6ea4017acfb19.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n\t\t\tif (mergingWindows == null) {\n\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n\t\t\t}\n\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"N"}],"commitId":"a3415028dd7bec24e170c0d8a3531b19c021aaaf","commitMessage":"@@@[hotfix] Fix EvictingWindowOperator to work with MergingWindowAssigner\n","date":"2016-04-07 16:35:24","modifiedFileCount":"1","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-04-12 22:27:18","codes":[{"authorDate":"2016-04-12 22:27:18","commitOrder":9,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n\t\t\t\telement.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(stateWindow,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n\t\t\t\t\t\tmergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-04-25 16:18:40","endLine":160,"groupId":"9661","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/84/ee0b93cbff113a646b0fc2b8e2161c05cb2966.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n\t\t\t\telement.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n\t\t\tif (mergingWindows == null) {\n\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n\t\t\t}\n\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(stateWindow,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n\t\t\t\t\t\tmergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2016-04-12 22:27:18","commitOrder":9,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-04-25 16:18:40","endLine":327,"groupId":"9661","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/91/9cee7465a93f31a2ec721b1f26eab0b4d16c7d.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tK key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n\t\t\tif (mergingWindows == null) {\n\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n\t\t\t}\n\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":255,"status":"M"}],"commitId":"f2f5bd5bed2f737b8418be09359691e899462184","commitMessage":"@@@[FLINK-3740] Make Session Window State Checkpointed\n","date":"2016-04-25 16:18:40","modifiedFileCount":"5","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-05-31 23:13:58","codes":[{"authorDate":"2016-05-31 23:13:58","commitOrder":10,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(),\n\t\t\telement.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-06-21 18:14:06","endLine":186,"groupId":"52707","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fa/1c894b83a9b1f15b87a329d7d667d08edebfdb.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n\t\t\t\telement.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(stateWindow,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n\t\t\t\t\t\tmergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(window,\n\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2016-05-31 23:13:58","commitOrder":10,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(),\n\t\t\telement.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element+ \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-06-21 18:14:06","endLine":378,"groupId":"52707","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/95/ad1b09d0c5e4c97cac71e2212ce922760daed4.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(stateWindowResult,\n\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer,\n\t\t\t\t\t\twindowStateDescriptor);\n\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tprocessTriggerResult(triggerResult, window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":281,"status":"M"}],"commitId":"34a8b03d2ad40db7dc00fa47923b96374c289838","commitMessage":"@@@[FLINK-3714] Add Support for \"Allowed Lateness\"\n\nHandle late elements and take care\nof cleaning the window state.\n","date":"2016-06-21 18:14:06","modifiedFileCount":"16","status":"M","submitter":"kl0u"},{"authorTime":"2016-05-12 20:16:14","codes":[{"authorDate":"2016-05-12 20:16:14","commitOrder":11,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-06-27 23:16:12","endLine":186,"groupId":"52707","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d8/2fc85cb6a16123c911df6e59b475dc981d1429.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(),\n\t\t\telement.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2016-05-12 20:16:14","commitOrder":11,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element+ \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-06-27 23:16:12","endLine":388,"groupId":"52707","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ad/01a5a1b744e8e35eca6eb19bb8824b43769536.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(),\n\t\t\telement.getTimestamp());\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element+ \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":293,"status":"M"}],"commitId":"4b5a789000a903c84f89b668a4cbd2ba1397e758","commitMessage":"@@@[FLINK-3464] Use Processing-Time Clock in Window Assigners/Triggers\n\nIntroduces a custom TimeServiceProvider to the StreamTask.\nThis is responsible for defining and updating the current\nprocessingtime for a task and handling all related action. \nsuch as registering timers for actions to be executed in\nthe future.\n","date":"2016-06-27 23:16:12","modifiedFileCount":"24","status":"M","submitter":"kl0u"},{"authorTime":"2016-07-04 20:32:42","codes":[{"authorDate":"2016-07-04 20:32:42","commitOrder":12,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-07-04 23:24:08","endLine":187,"groupId":"0","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3f/2c6a39040723b0dc7a69d1259d17ceb0402957.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2016-07-04 20:32:42","commitOrder":12,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element+ \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-07-04 23:24:08","endLine":388,"groupId":"43074","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/b6/ca564edcb790a3b4af363ee23d5cdf03e4ff7a.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element+ \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"M"}],"commitId":"e34fea53b69cd7c40eca716e3f2d7a68ac3cbc18","commitMessage":"@@@[FLINK-4134] Retire Late Windows/Elements in WindowOperator\n\nBefore.  when processing an element that would end up in a late window\n(when using a MergingWindowAssigner).  the element would be added to the\nMergingWindowSet. After determining that the window is late it would not\nbe removed from the MergingWindowSet. This can lead to problems with\nother elements being merged into these \"phantom\" windows and causing\ntriggers to be added for empty windows.\n\nThis also fixes the same code in EvictingWindowOperator.\n","date":"2016-07-04 23:24:08","modifiedFileCount":"3","status":"M","submitter":"Stefan Richter"},{"authorTime":"2016-07-18 17:37:06","codes":[{"authorDate":"2016-07-18 17:37:06","commitOrder":13,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-07-27 03:12:05","endLine":204,"groupId":"8797","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/15/f716c7754165822759cb036b13f6f0512404d8.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2016-07-18 17:37:06","commitOrder":13,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-07-27 03:12:05","endLine":404,"groupId":"8797","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/34843bd04a28637561497a62559424cbc3b784.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element+ \" for window \" + actualWindow + \" due to lateness.\");\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\t\t\t\tfireOrContinue(combinedTriggerResult, actualWindow, windowState);\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tLOG.info(\"Dropped element \" + element + \" for window \" + window + \" due to lateness.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tfireOrContinue(triggerResult, window, windowState);\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"M"}],"commitId":"12bf7c1a0b81d199085fe874c64763c51a93b3bf","commitMessage":"@@@[FLINK-4207] WindowOperator becomes very slow with allowed lateness\n","date":"2016-07-27 03:12:05","modifiedFileCount":"16","status":"M","submitter":"kl0u"},{"authorTime":"2016-09-01 05:59:27","codes":[{"authorDate":"2016-09-01 05:59:27","commitOrder":14,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-09-30 18:38:46","endLine":204,"groupId":"8797","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a8/38faa08c57735d01a6d85ba1388b7b244a1ed2.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2016-09-01 05:59:27","commitOrder":14,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-09-30 18:38:46","endLine":409,"groupId":"8797","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ff/df3346c72433393525b155f8a5c93fee93d7f9.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":297,"status":"M"}],"commitId":"53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c","commitMessage":"@@@[FLINK-4379] [checkpoints] Introduce rescalable operator state\n\nThis introduces the Operator State Backend.  which stores state that is not partitioned\nby a key. It replaces the 'Checkpointed' interface.\n\nAdditionally.  this introduces CheckpointStateHandles as container for all checkpoint related state handles\n\nThis closes #2512\n","date":"2016-09-30 18:38:46","modifiedFileCount":"96","status":"M","submitter":"Stefan Richter"},{"authorTime":"2016-10-21 23:55:53","codes":[{"authorDate":"2016-10-21 23:55:53","commitOrder":15,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-11-01 21:02:54","endLine":205,"groupId":"8797","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/f9/b409e5ed555fc241f60805fd810c22f1068b40.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2016-10-21 23:55:53","commitOrder":15,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(window, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-11-01 21:02:54","endLine":335,"groupId":"8797","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c4/657674908d06a5e006d066fa0593451c5a171f.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"}],"commitId":"ca68d2e074eee66066377c3ebf69c0e15e9956d0","commitMessage":"@@@[FLINK-4884] Eagerly Store MergingWindowSet in State in WindowOperator\n","date":"2016-11-01 21:02:54","modifiedFileCount":"4","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2016-10-21 23:55:53","codes":[{"authorDate":"2016-11-01 07:21:04","commitOrder":16,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-11-15 17:05:24","endLine":212,"groupId":"49306","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3b/e3f5a5032e8f7277a1788e8b8f96c21e71ffed.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"M"},{"authorDate":"2016-10-21 23:55:53","commitOrder":16,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(window, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-11-01 21:02:54","endLine":335,"groupId":"8797","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/c4/657674908d06a5e006d066fa0593451c5a171f.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(window, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"N"}],"commitId":"74bb7bb63919ce6de5736d52e4e5a254cf9b6509","commitMessage":"@@@[FLINK-4174] Enhance evictor functionality\n","date":"2016-11-15 17:05:24","modifiedFileCount":"7","status":"M","submitter":"Vishnu Viswanath"},{"authorTime":"2016-11-02 18:06:01","codes":[{"authorDate":"2016-11-02 18:06:01","commitOrder":17,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-11-28 19:48:11","endLine":203,"groupId":"49306","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8c/738780cf8250a6353d73d8af174f207bd12873.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2016-11-02 18:06:01","commitOrder":17,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(window, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2016-11-28 19:48:11","endLine":327,"groupId":"17451","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ed/cd8339c306ef4d113e6f3d6feff682ec622ab8.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tfinal Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmergeTriggerResult.f0 = context.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n\n\t\t\t\tif (combinedTriggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (combinedTriggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(window, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"}],"commitId":"1875cac03042dad4a4c47b0de8364f02fbe457c6","commitMessage":"@@@[FLINK-4993] Don't Allow Trigger.onMerge() to return TriggerResult\n\nAllowing Trigger.onMerge() to return a TriggerResult is not necessary\nsince an onMerge() call will always be followed by an onElement() call\nwhen adding the element that caused the merging to the merged window.\nHaving this complicates the internal logic of the WindowOperator and\nmakes writing Triggers more confusing than it has to be.\n","date":"2016-11-28 19:48:11","modifiedFileCount":"12","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-01-13 22:17:09","codes":[{"authorDate":"2017-01-13 22:17:09","commitOrder":18,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, evictingWindowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, evictingWindowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-01-23 04:53:39","endLine":211,"groupId":"22425","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/d9/c977a6ad1ef14e883f2dc1bac9bff0a0e62336.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\tstateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tListState<StreamRecord<IN>> windowState = getPartitionedState(\n\t\t\t\t\twindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents, windowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"},{"authorDate":"2017-01-13 22:17:09","commitOrder":18,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\t\t\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-01-23 04:53:39","endLine":422,"groupId":"16659","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9b/8af58ab17f27256f1a70bd32b1fa5d4db21ded.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tgetKeyedStateBackend().mergePartitionedStates(\n\t\t\t\t\t\t\tstateWindowResult,\n\t\t\t\t\t\t\tmergedStateWindows,\n\t\t\t\t\t\t\twindowSerializer,\n\t\t\t\t\t\t\t(StateDescriptor<? extends MergingState<?,?>, ?>) windowStateDescriptor);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tAppendingState<IN, ACC> windowState =\n\t\t\t\t\t\tgetPartitionedState(window, windowSerializer, windowStateDescriptor);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"3b97128f05bacfb80afe4a2a49741c31ff306cd2","commitMessage":"@@@[FLINK-5590] [runtime] Add proper internal state hierarchy\n\nThis introduces an internal state hierarchy that mirrors the external state hierarchy. \nbut gives the runtime access to methods that should not be part of the user facing API. \nsuch as:\n  - setting namespaces\n  - accessing raw values\n  - merging namespaces\n","date":"2017-01-23 04:53:39","modifiedFileCount":"38","status":"M","submitter":"Stephan Ewen"},{"authorTime":"2016-11-02 18:51:07","codes":[{"authorDate":"2016-11-02 18:51:07","commitOrder":19,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-01-24 17:42:34","endLine":209,"groupId":"22425","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/45/fea14a2237b3e46af1a80dc0d7748c868c21fd.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, evictingWindowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, evictingWindowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"},{"authorDate":"2016-11-02 18:51:07","commitOrder":19,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-01-24 17:42:34","endLine":422,"groupId":"16659","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3c/4f39776ec74ee54846dd1c03910f320ad8f06e.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\t\t\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(actualWindow, windowState, mergingWindows);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfire(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tcleanup(window, windowState, null);\n\t\t\t\t} else {\n\t\t\t\t\tregisterCleanupTimer(window);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":322,"status":"M"}],"commitId":"0b331a421267a541d91e94f2713534704ed32bed","commitMessage":"@@@[FLINK-4994] Don't Clear Trigger State and Merging Window Set When Purging\n\nBefore.  when a Trigger returns TriggerResult.PURGE from any of the\non*() methods the WindowOperator will clear all state of that window\n(window contents.  merging window set) and call Trigger.clear() so that the\nTrigger can clean up its state/timers.\n\nThis was problematic in some cases. For example.  with merging windows (session\nwindows) this means that a late-arriving element will not be put into the\nsession that was previously built up but will be put into a completely new\nsession that only contains this one element.\n\nThe new behaviour is this:\n * Only clean window contents on PURGE\n * Register cleanup timer for any window.  don't delete this on PURGE\n * When the cleanup timer fires: clean window state.  clean merging window set. \ncall Trigger.clear() to allow it to clean state/timers\n","date":"2017-01-24 17:42:34","modifiedFileCount":"3","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2017-03-01 22:36:17","commitOrder":20,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-03-18 14:44:17","endLine":211,"groupId":"22425","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/8d/fc717cf811586afbe5e3745aa1710ef96fccaa.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2017-03-01 22:36:17","commitOrder":20,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-18 14:44:17","endLine":446,"groupId":"13596","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9c/e1ae7fc8a76e94dd0be2102eea5fe0c6252aa3.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"M"}],"commitId":"07a15d0e1647c79ae010ca6df5b1830a4087dd56","commitMessage":"@@@[FLINK-4460] Provide late-data output for window operations\n\nWe use side outputs to emit dropped late data.\n","date":"2017-03-18 14:44:17","modifiedFileCount":"8","status":"M","submitter":"Chen Qin"},{"authorTime":"2017-03-01 22:36:17","codes":[{"authorDate":"2017-03-21 22:00:24","commitOrder":21,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-23 23:29:01","endLine":221,"groupId":"13596","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/95/1f661c0a32b729c130781a347b4c20158cdeba.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tCollection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(),\n\t\t\t\telement.getTimestamp(),\n\t\t\t\twindowAssignerContext);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal K key = (K) getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2017-03-01 22:36:17","commitOrder":21,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-18 14:44:17","endLine":446,"groupId":"13596","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/9c/e1ae7fc8a76e94dd0be2102eea5fe0c6252aa3.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"N"}],"commitId":"3c4b156527e9ca7cb2dafdda706913e91d688133","commitMessage":"@@@[hotfix] Add EvictingWindowOperatorContractTest\n\nThe existing WindowOperatorContractTest is turned into a test base while\nRegularWindowOperatorContract test tests WindowOperator and\nEvictingWindowOperatorTest tests EvictingWindowOperator. For this to\nwork.  the base tests now always use List windows and we have specific\ntests for reducing/folding windows in RegularWindowOperatorContractTest.\n\nThis also patches in the missing side output support for\nEvictingWindowOperator.\n","date":"2017-03-23 23:29:01","modifiedFileCount":"3","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-03-21 21:58:45","codes":[{"authorDate":"2017-03-21 21:58:45","commitOrder":22,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-23 23:29:02","endLine":234,"groupId":"13596","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/24/c8d328175a2b3302cb582cf8079ce07f341d5a.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2017-03-21 21:58:45","commitOrder":22,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-23 23:29:02","endLine":459,"groupId":"13596","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/37/45659fad5d623cc9214888a1a97c5cec9e121b.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"M"}],"commitId":"68289b1a52db7157d23085850ec947e78e729f01","commitMessage":"@@@[FLINK-5972] Don't allow shrinking merging windows\n\nThis closes #3587.\n","date":"2017-03-23 23:29:02","modifiedFileCount":"3","status":"M","submitter":"Aljoscha Krettek"},{"authorTime":"2017-03-06 12:07:18","codes":[{"authorDate":"2017-03-06 12:07:18","commitOrder":23,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-25 23:59:17","endLine":234,"groupId":"13596","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/85/451a52f3d39ef941c50bb00a6b29eb8aafb43d.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"},{"authorDate":"2017-03-06 12:07:18","commitOrder":23,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","date":"2017-03-25 23:59:17","endLine":472,"groupId":"13596","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/3d/407167b5cf1768b20593ebf309bbacd7f0f1ed.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontext.key = key;\n\t\t\t\t\t\tcontext.window = mergeResult;\n\n\t\t\t\t\t\tcontext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\tcontext.window = m;\n\t\t\t\t\t\t\tcontext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\tcontext.key = key;\n\t\t\t\tcontext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = context.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":346,"status":"M"}],"commitId":"fad201bfb0b1f2757f68f7b3ffaf97a486eb93e8","commitMessage":"@@@[FLINK-5929] Allow Access to Per-Window State in ProcessWindowFunction\n","date":"2017-03-25 23:59:17","modifiedFileCount":"24","status":"M","submitter":"Seth Wiesman"},{"authorTime":"2017-09-12 12:26:08","codes":[{"authorDate":"2017-09-12 12:26:08","commitOrder":24,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && isElementLate(element)) {\n\t\t\tif (lateDataOutputTag != null){\n\t\t\t\tsideOutput(element);\n\t\t\t} else {\n\t\t\t\tthis.numLateRecordsDropped.inc();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-10-25 20:21:51","endLine":239,"groupId":"13596","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fd/01446e6bf17cf9e28adc0e7aba5e499c1e29c2.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"},{"authorDate":"2017-09-12 12:26:08","commitOrder":24,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && isElementLate(element)) {\n\t\t\tif (lateDataOutputTag != null){\n\t\t\t\tsideOutput(element);\n\t\t\t} else {\n\t\t\t\tthis.numLateRecordsDropped.inc();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-10-25 20:21:51","endLine":419,"groupId":"13596","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/a9/216256bfefc4a05fd98d0dc2cee1a31522136d.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && lateDataOutputTag != null && isElementLate(element)) {\n\t\t\tsideOutput(element);\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"M"}],"commitId":"41e5a8338c3ce077ac7d98e97247b54f8f175ff5","commitMessage":"@@@[FLINK-7611][metrics] Measure number of dropped late elements\n\nThis closes #4665.\n","date":"2017-10-25 20:21:51","modifiedFileCount":"2","status":"M","submitter":"minwenjun"},{"authorTime":"2019-06-17 19:09:43","codes":[{"authorDate":"2017-09-12 12:26:08","commitOrder":25,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && isElementLate(element)) {\n\t\t\tif (lateDataOutputTag != null){\n\t\t\t\tsideOutput(element);\n\t\t\t} else {\n\t\t\t\tthis.numLateRecordsDropped.inc();\n\t\t\t}\n\t\t}\n\t}\n","date":"2017-10-25 20:21:51","endLine":239,"groupId":"103418","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/fd/01446e6bf17cf9e28adc0e7aba5e499c1e29c2.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window,\n\t\t\t\t\t\tnew MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\t\t\tfor (W m : mergedWindows) {\n\t\t\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tevictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(stateWindow);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window : elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tevictingWindowState.setCurrentNamespace(window);\n\t\t\t\tevictingWindowState.add(element);\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\t\t\t\tevictorContext.key = key;\n\t\t\t\tevictorContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tIterable<StreamRecord<IN>> contents = evictingWindowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents, evictingWindowState);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\tevictingWindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && isElementLate(element)) {\n\t\t\tif (lateDataOutputTag != null){\n\t\t\t\tsideOutput(element);\n\t\t\t} else {\n\t\t\t\tthis.numLateRecordsDropped.inc();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"N"},{"authorDate":"2019-06-17 19:09:43","commitOrder":25,"curCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime()) {\n\t\t\t\t\t\t\tlong currentProcessingTime = internalTimerService.currentProcessingTime();\n\t\t\t\t\t\t\tif (mergeResult.maxTimestamp() <= currentProcessingTime) {\n\t\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + currentProcessingTime +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && isElementLate(element)) {\n\t\t\tif (lateDataOutputTag != null){\n\t\t\t\tsideOutput(element);\n\t\t\t} else {\n\t\t\t\tthis.numLateRecordsDropped.inc();\n\t\t\t}\n\t\t}\n\t}\n","date":"2019-06-19 22:08:48","endLine":427,"groupId":"103418","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"processElement","params":"(StreamRecord<IN>element)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/08/aaf0493d77037eef9e59ac57f76c931ef2a3ee.src","preCode":"\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\tfinal Collection<W> elementWindows = windowAssigner.assignWindows(\n\t\t\telement.getValue(), element.getTimestamp(), windowAssignerContext);\n\n\t\t\r\n\t\tboolean isSkippedElement = true;\n\n\t\tfinal K key = this.<K>getKeyedStateBackend().getCurrentKey();\n\n\t\tif (windowAssigner instanceof MergingWindowAssigner) {\n\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tW actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void merge(W mergeResult,\n\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n\n\t\t\t\t\t\tif ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of an \" +\n\t\t\t\t\t\t\t\t\t\"event-time window cannot become earlier than the current watermark \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current watermark: \" + internalTimerService.currentWatermark() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t} else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\"The end timestamp of a \" +\n\t\t\t\t\t\t\t\t\t\"processing-time window cannot become earlier than the current processing time \" +\n\t\t\t\t\t\t\t\t\t\"by merging. Current processing time: \" + internalTimerService.currentProcessingTime() +\n\t\t\t\t\t\t\t\t\t\" window: \" + mergeResult);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttriggerContext.key = key;\n\t\t\t\t\t\ttriggerContext.window = mergeResult;\n\n\t\t\t\t\t\ttriggerContext.onMerge(mergedWindows);\n\n\t\t\t\t\t\tfor (W m: mergedWindows) {\n\t\t\t\t\t\t\ttriggerContext.window = m;\n\t\t\t\t\t\t\ttriggerContext.clear();\n\t\t\t\t\t\t\tdeleteCleanupTimer(m);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\r\n\t\t\t\t\t\twindowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(actualWindow)) {\n\t\t\t\t\tmergingWindows.retireWindow(actualWindow);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\tW stateWindow = mergingWindows.getStateWindow(actualWindow);\n\t\t\t\tif (stateWindow == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Window \" + window + \" is not in in-flight window set.\");\n\t\t\t\t}\n\n\t\t\t\twindowState.setCurrentNamespace(stateWindow);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = actualWindow;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(actualWindow, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(actualWindow);\n\t\t\t}\n\n\t\t\t\r\n\t\t\tmergingWindows.persist();\n\t\t} else {\n\t\t\tfor (W window: elementWindows) {\n\n\t\t\t\t\r\n\t\t\t\tif (isWindowLate(window)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisSkippedElement = false;\n\n\t\t\t\twindowState.setCurrentNamespace(window);\n\t\t\t\twindowState.add(element.getValue());\n\n\t\t\t\ttriggerContext.key = key;\n\t\t\t\ttriggerContext.window = window;\n\n\t\t\t\tTriggerResult triggerResult = triggerContext.onElement(element);\n\n\t\t\t\tif (triggerResult.isFire()) {\n\t\t\t\t\tACC contents = windowState.get();\n\t\t\t\t\tif (contents == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\temitWindowContents(window, contents);\n\t\t\t\t}\n\n\t\t\t\tif (triggerResult.isPurge()) {\n\t\t\t\t\twindowState.clear();\n\t\t\t\t}\n\t\t\t\tregisterCleanupTimer(window);\n\t\t\t}\n\t\t}\n\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (isSkippedElement && isElementLate(element)) {\n\t\t\tif (lateDataOutputTag != null){\n\t\t\t\tsideOutput(element);\n\t\t\t} else {\n\t\t\t\tthis.numLateRecordsDropped.inc();\n\t\t\t}\n\t\t}\n\t}\n","realPath":"flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"d79a3771192363f5cf6643741bfd50b4fab3a4e4","commitMessage":"@@@[hotfix][streaming] Report correct value of currentProcessingTime in the exception\n\nPreviously the actual and reported values were always of by small margin.\n","date":"2019-06-19 22:08:48","modifiedFileCount":"1","status":"M","submitter":"Piotr Nowojski"}]
