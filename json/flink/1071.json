[{"authorTime":"2018-02-26 13:00:06","codes":[{"authorDate":"2018-02-26 13:00:06","commitOrder":1,"curCode":"\tpublic void testScalingUp() throws Exception {\n\n\t\t\r\n\n\t\tOperatorSubtaskState snapshot;\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 1, records);\n\n\t\t\tsnapshot = harness.snapshot(0, 0);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(snapshot);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(snapshot);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].setup();\n\t\t\tharness3[0].initializeState(snapshot2);\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].setup();\n\t\t\tharness3[1].initializeState(snapshot2);\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].setup();\n\t\t\tharness3[2].initializeState(snapshot2);\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 3, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 3, records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[4], records[5], records[6], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[0], records[1], records[2], records[3], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[0], records[1], records[2], records[3], records[4], records[5], records[6]);\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\t}\n","date":"2018-06-05 20:18:44","endLine":208,"groupId":"33231","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testScalingUp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/65/14d0e594f87317a53a63c4c1870574ad76d7b4.src","preCode":"\tpublic void testScalingUp() throws Exception {\n\n\t\t\r\n\n\t\tOperatorSubtaskState snapshot;\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 1, records);\n\n\t\t\tsnapshot = harness.snapshot(0, 0);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(snapshot);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(snapshot);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].setup();\n\t\t\tharness3[0].initializeState(snapshot2);\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].setup();\n\t\t\tharness3[1].initializeState(snapshot2);\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].setup();\n\t\t\tharness3[2].initializeState(snapshot2);\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 3, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 3, records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[4], records[5], records[6], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[0], records[1], records[2], records[3], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[0], records[1], records[2], records[3], records[4], records[5], records[6]);\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksIncrementalCheckpointRescalingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"B"},{"authorDate":"2018-02-26 13:00:06","commitOrder":1,"curCode":"\tpublic void testScalingDown() throws Exception {\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 = new KeyedOneInputStreamOperatorTestHarness[3];\n\t\tOperatorSubtaskState snapshot3;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[7], records[8], records[9]);\n\n\t\t\tsnapshot3 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness3[0].snapshot(0, 0),\n\t\t\t\tharness3[1].snapshot(0, 0),\n\t\t\t\tharness3[2].snapshot(0, 0)\n\t\t\t);\n\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(snapshot3);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(snapshot3);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\n\t\t\t\r\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.setup();\n\t\t\tharness.initializeState(snapshot2);\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 3, records);\n\t\t}\n\t}\n","date":"2018-06-05 20:18:44","endLine":320,"groupId":"33231","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testScalingDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/65/14d0e594f87317a53a63c4c1870574ad76d7b4.src","preCode":"\tpublic void testScalingDown() throws Exception {\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 = new KeyedOneInputStreamOperatorTestHarness[3];\n\t\tOperatorSubtaskState snapshot3;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[7], records[8], records[9]);\n\n\t\t\tsnapshot3 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness3[0].snapshot(0, 0),\n\t\t\t\tharness3[1].snapshot(0, 0),\n\t\t\t\tharness3[2].snapshot(0, 0)\n\t\t\t);\n\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(snapshot3);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(snapshot3);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\n\t\t\t\r\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.setup();\n\t\t\tharness.initializeState(snapshot2);\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 3, records);\n\t\t}\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksIncrementalCheckpointRescalingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":212,"status":"B"}],"commitId":"bbf7ff2273d3e7724abdd6eb6414961a26e53159","commitMessage":"@@@[FLINK-8790][State] Improve performance of rescaling an incremental checkpoint\n\nThis closes #5582.\n","date":"2018-06-05 20:18:44","modifiedFileCount":"7","status":"B","submitter":"sihuazhou"},{"authorTime":"2019-02-23 03:19:12","codes":[{"authorDate":"2019-02-23 03:19:12","commitOrder":2,"curCode":"\tpublic void testScalingUp() throws Exception {\n\n\t\t\r\n\n\t\tOperatorSubtaskState snapshot;\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 1, records);\n\n\t\t\tsnapshot = harness.snapshot(0, 0);\n\t\t}\n\n\t\t\r\n\n\t\t\r\n\t\tOperatorSubtaskState initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot, maxParallelism, 1, 2, 0);\n\n\t\t\r\n\t\tOperatorSubtaskState initState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot, maxParallelism, 1, 2, 1);\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(initState1);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(initState2);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\t\r\n\t\tinitState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot2, maxParallelism, 2, 3, 0);\n\n\t\t\r\n\t\tinitState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot2, maxParallelism, 2, 3, 1);\n\n\t\t\r\n\t\tOperatorSubtaskState initState3 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot2, maxParallelism, 2, 3, 2);\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].setup();\n\t\t\tharness3[0].initializeState(initState1);\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].setup();\n\t\t\tharness3[1].initializeState(initState2);\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].setup();\n\t\t\tharness3[2].initializeState(initState3);\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 3, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 3, records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[4], records[5], records[6], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[0], records[1], records[2], records[3], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[0], records[1], records[2], records[3], records[4], records[5], records[6]);\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\t}\n","date":"2019-02-23 03:19:12","endLine":228,"groupId":"48964","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testScalingUp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/23/4651667fc0fe991e947ae05a2c753fd8d4e2c5.src","preCode":"\tpublic void testScalingUp() throws Exception {\n\n\t\t\r\n\n\t\tOperatorSubtaskState snapshot;\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 1, records);\n\n\t\t\tsnapshot = harness.snapshot(0, 0);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(snapshot);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(snapshot);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].setup();\n\t\t\tharness3[0].initializeState(snapshot2);\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].setup();\n\t\t\tharness3[1].initializeState(snapshot2);\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].setup();\n\t\t\tharness3[2].initializeState(snapshot2);\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 3, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 3, records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[4], records[5], records[6], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[0], records[1], records[2], records[3], records[7], records[8], records[9]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[0], records[1], records[2], records[3], records[4], records[5], records[6]);\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksIncrementalCheckpointRescalingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"},{"authorDate":"2019-02-23 03:19:12","commitOrder":2,"curCode":"\tpublic void testScalingDown() throws Exception {\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 = new KeyedOneInputStreamOperatorTestHarness[3];\n\t\tOperatorSubtaskState snapshot3;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[7], records[8], records[9]);\n\n\t\t\tsnapshot3 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness3[0].snapshot(0, 0),\n\t\t\t\tharness3[1].snapshot(0, 0),\n\t\t\t\tharness3[2].snapshot(0, 0)\n\t\t\t);\n\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\n\t\t\r\n\n\t\t\r\n\t\tOperatorSubtaskState initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot3, maxParallelism, 3, 2, 0);\n\n\t\t\r\n\t\tOperatorSubtaskState initState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot3, maxParallelism, 3, 2, 1);\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(initState1);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(initState2);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\t\r\n\t\tinitState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(\n\t\t\tsnapshot2, maxParallelism, 2, 1, 0);\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\n\t\t\t\r\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.setup();\n\t\t\tharness.initializeState(initState1);\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 3, records);\n\t\t}\n\t}\n","date":"2019-02-23 03:19:12","endLine":352,"groupId":"48966","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testScalingDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/23/4651667fc0fe991e947ae05a2c753fd8d4e2c5.src","preCode":"\tpublic void testScalingDown() throws Exception {\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 = new KeyedOneInputStreamOperatorTestHarness[3];\n\t\tOperatorSubtaskState snapshot3;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t3);\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n\t\t\tharness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n\t\t\tharness3[0].setStateBackend(getStateBackend());\n\t\t\tharness3[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n\t\t\tharness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n\t\t\tharness3[1].setStateBackend(getStateBackend());\n\t\t\tharness3[1].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n\t\t\tAssert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n\t\t\tharness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n\t\t\tharness3[2].setStateBackend(getStateBackend());\n\t\t\tharness3[2].open();\n\n\t\t\tvalidHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]);\n\t\t\tvalidHarnessResult(harness3[1], 1, records[4], records[5], records[6]);\n\t\t\tvalidHarnessResult(harness3[2], 1, records[7], records[8], records[9]);\n\n\t\t\tsnapshot3 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness3[0].snapshot(0, 0),\n\t\t\t\tharness3[1].snapshot(0, 0),\n\t\t\t\tharness3[2].snapshot(0, 0)\n\t\t\t);\n\n\t\t} finally {\n\t\t\tcloseHarness(harness3);\n\t\t}\n\n\t\t\r\n\n\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n\t\t\tnew KeyedOneInputStreamOperatorTestHarness[3];\n\n\t\tOperatorSubtaskState snapshot2;\n\n\t\ttry {\n\t\t\tList<KeyGroupRange> keyGroupPartitions = StateAssignmentOperation.createKeyGroupPartitions(\n\t\t\t\tmaxParallelism,\n\t\t\t\t2);\n\n\t\t\t\r\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n\t\t\tAssert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n\t\t\tharness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n\t\t\tharness2[0].setStateBackend(getStateBackend());\n\t\t\tharness2[0].setup();\n\t\t\tharness2[0].initializeState(snapshot3);\n\t\t\tharness2[0].open();\n\n\t\t\t\r\n\t\t\tKeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n\t\t\tAssert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n\t\t\tharness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n\t\t\tharness2[1].setStateBackend(getStateBackend());\n\t\t\tharness2[1].setup();\n\t\t\tharness2[1].initializeState(snapshot3);\n\t\t\tharness2[1].open();\n\n\t\t\tvalidHarnessResult(harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n\t\t\tvalidHarnessResult(harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tsnapshot2 = AbstractStreamOperatorTestHarness.repackageState(\n\t\t\t\tharness2[0].snapshot(0, 0),\n\t\t\t\tharness2[1].snapshot(0, 0)\n\t\t\t);\n\n\t\t\tvalidHarnessResult(harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n\t\t\tvalidHarnessResult(harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n\t\t} finally {\n\t\t\tcloseHarness(harness2);\n\t\t}\n\n\t\t\r\n\n\t\ttry (\n\t\t\tKeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n\t\t\t\tgetHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\n\t\t\t\r\n\t\t\tharness.setStateBackend(getStateBackend());\n\t\t\tharness.setup();\n\t\t\tharness.initializeState(snapshot2);\n\t\t\tharness.open();\n\n\t\t\tvalidHarnessResult(harness, 3, records);\n\t\t}\n\t}\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksIncrementalCheckpointRescalingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"}],"commitId":"bdb776035f7266916e9debc7a0d4e7cc5cb1dfd3","commitMessage":"@@@[FLINK-11618][state] Refactor operator state repartition mechanism\n\nThis closes #7711.\n","date":"2019-02-23 03:19:12","modifiedFileCount":"20","status":"M","submitter":"Yun Tang"},{"authorTime":"2021-02-04 16:09:11","codes":[{"authorDate":"2021-02-04 16:09:11","commitOrder":3,"curCode":"    public void testScalingUp() throws Exception {\n\n        \r\n        \r\n\n        OperatorSubtaskState snapshot;\n\n        try (KeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n                getHarnessTest(keySelector, maxParallelism, 1, 0)) {\n            harness.setStateBackend(getStateBackend());\n            harness.open();\n\n            validHarnessResult(harness, 1, records);\n\n            snapshot = harness.snapshot(0, 0);\n        }\n\n        \r\n        \r\n\n        \r\n        OperatorSubtaskState initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot, maxParallelism, 1, 2, 0);\n\n        \r\n        OperatorSubtaskState initState2 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot, maxParallelism, 1, 2, 1);\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n\n        OperatorSubtaskState snapshot2;\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 2);\n\n            \r\n            KeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n            harness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n            harness2[0].setStateBackend(getStateBackend());\n            harness2[0].setup();\n            harness2[0].initializeState(initState1);\n            harness2[0].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n            harness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n            harness2[1].setStateBackend(getStateBackend());\n            harness2[1].setup();\n            harness2[1].initializeState(initState2);\n            harness2[1].open();\n\n            validHarnessResult(\n                    harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n            validHarnessResult(\n                    harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n            snapshot2 =\n                    AbstractStreamOperatorTestHarness.repackageState(\n                            harness2[0].snapshot(0, 0), harness2[1].snapshot(0, 0));\n        } finally {\n            closeHarness(harness2);\n        }\n\n        \r\n        \r\n\n        \r\n        initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 3, 0);\n\n        \r\n        initState2 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 3, 1);\n\n        \r\n        OperatorSubtaskState initState3 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 3, 2);\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 3);\n\n            \r\n            \r\n            KeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n            harness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n            harness3[0].setStateBackend(getStateBackend());\n            harness3[0].setup();\n            harness3[0].initializeState(initState1);\n            harness3[0].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n            harness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n            harness3[1].setStateBackend(getStateBackend());\n            harness3[1].setup();\n            harness3[1].initializeState(initState2);\n            harness3[1].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n            Assert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n            harness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n            harness3[2].setStateBackend(getStateBackend());\n            harness3[2].setup();\n            harness3[2].initializeState(initState3);\n            harness3[2].open();\n\n            validHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]);\n            validHarnessResult(harness3[1], 3, records[4], records[5], records[6]);\n            validHarnessResult(harness3[2], 3, records[7], records[8], records[9]);\n        } finally {\n            closeHarness(harness3);\n        }\n    }\n","date":"2021-02-25 00:19:05","endLine":253,"groupId":"1071","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testScalingUp","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ba/f418f5d17ddf6349caebc9b1458170ae98db03.src","preCode":"    public void testScalingUp() throws Exception {\n\n        \r\n        \r\n\n        OperatorSubtaskState snapshot;\n\n        try (KeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n                getHarnessTest(keySelector, maxParallelism, 1, 0)) {\n            harness.setStateBackend(getStateBackend());\n            harness.open();\n\n            validHarnessResult(harness, 1, records);\n\n            snapshot = harness.snapshot(0, 0);\n        }\n\n        \r\n        \r\n\n        \r\n        OperatorSubtaskState initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot, maxParallelism, 1, 2, 0);\n\n        \r\n        OperatorSubtaskState initState2 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot, maxParallelism, 1, 2, 1);\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n\n        OperatorSubtaskState snapshot2;\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 2);\n\n            \r\n            KeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n            harness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n            harness2[0].setStateBackend(getStateBackend());\n            harness2[0].setup();\n            harness2[0].initializeState(initState1);\n            harness2[0].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n            harness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n            harness2[1].setStateBackend(getStateBackend());\n            harness2[1].setup();\n            harness2[1].initializeState(initState2);\n            harness2[1].open();\n\n            validHarnessResult(\n                    harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n            validHarnessResult(\n                    harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n            snapshot2 =\n                    AbstractStreamOperatorTestHarness.repackageState(\n                            harness2[0].snapshot(0, 0), harness2[1].snapshot(0, 0));\n\n            validHarnessResult(\n                    harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n            validHarnessResult(\n                    harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n        } finally {\n            closeHarness(harness2);\n        }\n\n        \r\n        \r\n\n        \r\n        initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 3, 0);\n\n        \r\n        initState2 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 3, 1);\n\n        \r\n        OperatorSubtaskState initState3 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 3, 2);\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 3);\n\n            \r\n            \r\n            KeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n            harness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n            harness3[0].setStateBackend(getStateBackend());\n            harness3[0].setup();\n            harness3[0].initializeState(initState1);\n            harness3[0].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n            harness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n            harness3[1].setStateBackend(getStateBackend());\n            harness3[1].setup();\n            harness3[1].initializeState(initState2);\n            harness3[1].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n            Assert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n            harness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n            harness3[2].setStateBackend(getStateBackend());\n            harness3[2].setup();\n            harness3[2].initializeState(initState3);\n            harness3[2].open();\n\n            validHarnessResult(harness3[0], 3, records[0], records[1], records[2], records[3]);\n            validHarnessResult(harness3[1], 3, records[4], records[5], records[6]);\n            validHarnessResult(harness3[2], 3, records[7], records[8], records[9]);\n\n            validHarnessResult(\n                    harness3[0],\n                    1,\n                    records[4],\n                    records[5],\n                    records[6],\n                    records[7],\n                    records[8],\n                    records[9]);\n            validHarnessResult(\n                    harness3[1],\n                    1,\n                    records[0],\n                    records[1],\n                    records[2],\n                    records[3],\n                    records[7],\n                    records[8],\n                    records[9]);\n            validHarnessResult(\n                    harness3[2],\n                    1,\n                    records[0],\n                    records[1],\n                    records[2],\n                    records[3],\n                    records[4],\n                    records[5],\n                    records[6]);\n        } finally {\n            closeHarness(harness3);\n        }\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksIncrementalCheckpointRescalingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2021-02-04 16:09:11","commitOrder":3,"curCode":"    public void testScalingDown() throws Exception {\n\n        \r\n        \r\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n        OperatorSubtaskState snapshot3;\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 3);\n\n            \r\n            KeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n            harness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n            harness3[0].setStateBackend(getStateBackend());\n            harness3[0].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n            harness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n            harness3[1].setStateBackend(getStateBackend());\n            harness3[1].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n            Assert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n            harness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n            harness3[2].setStateBackend(getStateBackend());\n            harness3[2].open();\n\n            validHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]);\n            validHarnessResult(harness3[1], 1, records[4], records[5], records[6]);\n            validHarnessResult(harness3[2], 1, records[7], records[8], records[9]);\n\n            snapshot3 =\n                    AbstractStreamOperatorTestHarness.repackageState(\n                            harness3[0].snapshot(0, 0),\n                            harness3[1].snapshot(0, 0),\n                            harness3[2].snapshot(0, 0));\n\n        } finally {\n            closeHarness(harness3);\n        }\n\n        \r\n        \r\n\n        \r\n        OperatorSubtaskState initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot3, maxParallelism, 3, 2, 0);\n\n        \r\n        OperatorSubtaskState initState2 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot3, maxParallelism, 3, 2, 1);\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n\n        OperatorSubtaskState snapshot2;\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 2);\n\n            \r\n            \r\n            \r\n            KeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n            harness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n            harness2[0].setStateBackend(getStateBackend());\n            harness2[0].setup();\n            harness2[0].initializeState(initState1);\n            harness2[0].open();\n\n            \r\n            \r\n            KeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n            harness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n            harness2[1].setStateBackend(getStateBackend());\n            harness2[1].setup();\n            harness2[1].initializeState(initState2);\n            harness2[1].open();\n\n            validHarnessResult(\n                    harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n            validHarnessResult(\n                    harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n            snapshot2 =\n                    AbstractStreamOperatorTestHarness.repackageState(\n                            harness2[0].snapshot(0, 0), harness2[1].snapshot(0, 0));\n        } finally {\n            closeHarness(harness2);\n        }\n\n        \r\n        \r\n\n        \r\n        initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 1, 0);\n\n        try (KeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n                getHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\n            \r\n            \r\n            harness.setStateBackend(getStateBackend());\n            harness.setup();\n            harness.initializeState(initState1);\n            harness.open();\n\n            validHarnessResult(harness, 3, records);\n        }\n    }\n","date":"2021-02-25 00:19:05","endLine":381,"groupId":"1071","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testScalingDown","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-flink-10-0.7/blobInfo/CC_OUT/blobs/ba/f418f5d17ddf6349caebc9b1458170ae98db03.src","preCode":"    public void testScalingDown() throws Exception {\n\n        \r\n        \r\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness3 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n        OperatorSubtaskState snapshot3;\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 3);\n\n            \r\n            KeyGroupRange localKeyGroupRange30 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 3), localKeyGroupRange30);\n            harness3[0] = getHarnessTest(keySelector, maxParallelism, 3, 0);\n            harness3[0].setStateBackend(getStateBackend());\n            harness3[0].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange31 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(4, 6), localKeyGroupRange31);\n            harness3[1] = getHarnessTest(keySelector, maxParallelism, 3, 1);\n            harness3[1].setStateBackend(getStateBackend());\n            harness3[1].open();\n\n            \r\n            KeyGroupRange localKeyGroupRange32 = keyGroupPartitions.get(2);\n            Assert.assertEquals(new KeyGroupRange(7, 9), localKeyGroupRange32);\n            harness3[2] = getHarnessTest(keySelector, maxParallelism, 3, 2);\n            harness3[2].setStateBackend(getStateBackend());\n            harness3[2].open();\n\n            validHarnessResult(harness3[0], 1, records[0], records[1], records[2], records[3]);\n            validHarnessResult(harness3[1], 1, records[4], records[5], records[6]);\n            validHarnessResult(harness3[2], 1, records[7], records[8], records[9]);\n\n            snapshot3 =\n                    AbstractStreamOperatorTestHarness.repackageState(\n                            harness3[0].snapshot(0, 0),\n                            harness3[1].snapshot(0, 0),\n                            harness3[2].snapshot(0, 0));\n\n        } finally {\n            closeHarness(harness3);\n        }\n\n        \r\n        \r\n\n        \r\n        OperatorSubtaskState initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot3, maxParallelism, 3, 2, 0);\n\n        \r\n        OperatorSubtaskState initState2 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot3, maxParallelism, 3, 2, 1);\n\n        KeyedOneInputStreamOperatorTestHarness<String, String, Integer>[] harness2 =\n                new KeyedOneInputStreamOperatorTestHarness[3];\n\n        OperatorSubtaskState snapshot2;\n\n        try {\n            List<KeyGroupRange> keyGroupPartitions =\n                    StateAssignmentOperation.createKeyGroupPartitions(maxParallelism, 2);\n\n            \r\n            \r\n            \r\n            KeyGroupRange localKeyGroupRange20 = keyGroupPartitions.get(0);\n            Assert.assertEquals(new KeyGroupRange(0, 4), localKeyGroupRange20);\n            harness2[0] = getHarnessTest(keySelector, maxParallelism, 2, 0);\n            harness2[0].setStateBackend(getStateBackend());\n            harness2[0].setup();\n            harness2[0].initializeState(initState1);\n            harness2[0].open();\n\n            \r\n            \r\n            KeyGroupRange localKeyGroupRange21 = keyGroupPartitions.get(1);\n            Assert.assertEquals(new KeyGroupRange(5, 9), localKeyGroupRange21);\n            harness2[1] = getHarnessTest(keySelector, maxParallelism, 2, 1);\n            harness2[1].setStateBackend(getStateBackend());\n            harness2[1].setup();\n            harness2[1].initializeState(initState2);\n            harness2[1].open();\n\n            validHarnessResult(\n                    harness2[0], 2, records[0], records[1], records[2], records[3], records[4]);\n\n            validHarnessResult(\n                    harness2[1], 2, records[5], records[6], records[7], records[8], records[9]);\n\n            snapshot2 =\n                    AbstractStreamOperatorTestHarness.repackageState(\n                            harness2[0].snapshot(0, 0), harness2[1].snapshot(0, 0));\n\n            validHarnessResult(\n                    harness2[0], 1, records[5], records[6], records[7], records[8], records[9]);\n\n            validHarnessResult(\n                    harness2[1], 1, records[0], records[1], records[2], records[3], records[4]);\n        } finally {\n            closeHarness(harness2);\n        }\n\n        \r\n        \r\n\n        \r\n        initState1 =\n                AbstractStreamOperatorTestHarness.repartitionOperatorState(\n                        snapshot2, maxParallelism, 2, 1, 0);\n\n        try (KeyedOneInputStreamOperatorTestHarness<String, String, Integer> harness =\n                getHarnessTest(keySelector, maxParallelism, 1, 0)) {\n\n            \r\n            \r\n            harness.setStateBackend(getStateBackend());\n            harness.setup();\n            harness.initializeState(initState1);\n            harness.open();\n\n            validHarnessResult(harness, 3, records);\n        }\n    }\n","realPath":"flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksIncrementalCheckpointRescalingTest.java","repoName":"flink","snippetEndLine":0,"snippetStartLine":0,"startLine":257,"status":"M"}],"commitId":"be628c67b150b03b316b55f09a7292939de21c0c","commitMessage":"@@@[hotfix] Fix RocksIncrementalCheckpointRescalingTest\n\nFew cases that were checked in the test are actually illegal\ncombination. They were testing keys that should never end up in a given\nsub task as they do not belong to a key group owned by the task.\n","date":"2021-02-25 00:19:05","modifiedFileCount":"1","status":"M","submitter":"Dawid Wysakowicz"}]
