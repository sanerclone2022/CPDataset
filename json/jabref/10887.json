[{"authorTime":"2017-02-17 05:41:47","codes":[{"authorDate":"2017-02-17 05:41:47","commitOrder":1,"curCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n            throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n            UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n            CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"BibTeX key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        cEntries[j] = new UndefinedBibtexEntry(keys[j]);\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isBibtexKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                    minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                    .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n\n            }\n\n        }\n\n        uniquefiers.clear();\n        if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                        WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","date":"2017-02-17 05:41:47","endLine":747,"groupId":"13158","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshCiteMarkersInternal","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/37/606d12ac90bbaf4c12609bded045cb9c22e77d.src","preCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n            throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n            UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n            CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"BibTeX key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        cEntries[j] = new UndefinedBibtexEntry(keys[j]);\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isBibtexKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                    minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                    .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n\n            }\n\n        }\n\n        uniquefiers.clear();\n        if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                        WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":445,"status":"B"},{"authorDate":"2017-02-17 05:41:47","commitOrder":1,"curCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","date":"2017-02-17 05:41:47","endLine":807,"groupId":"5068","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"rebuildBibTextSection","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/37/606d12ac90bbaf4c12609bded045cb9c22e77d.src","preCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":785,"status":"B"}],"commitId":"ebbeb1d249edf7134abf92d24c2031ae54d19881","commitMessage":"@@@Merge branch 'net-sf-to-org-jabref'\n","date":"2017-02-17 05:41:47","modifiedFileCount":"1","status":"B","submitter":"Oliver Kopp"},{"authorTime":"2017-02-17 05:41:47","codes":[{"authorDate":"2019-05-01 20:30:14","commitOrder":2,"curCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n        throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n        UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n        CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"BibTeX key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        throw new BibEntryNotFoundException(names.get(i), Localization\n                                                                                      .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isBibtexKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                                                          minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                                                                          .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                                                             type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                                                   true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n\n            }\n\n        }\n\n        uniquefiers.clear();\n        if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                                                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                         WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","date":"2019-05-01 20:30:14","endLine":752,"groupId":"13158","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshCiteMarkersInternal","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/5e/944a21e6ef3f15f3af378954084cee3e94ed91.src","preCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n        throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n        UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n        CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"BibTeX key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        cEntries[j] = new UndefinedBibtexEntry(keys[j]);\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isBibtexKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                                                          minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                                                                          .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                                                             type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                                                   true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n\n            }\n\n        }\n\n        uniquefiers.clear();\n        if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                                                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                         WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":449,"status":"M"},{"authorDate":"2017-02-17 05:41:47","commitOrder":2,"curCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","date":"2017-02-17 05:41:47","endLine":807,"groupId":"5068","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"rebuildBibTextSection","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/37/606d12ac90bbaf4c12609bded045cb9c22e77d.src","preCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":785,"status":"N"}],"commitId":"f1b4b5be3d4c9d6467f6f5be7cdb193269862bfb","commitMessage":"@@@Throw BibEntryNotFound exception in case entry is no longer present  (#4935)\n\n* improve oo Logging\n\n* fix typos\n\n* Throw BibEntryNotFound exception in case entry is no longer present\n\nFixes  #4932\n\n* add changelog\n\n* fix wording and move nonNullRequire to the top\n","date":"2019-05-01 20:30:14","modifiedFileCount":"2","status":"M","submitter":"Christoph"},{"authorTime":"2017-02-17 05:41:47","codes":[{"authorDate":"2020-06-04 18:52:52","commitOrder":3,"curCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n            throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n            UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n            CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"Citation key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        throw new BibEntryNotFoundException(names.get(i), Localization\n                                .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isCitationKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                    minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                    .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n            }\n        }\n\n        uniquefiers.clear();\n        if (!style.isCitationKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                        WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","date":"2020-06-04 18:52:52","endLine":728,"groupId":"13158","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshCiteMarkersInternal","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/55/de8d755ff534decccba2bdf4f79e0ef108b275.src","preCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n            throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n            UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n            CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"BibTeX key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        throw new BibEntryNotFoundException(names.get(i), Localization\n                                .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isBibtexKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                    minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                    .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n            }\n        }\n\n        uniquefiers.clear();\n        if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                        WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":427,"status":"M"},{"authorDate":"2017-02-17 05:41:47","commitOrder":3,"curCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","date":"2017-02-17 05:41:47","endLine":807,"groupId":"5068","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"rebuildBibTextSection","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/37/606d12ac90bbaf4c12609bded045cb9c22e77d.src","preCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":785,"status":"N"}],"commitId":"7cc57474b7aa991ef6ea148d4030d4bb68ee69bf","commitMessage":"@@@Rename bibtexkey (#6545)\n\n* Reworded 'BibtexKey' to 'CitationKey'\n\n* Fixed merge errors.  renamed constants\n\n* Renamed forgotten package\n\n* Fixed overlooked enum names and added CHANGELOG.md entry","date":"2020-06-04 18:52:52","modifiedFileCount":"54","status":"M","submitter":"Carl Christian Snethlage"},{"authorTime":"2017-02-17 05:41:47","codes":[{"authorDate":"2020-09-08 21:34:34","commitOrder":4,"curCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n            throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n            UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n            CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCitationKey().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByCitationKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"Citation key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        throw new BibEntryNotFoundException(names.get(i), Localization\n                                .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isCitationKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCitationKey().orElse(null);\n                        sb.append(cEntries[j].getCitationKey().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                    minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                    .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCitationKey().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n            }\n        }\n\n        uniquefiers.clear();\n        if (!style.isCitationKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByCitationKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByCitationKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByCitationKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                        WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","date":"2020-09-08 21:34:34","endLine":730,"groupId":"10887","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"refreshCiteMarkersInternal","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/4a/97139f0d04dd08bc9a55d267a29f5179dfa930.src","preCode":"    private List<String> refreshCiteMarkersInternal(List<BibDatabase> databases, OOBibStyle style)\n            throws WrappedTargetException, IllegalArgumentException, NoSuchElementException,\n            UndefinedCharacterFormatException, UnknownPropertyException, PropertyVetoException,\n            CreationException, BibEntryNotFoundException {\n\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase);\n\n        XNameAccess xReferenceMarks = getReferenceMarks();\n\n        List<String> names;\n        if (style.isSortByPosition()) {\n            \r\n            names = sortedReferenceMarks;\n        } else if (style.isNumberEntries()) {\n            \r\n            \r\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n            \r\n            cited.clear();\n            for (BibEntry entry : entries.keySet()) {\n                cited.add(entry.getCiteKeyOptional().orElse(null));\n            }\n            names = Arrays.asList(xReferenceMarks.getElementNames());\n        } else {\n            names = sortedReferenceMarks;\n        }\n\n        \r\n        List<String> tmp = new ArrayList<>();\n        for (String name : names) {\n            if (CITE_PATTERN.matcher(name).find()) {\n                tmp.add(name);\n            }\n        }\n        names = tmp;\n\n        Map<String, Integer> numbers = new HashMap<>();\n        int lastNum = 0;\n        \r\n        String[] citMarkers = new String[names.size()];\n        String[][] normCitMarkers = new String[names.size()][];\n        String[][] bibtexKeys = new String[names.size()][];\n\n        int minGroupingCount = style.getIntCitProperty(OOBibStyle.MINIMUM_GROUPING_COUNT);\n\n        int[] types = new int[names.size()];\n        for (int i = 0; i < names.size(); i++) {\n            Matcher citeMatcher = CITE_PATTERN.matcher(names.get(i));\n            if (citeMatcher.find()) {\n                String typeStr = citeMatcher.group(1);\n                int type = Integer.parseInt(typeStr);\n                types[i] = type; \r\n                String[] keys = citeMatcher.group(2).split(\",\");\n                bibtexKeys[i] = keys;\n                BibEntry[] cEntries = new BibEntry[keys.length];\n                for (int j = 0; j < cEntries.length; j++) {\n                    BibDatabase database = linkSourceBase.get(keys[j]);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (database != null) {\n                        tmpEntry = database.getEntryByKey(keys[j]);\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[j] = tmpEntry.get();\n                    } else {\n                        LOGGER.info(\"Citation key not found: '\" + keys[j] + '\\'');\n                        LOGGER.info(\"Problem with reference mark: '\" + names.get(i) + '\\'');\n                        throw new BibEntryNotFoundException(names.get(i), Localization\n                                .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                    }\n                }\n\n                String[] normCitMarker = new String[keys.length];\n                String citationMarker;\n                if (style.isCitationKeyCiteMarkers()) {\n                    StringBuilder sb = new StringBuilder();\n                    normCitMarkers[i] = new String[keys.length];\n                    for (int j = 0; j < keys.length; j++) {\n                        normCitMarkers[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        sb.append(cEntries[j].getCiteKeyOptional().orElse(\"\"));\n                        if (j < (keys.length - 1)) {\n                            sb.append(',');\n                        }\n                    }\n                    citationMarker = sb.toString();\n                } else if (style.isNumberEntries()) {\n                    if (style.isSortByPosition()) {\n                        \r\n                        \r\n                        List<Integer> num = new ArrayList<>(keys.length);\n                        for (int j = 0; j < keys.length; j++) {\n                            if (cEntries[j] instanceof UndefinedBibtexEntry) {\n                                num.add(j, -1);\n                            } else {\n                                num.add(j, lastNum + 1);\n                                if (numbers.containsKey(keys[j])) {\n                                    num.set(j, numbers.get(keys[j]));\n                                } else {\n                                    numbers.put(keys[j], num.get(j));\n                                    lastNum = num.get(j);\n                                }\n                            }\n                        }\n                        citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        for (int j = 0; j < keys.length; j++) {\n                            normCitMarker[j] = style.getNumCitationMarker(Collections.singletonList(num.get(j)),\n                                    minGroupingCount, false);\n                        }\n                    } else {\n                        \r\n                        \r\n                        List<Integer> num = findCitedEntryIndex(names.get(i), cited);\n\n                        if (num.isEmpty()) {\n                            throw new BibEntryNotFoundException(names.get(i), Localization\n                                    .lang(\"Could not resolve BibTeX entry for citation marker '%0'.\", names.get(i)));\n                        } else {\n                            citationMarker = style.getNumCitationMarker(num, minGroupingCount, false);\n                        }\n\n                        for (int j = 0; j < keys.length; j++) {\n                            List<Integer> list = new ArrayList<>(1);\n                            list.add(num.get(j));\n                            normCitMarker[j] = style.getNumCitationMarker(list, minGroupingCount, false);\n                        }\n                    }\n                } else {\n\n                    if (cEntries.length > 1) {\n                        if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\n                            Arrays.sort(cEntries, yearAuthorTitleComparator);\n                        } else {\n                            Arrays.sort(cEntries, entryComparator);\n                        }\n                        \r\n                        for (int j = 0; j < cEntries.length; j++) {\n                            bibtexKeys[i][j] = cEntries[j].getCiteKeyOptional().orElse(null);\n                        }\n                    }\n\n                    citationMarker = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            type == OOBibBase.AUTHORYEAR_PAR, null, null);\n                    \r\n                    for (int j = 0; j < cEntries.length; j++) {\n                        normCitMarker[j] = style.getCitationMarker(Collections.singletonList(cEntries[j]), entries,\n                                true, null, new int[] {-1});\n                    }\n                }\n                citMarkers[i] = citationMarker;\n                normCitMarkers[i] = normCitMarker;\n            }\n        }\n\n        uniquefiers.clear();\n        if (!style.isCitationKeyCiteMarkers() && !style.isNumberEntries()) {\n            \r\n            \r\n            Map<String, List<String>> refKeys = new HashMap<>();\n            Map<String, List<Integer>> refNums = new HashMap<>();\n            for (int i = 0; i < citMarkers.length; i++) {\n                String[] markers = normCitMarkers[i]; \r\n                for (int j = 0; j < markers.length; j++) {\n                    String marker = markers[j];\n                    String currentKey = bibtexKeys[i][j];\n                    if (refKeys.containsKey(marker)) {\n                        \r\n                        if (!refKeys.get(marker).contains(currentKey)) {\n                            \r\n                            refKeys.get(marker).add(currentKey);\n                            refNums.get(marker).add(i);\n                        }\n                    } else {\n                        List<String> l = new ArrayList<>(1);\n                        l.add(currentKey);\n                        refKeys.put(marker, l);\n                        List<Integer> l2 = new ArrayList<>(1);\n                        l2.add(i);\n                        refNums.put(marker, l2);\n                    }\n                }\n            }\n            \r\n            for (Map.Entry<String, List<String>> stringListEntry : refKeys.entrySet()) {\n                List<String> keys = stringListEntry.getValue();\n                if (keys.size() > 1) {\n                    \r\n                    int uniq = 'a';\n                    for (String key : keys) {\n                        \r\n                        \r\n                        uniquefiers.put(key, String.valueOf((char) uniq));\n                        uniq++;\n                    }\n                }\n            }\n\n            \r\n            int maxAuthorsFirst = style.getIntCitProperty(OOBibStyle.MAX_AUTHORS_FIRST);\n            Set<String> seenBefore = new HashSet<>();\n            for (int j = 0; j < bibtexKeys.length; j++) {\n                boolean needsChange = false;\n                int[] firstLimAuthors = new int[bibtexKeys[j].length];\n                String[] uniquif = new String[bibtexKeys[j].length];\n                BibEntry[] cEntries = new BibEntry[bibtexKeys[j].length];\n                for (int k = 0; k < bibtexKeys[j].length; k++) {\n                    String currentKey = bibtexKeys[j][k];\n                    firstLimAuthors[k] = -1;\n                    if (maxAuthorsFirst > 0) {\n                        if (!seenBefore.contains(currentKey)) {\n                            firstLimAuthors[k] = maxAuthorsFirst;\n                        }\n                        seenBefore.add(currentKey);\n                    }\n                    String uniq = uniquefiers.get(currentKey);\n                    Optional<BibEntry> tmpEntry = Optional.empty();\n                    if (uniq == null) {\n                        if (firstLimAuthors[k] > 0) {\n                            needsChange = true;\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        } else {\n                            BibDatabase database = linkSourceBase.get(currentKey);\n                            if (database != null) {\n                                tmpEntry = database.getEntryByKey(currentKey);\n                            }\n                        }\n                        uniquif[k] = \"\";\n                    } else {\n                        needsChange = true;\n                        BibDatabase database = linkSourceBase.get(currentKey);\n                        if (database != null) {\n                            tmpEntry = database.getEntryByKey(currentKey);\n                        }\n                        uniquif[k] = uniq;\n                    }\n                    if (tmpEntry.isPresent()) {\n                        cEntries[k] = tmpEntry.get();\n                    }\n                }\n                if (needsChange) {\n                    citMarkers[j] = style.getCitationMarker(Arrays.asList(cEntries), entries,\n                            types[j] == OOBibBase.AUTHORYEAR_PAR, uniquif, firstLimAuthors);\n                }\n            }\n        }\n\n        \r\n        boolean hadBibSection = getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;\n        \r\n        boolean mustTestCharFormat = style.isFormatCitations();\n        for (int i = 0; i < names.size(); i++) {\n            Object referenceMark = xReferenceMarks.getByName(names.get(i));\n            XTextContent bookmark = UnoRuntime.queryInterface(XTextContent.class, referenceMark);\n\n            XTextCursor cursor = bookmark.getAnchor().getText().createTextCursorByRange(bookmark.getAnchor());\n\n            if (mustTestCharFormat) {\n                \r\n                \r\n                \r\n                \r\n                mustTestCharFormat = false; \r\n                XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, cursor);\n                String charStyle = style.getCitationCharacterFormat();\n                try {\n                    xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\n                } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException |\n                        WrappedTargetException ex) {\n                    throw new UndefinedCharacterFormatException(charStyle);\n                }\n            }\n\n            text.removeTextContent(bookmark);\n\n            insertReferenceMark(names.get(i), citMarkers[i], cursor, types[i] != OOBibBase.INVISIBLE_CIT, style);\n            if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {\n                \r\n                \r\n                cursor.collapseToEnd();\n                OOUtil.insertParagraphBreak(text, cursor);\n                insertBookMark(OOBibBase.BIB_SECTION_NAME, cursor);\n            }\n        }\n\n        List<String> unresolvedKeys = new ArrayList<>();\n        for (BibEntry entry : entries.keySet()) {\n            if (entry instanceof UndefinedBibtexEntry) {\n                String key = ((UndefinedBibtexEntry) entry).getKey();\n                if (!unresolvedKeys.contains(key)) {\n                    unresolvedKeys.add(key);\n                }\n            }\n        }\n        return unresolvedKeys;\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"},{"authorDate":"2017-02-17 05:41:47","commitOrder":4,"curCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","date":"2017-02-17 05:41:47","endLine":807,"groupId":"10887","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"rebuildBibTextSection","params":"(List<BibDatabase>databases@OOBibStylestyle)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/37/606d12ac90bbaf4c12609bded045cb9c22e77d.src","preCode":"    public void rebuildBibTextSection(List<BibDatabase> databases, OOBibStyle style)\n            throws NoSuchElementException, WrappedTargetException, IllegalArgumentException,\n            CreationException, PropertyVetoException, UnknownPropertyException, UndefinedParagraphFormatException {\n        List<String> cited = findCitedKeys();\n        Map<String, BibDatabase> linkSourceBase = new HashMap<>();\n        Map<BibEntry, BibDatabase> entries = findCitedEntries(databases, cited, linkSourceBase); \r\n\n        List<String> names = sortedReferenceMarks;\n\n        if (style.isSortByPosition()) {\n            \r\n            entries = getSortedEntriesFromSortedRefMarks(names, linkSourceBase);\n        } else {\n            SortedMap<BibEntry, BibDatabase> newMap = new TreeMap<>(entryComparator);\n            for (Map.Entry<BibEntry, BibDatabase> bibtexEntryBibtexDatabaseEntry : findCitedEntries(databases, cited,\n                    linkSourceBase).entrySet()) {\n                newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(), bibtexEntryBibtexDatabaseEntry.getValue());\n            }\n            entries = newMap;\n        }\n        clearBibTextSectionContent2();\n        populateBibTextSection(entries, style);\n    }\n","realPath":"src/main/java/org/jabref/gui/openoffice/OOBibBase.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":785,"status":"N"}],"commitId":"6dec1747d8a1c89f6c62fc1d1939d88411f17eba","commitMessage":"@@@Complete rebranding of `bibtexkey` as `citationkey` (#6875)\n\n","date":"2020-09-08 21:34:34","modifiedFileCount":"127","status":"M","submitter":"Tobias Diez"}]
