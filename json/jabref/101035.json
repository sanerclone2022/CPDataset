[{"authorTime":"2017-02-17 05:41:47","codes":[{"authorDate":"2017-02-17 05:41:47","commitOrder":1,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","date":"2017-02-17 05:41:47","endLine":616,"groupId":"4889","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/16/2384ff21b8091f2f8e131bcf7a565cd1c11add.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"B"},{"authorDate":"2017-02-17 05:41:47","commitOrder":1,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase().charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-02-17 05:41:47","endLine":64,"groupId":"11036","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/f2/bc76cd613a6fe2301d2ef8f17b6232019175fe.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase().charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":43,"status":"B"}],"commitId":"ebbeb1d249edf7134abf92d24c2031ae54d19881","commitMessage":"@@@Merge branch 'net-sf-to-org-jabref'\n","date":"2017-02-17 05:41:47","modifiedFileCount":"1","status":"B","submitter":"Oliver Kopp"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2017-02-17 05:41:47","commitOrder":2,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","date":"2017-02-17 05:41:47","endLine":616,"groupId":"4889","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/16/2384ff21b8091f2f8e131bcf7a565cd1c11add.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"N"},{"authorDate":"2017-03-06 20:35:47","commitOrder":2,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"11036","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase().charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"7a1b15abb58016b40e21a72124edf9da17cd08f2","commitMessage":"@@@Merge pull request #2584 from JabRef/locales\n\nAdded Locale.ROOT to toUpper/toLower Methods","date":"2017-03-06 20:35:47","modifiedFileCount":"63","status":"M","submitter":"Linus Dietz"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2018-01-22 18:25:40","commitOrder":3,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","date":"2018-01-22 18:25:40","endLine":615,"groupId":"4889","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/53/26e8563385c8641850b8071bd27eb1df6be433.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2017-03-06 20:35:47","commitOrder":3,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"11036","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"cf8e6aac8263ce30eb2b042c8aacf2d88bbac4c8","commitMessage":"@@@Remove apache commons logging in favor of slf4j + log4j for JAVA 9 (#3653)\n\n* Remove apache commons logging in favor of slf4j + log4j for JAVA 9\nAdded ADR\n\n* fix checkstyle\n\n* fix checkstyle again\n\n* add comment that 1.8.0 beta is required\nadd some more info to ADR\n\n* fix wording in adr\nmake coday happy\n\n* remove swing utilities.  was only references in comment\n","date":"2018-01-22 18:25:40","modifiedFileCount":"220","status":"M","submitter":"Christoph"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2019-08-02 15:20:10","commitOrder":4,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType().getName());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","date":"2019-08-02 15:20:10","endLine":617,"groupId":"5089","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/a1/07936d515ac885cfe53a8d9bcba78afd5c86af.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2017-03-06 20:35:47","commitOrder":4,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"11036","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"4b39b78e4afcd6c36b385f5c46f1d9a4eac2e29b","commitMessage":"@@@Move to extended enums for fields and entry types (#5148)\n\n* Introduce interface for fields\n\n* Continue using fields interface instead of strings\n\n* Introduce OrFields class\n\n* Move FieldProperty\n\n* Convert entry types to extended enum\n\n* Start fixing build\n\n* Fix build\n\n* Start fixing tests\n\n* Everything compiles again\n\n* Make model tests pass\n\n* Fix most tests\n\n* Fix build\n\n* Fix a few more tests\n\n* Fix a few more tests\n\n* Fix a few more tests\n\n* Fix a few more tests\n\n* Fix checkstyle issues\n\n* Fix more tests\n\n* Fix more tests\n\n* Disable test that fails on CI\n\n* Disable test that fails on CI\n","date":"2019-08-02 15:20:10","modifiedFileCount":"439","status":"M","submitter":"Tobias Diez"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2020-01-18 08:05:30","commitOrder":5,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","date":"2020-01-18 08:05:30","endLine":620,"groupId":"0","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/44/8266e9c89847d67e3980ce0ba347a26b56aead.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n                \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2017-03-06 20:35:47","commitOrder":5,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"11036","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"49e8ee273bea8190127824c4933fb9dcc2c8d1bf","commitMessage":"@@@Fix BibTeX VM for IEEE (and some micro other fixes) (#5839)\n\n","date":"2020-01-18 08:05:30","modifiedFileCount":"3","status":"M","submitter":"Oliver Kopp"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2020-03-29 20:18:52","commitOrder":6,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.entry.getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.entry.getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.entry.getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","date":"2020-03-29 20:18:52","endLine":624,"groupId":"9473","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/f3/dce6d5cfb8aed91de1c157a2a2a75454860ec7.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.getBibtexEntry().getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.getBibtexEntry().getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.getBibtexEntry().getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2017-03-06 20:35:47","commitOrder":6,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"11036","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"14e979051abc329e4d111c0066c0610fe8eb1b44","commitMessage":"@@@Fix package of PreviewLayout (#5702)\n\n... and also improve (bst) VM (and introduce BstPreviewLayout)\n\n* Move PreviewLayout to org.jabref.logic.preview\n* Modernize code of (bst) VM\n* Add IEEEtran.bst\n* Introduce BstPreviewLayout\n* Fix Bst.g to allow \"_\" as identifier\n* Fix quotes and other output of IEEEtran.bst\n* Use public final instead of getters\n\n","date":"2020-03-29 20:18:52","modifiedFileCount":"22","status":"M","submitter":"Oliver Kopp"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2020-03-30 20:54:08","commitOrder":7,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.entry.getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.entry.getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry {}\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry {}\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.entry.getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","date":"2020-03-30 20:54:08","endLine":624,"groupId":"9473","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/7b/120710e1ba7100e35f45b413c7b5e4e38fdcd8.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.entry.getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.entry.getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry\", stack.pop());\n            }\n        });\n\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.entry.getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2017-03-06 20:35:47","commitOrder":7,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"11036","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"d1a83cd0601ef9e6ecc9ed8efbc4a0648f7cf681","commitMessage":"@@@Fix some IntelliJ findings (#6204)\n\n* Fix some IntelliJ findings\n\n- Fix bug in TagBar (added itself instead of newTags)\n- Wrong number of LOGGER paramters\n- Inner class may be static\n- Fix comment typo\n- Bulk operation can be used instead of iteration\n- Arrays.asList with only one element\n- Optimized count by using numbers earlier\n- Chained append for StringBuilder\n- Initialize ArrayList by passing the initial contents in the constructor\n\n* Fix checkstyle\n\n* Revert partially \"Fix some IntelliJ findings\"\n\nThis partially reverts commit 167558dfe1aaa090e57b9bae672e40a76a78abd0.","date":"2020-03-30 20:54:08","modifiedFileCount":"19","status":"M","submitter":"Oliver Kopp"},{"authorTime":"2017-03-06 20:35:47","codes":[{"authorDate":"2020-09-08 21:34:34","commitOrder":8,"curCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.entry.getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.entry.getCitationKey().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry {}\", stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry {}\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.entry.getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","date":"2020-09-08 21:34:34","endLine":623,"groupId":"101035","id":15,"instanceNumber":1,"isCurCommit":1,"methodName":"VM","params":"(CommonTreetree)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/5e/99a62b12c5e72cb305d080480cbaefb3763a5a.src","preCode":"    private VM(CommonTree tree) {\n        this.tree = tree;\n\n        this.buildInFunctions = new HashMap<>(37);\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\">\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation >\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with >\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) > 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"<\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation <\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with <\");\n            }\n\n            stack.push(((Integer) o1).compareTo((Integer) o2) < 0 ? VM.TRUE : VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n\n            if ((o1 == null) ^ (o2 == null)) {\n                stack.push(VM.FALSE);\n                return;\n            }\n\n            if ((o1 == null) && (o2 == null)) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);\n        });\n\n        \n        buildInFunctions.put(\"+\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation +\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only compare two integers with +\");\n            }\n\n            stack.push((Integer) o1 + (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"-\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation -\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof Integer) && (o2 instanceof Integer))) {\n                throw new VMException(\"Can only subtract two integers with -\");\n            }\n\n            stack.push((Integer) o1 - (Integer) o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"*\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation *\");\n            }\n            Object o2 = stack.pop();\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                o1 = \"\";\n            }\n            if (o2 == null) {\n                o2 = \"\";\n            }\n\n            if (!((o1 instanceof String) && (o2 instanceof String))) {\n                LOGGER.error(\"o1: {} ({})\", o1, o1.getClass());\n                LOGGER.error(\"o2: {} ({})\", o2, o2.getClass());\n                throw new VMException(\"Can only concatenate two String with *\");\n            }\n\n            stack.push(o1.toString() + o2);\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\":=\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Invalid call to operation :=\");\n            }\n            Object o1 = stack.pop();\n            Object o2 = stack.pop();\n            assign(context, o1, o2);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"add.period$\", context -> addPeriodFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"call.type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Call.type$ can only be called from within a context (ITERATE or REVERSE).\");\n            }\n            VM.this.execute(context.entry.getType().getName(), context);\n        });\n\n        buildInFunctions.put(\"change.case$\", new ChangeCaseFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"chr.to.int$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation chr.to.int$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n                throw new VMException(\"Can only perform chr.to.int$ on string with length 1\");\n            }\n\n            String s = (String) o1;\n\n            stack.push((int) s.charAt(0));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"cite$\", context -> {\n            if (context == null) {\n                throw new VMException(\"Must have an entry to cite$\");\n            }\n            stack.push(context.entry.getCiteKeyOptional().orElse(null));\n        });\n\n        \r\n\r\n\n        buildInFunctions.put(\"duplicate$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation duplicate$\");\n            }\n            Object o1 = stack.pop();\n\n            stack.push(o1);\n            stack.push(o1);\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"empty$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation empty$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Operand does not match function empty$\");\n            }\n\n            String s = (String) o1;\n\n            stack.push(\"\".equals(s.trim()) ? VM.TRUE : VM.FALSE);\n        });\n\n        buildInFunctions.put(\"format.name$\", new FormatNameFunction(this));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"if$\", context -> {\n            if (stack.size() < 3) {\n                throw new VMException(\"Not enough operands on stack for operation =\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n            Object i = stack.pop();\n\n            if (!((f1 instanceof Identifier) || (f1 instanceof Tree))\n                    && ((f2 instanceof Identifier) || (f2 instanceof Tree)) && (i instanceof Integer)) {\n                throw new VMException(\"Expecting two functions and an integer for if$.\");\n            }\n\n            if ((Integer) i > 0) {\n                VM.this.executeInContext(f2, context);\n            } else {\n                VM.this.executeInContext(f1, context);\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.chr$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.chr$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only perform operation int.to.chr$ on an Integer\");\n            }\n\n            Integer i = (Integer) o1;\n\n            stack.push(String.valueOf((char) i.intValue()));\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"int.to.str$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation int.to.str$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof Integer)) {\n                throw new VMException(\"Can only transform an integer to an string using int.to.str$\");\n            }\n\n            stack.push(o1.toString());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"missing$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation missing$\");\n            }\n            Object o1 = stack.pop();\n\n            if (o1 == null) {\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            if (!(o1 instanceof String)) {\n                warn(\"Not a string or missing field in operation missing$\");\n                stack.push(VM.TRUE);\n                return;\n            }\n\n            stack.push(VM.FALSE);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"newline$\", context -> VM.this.bbl.append('\\n'));\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"num.names$\", context -> {\n            if (stack.isEmpty()) {\n                throw new VMException(\"Not enough operands on stack for operation num.names$\");\n            }\n            Object o1 = stack.pop();\n\n            if (!(o1 instanceof String)) {\n                throw new VMException(\"Need a string at the top of the stack for num.names$\");\n            }\n            String s = (String) o1;\n\n            stack.push(AuthorList.parse(s).getNumberOfAuthors());\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"pop$\", context -> stack.pop());\n\n        \r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"preamble$\", context -> {\n            stack.push(preamble);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"purify$\", new PurifyFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"quote$\", context -> stack.push(\"\\\"\"));\n\n        \r\n\r\n\n        buildInFunctions.put(\"skip$\", context -> {\n            \r\n        });\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"stack$\", context -> {\n            while (!stack.empty()) {\n                LOGGER.debug(\"Stack entry {}\", stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"substring$\", context -> substringFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"swap$\", context -> {\n            if (stack.size() < 2) {\n                throw new VMException(\"Not enough operands on stack for operation swap$\");\n            }\n            Object f1 = stack.pop();\n            Object f2 = stack.pop();\n\n            stack.push(f1);\n            stack.push(f2);\n        });\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.length$\", context -> textLengthFunction());\n\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"text.prefix$\", new TextPrefixFunction(this));\n\n        \r\n\r\n\n        buildInFunctions.put(\"top$\", context -> LOGGER.debug(\"Stack entry {}\", stack.pop()));\n\n        \r\n\r\n\r\n\n        buildInFunctions.put(\"type$\", context -> {\n            if (context == null) {\n                throw new VMException(\"type$ need a context.\");\n            }\n\n            stack.push(context.entry.getType().getName());\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"warning$\", new BstFunction() {\n\n            int warning = 1;\n\n            @Override\n            public void execute(BstEntry context) {\n                LOGGER.warn(\"Warning (#\" + (warning++) + \"): \" + stack.pop());\n            }\n        });\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"while$\", this::whileFunction);\n\n        buildInFunctions.put(\"width$\", new WidthFunction(this));\n\n        \r\n\r\n\r\n\r\n\n        buildInFunctions.put(\"write$\", context -> {\n            String s = (String) stack.pop();\n            VM.this.bbl.append(s);\n        });\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/VM.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2017-03-06 20:35:47","commitOrder":8,"curCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","date":"2017-03-06 20:35:47","endLine":65,"groupId":"101035","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"execute","params":"(BstEntrycontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-jabref-10-0.7/blobInfo/CC_OUT/blobs/ab/602be398a217447a73d1ecd183ef73584c09a2.src","preCode":"    public void execute(BstEntry context) {\n        Stack<Object> stack = vm.getStack();\n\n        if (stack.size() < 2) {\n            throw new VMException(\"Not enough operands on stack for operation change.case$\");\n        }\n\n        Object o1 = stack.pop();\n        if (!((o1 instanceof String) && (((String) o1).length() == 1))) {\n            throw new VMException(\"A format string of length 1 is needed for change.case$\");\n        }\n\n        Object o2 = stack.pop();\n        if (!(o2 instanceof String)) {\n            throw new VMException(\"A string is needed as second parameter for change.case$\");\n        }\n\n        char format = ((String) o1).toLowerCase(Locale.ROOT).charAt(0);\n        String s = (String) o2;\n\n        stack.push(BibtexCaseChanger.changeCase(s, FORMAT_MODE.getFormatModeForBSTFormat(format)));\n    }\n","realPath":"src/main/java/org/jabref/logic/bst/ChangeCaseFunction.java","repoName":"jabref","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"}],"commitId":"6dec1747d8a1c89f6c62fc1d1939d88411f17eba","commitMessage":"@@@Complete rebranding of `bibtexkey` as `citationkey` (#6875)\n\n","date":"2020-09-08 21:34:34","modifiedFileCount":"127","status":"M","submitter":"Tobias Diez"}]
