[{"authorTime":"2013-03-08 06:54:59","codes":[{"authorDate":"2013-03-08 06:54:59","commitOrder":1,"curCode":"    public void     testMultiClient() throws Exception\n    {\n        final Timing            timing = new Timing();\n        final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n        final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n        final AtomicInteger     count = new AtomicInteger(0);\n        final AtomicInteger     max = new AtomicInteger(0);\n        List<Future<Void>>      futures = Lists.newArrayList();\n        ExecutorService         service = Executors.newCachedThreadPool();\n        for ( int i = 0; i < QTY; ++i )\n        {\n            Future<Void>    future = service.submit\n            (\n                new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        CuratorFramework                client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n                        try\n                        {\n                            client.start();\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n                        }\n                        finally\n                        {\n                            Closeables.closeQuietly(client);\n                        }\n\n                        return null;\n                    }\n                }\n            );\n            futures.add(future);\n        }\n\n        for ( Future<Void> f : futures )\n        {\n            f.get();\n        }\n        Assert.assertEquals(count.get(), 0);\n        Assert.assertEquals(max.get(), QTY);\n    }\n","date":"2013-03-08 06:54:59","endLine":109,"groupId":"1630","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-curator-10-0.7/blobInfo/CC_OUT/blobs/fe/5cb8725cb396ed7e5226d277e07abf4f47482b.src","preCode":"    public void     testMultiClient() throws Exception\n    {\n        final Timing            timing = new Timing();\n        final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n        final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n        final AtomicInteger     count = new AtomicInteger(0);\n        final AtomicInteger     max = new AtomicInteger(0);\n        List<Future<Void>>      futures = Lists.newArrayList();\n        ExecutorService         service = Executors.newCachedThreadPool();\n        for ( int i = 0; i < QTY; ++i )\n        {\n            Future<Void>    future = service.submit\n            (\n                new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        CuratorFramework                client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n                        try\n                        {\n                            client.start();\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n                        }\n                        finally\n                        {\n                            Closeables.closeQuietly(client);\n                        }\n\n                        return null;\n                    }\n                }\n            );\n            futures.add(future);\n        }\n\n        for ( Future<Void> f : futures )\n        {\n            f.get();\n        }\n        Assert.assertEquals(count.get(), 0);\n        Assert.assertEquals(max.get(), QTY);\n    }\n","realPath":"curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedDoubleBarrier.java","repoName":"curator","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"},{"authorDate":"2013-03-08 06:54:59","commitOrder":1,"curCode":"    public void     testBasic() throws Exception\n    {\n        final Timing              timing = new Timing();\n        final List<Closeable>     closeables = Lists.newArrayList();\n        final CuratorFramework    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n        try\n        {\n            closeables.add(client);\n            client.start();\n\n            final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n            final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n            final AtomicInteger     count = new AtomicInteger(0);\n            final AtomicInteger     max = new AtomicInteger(0);\n            List<Future<Void>>      futures = Lists.newArrayList();\n            ExecutorService         service = Executors.newCachedThreadPool();\n            for ( int i = 0; i < QTY; ++i )\n            {\n                Future<Void>    future = service.submit\n                (\n                    new Callable<Void>()\n                    {\n                        @Override\n                        public Void call() throws Exception\n                        {\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postLeaveLatch));\n\n                            return null;\n                        }\n                    }\n                );\n                futures.add(future);\n            }\n\n            for ( Future<Void> f : futures )\n            {\n                f.get();\n            }\n            Assert.assertEquals(count.get(), 0);\n            Assert.assertEquals(max.get(), QTY);\n        }\n        finally\n        {\n            for ( Closeable c : closeables )\n            {\n                Closeables.closeQuietly(c);\n            }\n        }\n    }\n","date":"2013-03-08 06:54:59","endLine":237,"groupId":"1631","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testBasic","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-curator-10-0.7/blobInfo/CC_OUT/blobs/fe/5cb8725cb396ed7e5226d277e07abf4f47482b.src","preCode":"    public void     testBasic() throws Exception\n    {\n        final Timing              timing = new Timing();\n        final List<Closeable>     closeables = Lists.newArrayList();\n        final CuratorFramework    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n        try\n        {\n            closeables.add(client);\n            client.start();\n\n            final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n            final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n            final AtomicInteger     count = new AtomicInteger(0);\n            final AtomicInteger     max = new AtomicInteger(0);\n            List<Future<Void>>      futures = Lists.newArrayList();\n            ExecutorService         service = Executors.newCachedThreadPool();\n            for ( int i = 0; i < QTY; ++i )\n            {\n                Future<Void>    future = service.submit\n                (\n                    new Callable<Void>()\n                    {\n                        @Override\n                        public Void call() throws Exception\n                        {\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postLeaveLatch));\n\n                            return null;\n                        }\n                    }\n                );\n                futures.add(future);\n            }\n\n            for ( Future<Void> f : futures )\n            {\n                f.get();\n            }\n            Assert.assertEquals(count.get(), 0);\n            Assert.assertEquals(max.get(), QTY);\n        }\n        finally\n        {\n            for ( Closeable c : closeables )\n            {\n                Closeables.closeQuietly(c);\n            }\n        }\n    }\n","realPath":"curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedDoubleBarrier.java","repoName":"curator","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"B"}],"commitId":"8d32c4738afe4fb6fa5e6fd843b05821ddc2ce88","commitMessage":"@@@Beginning to move everything to Apache\n","date":"2013-03-08 06:54:59","modifiedFileCount":"10","status":"B","submitter":"Jordan Zimmerman"},{"authorTime":"2014-02-04 02:55:50","codes":[{"authorDate":"2014-02-04 02:55:50","commitOrder":2,"curCode":"    public void     testMultiClient() throws Exception\n    {\n        final Timing            timing = new Timing();\n        final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n        final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n        final AtomicInteger     count = new AtomicInteger(0);\n        final AtomicInteger     max = new AtomicInteger(0);\n        List<Future<Void>>      futures = Lists.newArrayList();\n        ExecutorService         service = Executors.newCachedThreadPool();\n        for ( int i = 0; i < QTY; ++i )\n        {\n            Future<Void>    future = service.submit\n            (\n                new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        CuratorFramework                client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n                        try\n                        {\n                            client.start();\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n                        }\n                        finally\n                        {\n                            CloseableUtils.closeQuietly(client);\n                        }\n\n                        return null;\n                    }\n                }\n            );\n            futures.add(future);\n        }\n\n        for ( Future<Void> f : futures )\n        {\n            f.get();\n        }\n        Assert.assertEquals(count.get(), 0);\n        Assert.assertEquals(max.get(), QTY);\n    }\n","date":"2014-02-04 02:55:50","endLine":111,"groupId":"1630","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-curator-10-0.7/blobInfo/CC_OUT/blobs/53/bfeda96010ce1515e6bbe992a135d5d974bd64.src","preCode":"    public void     testMultiClient() throws Exception\n    {\n        final Timing            timing = new Timing();\n        final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n        final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n        final AtomicInteger     count = new AtomicInteger(0);\n        final AtomicInteger     max = new AtomicInteger(0);\n        List<Future<Void>>      futures = Lists.newArrayList();\n        ExecutorService         service = Executors.newCachedThreadPool();\n        for ( int i = 0; i < QTY; ++i )\n        {\n            Future<Void>    future = service.submit\n            (\n                new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        CuratorFramework                client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n                        try\n                        {\n                            client.start();\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n                        }\n                        finally\n                        {\n                            Closeables.closeQuietly(client);\n                        }\n\n                        return null;\n                    }\n                }\n            );\n            futures.add(future);\n        }\n\n        for ( Future<Void> f : futures )\n        {\n            f.get();\n        }\n        Assert.assertEquals(count.get(), 0);\n        Assert.assertEquals(max.get(), QTY);\n    }\n","realPath":"curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedDoubleBarrier.java","repoName":"curator","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2014-02-04 02:55:50","commitOrder":2,"curCode":"    public void     testBasic() throws Exception\n    {\n        final Timing              timing = new Timing();\n        final List<Closeable>     closeables = Lists.newArrayList();\n        final CuratorFramework    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n        try\n        {\n            closeables.add(client);\n            client.start();\n\n            final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n            final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n            final AtomicInteger     count = new AtomicInteger(0);\n            final AtomicInteger     max = new AtomicInteger(0);\n            List<Future<Void>>      futures = Lists.newArrayList();\n            ExecutorService         service = Executors.newCachedThreadPool();\n            for ( int i = 0; i < QTY; ++i )\n            {\n                Future<Void>    future = service.submit\n                (\n                    new Callable<Void>()\n                    {\n                        @Override\n                        public Void call() throws Exception\n                        {\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postLeaveLatch));\n\n                            return null;\n                        }\n                    }\n                );\n                futures.add(future);\n            }\n\n            for ( Future<Void> f : futures )\n            {\n                f.get();\n            }\n            Assert.assertEquals(count.get(), 0);\n            Assert.assertEquals(max.get(), QTY);\n        }\n        finally\n        {\n            for ( Closeable c : closeables )\n            {\n                CloseableUtils.closeQuietly(c);\n            }\n        }\n    }\n","date":"2014-02-04 02:55:50","endLine":239,"groupId":"1631","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testBasic","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-curator-10-0.7/blobInfo/CC_OUT/blobs/53/bfeda96010ce1515e6bbe992a135d5d974bd64.src","preCode":"    public void     testBasic() throws Exception\n    {\n        final Timing              timing = new Timing();\n        final List<Closeable>     closeables = Lists.newArrayList();\n        final CuratorFramework    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n        try\n        {\n            closeables.add(client);\n            client.start();\n\n            final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n            final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n            final AtomicInteger     count = new AtomicInteger(0);\n            final AtomicInteger     max = new AtomicInteger(0);\n            List<Future<Void>>      futures = Lists.newArrayList();\n            ExecutorService         service = Executors.newCachedThreadPool();\n            for ( int i = 0; i < QTY; ++i )\n            {\n                Future<Void>    future = service.submit\n                (\n                    new Callable<Void>()\n                    {\n                        @Override\n                        public Void call() throws Exception\n                        {\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postLeaveLatch));\n\n                            return null;\n                        }\n                    }\n                );\n                futures.add(future);\n            }\n\n            for ( Future<Void> f : futures )\n            {\n                f.get();\n            }\n            Assert.assertEquals(count.get(), 0);\n            Assert.assertEquals(max.get(), QTY);\n        }\n        finally\n        {\n            for ( Closeable c : closeables )\n            {\n                Closeables.closeQuietly(c);\n            }\n        }\n    }\n","realPath":"curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedDoubleBarrier.java","repoName":"curator","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"863eaee2f11fe930601c3da3bce386263fb552c4","commitMessage":"@@@CURATOR-85 - Guava no longer has closeQuietly(). This change adds the implementation internally to Curator\n","date":"2014-02-04 02:55:50","modifiedFileCount":"61","status":"M","submitter":"randgalt"},{"authorTime":"2020-10-20 21:18:25","codes":[{"authorDate":"2020-10-20 21:18:25","commitOrder":3,"curCode":"    public void     testMultiClient() throws Exception\n    {\n        final Timing            timing = new Timing();\n        final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n        final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n        final AtomicInteger     count = new AtomicInteger(0);\n        final AtomicInteger     max = new AtomicInteger(0);\n        List<Future<Void>>      futures = Lists.newArrayList();\n        ExecutorService         service = Executors.newCachedThreadPool();\n        for ( int i = 0; i < QTY; ++i )\n        {\n            Future<Void>    future = service.submit\n            (\n                new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        CuratorFramework                client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n                        try\n                        {\n                            client.start();\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            assertEquals(count.get(), QTY);\n\n                            assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            assertTrue(timing.awaitLatch(postEnterLatch));\n                        }\n                        finally\n                        {\n                            CloseableUtils.closeQuietly(client);\n                        }\n\n                        return null;\n                    }\n                }\n            );\n            futures.add(future);\n        }\n\n        for ( Future<Void> f : futures )\n        {\n            f.get();\n        }\n        assertEquals(count.get(), 0);\n        assertEquals(max.get(), QTY);\n    }\n","date":"2020-10-20 21:18:25","endLine":113,"groupId":"10245","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testMultiClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-curator-10-0.7/blobInfo/CC_OUT/blobs/aa/4aaa62bd098be70e320be1400771a14866a05c.src","preCode":"    public void     testMultiClient() throws Exception\n    {\n        final Timing            timing = new Timing();\n        final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n        final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n        final AtomicInteger     count = new AtomicInteger(0);\n        final AtomicInteger     max = new AtomicInteger(0);\n        List<Future<Void>>      futures = Lists.newArrayList();\n        ExecutorService         service = Executors.newCachedThreadPool();\n        for ( int i = 0; i < QTY; ++i )\n        {\n            Future<Void>    future = service.submit\n            (\n                new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        CuratorFramework                client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n                        try\n                        {\n                            client.start();\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n                        }\n                        finally\n                        {\n                            CloseableUtils.closeQuietly(client);\n                        }\n\n                        return null;\n                    }\n                }\n            );\n            futures.add(future);\n        }\n\n        for ( Future<Void> f : futures )\n        {\n            f.get();\n        }\n        Assert.assertEquals(count.get(), 0);\n        Assert.assertEquals(max.get(), QTY);\n    }\n","realPath":"curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedDoubleBarrier.java","repoName":"curator","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"},{"authorDate":"2020-10-20 21:18:25","commitOrder":3,"curCode":"    public void     testBasic() throws Exception\n    {\n        final Timing              timing = new Timing();\n        final List<Closeable>     closeables = Lists.newArrayList();\n        final CuratorFramework    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n        try\n        {\n            closeables.add(client);\n            client.start();\n\n            final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n            final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n            final AtomicInteger     count = new AtomicInteger(0);\n            final AtomicInteger     max = new AtomicInteger(0);\n            List<Future<Void>>      futures = Lists.newArrayList();\n            ExecutorService         service = Executors.newCachedThreadPool();\n            for ( int i = 0; i < QTY; ++i )\n            {\n                Future<Void>    future = service.submit\n                (\n                    new Callable<Void>()\n                    {\n                        @Override\n                        public Void call() throws Exception\n                        {\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            assertEquals(count.get(), QTY);\n\n                            assertTrue(barrier.leave(10, TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            assertTrue(timing.awaitLatch(postLeaveLatch));\n\n                            return null;\n                        }\n                    }\n                );\n                futures.add(future);\n            }\n\n            for ( Future<Void> f : futures )\n            {\n                f.get();\n            }\n            assertEquals(count.get(), 0);\n            assertEquals(max.get(), QTY);\n        }\n        finally\n        {\n            for ( Closeable c : closeables )\n            {\n                CloseableUtils.closeQuietly(c);\n            }\n        }\n    }\n","date":"2020-10-20 21:18:25","endLine":241,"groupId":"10245","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testBasic","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-curator-10-0.7/blobInfo/CC_OUT/blobs/aa/4aaa62bd098be70e320be1400771a14866a05c.src","preCode":"    public void     testBasic() throws Exception\n    {\n        final Timing              timing = new Timing();\n        final List<Closeable>     closeables = Lists.newArrayList();\n        final CuratorFramework    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));\n        try\n        {\n            closeables.add(client);\n            client.start();\n\n            final CountDownLatch    postEnterLatch = new CountDownLatch(QTY);\n            final CountDownLatch    postLeaveLatch = new CountDownLatch(QTY);\n            final AtomicInteger     count = new AtomicInteger(0);\n            final AtomicInteger     max = new AtomicInteger(0);\n            List<Future<Void>>      futures = Lists.newArrayList();\n            ExecutorService         service = Executors.newCachedThreadPool();\n            for ( int i = 0; i < QTY; ++i )\n            {\n                Future<Void>    future = service.submit\n                (\n                    new Callable<Void>()\n                    {\n                        @Override\n                        public Void call() throws Exception\n                        {\n                            DistributedDoubleBarrier        barrier = new DistributedDoubleBarrier(client, \"/barrier\", QTY);\n\n                            Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));\n\n                            synchronized(TestDistributedDoubleBarrier.this)\n                            {\n                                int     thisCount = count.incrementAndGet();\n                                if ( thisCount > max.get() )\n                                {\n                                    max.set(thisCount);\n                                }\n                            }\n\n                            postEnterLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postEnterLatch));\n\n                            Assert.assertEquals(count.get(), QTY);\n\n                            Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));\n                            count.decrementAndGet();\n\n                            postLeaveLatch.countDown();\n                            Assert.assertTrue(timing.awaitLatch(postLeaveLatch));\n\n                            return null;\n                        }\n                    }\n                );\n                futures.add(future);\n            }\n\n            for ( Future<Void> f : futures )\n            {\n                f.get();\n            }\n            Assert.assertEquals(count.get(), 0);\n            Assert.assertEquals(max.get(), QTY);\n        }\n        finally\n        {\n            for ( Closeable c : closeables )\n            {\n                CloseableUtils.closeQuietly(c);\n            }\n        }\n    }\n","realPath":"curator-recipes/src/test/java/org/apache/curator/framework/recipes/barriers/TestDistributedDoubleBarrier.java","repoName":"curator","snippetEndLine":0,"snippetStartLine":0,"startLine":171,"status":"M"}],"commitId":"7a148288603ae5db0c232142f7dc07d43e01bea3","commitMessage":"@@@CURATOR-582: Migrate to jUnit 5.6 (#372)\n\n","date":"2020-10-20 21:18:25","modifiedFileCount":"125","status":"M","submitter":"Tam?s P?nzes"}]
