[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public List<AuditEntry> fetchAuditHistory(final String key, final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        new HandleCallback<List<AuditEntry>>()\n        {\n          @Override\n          public List<AuditEntry> withHandle(Handle handle)\n          {\n            return handle.createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE audit_key = :audit_key and type = :type and created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            ).bind(\"audit_key\", key)\n                         .bind(\"type\", type)\n                         .bind(\"start_date\", theInterval.getStart().toString())\n                         .bind(\"end_date\", theInterval.getEnd().toString())\n                         .map(\n                             new ResultSetMapper<AuditEntry>()\n                             {\n                               @Override\n                               public AuditEntry map(int index, ResultSet r, StatementContext ctx)\n                                   throws SQLException\n                               {\n                                 try {\n                                   return jsonMapper.readValue(r.getBytes(\"payload\"), AuditEntry.class);\n                                 }\n                                 catch (IOException e) {\n                                   throw new SQLException(e);\n                                 }\n                               }\n                             }\n                         )\n                         .list();\n          }\n        }\n    );\n  }\n","date":"2018-08-31 00:56:26","endLine":161,"groupId":"16241","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"fetchAuditHistory","params":"(finalStringkey@finalStringtype@Intervalinterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/7c/6c65e909152a20c26f0fc49096fb825ec7f29b.src","preCode":"  public List<AuditEntry> fetchAuditHistory(final String key, final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        new HandleCallback<List<AuditEntry>>()\n        {\n          @Override\n          public List<AuditEntry> withHandle(Handle handle)\n          {\n            return handle.createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE audit_key = :audit_key and type = :type and created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            ).bind(\"audit_key\", key)\n                         .bind(\"type\", type)\n                         .bind(\"start_date\", theInterval.getStart().toString())\n                         .bind(\"end_date\", theInterval.getEnd().toString())\n                         .map(\n                             new ResultSetMapper<AuditEntry>()\n                             {\n                               @Override\n                               public AuditEntry map(int index, ResultSet r, StatementContext ctx)\n                                   throws SQLException\n                               {\n                                 try {\n                                   return jsonMapper.readValue(r.getBytes(\"payload\"), AuditEntry.class);\n                                 }\n                                 catch (IOException e) {\n                                   throw new SQLException(e);\n                                 }\n                               }\n                             }\n                         )\n                         .list();\n          }\n        }\n    );\n  }\n","realPath":"server/src/main/java/org/apache/druid/server/audit/SQLAuditManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public List<AuditEntry> fetchAuditHistory(final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        new HandleCallback<List<AuditEntry>>()\n        {\n          @Override\n          public List<AuditEntry> withHandle(Handle handle)\n          {\n            return handle.createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE type = :type and created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            )\n                         .bind(\"type\", type)\n                         .bind(\"start_date\", theInterval.getStart().toString())\n                         .bind(\"end_date\", theInterval.getEnd().toString())\n                         .map(\n                             new ResultSetMapper<AuditEntry>()\n                             {\n                               @Override\n                               public AuditEntry map(int index, ResultSet r, StatementContext ctx)\n                                   throws SQLException\n                               {\n                                 try {\n                                   return jsonMapper.readValue(r.getBytes(\"payload\"), AuditEntry.class);\n                                 }\n                                 catch (IOException e) {\n                                   throw new SQLException(e);\n                                 }\n                               }\n                             }\n                         )\n                         .list();\n          }\n        }\n    );\n  }\n","date":"2018-08-31 00:56:26","endLine":222,"groupId":"16097","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"fetchAuditHistory","params":"(finalStringtype@Intervalinterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/7c/6c65e909152a20c26f0fc49096fb825ec7f29b.src","preCode":"  public List<AuditEntry> fetchAuditHistory(final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        new HandleCallback<List<AuditEntry>>()\n        {\n          @Override\n          public List<AuditEntry> withHandle(Handle handle)\n          {\n            return handle.createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE type = :type and created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            )\n                         .bind(\"type\", type)\n                         .bind(\"start_date\", theInterval.getStart().toString())\n                         .bind(\"end_date\", theInterval.getEnd().toString())\n                         .map(\n                             new ResultSetMapper<AuditEntry>()\n                             {\n                               @Override\n                               public AuditEntry map(int index, ResultSet r, StatementContext ctx)\n                                   throws SQLException\n                               {\n                                 try {\n                                   return jsonMapper.readValue(r.getBytes(\"payload\"), AuditEntry.class);\n                                 }\n                                 catch (IOException e) {\n                                   throw new SQLException(e);\n                                 }\n                               }\n                             }\n                         )\n                         .list();\n          }\n        }\n    );\n  }\n","realPath":"server/src/main/java/org/apache/druid/server/audit/SQLAuditManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":184,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2019-11-07 03:07:04","codes":[{"authorDate":"2019-11-07 03:07:04","commitOrder":2,"curCode":"  public List<AuditEntry> fetchAuditHistory(final String key, final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        (Handle handle) -> handle\n            .createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE audit_key = :audit_key and type = :type and \"\n                    + \"created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            )\n            .bind(\"audit_key\", key)\n            .bind(\"type\", type)\n            .bind(\"start_date\", theInterval.getStart().toString())\n            .bind(\"end_date\", theInterval.getEnd().toString())\n            .map((index, r, ctx) -> JacksonUtils.readValue(jsonMapper, r.getBytes(\"payload\"), AuditEntry.class))\n            .list()\n    );\n  }\n","date":"2019-11-07 03:07:04","endLine":139,"groupId":"111209","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"fetchAuditHistory","params":"(finalStringkey@finalStringtype@Intervalinterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fc/68c84727c21177eaaa9451e87712a6bab0ecf2.src","preCode":"  public List<AuditEntry> fetchAuditHistory(final String key, final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        new HandleCallback<List<AuditEntry>>()\n        {\n          @Override\n          public List<AuditEntry> withHandle(Handle handle)\n          {\n            return handle.createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE audit_key = :audit_key and type = :type and created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            ).bind(\"audit_key\", key)\n                         .bind(\"type\", type)\n                         .bind(\"start_date\", theInterval.getStart().toString())\n                         .bind(\"end_date\", theInterval.getEnd().toString())\n                         .map(\n                             new ResultSetMapper<AuditEntry>()\n                             {\n                               @Override\n                               public AuditEntry map(int index, ResultSet r, StatementContext ctx)\n                                   throws SQLException\n                               {\n                                 try {\n                                   return jsonMapper.readValue(r.getBytes(\"payload\"), AuditEntry.class);\n                                 }\n                                 catch (IOException e) {\n                                   throw new SQLException(e);\n                                 }\n                               }\n                             }\n                         )\n                         .list();\n          }\n        }\n    );\n  }\n","realPath":"server/src/main/java/org/apache/druid/server/audit/SQLAuditManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2019-11-07 03:07:04","commitOrder":2,"curCode":"  public List<AuditEntry> fetchAuditHistory(final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        (Handle handle) -> handle\n            .createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE type = :type and created_date between :start_date and \"\n                    + \":end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            )\n            .bind(\"type\", type)\n            .bind(\"start_date\", theInterval.getStart().toString())\n            .bind(\"end_date\", theInterval.getEnd().toString())\n            .map((index, r, ctx) -> JacksonUtils.readValue(jsonMapper, r.getBytes(\"payload\"), AuditEntry.class))\n            .list()\n    );\n  }\n","date":"2019-11-07 03:07:04","endLine":180,"groupId":"111209","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"fetchAuditHistory","params":"(finalStringtype@Intervalinterval)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fc/68c84727c21177eaaa9451e87712a6bab0ecf2.src","preCode":"  public List<AuditEntry> fetchAuditHistory(final String type, Interval interval)\n  {\n    final Interval theInterval = getIntervalOrDefault(interval);\n    return dbi.withHandle(\n        new HandleCallback<List<AuditEntry>>()\n        {\n          @Override\n          public List<AuditEntry> withHandle(Handle handle)\n          {\n            return handle.createQuery(\n                StringUtils.format(\n                    \"SELECT payload FROM %s WHERE type = :type and created_date between :start_date and :end_date ORDER BY created_date\",\n                    getAuditTable()\n                )\n            )\n                         .bind(\"type\", type)\n                         .bind(\"start_date\", theInterval.getStart().toString())\n                         .bind(\"end_date\", theInterval.getEnd().toString())\n                         .map(\n                             new ResultSetMapper<AuditEntry>()\n                             {\n                               @Override\n                               public AuditEntry map(int index, ResultSet r, StatementContext ctx)\n                                   throws SQLException\n                               {\n                                 try {\n                                   return jsonMapper.readValue(r.getBytes(\"payload\"), AuditEntry.class);\n                                 }\n                                 catch (IOException e) {\n                                   throw new SQLException(e);\n                                 }\n                               }\n                             }\n                         )\n                         .list();\n          }\n        }\n    );\n  }\n","realPath":"server/src/main/java/org/apache/druid/server/audit/SQLAuditManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"M"}],"commitId":"5c0fc0a13ab4d259b430bf50b322f631504c4529","commitMessage":"@@@Fix ambiguity about IndexerSQLMetadataStorageCoordinator.getUsedSegmentsForInterval() returning only non-overshadowed or all used segments (#8564)\n\n* IndexerSQLMetadataStorageCoordinator.getTimelineForIntervalsWithHandle() don't fetch abutting intervals; simplify getUsedSegmentsForIntervals()\n\n* Add VersionedIntervalTimeline.findNonOvershadowedObjectsInInterval() method; Propagate the decision about whether only visible segmetns or visible and overshadowed segments should be returned from IndexerMetadataStorageCoordinator's methods to the user logic; Rename SegmentListUsedAction to RetrieveUsedSegmentsAction.  SegmetnListUnusedAction to RetrieveUnusedSegmentsAction.  and UsedSegmentLister to UsedSegmentsRetriever\n\n* Fix tests\n\n* More fixes\n\n* Add javadoc notes about returning Collection instead of Set. Add JacksonUtils.readValue() to reduce boilerplate code\n\n* Fix KinesisIndexTaskTest.  factor out common parts from KinesisIndexTaskTest and KafkaIndexTaskTest into SeekableStreamIndexTaskTestBase\n\n* More test fixes\n\n* More test fixes\n\n* Add a comment to VersionedIntervalTimelineTestBase\n\n* Fix tests\n\n* Set DataSegment.size(0) in more tests\n\n* Specify DataSegment.size(0) in more places in tests\n\n* Fix more tests\n\n* Fix DruidSchemaTest\n\n* Set DataSegment's size in more tests and benchmarks\n\n* Fix HdfsDataSegmentPusherTest\n\n* Doc changes addressing comments\n\n* Extended doc for visibility\n\n* Typo\n\n* Typo 2\n\n* Address comment\n","date":"2019-11-07 03:07:04","modifiedFileCount":"88","status":"M","submitter":"Roman Leventov"}]
