[{"authorTime":"2019-06-20 04:57:37","codes":[{"authorDate":"2019-06-20 04:57:37","commitOrder":1,"curCode":"  public void exitLongArray(ExprParser.LongArrayContext ctx)\n  {\n    Long[] values = new Long[ctx.LONG().size()];\n    for (int i = 0; i < values.length; i++) {\n      values[i] = Long.parseLong(ctx.LONG(i).getText());\n    }\n    nodes.put(ctx, new LongArrayExpr(values));\n  }\n","date":"2019-06-20 04:57:37","endLine":187,"groupId":"15540","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"exitLongArray","params":"(ExprParser.LongArrayContextctx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b4/dc961e61f914671e9c816e9c6215d94edc0d3f.src","preCode":"  public void exitLongArray(ExprParser.LongArrayContext ctx)\n  {\n    Long[] values = new Long[ctx.LONG().size()];\n    for (int i = 0; i < values.length; i++) {\n      values[i] = Long.parseLong(ctx.LONG(i).getText());\n    }\n    nodes.put(ctx, new LongArrayExpr(values));\n  }\n","realPath":"core/src/main/java/org/apache/druid/math/expr/ExprListenerImpl.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"B"},{"authorDate":"2019-06-20 04:57:37","commitOrder":1,"curCode":"  public void exitStringArray(ExprParser.StringArrayContext ctx)\n  {\n    String[] values = new String[ctx.STRING().size()];\n    for (int i = 0; i < values.length; i++) {\n      values[i] = escapeStringLiteral(ctx.STRING(i).getText());\n    }\n    nodes.put(ctx, new StringArrayExpr(values));\n  }\n","date":"2019-06-20 04:57:37","endLine":400,"groupId":"15540","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"exitStringArray","params":"(ExprParser.StringArrayContextctx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b4/dc961e61f914671e9c816e9c6215d94edc0d3f.src","preCode":"  public void exitStringArray(ExprParser.StringArrayContext ctx)\n  {\n    String[] values = new String[ctx.STRING().size()];\n    for (int i = 0; i < values.length; i++) {\n      values[i] = escapeStringLiteral(ctx.STRING(i).getText());\n    }\n    nodes.put(ctx, new StringArrayExpr(values));\n  }\n","realPath":"core/src/main/java/org/apache/druid/math/expr/ExprListenerImpl.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":393,"status":"B"}],"commitId":"494b8ebe56308fe69c2a758f80f1ae56bf17d54d","commitMessage":"@@@multi-value string column support for expressions (#7588)\n\n* array support for expression language for multi-value string columns\n\n* fix tests?\n\n* fixes\n\n* more tests\n\n* fixes\n\n* cleanup\n\n* more better.  more test\n\n* ignore inspection\n\n* license\n\n* license fix\n\n* inspection\n\n* remove dumb import\n\n* more better\n\n* some comments\n\n* add expr rewrite for arrayfn args for more magic.  tests\n\n* test stuff\n\n* more tests\n\n* fix test\n\n* fix test\n\n* castfunc can deal with arrays\n\n* needs more empty array\n\n* more tests.  make cast to long array more forgiving\n\n* refactor\n\n* simplify ExprMacro Expr implementations with base classes in core\n\n* oops\n\n* more test\n\n* use Shuttle for Parser.flatten.  javadoc.  cleanup\n\n* fixes and more tests\n\n* unused import\n\n* fixes\n\n* javadocs.  cleanup.  refactors\n\n* fix imports\n\n* more javadoc\n\n* more javadoc\n\n* more\n\n* more javadocs.  nonnullbydefault.  minor refactor\n\n* markdown fix\n\n* adjustments\n\n* more doc\n\n* move initial filter out\n\n* docs\n\n* map empty arg lambda.  apply function argument validation\n\n* check function args at parse time instead of eval time\n\n* more immutable\n\n* more more immutable\n\n* clarify grammar\n\n* fix docs\n\n* empty array is string test.  we need a way to make arrays better maybe in the future.  or define empty arrays as other types..\n","date":"2019-06-20 04:57:37","modifiedFileCount":"43","status":"B","submitter":"Clint Wylie"},{"authorTime":"2020-02-22 07:43:02","codes":[{"authorDate":"2020-02-22 07:43:02","commitOrder":2,"curCode":"  public void exitLongArray(ExprParser.LongArrayContext ctx)\n  {\n    Long[] values = new Long[ctx.longElement().size()];\n    for (int i = 0; i < values.length; i++) {\n      if (ctx.longElement(i).NULL() != null) {\n        values[i] = null;\n      } else if (ctx.longElement(i).LONG() != null) {\n        values[i] = Long.parseLong(ctx.longElement(i).LONG().getText());\n      } else {\n        throw new RE(\"Failed to parse array element %s as a long\", ctx.longElement(i).getText());\n      }\n    }\n    nodes.put(ctx, new LongArrayExpr(values));\n  }\n","date":"2020-02-22 07:43:02","endLine":422,"groupId":"105497","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"exitLongArray","params":"(ExprParser.LongArrayContextctx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ae/41653950f9c62ab5e414caddba01eb91537cb8.src","preCode":"  public void exitLongArray(ExprParser.LongArrayContext ctx)\n  {\n    Long[] values = new Long[ctx.LONG().size()];\n    for (int i = 0; i < values.length; i++) {\n      values[i] = Long.parseLong(ctx.LONG(i).getText());\n    }\n    nodes.put(ctx, new LongArrayExpr(values));\n  }\n","realPath":"core/src/main/java/org/apache/druid/math/expr/ExprListenerImpl.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":409,"status":"M"},{"authorDate":"2020-02-22 07:43:02","commitOrder":2,"curCode":"  public void exitStringArray(ExprParser.StringArrayContext ctx)\n  {\n    String[] values = new String[ctx.stringElement().size()];\n    for (int i = 0; i < values.length; i++) {\n      if (ctx.stringElement(i).NULL() != null) {\n        values[i] = null;\n      } else if (ctx.stringElement(i).STRING() != null) {\n        values[i] = escapeStringLiteral(ctx.stringElement(i).STRING().getText());\n      } else {\n        throw new RE(\"Failed to parse array: element %s is not a string\", ctx.stringElement(i).getText());\n      }\n    }\n    nodes.put(ctx, new StringArrayExpr(values));\n  }\n","date":"2020-02-22 07:43:02","endLine":456,"groupId":"105497","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"exitStringArray","params":"(ExprParser.StringArrayContextctx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ae/41653950f9c62ab5e414caddba01eb91537cb8.src","preCode":"  public void exitStringArray(ExprParser.StringArrayContext ctx)\n  {\n    String[] values = new String[ctx.STRING().size()];\n    for (int i = 0; i < values.length; i++) {\n      values[i] = escapeStringLiteral(ctx.STRING(i).getText());\n    }\n    nodes.put(ctx, new StringArrayExpr(values));\n  }\n","realPath":"core/src/main/java/org/apache/druid/math/expr/ExprListenerImpl.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":443,"status":"M"}],"commitId":"6d8dd5ec10042a827aca20429b3ea19dd39b5827","commitMessage":"@@@string -> expression -> string -> expression (#9367)\n\n* add Expr.stringify which produces parseable expression strings.  parser support for null values in arrays.  and parser support for empty numeric arrays\n\n* oops.  macros are expressions too\n\n* style\n\n* spotbugs\n\n* qualified type arrays\n\n* review stuffs\n\n* simplify grammar\n\n* more permissive array parsing\n\n* reuse expr joiner\n\n* fix it\n","date":"2020-02-22 07:43:02","modifiedFileCount":"28","status":"M","submitter":"Clint Wylie"}]
