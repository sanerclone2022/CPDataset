[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2019-07-30 08:06:33","commitOrder":2,"curCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (tasks) {\n      for (TaskRunnerWorkItem item : tasks.values()) {\n        TaskRunnerUtils.notifyLocationChanged(ImmutableList.of(listenerPair), item.getTaskId(), item.getLocation());\n      }\n\n      listeners.add(listenerPair);\n      LOG.info(\"Registered listener [%s]\", listener.getListenerId());\n    }\n  }\n","date":"2019-07-30 08:06:33","endLine":132,"groupId":"14404","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"registerListener","params":"(TaskRunnerListenerlistener@Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4c/9910f079740aa5cdd98dfc0aba23ad08e218a2.src","preCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (tasks) {\n      for (TaskRunnerWorkItem item : tasks.values()) {\n        TaskRunnerUtils.notifyLocationChanged(ImmutableList.of(listenerPair), item.getTaskId(), item.getLocation());\n      }\n\n      listeners.add(listenerPair);\n      LOG.info(\"Registered listener [%s]\", listener.getListenerId());\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/BaseRestorableTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (statusLock) {\n      for (Map.Entry<String, HttpRemoteTaskRunnerWorkItem> entry : tasks.entrySet()) {\n        if (entry.getValue().getState() == HttpRemoteTaskRunnerWorkItem.State.RUNNING) {\n          TaskRunnerUtils.notifyLocationChanged(\n              ImmutableList.of(listenerPair),\n              entry.getKey(),\n              entry.getValue().getLocation()\n          );\n        }\n      }\n\n      log.info(\"Registered listener [%s]\", listener.getListenerId());\n      listeners.add(listenerPair);\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":919,"groupId":"13346","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"registerListener","params":"(TaskRunnerListenerlistener@Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ae/8cd0ddd86c2ac57c4b82064904af624e730c5e.src","preCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (statusLock) {\n      for (Map.Entry<String, HttpRemoteTaskRunnerWorkItem> entry : tasks.entrySet()) {\n        if (entry.getValue().getState() == HttpRemoteTaskRunnerWorkItem.State.RUNNING) {\n          TaskRunnerUtils.notifyLocationChanged(\n              ImmutableList.of(listenerPair),\n              entry.getKey(),\n              entry.getValue().getLocation()\n          );\n        }\n      }\n\n      log.info(\"Registered listener [%s]\", listener.getListenerId());\n      listeners.add(listenerPair);\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":895,"status":"NB"}],"commitId":"640b7afc1cee911a27de7bf938dda24a85ba1510","commitMessage":"@@@Add CliIndexer process type and initial task runner implementation (#8107)\n\n* Add CliIndexer process type and initial task runner implementation\n\n* Fix HttpRemoteTaskRunnerTest\n\n* Remove batch sanity check on PeonAppenderatorsManager\n\n* Fix paralle index tests\n\n* PR comments\n\n* Adjust Jersey resource logging\n\n* Additional cleanup\n\n* Fix SystemSchemaTest\n\n* Add comment to LocalDataSegmentPusherTest absolute path test\n\n* More PR comments\n\n* Use Server annotated with RemoteChatHandler\n\n* More PR comments\n\n* Checkstyle\n\n* PR comments\n\n* Add task shutdown to stopGracefully\n\n* Small cleanup\n\n* Compile fix\n\n* Address PR comments\n\n* Adjust TaskReportFileWriter and fix nits\n\n* Remove unnecessary closer\n\n* More PR comments\n\n* Minor adjustments\n\n* PR comments\n\n* ThreadingTaskRunner: cancel  task run future not shutdownFuture and remove thread from workitem\n","date":"2019-07-30 08:06:33","modifiedFileCount":"64","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2019-11-20 05:57:58","commitOrder":3,"curCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (tasks) {\n      for (TaskRunnerWorkItem item : tasks.values()) {\n        TaskRunnerUtils.notifyLocationChanged(ImmutableList.of(listenerPair), item.getTaskId(), item.getLocation());\n      }\n\n      listeners.add(listenerPair);\n      LOG.debug(\"Registered listener [%s]\", listener.getListenerId());\n    }\n  }\n","date":"2019-11-20 05:57:58","endLine":137,"groupId":"104699","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"registerListener","params":"(TaskRunnerListenerlistener@Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/30/dcec286bb2983dffc7e99c6bc226400dcfe566.src","preCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (tasks) {\n      for (TaskRunnerWorkItem item : tasks.values()) {\n        TaskRunnerUtils.notifyLocationChanged(ImmutableList.of(listenerPair), item.getTaskId(), item.getLocation());\n      }\n\n      listeners.add(listenerPair);\n      LOG.info(\"Registered listener [%s]\", listener.getListenerId());\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/BaseRestorableTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2018-08-31 00:56:26","commitOrder":3,"curCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (statusLock) {\n      for (Map.Entry<String, HttpRemoteTaskRunnerWorkItem> entry : tasks.entrySet()) {\n        if (entry.getValue().getState() == HttpRemoteTaskRunnerWorkItem.State.RUNNING) {\n          TaskRunnerUtils.notifyLocationChanged(\n              ImmutableList.of(listenerPair),\n              entry.getKey(),\n              entry.getValue().getLocation()\n          );\n        }\n      }\n\n      log.info(\"Registered listener [%s]\", listener.getListenerId());\n      listeners.add(listenerPair);\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":919,"groupId":"104699","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"registerListener","params":"(TaskRunnerListenerlistener@Executorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ae/8cd0ddd86c2ac57c4b82064904af624e730c5e.src","preCode":"  public void registerListener(TaskRunnerListener listener, Executor executor)\n  {\n    for (Pair<TaskRunnerListener, Executor> pair : listeners) {\n      if (pair.lhs.getListenerId().equals(listener.getListenerId())) {\n        throw new ISE(\"Listener [%s] already registered\", listener.getListenerId());\n      }\n    }\n\n    final Pair<TaskRunnerListener, Executor> listenerPair = Pair.of(listener, executor);\n\n    synchronized (statusLock) {\n      for (Map.Entry<String, HttpRemoteTaskRunnerWorkItem> entry : tasks.entrySet()) {\n        if (entry.getValue().getState() == HttpRemoteTaskRunnerWorkItem.State.RUNNING) {\n          TaskRunnerUtils.notifyLocationChanged(\n              ImmutableList.of(listenerPair),\n              entry.getKey(),\n              entry.getValue().getLocation()\n          );\n        }\n      }\n\n      log.info(\"Registered listener [%s]\", listener.getListenerId());\n      listeners.add(listenerPair);\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":895,"status":"N"}],"commitId":"c44452f0c1b051b03343d8bb479828f01461d68f","commitMessage":"@@@Tidy up lifecycle.  query.  and ingestion logging. (#8889)\n\n* Tidy up lifecycle.  query.  and ingestion logging.\n\nThe goal of this patch is to improve the clarity and usefulness of\nDruid's logging for cluster operators. For more information.  see\nhttps://twitter.com/cowtowncoder/status/1195469299814555648.\n\nConcretely.  this patch does the following:\n\n- Changes a lot of INFO logs to DEBUG.  and DEBUG to TRACE.  with the\n  goal of reducing redundancy and improving clarity by avoiding\n  showing rarely-useful log messages. This includes most \"starting\"\n  and \"stopping\" messages.  and most messages related to individual\n  columns.\n- Adds new log4j2 templates that show operators how to enabled DEBUG\n  logging for certain important packages.\n- Eliminate stack traces for query errors.  unless log level is DEBUG\n  or more. This is useful because query errors often indicate user\n  error rather than system error.  but dumping stack trace often gave\n  operators the impression that there was a system failure.\n- Adds task id to Appenderator.  AppenderatorDriver thread names. In\n  the default log4j2 configuration.  this will put them in log lines\n  as well. It's very useful if a user is using the Indexer.  where\n  multiple tasks run in the same JVM.\n- More consistent terminology when it comes to \"sequences\" (sets of\n  segments that are handed-off together by Kafka ingestion) and\n  \"offsets\" (cursors in partitions). These terms had been confused in\n  some log messages due to the fact that Kinesis calls offsets\n  \"sequence numbers\".\n- Replaces some ugly toString calls with either the JSONification or\n  something more operator-accessible (like a URL or segment identifier. \n  instead of JSON object representing the same).\n\n* Adjustments.\n\n* Adjust integration test.\n","date":"2019-11-20 05:57:58","modifiedFileCount":"101","status":"M","submitter":"Gian Merlino"}]
