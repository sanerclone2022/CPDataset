[{"authorTime":"2019-10-16 14:19:17","codes":[{"authorDate":"2019-10-16 14:19:17","commitOrder":2,"curCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"0\",\n        SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","date":"2019-10-16 14:19:17","endLine":4088,"groupId":"15486","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardSplitPhaseTwo","params":"(List<Task>phaseOneTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/87e4b1c528a6ae31a000c6d18098d01f89dc4c.src","preCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"0\",\n        SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3938,"status":"MB"},{"authorDate":"2019-10-16 14:19:17","commitOrder":2,"curCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Map<String, String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableMap.of(SHARD_ID1, \"-1\"),\n        1, ImmutableMap.of(SHARD_ID2, \"-1\")\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n  }\n","date":"2019-10-16 14:19:17","endLine":4275,"groupId":"2150","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardSplitPhaseThree","params":"(List<Task>phaseTwoTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/87e4b1c528a6ae31a000c6d18098d01f89dc4c.src","preCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Map<String, String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableMap.of(SHARD_ID1, \"-1\"),\n        1, ImmutableMap.of(SHARD_ID2, \"-1\")\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4096,"status":"MB"}],"commitId":"89ce6384f57cb13c776cfcc9fc7b97126b834fac","commitMessage":"@@@More Kinesis resharding adjustments (#8671)\n\n* More Kinesis resharding adjustments\n\n* Fix TC inspection\n\n* Fix comment'\n\n* Adjust comment.  small refactor\n\n* Make repartition transition time configurable\n\n* Add spellcheck exclusion\n\n* Spelling fix\n","date":"2019-10-16 14:19:17","modifiedFileCount":"13","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2019-11-29 04:59:01","codes":[{"authorDate":"2019-11-29 04:59:01","commitOrder":3,"curCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","date":"2019-11-29 04:59:01","endLine":3978,"groupId":"15486","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardSplitPhaseTwo","params":"(List<Task>phaseOneTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/5c/e8f3659daf8b21dc5cc92c4d1b011e270107ca.src","preCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"0\",\n        SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3829,"status":"M"},{"authorDate":"2019-11-29 04:59:01","commitOrder":3,"curCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","date":"2019-11-29 04:59:01","endLine":4175,"groupId":"2150","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardSplitPhaseThree","params":"(List<Task>phaseTwoTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/5c/e8f3659daf8b21dc5cc92c4d1b011e270107ca.src","preCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Map<String, String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableMap.of(SHARD_ID1, \"-1\"),\n        1, ImmutableMap.of(SHARD_ID2, \"-1\")\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3986,"status":"M"}],"commitId":"00ce18a0ea1b984a07479489d43d9901575d3d28","commitMessage":"@@@Additional Kinesis resharding fixes (#8870)\n\n* Additional Kinesis resharding fixes\n\n* Address PR comments\n\n* Remove unused method\n\n* Adjust SegmentTransactionalInsertAction null handling\n\n* Check for unchanged metadata on empty publish\n\n* Add logs for empty publish\n\n* Fix javadoc\n\n* Clear offset when invalid endOffsets are seen\n\n* Fix LGTM alert\n\n* Fix build\n\n* Add resharding note to Kinesis docs\n\n* Checkstyle\n\n* Spelling\n\n* Address PR comments\n\n* Checkstyle\n","date":"2019-11-29 04:59:01","modifiedFileCount":"13","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2020-01-28 03:24:29","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":4,"curCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","date":"2020-01-28 03:24:29","endLine":3989,"groupId":"15486","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardSplitPhaseTwo","params":"(List<Task>phaseOneTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ad/267e8a1eaa52ef1a024b696bf027db057d33b6.src","preCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3840,"status":"M"},{"authorDate":"2020-01-28 03:24:29","commitOrder":4,"curCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","date":"2020-01-28 03:24:29","endLine":4186,"groupId":"2150","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardSplitPhaseThree","params":"(List<Task>phaseTwoTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ad/267e8a1eaa52ef1a024b696bf027db057d33b6.src","preCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.getDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3997,"status":"M"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"M","submitter":"Roman Leventov"},{"authorTime":"2020-03-17 12:39:53","codes":[{"authorDate":"2020-03-17 12:39:53","commitOrder":5,"curCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","date":"2020-03-17 12:39:53","endLine":4082,"groupId":"15486","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardSplitPhaseTwo","params":"(List<Task>phaseOneTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/ca6bf693b0f756794d2354302ba22e8b2b1d8f.src","preCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3930,"status":"M"},{"authorDate":"2020-03-17 12:39:53","commitOrder":5,"curCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","date":"2020-03-17 12:39:53","endLine":4282,"groupId":"2150","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardSplitPhaseThree","params":"(List<Task>phaseTwoTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/ca6bf693b0f756794d2354302ba22e8b2b1d8f.src","preCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4090,"status":"M"}],"commitId":"142742f291daaf1ac9afea319cacbbe2a3077952","commitMessage":"@@@add kinesis lag metric (#9509)\n\n* add kinesis lag metric\n\n* fixes\n\n* heh\n\n* do it right this time\n\n* more test\n\n* split out supervisor report lags into lagMillis.  remove latest offsets from kinesis supervisor report since always null.  review stuffs","date":"2020-03-17 12:39:53","modifiedFileCount":"17","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-05-17 05:09:39","codes":[{"authorDate":"2020-05-17 05:09:39","commitOrder":6,"curCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","date":"2020-05-17 05:09:39","endLine":4067,"groupId":"15486","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardSplitPhaseTwo","params":"(List<Task>phaseOneTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/a21d9b2278abf9369dd4760fda54ee8e78a8af.src","preCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3918,"status":"M"},{"authorDate":"2020-05-17 05:09:39","commitOrder":6,"curCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","date":"2020-05-17 05:09:39","endLine":4264,"groupId":"2150","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardSplitPhaseThree","params":"(List<Task>phaseTwoTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/a21d9b2278abf9369dd4760fda54ee8e78a8af.src","preCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getPartitionTimeLag(EasyMock.anyObject()))\n            .andReturn(TIME_LAG)\n            .atLeastOnce();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4075,"status":"M"}],"commitId":"2e9548d93d5a27e824cc93293e1de55af63d158f","commitMessage":"@@@refactor SeekableStreamSupervisor usage of RecordSupplier (#9819)\n\n* refactor SeekableStreamSupervisor usage of RecordSupplier to reduce contention between background threads and main thread.  refactor KinesisRecordSupplier.  refactor Kinesis lag metric collection and emitting\n\n* fix style and test\n\n* cleanup.  refactor.  javadocs.  test\n\n* fixes\n\n* keep collecting current offsets and lag if unhealthy in background reporting thread\n\n* review stuffs\n\n* add comment","date":"2020-05-17 05:09:39","modifiedFileCount":"13","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-06-19 00:47:07","codes":[{"authorDate":"2020-06-19 00:47:07","commitOrder":7,"curCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.emptyList()).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","date":"2020-06-19 00:47:07","endLine":4067,"groupId":"102307","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testShardSplitPhaseTwo","params":"(List<Task>phaseOneTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/d309c8b7d36589c3bce8ef8067d38a0e5f58d2.src","preCode":"  private List<Task> testShardSplitPhaseTwo(List<Task> phaseOneTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER)\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID0, SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD0_PARTITION, SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID0)))\n            .andReturn(KinesisSequenceNumber.END_OF_SHARD_MARKER).anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"100\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"100\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    Task successfulTask = phaseOneTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask.getId())).andReturn(Optional.of(successfulTask)).anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID1, \"0\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID2, \"0\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"0\"\n            ),\n            ImmutableSet.of()\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    return postSplitTasks;\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":3918,"status":"M"},{"authorDate":"2020-06-19 00:47:07","commitOrder":7,"curCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.emptyList()).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","date":"2020-06-19 00:47:07","endLine":4264,"groupId":"102307","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testShardSplitPhaseThree","params":"(List<Task>phaseTwoTasks)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/d309c8b7d36589c3bce8ef8067d38a0e5f58d2.src","preCode":"  private void testShardSplitPhaseThree(List<Task> phaseTwoTasks) throws Exception\n  {\n    EasyMock.reset(indexerMetadataStorageCoordinator);\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskQueue);\n    EasyMock.reset(taskClient);\n    EasyMock.reset(taskMaster);\n    EasyMock.reset(taskRunner);\n    EasyMock.reset(supervisorRecordSupplier);\n\n    \r\n    EasyMock.expect(indexerMetadataStorageCoordinator.retrieveDataSourceMetadata(DATASOURCE)).andReturn(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<String, String>(\n                STREAM,\n                ImmutableMap.of(\n                    SHARD_ID0, KinesisSequenceNumber.END_OF_SHARD_MARKER,\n                    SHARD_ID1, \"100\",\n                    SHARD_ID2, \"100\"\n                )\n            )\n        )\n    ).anyTimes();\n\n    EasyMock.expect(\n        indexerMetadataStorageCoordinator.resetDataSourceMetadata(\n            DATASOURCE,\n            new KinesisDataSourceMetadata(\n                new SeekableStreamEndSequenceNumbers<String, String>(\n                    STREAM,\n                    ImmutableMap.of(\n                        SHARD_ID0, KinesisSequenceNumber.EXPIRED_MARKER,\n                        SHARD_ID1, \"100\",\n                        SHARD_ID2, \"100\"\n                    )\n                )\n            )\n        )\n    ).andReturn(true).anyTimes();\n\n    EasyMock.expect(supervisorRecordSupplier.getPartitionIds(STREAM))\n            .andReturn(ImmutableSet.of(SHARD_ID1, SHARD_ID2))\n            .anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getAssignment())\n            .andReturn(ImmutableSet.of(SHARD1_PARTITION, SHARD2_PARTITION))\n            .anyTimes();\n\n    supervisorRecordSupplier.seekToLatest(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID1)))\n            .andReturn(\"200\").anyTimes();\n    EasyMock.expect(supervisorRecordSupplier.getLatestSequenceNumber(new StreamPartition<>(STREAM, SHARD_ID2)))\n            .andReturn(\"200\").anyTimes();\n\n    supervisorRecordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    Capture<Task> postSplitCaptured = Capture.newInstance(CaptureType.ALL);\n\n    EasyMock.expect(taskMaster.getTaskQueue()).andReturn(Optional.of(taskQueue)).anyTimes();\n    EasyMock.expect(taskMaster.getTaskRunner()).andReturn(Optional.of(taskRunner)).anyTimes();\n    EasyMock.expect(taskRunner.getRunningTasks()).andReturn(Collections.EMPTY_LIST).anyTimes();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(ImmutableList.of()).anyTimes();\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n\n    Task successfulTask0 = phaseTwoTasks.get(0);\n    EasyMock.expect(taskStorage.getStatus(successfulTask0.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask0.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask0.getId())).andReturn(Optional.of(successfulTask0)).anyTimes();\n\n    Task successfulTask1 = phaseTwoTasks.get(1);\n    EasyMock.expect(taskStorage.getStatus(successfulTask1.getId()))\n            .andReturn(Optional.of(TaskStatus.success(successfulTask1.getId())));\n    EasyMock.expect(taskStorage.getTask(successfulTask1.getId())).andReturn(Optional.of(successfulTask1)).anyTimes();\n\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n\n    EasyMock.expect(taskQueue.add(EasyMock.capture(postSplitCaptured))).andReturn(true).times(2);\n\n    replayAll();\n\n    supervisor.runInternal();\n    verifyAll();\n\n    EasyMock.reset(taskStorage);\n    EasyMock.reset(taskClient);\n\n    EasyMock.expect(taskClient.getStatusAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(SeekableStreamIndexTaskRunner.Status.NOT_STARTED))\n            .anyTimes();\n    EasyMock.expect(taskClient.getStartTimeAsync(EasyMock.anyString()))\n            .andReturn(Futures.immediateFuture(DateTimes.nowUtc()))\n            .anyTimes();\n    TreeMap<Integer, Map<String, String>> checkpointsGroup0 = new TreeMap<>();\n    checkpointsGroup0.put(0, ImmutableMap.of(\n        SHARD_ID2, \"100\"\n    ));\n    TreeMap<Integer, Map<String, String>> checkpointsGroup1 = new TreeMap<>();\n    checkpointsGroup1.put(1, ImmutableMap.of(\n        SHARD_ID1, \"100\"\n    ));\n    \r\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-0\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup0))\n            .times(1);\n    EasyMock.expect(taskClient.getCheckpointsAsync(EasyMock.contains(\"sequenceName-1\"), EasyMock.anyBoolean()))\n            .andReturn(Futures.immediateFuture(checkpointsGroup1))\n            .times(1);\n\n    List<Task> postSplitTasks = postSplitCaptured.getValues();\n    EasyMock.expect(taskStorage.getActiveTasksByDatasource(DATASOURCE)).andReturn(postSplitTasks).anyTimes();\n    for (Task task : postSplitTasks) {\n      EasyMock.expect(taskStorage.getStatus(task.getId()))\n              .andReturn(Optional.of(TaskStatus.running(task.getId())))\n              .anyTimes();\n      EasyMock.expect(taskStorage.getTask(task.getId())).andReturn(Optional.of(task)).anyTimes();\n    }\n    EasyMock.replay(taskStorage);\n    EasyMock.replay(taskClient);\n\n    supervisor.runInternal();\n    verifyAll();\n\n\n    \r\n    SeekableStreamStartSequenceNumbers<String, String> group0ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID1)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group0ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID1, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    SeekableStreamStartSequenceNumbers<String, String> group1ExpectedStartSequenceNumbers =\n        new SeekableStreamStartSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, \"100\"\n            ),\n            ImmutableSet.of(SHARD_ID2)\n        );\n\n    SeekableStreamEndSequenceNumbers<String, String> group1ExpectedEndSequenceNumbers =\n        new SeekableStreamEndSequenceNumbers<>(\n            STREAM,\n            ImmutableMap.of(\n                SHARD_ID2, KinesisSequenceNumber.NO_END_SEQUENCE_NUMBER\n            )\n        );\n\n    Assert.assertEquals(2, postSplitTasks.size());\n    KinesisIndexTaskIOConfig group0Config = ((KinesisIndexTask) postSplitTasks.get(0)).getIOConfig();\n    KinesisIndexTaskIOConfig group1Config = ((KinesisIndexTask) postSplitTasks.get(1)).getIOConfig();\n    Assert.assertEquals((Integer) 0, group0Config.getTaskGroupId());\n    Assert.assertEquals((Integer) 1, group1Config.getTaskGroupId());\n    Assert.assertEquals(group0ExpectedStartSequenceNumbers, group0Config.getStartSequenceNumbers());\n    Assert.assertEquals(group0ExpectedEndSequenceNumbers, group0Config.getEndSequenceNumbers());\n    Assert.assertEquals(group1ExpectedStartSequenceNumbers, group1Config.getStartSequenceNumbers());\n    Assert.assertEquals(group1ExpectedEndSequenceNumbers, group1Config.getEndSequenceNumbers());\n\n    Map<Integer, Set<String>> expectedPartitionGroups = ImmutableMap.of(\n        0, ImmutableSet.of(SHARD_ID1),\n        1, ImmutableSet.of(SHARD_ID2)\n    );\n    Assert.assertEquals(expectedPartitionGroups, supervisor.getPartitionGroups());\n\n    ConcurrentHashMap<String, String> expectedPartitionOffsets = new ConcurrentHashMap<>(\n        ImmutableMap.of(\n            SHARD_ID2, \"-1\",\n            SHARD_ID1, \"-1\",\n            SHARD_ID0, \"-1\"\n        )\n    );\n    Assert.assertEquals(expectedPartitionOffsets, supervisor.getPartitionOffsets());\n\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/supervisor/KinesisSupervisorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":4075,"status":"M"}],"commitId":"2c384b61ff47f858a0adb6f8b389c84f2acc84d1","commitMessage":"@@@IntelliJ inspection and checkstyle rule for \"Collection.EMPTY_* field accesses replaceable with Collections.empty*()\" (#9690)\n\n* IntelliJ inspection and checkstyle rule for \"Collection.EMPTY_* field accesses replaceable with Collections.empty*()\"\n\n* Reverted checkstyle rule\n\n* Added tests to pass CI\n\n* Codestyle","date":"2020-06-19 00:47:07","modifiedFileCount":"33","status":"M","submitter":"Aleksey Plekhanov"}]
