[{"authorTime":"2018-12-22 03:49:24","codes":[{"authorDate":"2019-03-15 15:22:43","commitOrder":2,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-03-15 15:22:42","endLine":1142,"groupId":"5726","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/43/9584fd76d82dc14d56362f6ca7d928059f7e31.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1083,"status":"B"},{"authorDate":"2018-12-22 03:49:24","commitOrder":2,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"9\"\n            )),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2018-12-22 03:49:24","endLine":1534,"groupId":"14312","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ce/f97955db2e8ceaae814ce65540385404536749.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"9\"\n            )),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1448,"status":"NB"}],"commitId":"a8c7132482358e9d8113632b38e284a84b66c6db","commitMessage":"@@@Logic adjustments to SeekableStreamIndexTaskRunner. (#7267)\n\n* Logic adjustments to SeekableStreamIndexTaskRunner.\n\nA mix of simplifications and bug fixes. They are intermingled because\nsome of the bugs were made difficult to fix.  and also more likely to\nhappen in the first place.  by how the code was structured. I tried to\nkeep restructuring to a minimum. The changes are:\n\n- Remove \"initialOffsetsSnapshot\".  which was used to determine when to\n  skip start offsets. Replace it with \"lastReadOffsets\".  which I hope\n  is more intuitive. (There is a connection: start offsets must be\n  skipped if and only if they have already been read.  either by a\n  previous task or by a previous sequence in the same task.  post-restoring.)\n- Remove \"isStartingSequenceOffsetsExclusive\".  because it should always\n  be the opposite of isEndOffsetExclusive. The reason is that starts are\n  exclusive exactly when the prior ends are inclusive: they must match\n  up in that way for adjacent reads to link up properly.\n- Don't call \"seekToStartingSequence\" after the initial seek. There is\n  no reason to.  since we expect to read continuous message streams\n  throughout the task. And calling it makes offset-tracking logic\n  trickier.  so better to avoid the need for trickiness. I believe the\n  call being here was causing a bug in Kinesis ingestion where a\n  message might get double-read.\n- Remove the \"continue\" calls in the main read loop. They are bad\n  because they prevent keeping currOffsets and lastReadOffsets up to\n  date.  and prevent us from detecting that we have finished reading.\n- Rework \"verifyInitialRecordAndSkipExclusivePartition\" into\n  \"verifyRecordInRange\". It no longer has side effects. It does a sanity\n  check on the message offset and also makes sure that it is not past\n  the endOffsets.\n- Rework \"assignPartitions\" to replace inline comparisons with\n  \"isRecordAlreadyRead\" and \"isMoreToReadBeforeReadingRecord\" calls. I\n  believe this fixes an off-by-one error with Kinesis where the last\n  record would not get read. It also makes the logic easier to read.\n- When doing the final publish.  only adjust end offsets of the final\n  sequence.  rather than potentially adjusting any unpublished sequence.\n  Adjusting sequences other than the last one is a mistake since it\n  will extend their endOffsets beyond what they actually read. (I'm not\n  sure if this was an issue in practice.  since I'm not sure if real\n  world situations would have more than one unpublished sequence.)\n- Rename \"isEndSequenceOffsetsExclusive\" to \"isEndOffsetExclusive\". It's\n  shorter and more clear.  I think.\n- Add equals/hashCode/toString methods to OrderedSequenceNumber.\n\nKafka test changes:\n\n- Added a Kafka \"testRestoreAtEndOffset\" test to verify that restores at\n  the very end of the task lifecycle still work properly.\n\nKinesis test changes:\n\n- Renamed \"testRunOnNothing\" to \"testRunOnSingletonRange\". I think that\n  given Kinesis semantics.  the right behavior when start offset equals\n  end offset (and there aren't exclusive partitions set) is to read that\n  single offset. This is because they are both meant to be treated as\n  inclusive.\n- Adjusted \"testRestoreAfterPersistingSequences\" to expect one more\n  message read. I believe the old test was wrong; it expected the task\n  not to read message number 5.\n- Adjusted \"testRunContextSequenceAheadOfStartingOffsets\" to use a\n  checkpoint starting from 1 rather than 2. I believe the old test was\n  wrong here too; it was expecting the task to start reading from the\n  checkpointed offset.  but it actually should have started reading from\n  one past the checkpointed offset.\n- Adjusted \"testIncrementalHandOffReadsThroughEndOffsets\" to expect\n  11 messages read instead of 12. It's starting at message 0 and reading\n  up to 10.  which should be 11 messages.\n\n* Changes from code review.\n","date":"2019-03-15 15:22:42","modifiedFileCount":"8","status":"M","submitter":"Gian Merlino"},{"authorTime":"2019-03-22 04:12:22","codes":[{"authorDate":"2019-03-22 04:12:22","commitOrder":3,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-03-22 04:12:22","endLine":1045,"groupId":"1399","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/43/5bb2abf8e4aa9a5b48367bb0a0c33d66fdd44b.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":993,"status":"M"},{"authorDate":"2019-03-22 04:12:22","commitOrder":3,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-03-22 04:12:22","endLine":1423,"groupId":"14312","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/43/5bb2abf8e4aa9a5b48367bb0a0c33d66fdd44b.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"2\"\n            )),\n            new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n                shardId1,\n                \"9\"\n            )),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1344,"status":"M"}],"commitId":"0c5dcf5586e33607849e397209f3eb0b10661f1e","commitMessage":"@@@Fix exclusivity for start offset in kinesis indexing service & check exclusivity properly in IndexerSQLMetadataStorageCoordinator (#7291)\n\n* Fix exclusivity for start offset in kinesis indexing service\n\n* some adjustment\n\n* Fix SeekableStreamDataSourceMetadata\n\n* Add missing javadocs\n\n* Add missing comments and unit test\n\n* fix SeekableStreamStartSequenceNumbers.plus and add comments\n\n* remove extra exclusivePartitions in KafkaIOConfig and fix downgrade issue\n\n* Add javadocs\n\n* fix compilation\n\n* fix test\n\n* remove unused variable\n","date":"2019-03-22 04:12:22","modifiedFileCount":"30","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-04-09 10:19:34","codes":[{"authorDate":"2019-04-09 10:19:34","commitOrder":4,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-04-09 10:19:34","endLine":1048,"groupId":"3721","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/96/9cc399636844b4dc771e9dcb171336b8b71c50.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":996,"status":"M"},{"authorDate":"2019-04-09 10:19:34","commitOrder":4,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-04-09 10:19:34","endLine":1426,"groupId":"14312","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/96/9cc399636844b4dc771e9dcb171336b8b71c50.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1347,"status":"M"}],"commitId":"e87d6e32b3b3f56441a6bdef4974e9c24ffcbf47","commitMessage":"@@@Support kinesis compatibility (#7351)\n\n","date":"2019-04-09 10:19:34","modifiedFileCount":"5","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-05-07 03:28:56","codes":[{"authorDate":"2019-04-09 10:19:34","commitOrder":5,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-04-09 10:19:34","endLine":1048,"groupId":"3721","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/96/9cc399636844b4dc771e9dcb171336b8b71c50.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":996,"status":"N"},{"authorDate":"2019-05-07 03:28:56","commitOrder":5,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-05-07 03:28:56","endLine":1431,"groupId":"14312","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a0/4556d6abf014cb8df7c63deac4cc88526b481d.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1350,"status":"M"}],"commitId":"f7bfe8f2697277f4216d90607d01bfd26e813ab3","commitMessage":"@@@Update mocking libraries for Java 11 support (#7596)\n\n* update easymock / powermock for to 4.0.2 / 2.0.2 for JDK11 support\n* update tests to use new easymock interfaces\n* fix tests failing due to easymock fixes\n* remove dependency on jmockit\n* fix race condition in ResourcePoolTest","date":"2019-05-07 03:28:56","modifiedFileCount":"7","status":"M","submitter":"Xavier L?aut?"},{"authorTime":"2019-07-07 00:33:12","codes":[{"authorDate":"2019-07-07 00:33:12","commitOrder":6,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-07-07 00:33:12","endLine":1047,"groupId":"12014","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/bf83ce2a3969f1243df5bd1dad6429b383e83e.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":995,"status":"M"},{"authorDate":"2019-07-07 00:33:12","commitOrder":6,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-07-07 00:33:12","endLine":1430,"groupId":"14312","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/bf83ce2a3969f1243df5bd1dad6429b383e83e.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1349,"status":"M"}],"commitId":"1166bbcb75d432817715fdd429737f86730b5591","commitMessage":"@@@Remove static imports from tests (#8036)\n\nMake static imports forbidden in tests and remove all occurrences to be\nconsistent with the non-test code.\n\nAlso.  various changes to files affected by above:\n- Reformat to adhere to druid style guide\n- Fix various IntelliJ warnings\n- Fix various SonarLint warnings (e.g..  the expected/actual args to\n  Assert.assertEquals() were flipped)","date":"2019-07-07 00:33:12","modifiedFileCount":"98","status":"M","submitter":"Chi Cao Minh"},{"authorTime":"2019-07-25 08:35:46","codes":[{"authorDate":"2019-07-25 08:35:46","commitOrder":7,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-07-25 08:35:46","endLine":1077,"groupId":"12014","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/00/6677b0a28185be95d0eb677acfab7ede656120.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(sd(task, \"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1025,"status":"M"},{"authorDate":"2019-07-25 08:35:46","commitOrder":7,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-07-25 08:35:46","endLine":1462,"groupId":"14312","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/00/6677b0a28185be95d0eb677acfab7ede656120.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableSet.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1381,"status":"M"}],"commitId":"db149462073d59e7563f0d3834e69d44a2bb4011","commitMessage":"@@@Add support minor compaction with segment locking (#7547)\n\n* Segment locking\n\n* Allow both timeChunk and segment lock in the same gruop\n\n* fix it test\n\n* Fix adding same chunk to atomicUpdateGroup\n\n* resolving todos\n\n* Fix segments to lock\n\n* fix segments to lock\n\n* fix kill task\n\n* resolving todos\n\n* resolving todos\n\n* fix teamcity\n\n* remove unused class\n\n* fix single map\n\n* resolving todos\n\n* fix build\n\n* fix SQLMetadataSegmentManager\n\n* fix findInputSegments\n\n* adding more tests\n\n* fixing task lock checks\n\n* add SegmentTransactionalOverwriteAction\n\n* changing publisher\n\n* fixing something\n\n* fix for perfect rollup\n\n* fix test\n\n* adjust package-lock.json\n\n* fix test\n\n* fix style\n\n* adding javadocs\n\n* remove unused classes\n\n* add more javadocs\n\n* unused import\n\n* fix test\n\n* fix test\n\n* Support forceTimeChunk context and force timeChunk lock for parallel index task if intervals are missing\n\n* fix travis\n\n* fix travis\n\n* unused import\n\n* spotbug\n\n* revert getMaxVersion\n\n* address comments\n\n* fix tc\n\n* add missing error handling\n\n* fix backward compatibility\n\n* unused import\n\n* Fix perf of versionedIntervalTimeline\n\n* fix timeline\n\n* fix tc\n\n* remove remaining todos\n\n* add comment for parallel index\n\n* fix javadoc and typos\n\n* typo\n\n* address comments\n","date":"2019-07-25 08:35:46","modifiedFileCount":"130","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-07-25 08:35:46","codes":[{"authorDate":"2019-11-07 03:07:04","commitOrder":8,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-11-07 03:07:04","endLine":966,"groupId":"12014","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/27/4549891b92c24291334168d8161d2a1bfc90f5.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":914,"status":"M"},{"authorDate":"2019-07-25 08:35:46","commitOrder":8,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-07-25 08:35:46","endLine":1462,"groupId":"14312","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/00/6677b0a28185be95d0eb677acfab7ede656120.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1381,"status":"N"}],"commitId":"5c0fc0a13ab4d259b430bf50b322f631504c4529","commitMessage":"@@@Fix ambiguity about IndexerSQLMetadataStorageCoordinator.getUsedSegmentsForInterval() returning only non-overshadowed or all used segments (#8564)\n\n* IndexerSQLMetadataStorageCoordinator.getTimelineForIntervalsWithHandle() don't fetch abutting intervals; simplify getUsedSegmentsForIntervals()\n\n* Add VersionedIntervalTimeline.findNonOvershadowedObjectsInInterval() method; Propagate the decision about whether only visible segmetns or visible and overshadowed segments should be returned from IndexerMetadataStorageCoordinator's methods to the user logic; Rename SegmentListUsedAction to RetrieveUsedSegmentsAction.  SegmetnListUnusedAction to RetrieveUnusedSegmentsAction.  and UsedSegmentLister to UsedSegmentsRetriever\n\n* Fix tests\n\n* More fixes\n\n* Add javadoc notes about returning Collection instead of Set. Add JacksonUtils.readValue() to reduce boilerplate code\n\n* Fix KinesisIndexTaskTest.  factor out common parts from KinesisIndexTaskTest and KafkaIndexTaskTest into SeekableStreamIndexTaskTestBase\n\n* More test fixes\n\n* More test fixes\n\n* Add a comment to VersionedIntervalTimelineTestBase\n\n* Fix tests\n\n* Set DataSegment.size(0) in more tests\n\n* Specify DataSegment.size(0) in more places in tests\n\n* Fix more tests\n\n* Fix DruidSchemaTest\n\n* Set DataSegment's size in more tests and benchmarks\n\n* Fix HdfsDataSegmentPusherTest\n\n* Doc changes addressing comments\n\n* Extended doc for visibility\n\n* Typo\n\n* Typo 2\n\n* Address comment\n","date":"2019-11-07 03:07:04","modifiedFileCount":"88","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-11-21 06:51:25","codes":[{"authorDate":"2019-11-21 06:51:25","commitOrder":9,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-11-21 06:51:25","endLine":1041,"groupId":"10625","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a3/34a790bdbace996db1007835d408c9c203e38c.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":988,"status":"M"},{"authorDate":"2019-11-21 06:51:25","commitOrder":9,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(NEW_DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2019-11-21 06:51:25","endLine":1428,"groupId":"3035","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a3/34a790bdbace996db1007835d408c9c203e38c.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1346,"status":"M"}],"commitId":"ac6d703814ccb5b258c586b63e0bc33d669e0f57","commitMessage":"@@@Support inputFormat and inputSource for sampler (#8901)\n\n* Support inputFormat and inputSource for sampler\n\n* Cleanup javadocs and names\n\n* fix style\n\n* fix timed shutoff input source reader\n\n* fix timed shutoff input source reader again\n\n* tidy up timed shutoff reader\n\n* unused imports\n\n* fix tc\n","date":"2019-11-21 06:51:25","modifiedFileCount":"66","status":"M","submitter":"Jihoon Son"},{"authorTime":"2020-01-28 03:24:29","codes":[{"authorDate":"2019-11-21 06:51:25","commitOrder":10,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2019-11-21 06:51:25","endLine":1041,"groupId":"10625","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a3/34a790bdbace996db1007835d408c9c203e38c.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":988,"status":"N"},{"authorDate":"2020-01-28 03:24:29","commitOrder":10,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(newDataSchemaMetadata());\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2020-01-28 03:24:29","endLine":1431,"groupId":"3035","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/78/67522a54ebcfbe41346f09fcd327a4d81923d3.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(metadataStorageCoordinator.getDataSourceMetadata(NEW_DATA_SCHEMA.getDataSource()));\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1349,"status":"M"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"M","submitter":"Roman Leventov"},{"authorTime":"2021-01-09 08:04:37","codes":[{"authorDate":"2021-01-09 08:04:37","commitOrder":11,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2021-01-09 08:04:37","endLine":1056,"groupId":"10625","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/37/d699a39eb40765e6e0d5b39c1e64d358746164.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1003,"status":"M"},{"authorDate":"2021-01-09 08:04:37","commitOrder":11,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(newDataSchemaMetadata());\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2021-01-09 08:04:37","endLine":1443,"groupId":"3035","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/37/d699a39eb40765e6e0d5b39c1e64d358746164.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(newDataSchemaMetadata());\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"M"}],"commitId":"118b50195e5c2989e04e0f5290aa72cae114db39","commitMessage":"@@@Introduce KafkaRecordEntity to support Kafka headers in InputFormats (#10730)\n\nToday Kafka message support in streaming indexing tasks is limited to\nmessage values.  and does not provide a way to expose Kafka headers. \ntimestamps.  or keys.  which may be of interest to more specialized\nDruid input formats. For instance.  Kafka headers may be used to indicate\npayload format/encoding or additional metadata.  and timestamps are often\nomitted from values in Kafka streams applications.  since they are\nincluded in the record.\n\nThis change proposes to introduce KafkaRecordEntity as InputEntity. \nwhich would give input formats full access to the underlying Kafka record. \nincluding headers.  key.  timestamps. It would also open access to low-level\ninformation such as topic.  partition.  offset if needed.\n\nKafkaEntity is a subclass of ByteEntity for backwards compatibility with\nexisting input formats.  and to avoid introducing unnecessary complexity\nfor Kinesis indexing tasks.","date":"2021-01-09 08:04:37","modifiedFileCount":"30","status":"M","submitter":"Xavier L?aut?"},{"authorTime":"2021-03-10 04:11:58","codes":[{"authorDate":"2021-01-09 08:04:37","commitOrder":12,"curCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","date":"2021-01-09 08:04:37","endLine":1056,"groupId":"102353","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testRunOnSingletonRange","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/37/d699a39eb40765e6e0d5b39c1e64d358746164.src","preCode":"  public void testRunOnSingletonRange() throws Exception\n  {\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(2, 3)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    \r\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    \r\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    \r\n    Assert.assertEquals(1, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(ImmutableList.of(sdd(\"2010/P1D\", 0)), publishedDescriptors());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1003,"status":"N"},{"authorDate":"2021-03-10 04:11:58","commitOrder":12,"curCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(newDataSchemaMetadata());\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse [] as the intermediateRow resulted in empty input row\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","date":"2021-03-10 04:11:58","endLine":1443,"groupId":"102353","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testMultipleParseExceptionsFailure","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/74/5375d96ba21727e83da99bb27d40c8d0c8a4dc.src","preCode":"  public void testMultipleParseExceptionsFailure() throws Exception\n  {\n    reportParseExceptions = false;\n    maxParseExceptions = 2;\n    maxSavedParseExceptions = 2;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(2, 13)).once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            \"sequence0\",\n            new SeekableStreamStartSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"2\"), ImmutableSet.of()),\n            new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"9\")),\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n\n    TaskStatus status = future.get();\n\n    \r\n    Assert.assertEquals(TaskState.FAILED, status.getStatusCode());\n    verifyAll();\n    IndexTaskTest.checkTaskStatusErrorMsgForParseExceptionsExceeded(status);\n\n    \r\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getProcessedWithError());\n    Assert.assertEquals(3, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    Assert.assertEquals(ImmutableList.of(), publishedDescriptors());\n    Assert.assertNull(newDataSchemaMetadata());\n\n    IngestionStatsAndErrorsTaskReportData reportData = getTaskReportData();\n\n    Map<String, Object> expectedMetrics = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        ImmutableMap.of(\n            RowIngestionMeters.PROCESSED, 3,\n            RowIngestionMeters.PROCESSED_WITH_ERROR, 0,\n            RowIngestionMeters.UNPARSEABLE, 3,\n            RowIngestionMeters.THROWN_AWAY, 0\n        )\n    );\n    Assert.assertEquals(expectedMetrics, reportData.getRowStats());\n\n    Map<String, Object> unparseableEvents = ImmutableMap.of(\n        RowIngestionMeters.BUILD_SEGMENTS,\n        Arrays.asList(\n            \"Unable to parse row [unparseable2]\",\n            \"Unable to parse row [unparseable]\"\n        )\n    );\n\n    Assert.assertEquals(unparseableEvents, reportData.getUnparseableEvents());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"M"}],"commitId":"4dd22a850b2e5acc8d9732513303fe6e3560d3d0","commitMessage":"@@@Fix streaming ingestion fails if it encounters empty rows (Regression) (#10962)\n\n* Fix streaming ingestion fails and halt if it  encounters empty rows\n\n* address comments","date":"2021-03-10 04:11:58","modifiedFileCount":"4","status":"M","submitter":"Maytas Monsereenusorn"}]
