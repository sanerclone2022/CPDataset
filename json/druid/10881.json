[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = Lists.newArrayList();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<String> segmentIds = Lists.newArrayList();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults((TimeseriesQuery) capture.getValue().getQuery(), segmentIds, queryIntervals, results);\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":1918,"groupId":"18241","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4a/6dfd0a7ba50835713564aebc5ab8650ac4b7a1.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = Lists.newArrayList();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<String> segmentIds = Lists.newArrayList();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults((TimeseriesQuery) capture.getValue().getQuery(), segmentIds, queryIntervals, results);\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1816,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = Lists.newArrayList();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = Lists.newArrayList();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TimeseriesResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TopNResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<SearchResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<SelectResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Row>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = Lists.newArrayList();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":2154,"groupId":"17064","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4a/6dfd0a7ba50835713564aebc5ab8650ac4b7a1.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = Lists.newArrayList();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = Lists.newArrayList();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TimeseriesResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TopNResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<SearchResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<SelectResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Row>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = Lists.newArrayList();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1954,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-10-29 20:02:43","codes":[{"authorDate":"2018-10-29 20:02:43","commitOrder":2,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<String> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults((TimeseriesQuery) capture.getValue().getQuery(), segmentIds, queryIntervals, results);\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2018-10-29 20:02:43","endLine":1937,"groupId":"6107","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d5/bd504191a623447e6f85270523a40d18046616.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = Lists.newArrayList();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<String> segmentIds = Lists.newArrayList();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults((TimeseriesQuery) capture.getValue().getQuery(), segmentIds, queryIntervals, results);\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1835,"status":"M"},{"authorDate":"2018-10-29 20:02:43","commitOrder":2,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2018-10-29 20:02:43","endLine":2173,"groupId":"11384","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d5/bd504191a623447e6f85270523a40d18046616.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = Lists.newArrayList();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = Lists.newArrayList();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TimeseriesResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TopNResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<SearchResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<SelectResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Row>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<String> segmentIds = Lists.newArrayList();\n          List<Interval> intervals = Lists.newArrayList();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = Lists.newArrayList();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = Lists.newArrayList();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1973,"status":"M"}],"commitId":"676f5e6d7f184101b8763e4249b18b237bbe0ec7","commitMessage":"@@@Prohibit some guava collection APIs and use JDK collection APIs directly (#6511)\n\n* Prohibit some guava collection APIs and use JDK APIs directly\n\n* reset files that changed by accident\n\n* sort codestyle/druid-forbidden-apis.txt alphabetically\n","date":"2018-10-29 20:02:43","modifiedFileCount":"427","status":"M","submitter":"QiuMM"},{"authorTime":"2019-01-22 03:11:10","codes":[{"authorDate":"2019-01-22 03:11:10","commitOrder":3,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-01-22 03:11:10","endLine":1946,"groupId":"6107","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/2e/ff321d78f0b77d3a59870997b3301e4087300b.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<String> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1839,"status":"M"},{"authorDate":"2019-01-22 03:11:10","commitOrder":3,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2019-01-22 03:11:10","endLine":2185,"groupId":"16752","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/2e/ff321d78f0b77d3a59870997b3301e4087300b.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<String> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1985,"status":"M"}],"commitId":"8eae26fd4e7572060d112864dd3d5f6a865b9c89","commitMessage":"@@@Introduce SegmentId class (#6370)\n\n* Introduce SegmentId class\n\n* tmp\n\n* Fix SelectQueryRunnerTest\n\n* Fix indentation\n\n* Fixes\n\n* Remove Comparators.inverse() tests\n\n* Refinements\n\n* Fix tests\n\n* Fix more tests\n\n* Remove duplicate DataSegmentTest.  fixes #6064\n\n* SegmentDescriptor doc\n\n* Fix SQLMetadataStorageUpdaterJobHandler\n\n* Fix DataSegment deserialization for ignoring id\n\n* Add comments\n\n* More comments\n\n* Address more comments\n\n* Fix compilation\n\n* Restore segment2 in SystemSchemaTest according to a comment\n\n* Fix style\n\n* fix testServerSegmentsTable\n\n* Fix compilation\n\n* Add comments about why SegmentId and SegmentIdWithShardSpec are separate classes\n\n* Fix SystemSchemaTest\n\n* Fix style\n\n* Compare SegmentDescriptor with SegmentId in Javadoc and comments rather than with DataSegment\n\n* Remove a link.  see https://youtrack.jetbrains.com/issue/IDEA-205164\n\n* Fix compilation\n","date":"2019-01-22 03:11:10","modifiedFileCount":"308","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-05-07 03:28:56","codes":[{"authorDate":"2019-05-07 03:28:56","commitOrder":4,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends Map> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-05-07 03:28:56","endLine":1945,"groupId":"3165","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/59/367c6571646c52cc0e25d01c7e08facc8c1c76.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1838,"status":"M"},{"authorDate":"2019-05-07 03:28:56","commitOrder":4,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends Map> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2019-05-07 03:28:56","endLine":2184,"groupId":"16752","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/59/367c6571646c52cc0e25d01c7e08facc8c1c76.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = new Capture();\n        final Capture<? extends Map> context = new Capture();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1984,"status":"M"}],"commitId":"f7bfe8f2697277f4216d90607d01bfd26e813ab3","commitMessage":"@@@Update mocking libraries for Java 11 support (#7596)\n\n* update easymock / powermock for to 4.0.2 / 2.0.2 for JDK11 support\n* update tests to use new easymock interfaces\n* fix tests failing due to easymock fixes\n* remove dependency on jmockit\n* fix race condition in ResourcePoolTest","date":"2019-05-07 03:28:56","modifiedFileCount":"7","status":"M","submitter":"Xavier L?aut?"},{"authorTime":"2019-07-24 23:29:03","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":5,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-07-24 23:29:03","endLine":1931,"groupId":"3165","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/9b49f4678c068e8f186b7e52c88926a999f50a.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends Map> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, Object> context = new HashMap<>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1826,"status":"M"},{"authorDate":"2019-07-24 23:29:03","commitOrder":5,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2019-07-24 23:29:03","endLine":2168,"groupId":"16752","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/9b49f4678c068e8f186b7e52c88926a999f50a.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends Map> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              HashMap<String, List> context = new HashMap<String, List>();\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        context\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1970,"status":"M"}],"commitId":"799d20249fe6333ea86b020f6d09c91fa4d3f998","commitMessage":"@@@Response context refactoring (#8110)\n\n* Response context refactoring\n\n* Serialization/Deserialization of ResponseContext\n\n* Added java doc comments\n\n* Renamed vars related to ResponseContext\n\n* Renamed empty() methods to createEmpty()\n\n* Fixed ResponseContext usage\n\n* Renamed multiple ResponseContext static fields\n\n* Added PublicApi annotations\n\n* Renamed QueryResponseContext class to ResourceIOReaderWriter\n\n* Moved the protected method below public static constants\n\n* Added createEmpty method to ResponseContext with DefaultResponseContext creation\n\n* Fixed inspection error\n\n* Added comments to the ResponseContext length limit and ResponseContext\nhttp header name\n\n* Added a comment of possible future refactoring\n\n* Removed .gitignore file of indexing-service\n\n* Removed a never-used method\n\n* VisibleForTesting method reducing boilerplate\n\nCo-Authored-By: Clint Wylie <cjwylie@gmail.com>\n\n* Reduced boilerplate\n\n* Renamed the method serialize to serializeWith\n\n* Removed unused import\n\n* Fixed incorrectly refactored test method\n\n* Added comments for ResponseContext keys\n\n* Fixed incorrectly refactored test method\n\n* Fixed IntervalChunkingQueryRunnerTest mocks\n","date":"2019-07-24 23:29:03","modifiedFileCount":"142","status":"M","submitter":"Eugene Sevastianov"},{"authorTime":"2019-08-01 07:15:12","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":6,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-07-24 23:29:03","endLine":1931,"groupId":"3165","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/9b49f4678c068e8f186b7e52c88926a999f50a.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1826,"status":"N"},{"authorDate":"2019-08-01 07:15:12","commitOrder":6,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2019-08-01 07:15:12","endLine":2178,"groupId":"7573","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/60/944fd96720e6c16dae1641163dcc433b33def9.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Row>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable<>(\n                        Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1978,"status":"M"}],"commitId":"77297f4e6f2e9d617c96cd46852bb5a772961e85","commitMessage":"@@@GroupBy array-based result rows. (#8196)\n\n* GroupBy array-based result rows.\n\nFixes #8118; see that proposal for details.\n\nOther than the GroupBy changes.  the main other \"interesting\" classes are:\n\n- ResultRow: The array-based result type.\n- BaseQuery: T is no longer required to be Comparable.\n- QueryToolChest: Adds \"decorateObjectMapper\" to enable query-aware serialization\n  and deserialization of result rows (necessary due to their positional nature).\n- QueryResource: Uses the new decoration functionality.\n- DirectDruidClient: Also uses the new decoration functionality.\n- QueryMaker (in Druid SQL): Modifications to read ResultRows.\n\nThese classes weren't changed.  but got some new javadocs:\n\n- BySegmentQueryRunner\n- FinalizeResultsQueryRunner\n- Query\n\n* Adjustments for TC stuff.\n","date":"2019-08-01 07:15:12","modifiedFileCount":"111","status":"M","submitter":"Gian Merlino"},{"authorTime":"2019-10-31 10:29:56","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":7,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-07-24 23:29:03","endLine":1931,"groupId":"3165","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/9b49f4678c068e8f186b7e52c88926a999f50a.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1826,"status":"N"},{"authorDate":"2019-10-31 10:29:56","commitOrder":7,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2019-10-31 10:29:56","endLine":1977,"groupId":"22095","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/24/279508491796e08c34b91993660a389712d759.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SelectQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SelectResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSelectResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1789,"status":"M"}],"commitId":"3ff5e0223752e0a10942bcf64a421b0f147e7d06","commitMessage":"@@@remove select query (#8739)\n\n* remove select query\n\n* thanks teamcity\n\n* oops\n\n* oops\n\n* add back a SelectQuery class that throws RuntimeExceptions linking to docs\n\n* adjust text\n\n* update docs per review\n\n* deprecated\n","date":"2019-10-31 10:29:56","modifiedFileCount":"22","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-07-02 05:02:21","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":8,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-07-24 23:29:03","endLine":1931,"groupId":"3165","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/9b49f4678c068e8f186b7e52c88926a999f50a.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1826,"status":"N"},{"authorDate":"2020-07-02 05:02:21","commitOrder":8,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        initializeResponseContext()\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2020-07-02 05:02:21","endLine":1967,"groupId":"22095","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/45/2dd8cadd6b4c232ab41fc0990812d7c3f25a27.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1779,"status":"M"}],"commitId":"657f8ee80fa86779cf26a01072814b1530277aa7","commitMessage":"@@@Fix RetryQueryRunner to actually do the job (#10082)\n\n* Fix RetryQueryRunner to actually do the job\n\n* more javadoc\n\n* fix test and checkstyle\n\n* don't combine for testing\n\n* address comments\n\n* fix unit tests\n\n* always initialize response context in cachingClusteredClient\n\n* fix subquery\n\n* address comments\n\n* fix test\n\n* query id for builders\n\n* make queryId optional in the builders and ClusterQueryResult\n\n* fix test\n\n* suppress tests and unused methods\n\n* exclude groupBy builder\n\n* fix jacoco exclusion\n\n* add tests for builders\n\n* address comments\n\n* don't truncate","date":"2020-07-02 05:02:21","modifiedFileCount":"33","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-06-12 04:49:03","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":9,"curCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","date":"2019-07-24 23:29:03","endLine":1931,"groupId":"10881","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCachingWithFilter","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@finalQueryquery@finalList<Iterable<Result<TimeseriesResultValue>>>filteredExpected@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/9b49f4678c068e8f186b7e52c88926a999f50a.src","preCode":"  public void testQueryCachingWithFilter(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      final Query query,\n      final List<Iterable<Result<TimeseriesResultValue>>> filteredExpected,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .times(0, 1);\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          final List<SegmentId> segmentIds = new ArrayList<>();\n          final List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andAnswer(new IAnswer<Sequence>()\n                  {\n                    @Override\n                    public Sequence answer()\n                    {\n                      return toFilteredQueryableTimeseriesResults(\n                          (TimeseriesQuery) capture.getValue().getQuery(),\n                          segmentIds,\n                          queryIntervals,\n                          results\n                      );\n                    }\n                  })\n                  .times(0, 1);\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final Iterable<Result<Object>> expected = new ArrayList<>();\n      for (int intervalNo = 0; intervalNo < i + 1; intervalNo++) {\n        Iterables.addAll((List) expected, filteredExpected.get(intervalNo));\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    expected,\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(\n                                    ImmutableList.of(\n                                        actualQueryInterval\n                                    )\n                                )\n                            )\n                        )\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1826,"status":"N"},{"authorDate":"2021-06-12 04:49:03","commitOrder":9,"curCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        initializeResponseContext()\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(QueryContexts.BY_SEGMENT_KEY));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(QueryContexts.BY_SEGMENT_KEY) == null ||\n              capturedQuery.getContextValue(QueryContexts.BY_SEGMENT_KEY).equals(false)\n          );\n        }\n      }\n    }\n  }\n","date":"2021-06-12 04:49:03","endLine":2311,"groupId":"10881","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryCaching","params":"(finalQueryRunnerrunner@finalintnumTimesToQuery@booleanexpectBySegment@finalQueryquery@Object...args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cd/a0170d5f0aa52c89d97e6db0681b7c7bce2bfc.src","preCode":"  public void testQueryCaching(\n      final QueryRunner runner,\n      final int numTimesToQuery,\n      boolean expectBySegment,\n      final Query query,\n      Object... args \r\n  )\n  {\n    final List<Interval> queryIntervals = Lists.newArrayListWithCapacity(args.length / 2);\n    final List<List<Iterable<Result<Object>>>> expectedResults = Lists.newArrayListWithCapacity(queryIntervals.size());\n\n    parseResults(queryIntervals, expectedResults, args);\n\n    for (int i = 0; i < queryIntervals.size(); ++i) {\n      List<Object> mocks = new ArrayList<>();\n      mocks.add(serverView);\n\n      final Interval actualQueryInterval = new Interval(\n          queryIntervals.get(0).getStart(), queryIntervals.get(i).getEnd()\n      );\n\n      final List<Map<DruidServer, ServerExpectations>> serverExpectationList = populateTimeline(\n          queryIntervals,\n          expectedResults,\n          i,\n          mocks\n      );\n\n      List<Capture> queryCaptures = new ArrayList<>();\n      final Map<DruidServer, ServerExpectations> finalExpectation = serverExpectationList.get(\n          serverExpectationList.size() - 1\n      );\n      for (Map.Entry<DruidServer, ServerExpectations> entry : finalExpectation.entrySet()) {\n        DruidServer server = entry.getKey();\n        ServerExpectations expectations = entry.getValue();\n\n\n        EasyMock.expect(serverView.getQueryRunner(server))\n                .andReturn(expectations.getQueryRunner())\n                .once();\n\n        final Capture<? extends QueryPlus> capture = Capture.newInstance();\n        final Capture<? extends ResponseContext> context = Capture.newInstance();\n        queryCaptures.add(capture);\n        QueryRunner queryable = expectations.getQueryRunner();\n\n        if (query instanceof TimeseriesQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeseriesResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeseriesResults(expectBySegment, segmentIds, intervals, results))\n                  .once();\n\n        } else if (query instanceof TopNQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TopNResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTopNResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof SearchQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<SearchResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableSearchResults(segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof GroupByQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<ResultRow>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableGroupByResults((GroupByQuery) query, segmentIds, intervals, results))\n                  .once();\n        } else if (query instanceof TimeBoundaryQuery) {\n          List<SegmentId> segmentIds = new ArrayList<>();\n          List<Interval> intervals = new ArrayList<>();\n          List<Iterable<Result<TimeBoundaryResultValue>>> results = new ArrayList<>();\n          for (ServerExpectation expectation : expectations) {\n            segmentIds.add(expectation.getSegmentId());\n            intervals.add(expectation.getInterval());\n            results.add(expectation.getResults());\n          }\n          EasyMock.expect(queryable.run(EasyMock.capture(capture), EasyMock.capture(context)))\n                  .andReturn(toQueryableTimeBoundaryResults(segmentIds, intervals, results))\n                  .once();\n        } else {\n          throw new ISE(\"Unknown query type[%s]\", query.getClass());\n        }\n      }\n\n      final int expectedResultsRangeStart;\n      final int expectedResultsRangeEnd;\n      if (query instanceof TimeBoundaryQuery) {\n        expectedResultsRangeStart = i;\n        expectedResultsRangeEnd = i + 1;\n      } else {\n        expectedResultsRangeStart = 0;\n        expectedResultsRangeEnd = i + 1;\n      }\n\n      runWithMocks(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              for (int i = 0; i < numTimesToQuery; ++i) {\n                TestHelper.assertExpectedResults(\n                    new MergeIterable(\n                        query instanceof GroupByQuery\n                        ? ((GroupByQuery) query).getResultOrdering()\n                        : Comparators.naturalNullsFirst(),\n                        FunctionalIterable\n                            .create(new RangeIterable(expectedResultsRangeStart, expectedResultsRangeEnd))\n                            .transformCat(\n                                new Function<Integer, Iterable<Iterable<Result<Object>>>>()\n                                {\n                                  @Override\n                                  public Iterable<Iterable<Result<Object>>> apply(@Nullable Integer input)\n                                  {\n                                    List<Iterable<Result<Object>>> retVal = new ArrayList<>();\n\n                                    final Map<DruidServer, ServerExpectations> exps = serverExpectationList.get(input);\n                                    for (ServerExpectations expectations : exps.values()) {\n                                      for (ServerExpectation expectation : expectations) {\n                                        retVal.add(expectation.getResults());\n                                      }\n                                    }\n\n                                    return retVal;\n                                  }\n                                }\n                            )\n                    ),\n                    runner.run(\n                        QueryPlus.wrap(\n                            query.withQuerySegmentSpec(\n                                new MultipleIntervalSegmentSpec(ImmutableList.of(actualQueryInterval))\n                            )\n                        ),\n                        initializeResponseContext()\n                    )\n                );\n                if (queryCompletedCallback != null) {\n                  queryCompletedCallback.run();\n                }\n              }\n            }\n          },\n          mocks.toArray()\n      );\n\n      \r\n      for (Capture queryCapture : queryCaptures) {\n        QueryPlus capturedQueryPlus = (QueryPlus) queryCapture.getValue();\n        Query capturedQuery = capturedQueryPlus.getQuery();\n        if (expectBySegment) {\n          Assert.assertEquals(true, capturedQuery.getContextValue(\"bySegment\"));\n        } else {\n          Assert.assertTrue(\n              capturedQuery.getContextValue(\"bySegment\") == null ||\n              capturedQuery.getContextValue(\"bySegment\").equals(false)\n          );\n        }\n      }\n    }\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2123,"status":"M"}],"commitId":"50327b8f6334f9bb89ab60e262ed47983a7711ee","commitMessage":"@@@ignore bySegment query context for SQL queries (#11352)\n\n* ignore bySegment query context for SQL queries\n\n* revert unintended change","date":"2021-06-12 04:49:03","modifiedFileCount":"9","status":"M","submitter":"Clint Wylie"}]
