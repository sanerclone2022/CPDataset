[{"authorTime":"2019-04-13 10:08:34","codes":[{"authorDate":"2019-04-13 10:08:34","commitOrder":1,"curCode":"  public void testComparisonDescendingCompactedList()\n  {\n    ScanQuery query = Druids.newScanQueryBuilder()\n                            .order(ScanQuery.Order.DESCENDING)\n                            .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                            .dataSource(\"some src\")\n                            .intervals(intervalSpec)\n                            .build();\n\n    ScanResultValueTimestampComparator comparator = new ScanResultValueTimestampComparator(query);\n\n    List<List<Object>> events1 = new ArrayList<>();\n    List<Object> event1 = Collections.singletonList(new Long(42));\n    events1.add(event1);\n\n    ScanResultValue s1 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events1\n    );\n\n    List<List<Object>> events2 = new ArrayList<>();\n    List<Object> event2 = Collections.singletonList(new Long(43));\n    events2.add(event2);\n\n    ScanResultValue s2 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events2\n    );\n\n    Assert.assertEquals(-1, comparator.compare(s1, s2));\n  }\n","date":"2019-04-13 10:08:34","endLine":158,"groupId":"9695","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testComparisonDescendingCompactedList","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/46/5794a28316315d16a2ac2e0b6d16e8dc7f90a5.src","preCode":"  public void testComparisonDescendingCompactedList()\n  {\n    ScanQuery query = Druids.newScanQueryBuilder()\n                            .order(ScanQuery.Order.DESCENDING)\n                            .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                            .dataSource(\"some src\")\n                            .intervals(intervalSpec)\n                            .build();\n\n    ScanResultValueTimestampComparator comparator = new ScanResultValueTimestampComparator(query);\n\n    List<List<Object>> events1 = new ArrayList<>();\n    List<Object> event1 = Collections.singletonList(new Long(42));\n    events1.add(event1);\n\n    ScanResultValue s1 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events1\n    );\n\n    List<List<Object>> events2 = new ArrayList<>();\n    List<Object> event2 = Collections.singletonList(new Long(43));\n    events2.add(event2);\n\n    ScanResultValue s2 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events2\n    );\n\n    Assert.assertEquals(-1, comparator.compare(s1, s2));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/scan/ScanResultValueTimestampComparatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"B"},{"authorDate":"2019-04-13 10:08:34","commitOrder":1,"curCode":"  public void testMergeSequenceForResults()\n  {\n    \r\n    ScanQuery noOrderScan = Druids.newScanQueryBuilder()\n                                  .order(ScanQuery.Order.NONE)\n                                  .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                  .dataSource(\"some src\")\n                                  .intervals(intervalSpec)\n                                  .build();\n\n    \r\n    ScanQuery descendingOrderScan = Druids.newScanQueryBuilder()\n                                          .order(ScanQuery.Order.DESCENDING)\n                                          .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                          .dataSource(\"some src\")\n                                          .intervals(intervalSpec)\n                                          .build();\n\n    \r\n    ScanQuery ascendingOrderScan = Druids.newScanQueryBuilder()\n                                         .order(ScanQuery.Order.ASCENDING)\n                                         .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                         .dataSource(\"some src\")\n                                         .intervals(intervalSpec)\n                                         .build();\n    \r\n    Sequence<ScanResultValue> noOrderSeq =\n        Sequences.simple(\n            ImmutableList.of(\n                Sequences.simple(ImmutableList.of(s1, s3)),\n                Sequences.simple(ImmutableList.of(s2))\n            )\n        ).flatMerge(seq -> seq, noOrderScan.getResultOrdering());\n\n    List<ScanResultValue> noOrderList = noOrderSeq.toList();\n    Assert.assertEquals(3, noOrderList.size());\n\n\n    \r\n    Sequence<ScanResultValue> ascendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, ascendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> ascendingList = ascendingOrderSeq.toList();\n    Assert.assertEquals(2, ascendingList.size());\n    Assert.assertEquals(s1, ascendingList.get(0));\n    Assert.assertEquals(s2, ascendingList.get(1));\n\n    \r\n    Sequence<ScanResultValue> descendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, descendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> descendingList = descendingOrderSeq.toList();\n    Assert.assertEquals(2, descendingList.size());\n    Assert.assertEquals(s2, descendingList.get(0));\n    Assert.assertEquals(s1, descendingList.get(1));\n  }\n","date":"2019-04-13 10:08:34","endLine":250,"groupId":"9695","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMergeSequenceForResults","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/18/54883ca5b95376b13e71acc0e80f2b6ee5f56e.src","preCode":"  public void testMergeSequenceForResults()\n  {\n    \r\n    ScanQuery noOrderScan = Druids.newScanQueryBuilder()\n                                  .order(ScanQuery.Order.NONE)\n                                  .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                  .dataSource(\"some src\")\n                                  .intervals(intervalSpec)\n                                  .build();\n\n    \r\n    ScanQuery descendingOrderScan = Druids.newScanQueryBuilder()\n                                          .order(ScanQuery.Order.DESCENDING)\n                                          .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                          .dataSource(\"some src\")\n                                          .intervals(intervalSpec)\n                                          .build();\n\n    \r\n    ScanQuery ascendingOrderScan = Druids.newScanQueryBuilder()\n                                         .order(ScanQuery.Order.ASCENDING)\n                                         .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                         .dataSource(\"some src\")\n                                         .intervals(intervalSpec)\n                                         .build();\n    \r\n    Sequence<ScanResultValue> noOrderSeq =\n        Sequences.simple(\n            ImmutableList.of(\n                Sequences.simple(ImmutableList.of(s1, s3)),\n                Sequences.simple(ImmutableList.of(s2))\n            )\n        ).flatMerge(seq -> seq, noOrderScan.getResultOrdering());\n\n    List<ScanResultValue> noOrderList = noOrderSeq.toList();\n    Assert.assertEquals(3, noOrderList.size());\n\n\n    \r\n    Sequence<ScanResultValue> ascendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, ascendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> ascendingList = ascendingOrderSeq.toList();\n    Assert.assertEquals(2, ascendingList.size());\n    Assert.assertEquals(s1, ascendingList.get(0));\n    Assert.assertEquals(s2, ascendingList.get(1));\n\n    \r\n    Sequence<ScanResultValue> descendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, descendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> descendingList = descendingOrderSeq.toList();\n    Assert.assertEquals(2, descendingList.size());\n    Assert.assertEquals(s2, descendingList.get(0));\n    Assert.assertEquals(s1, descendingList.get(1));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/scan/ScanQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"B"}],"commitId":"85f10ed0d0df0e040a5448ce8b99a2c972537381","commitMessage":"@@@Support querying realtime segments using time-ordered scan queries and fix broken scan queries without time column (#7454)\n\n* Update scan query runner factory to accept SpecificSegmentSpec\n\n*  nit\n\n* Sorry travis\n\n* Improve logging and fix doc\n\n* Bug fix\n\n* Friendlier error msgs and tests to cover bug\n\n* Address Gian's comments\n\n* Fix doc\n\n* Added tests for empty and null column list\n\n* Style\n\n* Fix checking wrong order (looking at query param when it should be\nlooking at the null-handled order)\n\n* Add test case for null order\n\n* Fix ScanQueryRunnerTest\n\n* Forbidden APIs fixed\n","date":"2019-04-13 10:08:34","modifiedFileCount":"8","status":"B","submitter":"Justin Borromeo"},{"authorTime":"2019-04-13 10:08:34","codes":[{"authorDate":"2020-08-14 05:56:24","commitOrder":2,"curCode":"  public void testComparisonDescendingCompactedList()\n  {\n    ScanQuery query = Druids.newScanQueryBuilder()\n                            .order(ScanQuery.Order.DESCENDING)\n                            .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                            .dataSource(\"some src\")\n                            .intervals(intervalSpec)\n                            .build();\n\n    ScanResultValueTimestampComparator comparator = new ScanResultValueTimestampComparator(query);\n\n    List<List<Object>> events1 = new ArrayList<>();\n    List<Object> event1 = Collections.singletonList(new Long(42));\n    events1.add(event1);\n\n    ScanResultValue s1 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events1\n    );\n\n    List<List<Object>> events2 = new ArrayList<>();\n    List<Object> event2 = Collections.singletonList(new Long(43));\n    events2.add(event2);\n\n    ScanResultValue s2 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events2\n    );\n\n    Assert.assertEquals(1, comparator.compare(s1, s2));\n  }\n","date":"2020-08-14 05:56:24","endLine":158,"groupId":"106676","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testComparisonDescendingCompactedList","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/47/cc4208640215745485825db1b24b1fb56c2963.src","preCode":"  public void testComparisonDescendingCompactedList()\n  {\n    ScanQuery query = Druids.newScanQueryBuilder()\n                            .order(ScanQuery.Order.DESCENDING)\n                            .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                            .dataSource(\"some src\")\n                            .intervals(intervalSpec)\n                            .build();\n\n    ScanResultValueTimestampComparator comparator = new ScanResultValueTimestampComparator(query);\n\n    List<List<Object>> events1 = new ArrayList<>();\n    List<Object> event1 = Collections.singletonList(new Long(42));\n    events1.add(event1);\n\n    ScanResultValue s1 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events1\n    );\n\n    List<List<Object>> events2 = new ArrayList<>();\n    List<Object> event2 = Collections.singletonList(new Long(43));\n    events2.add(event2);\n\n    ScanResultValue s2 = new ScanResultValue(\n        \"segmentId\",\n        Collections.singletonList(ColumnHolder.TIME_COLUMN_NAME),\n        events2\n    );\n\n    Assert.assertEquals(-1, comparator.compare(s1, s2));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/scan/ScanResultValueTimestampComparatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2019-04-13 10:08:34","commitOrder":2,"curCode":"  public void testMergeSequenceForResults()\n  {\n    \r\n    ScanQuery noOrderScan = Druids.newScanQueryBuilder()\n                                  .order(ScanQuery.Order.NONE)\n                                  .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                  .dataSource(\"some src\")\n                                  .intervals(intervalSpec)\n                                  .build();\n\n    \r\n    ScanQuery descendingOrderScan = Druids.newScanQueryBuilder()\n                                          .order(ScanQuery.Order.DESCENDING)\n                                          .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                          .dataSource(\"some src\")\n                                          .intervals(intervalSpec)\n                                          .build();\n\n    \r\n    ScanQuery ascendingOrderScan = Druids.newScanQueryBuilder()\n                                         .order(ScanQuery.Order.ASCENDING)\n                                         .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                         .dataSource(\"some src\")\n                                         .intervals(intervalSpec)\n                                         .build();\n    \r\n    Sequence<ScanResultValue> noOrderSeq =\n        Sequences.simple(\n            ImmutableList.of(\n                Sequences.simple(ImmutableList.of(s1, s3)),\n                Sequences.simple(ImmutableList.of(s2))\n            )\n        ).flatMerge(seq -> seq, noOrderScan.getResultOrdering());\n\n    List<ScanResultValue> noOrderList = noOrderSeq.toList();\n    Assert.assertEquals(3, noOrderList.size());\n\n\n    \r\n    Sequence<ScanResultValue> ascendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, ascendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> ascendingList = ascendingOrderSeq.toList();\n    Assert.assertEquals(2, ascendingList.size());\n    Assert.assertEquals(s1, ascendingList.get(0));\n    Assert.assertEquals(s2, ascendingList.get(1));\n\n    \r\n    Sequence<ScanResultValue> descendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, descendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> descendingList = descendingOrderSeq.toList();\n    Assert.assertEquals(2, descendingList.size());\n    Assert.assertEquals(s2, descendingList.get(0));\n    Assert.assertEquals(s1, descendingList.get(1));\n  }\n","date":"2019-04-13 10:08:34","endLine":250,"groupId":"106676","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMergeSequenceForResults","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/18/54883ca5b95376b13e71acc0e80f2b6ee5f56e.src","preCode":"  public void testMergeSequenceForResults()\n  {\n    \r\n    ScanQuery noOrderScan = Druids.newScanQueryBuilder()\n                                  .order(ScanQuery.Order.NONE)\n                                  .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                  .dataSource(\"some src\")\n                                  .intervals(intervalSpec)\n                                  .build();\n\n    \r\n    ScanQuery descendingOrderScan = Druids.newScanQueryBuilder()\n                                          .order(ScanQuery.Order.DESCENDING)\n                                          .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                          .dataSource(\"some src\")\n                                          .intervals(intervalSpec)\n                                          .build();\n\n    \r\n    ScanQuery ascendingOrderScan = Druids.newScanQueryBuilder()\n                                         .order(ScanQuery.Order.ASCENDING)\n                                         .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_LIST)\n                                         .dataSource(\"some src\")\n                                         .intervals(intervalSpec)\n                                         .build();\n    \r\n    Sequence<ScanResultValue> noOrderSeq =\n        Sequences.simple(\n            ImmutableList.of(\n                Sequences.simple(ImmutableList.of(s1, s3)),\n                Sequences.simple(ImmutableList.of(s2))\n            )\n        ).flatMerge(seq -> seq, noOrderScan.getResultOrdering());\n\n    List<ScanResultValue> noOrderList = noOrderSeq.toList();\n    Assert.assertEquals(3, noOrderList.size());\n\n\n    \r\n    Sequence<ScanResultValue> ascendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, ascendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> ascendingList = ascendingOrderSeq.toList();\n    Assert.assertEquals(2, ascendingList.size());\n    Assert.assertEquals(s1, ascendingList.get(0));\n    Assert.assertEquals(s2, ascendingList.get(1));\n\n    \r\n    Sequence<ScanResultValue> descendingOrderSeq = Sequences.simple(\n        ImmutableList.of(\n            Sequences.simple(ImmutableList.of(s1)),\n            Sequences.simple(ImmutableList.of(s2))\n        )\n    ).flatMerge(seq -> seq, descendingOrderScan.getResultOrdering());\n\n    List<ScanResultValue> descendingList = descendingOrderSeq.toList();\n    Assert.assertEquals(2, descendingList.size());\n    Assert.assertEquals(s2, descendingList.get(0));\n    Assert.assertEquals(s1, descendingList.get(1));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/scan/ScanQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"N"}],"commitId":"6cca7242de629ad07478c6792b01dc1f37dc6b40","commitMessage":"@@@Add \"offset\" parameter to the Scan query. (#10233)\n\n* Add \"offset\" parameter to the Scan query.\n\nIt works by doing the query as normal and then throwing away the first\n\"offset\" number of rows on the broker.\n\n* Fix constructor call.\n\n* Fix up JSONs.\n\n* Fix call to ScanQuery.\n\n* Doc update.\n\n* Fix javadocs.\n\n* Spotbugs.  LGTM suppressions.\n\n* Javadocs.\n\n* Fix suppression.\n\n* Stabilize Scan query result order.  add tests.\n\n* Update LGTM comment.\n\n* Fixup.\n\n* Test different batch sizes too.\n\n* Nicer tests.\n\n* Fix comment.","date":"2020-08-14 05:56:24","modifiedFileCount":"14","status":"M","submitter":"Gian Merlino"}]
