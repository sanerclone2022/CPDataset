[{"authorTime":"2018-12-22 03:49:24","codes":[{"authorDate":"2018-12-22 03:49:24","commitOrder":1,"curCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId0),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId1),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(stream, shardId0);\n    StreamPartition<String> shard1 = StreamPartition.of(stream, shardId1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(poll_timeout_millis)));\n\n    verifyAll();\n  }\n","date":"2018-12-22 03:49:24","endLine":422,"groupId":"22110","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSeekToLatest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/16/6678cb7eb4ef68537767a49abb3f7f54e64803.src","preCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId0),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId1),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(stream, shardId0);\n    StreamPartition<String> shard1 = StreamPartition.of(stream, shardId1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(poll_timeout_millis)));\n\n    verifyAll();\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":366,"status":"B"},{"authorDate":"2018-12-22 03:49:24","commitOrder":1,"curCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId0),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId1),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    expect(getShardIteratorResult0.getShardIterator()).andReturn(shard0Iterator).anyTimes();\n    expect(getShardIteratorResult1.getShardIterator()).andReturn(shard1Iterator).anyTimes();\n    expect(kinesis.getRecords(generateGetRecordsReq(shard0Iterator, recordsPerFetch))).andReturn(getRecordsResult0)\n                                                                                      .anyTimes();\n    expect(kinesis.getRecords(generateGetRecordsReq(shard1Iterator, recordsPerFetch))).andReturn(getRecordsResult1)\n                                                                                      .anyTimes();\n    expect(getRecordsResult0.getRecords()).andReturn(shard0Records).once();\n    expect(getRecordsResult1.getRecords()).andReturn(shard1Records).once();\n    expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(stream, shardId0),\n        StreamPartition.of(stream, shardId1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        poll_timeout_millis));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(allRecords));\n  }\n","date":"2018-12-22 03:49:24","endLine":596,"groupId":"8615","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPollDeaggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/16/6678cb7eb4ef68537767a49abb3f7f54e64803.src","preCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId0),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId1),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    expect(getShardIteratorResult0.getShardIterator()).andReturn(shard0Iterator).anyTimes();\n    expect(getShardIteratorResult1.getShardIterator()).andReturn(shard1Iterator).anyTimes();\n    expect(kinesis.getRecords(generateGetRecordsReq(shard0Iterator, recordsPerFetch))).andReturn(getRecordsResult0)\n                                                                                      .anyTimes();\n    expect(kinesis.getRecords(generateGetRecordsReq(shard1Iterator, recordsPerFetch))).andReturn(getRecordsResult1)\n                                                                                      .anyTimes();\n    expect(getRecordsResult0.getRecords()).andReturn(shard0Records).once();\n    expect(getRecordsResult1.getRecords()).andReturn(shard1Records).once();\n    expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(stream, shardId0),\n        StreamPartition.of(stream, shardId1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        poll_timeout_millis));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(allRecords));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":529,"status":"B"}],"commitId":"7c7997e8a1183a7bffad731ca94e8b4c381e8665","commitMessage":"@@@Add Kinesis Indexing Service to core Druid (#6431)\n\n* created seekablestream classes\n\n* created seekablestreamsupervisor class\n\n* first attempt to integrate kafa indexing service to use SeekableStream\n\n* seekablestream bug fixes\n\n* kafkarecordsupplier\n\n* integrated kafka indexing service with seekablestream\n\n* implemented resume/suspend and refactored some package names\n\n* moved kinesis indexing service into core druid extensions\n\n* merged some changes from kafka supervisor race condition\n\n* integrated kinesis-indexing-service with seekablestream\n\n* unite tests for kinesis-indexing-service\n\n* various bug fixes for kinesis-indexing-service\n\n* refactored kinesisindexingtask\n\n* finished up more kinesis unit tests\n\n* more bug fixes for kinesis-indexing-service\n\n* finsihed refactoring kinesis unit tests\n\n* removed KinesisParititons and KafkaPartitions to use SeekableStreamPartitions\n\n* kinesis-indexing-service code cleanup and docs\n\n* merge #6291\n\nmerge #6337\n\nmerge #6383\n\n* added more docs and reordered methods\n\n* fixd kinesis tests after merging master and added docs in seekablestream\n\n* fix various things from pr comment\n\n* improve recordsupplier and add unit tests\n\n* migrated to aws-java-sdk-kinesis\n\n* merge changes from master\n\n* fix pom files and forbiddenapi checks\n\n* checkpoint JavaType bug fix\n\n* fix pom and stuff\n\n* disable checkpointing in kinesis\n\n* fix kinesis sequence number null in closed shard\n\n* merge changes from master\n\n* fixes for kinesis tasks\n\n* capitalized <partitionType.  sequenceType>\n\n* removed abstract class loggers\n\n* conform to guava api restrictions\n\n* add docker for travis other modules test\n\n* address comments\n\n* improve RecordSupplier to supply records in batch\n\n* fix strict compile issue\n\n* add test scope for localstack dependency\n\n* kinesis indexing task refactoring\n\n* comments\n\n* github comments\n\n* minor fix\n\n* removed unneeded readme\n\n* fix deserialization bug\n\n* fix various bugs\n\n* KinesisRecordSupplier unable to catch up to earliest position in stream bug fix\n\n* minor changes to kinesis\n\n* implement deaggregate for kinesis\n\n* Merge remote-tracking branch 'upstream/master' into seekablestream\n\n* fix kinesis offset discrepancy with kafka\n\n* kinesis record supplier disable getPosition\n\n* pr comments\n\n* mock for kinesis tests and remove docker dependency for unit tests\n\n* PR comments\n\n* avg lag in kafkasupervisor #6587\n\n* refacotred SequenceMetadata in taskRunners\n\n* small fix\n\n* more small fix\n\n* recordsupplier resource leak\n\n* revert .travis.yml formatting\n\n* fix style\n\n* kinesis docs\n\n* doc part2\n\n* more docs\n\n* comments\n\n* comments*2\n\n* revert string replace changes\n\n* comments\n\n* teamcity\n\n* comments part 1\n\n* comments part 2\n\n* comments part 3\n\n* merge #6754\n\n* fix injection binding\n\n* comments\n\n* KinesisRegion refactor\n\n* comments part idk lol\n\n* can't think of a commit msg anymore\n\n* remove possiblyResetDataSourceMetadata() for IncrementalPublishingTaskRunner\n\n* commmmmmmmmmments\n\n* extra error handling in KinesisRecordSupplier getRecords\n\n* comments\n\n* quickfix\n\n* typo\n\n* oof\n","date":"2018-12-22 03:49:24","modifiedFileCount":"22","status":"B","submitter":"Joshua Sun"},{"authorTime":"2019-07-07 00:33:12","codes":[{"authorDate":"2019-07-07 00:33:12","commitOrder":2,"curCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(stream, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(stream, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","date":"2019-07-07 00:33:12","endLine":438,"groupId":"12507","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSeekToLatest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/23/0432a58eb0c33a4affc64e521b19fa8f716f5c.src","preCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId0),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId1),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(stream, shardId0);\n    StreamPartition<String> shard1 = StreamPartition.of(stream, shardId1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(poll_timeout_millis)));\n\n    verifyAll();\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":382,"status":"M"},{"authorDate":"2019-07-07 00:33:12","commitOrder":2,"curCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(stream, SHARD_ID0),\n        StreamPartition.of(stream, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n  }\n","date":"2019-07-07 00:33:12","endLine":621,"groupId":"13306","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPollDeaggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/23/0432a58eb0c33a4affc64e521b19fa8f716f5c.src","preCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId0),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    expect(kinesis.getShardIterator(\n        anyObject(),\n        eq(shardId1),\n        anyString(),\n        anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    expect(getShardIteratorResult0.getShardIterator()).andReturn(shard0Iterator).anyTimes();\n    expect(getShardIteratorResult1.getShardIterator()).andReturn(shard1Iterator).anyTimes();\n    expect(kinesis.getRecords(generateGetRecordsReq(shard0Iterator, recordsPerFetch))).andReturn(getRecordsResult0)\n                                                                                      .anyTimes();\n    expect(kinesis.getRecords(generateGetRecordsReq(shard1Iterator, recordsPerFetch))).andReturn(getRecordsResult1)\n                                                                                      .anyTimes();\n    expect(getRecordsResult0.getRecords()).andReturn(shard0Records).once();\n    expect(getRecordsResult1.getRecords()).andReturn(shard1Records).once();\n    expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(stream, shardId0),\n        StreamPartition.of(stream, shardId1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        poll_timeout_millis));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(allRecords));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":552,"status":"M"}],"commitId":"1166bbcb75d432817715fdd429737f86730b5591","commitMessage":"@@@Remove static imports from tests (#8036)\n\nMake static imports forbidden in tests and remove all occurrences to be\nconsistent with the non-test code.\n\nAlso.  various changes to files affected by above:\n- Reformat to adhere to druid style guide\n- Fix various IntelliJ warnings\n- Fix various SonarLint warnings (e.g..  the expected/actual args to\n  Assert.assertEquals() were flipped)","date":"2019-07-07 00:33:12","modifiedFileCount":"98","status":"M","submitter":"Chi Cao Minh"},{"authorTime":"2019-08-23 18:13:54","codes":[{"authorDate":"2019-08-23 18:13:54","commitOrder":3,"curCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","date":"2019-08-23 18:13:54","endLine":438,"groupId":"12507","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSeekToLatest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/3b/b675e464ebf1b5909298cbffcd6ee437a84d6f.src","preCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(stream, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(stream, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":382,"status":"M"},{"authorDate":"2019-08-23 18:13:54","commitOrder":3,"curCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n  }\n","date":"2019-08-23 18:13:54","endLine":621,"groupId":"13306","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testPollDeaggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/3b/b675e464ebf1b5909298cbffcd6ee437a84d6f.src","preCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(stream, SHARD_ID0),\n        StreamPartition.of(stream, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":552,"status":"M"}],"commitId":"33f0753a70361e7d345a488034f76a889f7c3682","commitMessage":"@@@Add Checkstyle for constant name static final (#8060)\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* merging with upstream\n\n* review-1\n\n* unknow changes\n\n* unknow changes\n\n* review-2\n\n* merging with master\n\n* review-2 1 changes\n\n* review changes-2 2\n\n* bug fix\n","date":"2019-08-23 18:13:54","modifiedFileCount":"298","status":"M","submitter":"SandishKumarHN"},{"authorTime":"2020-03-17 12:39:53","codes":[{"authorDate":"2019-08-23 18:13:54","commitOrder":4,"curCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","date":"2019-08-23 18:13:54","endLine":438,"groupId":"12507","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSeekToLatest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/3b/b675e464ebf1b5909298cbffcd6ee437a84d6f.src","preCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":382,"status":"N"},{"authorDate":"2020-03-17 12:39:53","commitOrder":4,"curCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult0.getMillisBehindLatest()).andReturn(SHARD0_LAG_MILLIS).once();\n    EasyMock.expect(getRecordsResult1.getMillisBehindLatest()).andReturn(SHARD1_LAG_MILLIS).once();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n    Assert.assertEquals(SHARDS_LAG_MILLIS, recordSupplier.getPartitionTimeLag());\n  }\n","date":"2020-03-17 12:39:53","endLine":644,"groupId":"16000","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testPollDeaggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/76/de9a95139bed2bb607574dda9d4f5c13361291.src","preCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"M"}],"commitId":"142742f291daaf1ac9afea319cacbbe2a3077952","commitMessage":"@@@add kinesis lag metric (#9509)\n\n* add kinesis lag metric\n\n* fixes\n\n* heh\n\n* do it right this time\n\n* more test\n\n* split out supervisor report lags into lagMillis.  remove latest offsets from kinesis supervisor report since always null.  review stuffs","date":"2020-03-17 12:39:53","modifiedFileCount":"17","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-05-17 05:09:39","codes":[{"authorDate":"2020-05-17 05:09:39","commitOrder":5,"curCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100,\n        true\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","date":"2020-05-17 05:09:39","endLine":457,"groupId":"12507","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSeekToLatest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/2f32f6cdda90e78e42c84425bc22a30f15f338.src","preCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":400,"status":"M"},{"authorDate":"2020-05-17 05:09:39","commitOrder":5,"curCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult0.getMillisBehindLatest()).andReturn(SHARD0_LAG_MILLIS).once();\n    EasyMock.expect(getRecordsResult1.getMillisBehindLatest()).andReturn(SHARD1_LAG_MILLIS).once();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100,\n        true\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n    Assert.assertEquals(SHARDS_LAG_MILLIS, recordSupplier.getPartitionResourcesTimeLag());\n  }\n","date":"2020-05-17 05:09:39","endLine":654,"groupId":"16000","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testPollDeaggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/2f32f6cdda90e78e42c84425bc22a30f15f338.src","preCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult0.getMillisBehindLatest()).andReturn(SHARD0_LAG_MILLIS).once();\n    EasyMock.expect(getRecordsResult1.getMillisBehindLatest()).andReturn(SHARD1_LAG_MILLIS).once();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n    Assert.assertEquals(SHARDS_LAG_MILLIS, recordSupplier.getPartitionTimeLag());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":581,"status":"M"}],"commitId":"2e9548d93d5a27e824cc93293e1de55af63d158f","commitMessage":"@@@refactor SeekableStreamSupervisor usage of RecordSupplier (#9819)\n\n* refactor SeekableStreamSupervisor usage of RecordSupplier to reduce contention between background threads and main thread.  refactor KinesisRecordSupplier.  refactor Kinesis lag metric collection and emitting\n\n* fix style and test\n\n* cleanup.  refactor.  javadocs.  test\n\n* fixes\n\n* keep collecting current offsets and lag if unhealthy in background reporting thread\n\n* review stuffs\n\n* add comment","date":"2020-05-17 05:09:39","modifiedFileCount":"13","status":"M","submitter":"Clint Wylie"},{"authorTime":"2021-01-09 08:04:37","codes":[{"authorDate":"2020-05-17 05:09:39","commitOrder":6,"curCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100,\n        true\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","date":"2020-05-17 05:09:39","endLine":457,"groupId":"102344","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testSeekToLatest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6b/2f32f6cdda90e78e42c84425bc22a30f15f338.src","preCode":"  public void testSeekToLatest()\n      throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(null).once();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(null).once();\n\n    replayAll();\n\n    StreamPartition<String> shard0 = StreamPartition.of(STREAM, SHARD_ID0);\n    StreamPartition<String> shard1 = StreamPartition.of(STREAM, SHARD_ID1);\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        shard0,\n        shard1\n    );\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        false,\n        100,\n        5000,\n        5000,\n        60000,\n        100,\n        true\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToLatest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 2; i++) {\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(Collections.emptyList(), cleanRecords(recordSupplier.poll(POLL_TIMEOUT_MILLIS)));\n\n    verifyAll();\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":400,"status":"N"},{"authorDate":"2021-01-09 08:04:37","commitOrder":6,"curCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult0.getMillisBehindLatest()).andReturn(SHARD0_LAG_MILLIS).once();\n    EasyMock.expect(getRecordsResult1.getMillisBehindLatest()).andReturn(SHARD1_LAG_MILLIS).once();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100,\n        true\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String, ByteEntity>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n    Assert.assertEquals(SHARDS_LAG_MILLIS, recordSupplier.getPartitionResourcesTimeLag());\n  }\n","date":"2021-01-09 08:04:37","endLine":749,"groupId":"102344","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testPollDeaggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/cdec5670ba7cd5277fbe8af64b75bc37c7fc62.src","preCode":"  public void testPollDeaggregate() throws InterruptedException\n  {\n    recordsPerFetch = 100;\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID0),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult0).anyTimes();\n\n    EasyMock.expect(kinesis.getShardIterator(\n        EasyMock.anyObject(),\n        EasyMock.eq(SHARD_ID1),\n        EasyMock.anyString(),\n        EasyMock.anyString()\n    )).andReturn(\n        getShardIteratorResult1).anyTimes();\n\n    EasyMock.expect(getShardIteratorResult0.getShardIterator()).andReturn(SHARD0_ITERATOR).anyTimes();\n    EasyMock.expect(getShardIteratorResult1.getShardIterator()).andReturn(SHARD1_ITERATOR).anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD0_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult0)\n            .anyTimes();\n    EasyMock.expect(kinesis.getRecords(generateGetRecordsReq(SHARD1_ITERATOR, recordsPerFetch)))\n            .andReturn(getRecordsResult1)\n            .anyTimes();\n    EasyMock.expect(getRecordsResult0.getRecords()).andReturn(SHARD0_RECORDS).once();\n    EasyMock.expect(getRecordsResult1.getRecords()).andReturn(SHARD1_RECORDS).once();\n    EasyMock.expect(getRecordsResult0.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult1.getNextShardIterator()).andReturn(null).anyTimes();\n    EasyMock.expect(getRecordsResult0.getMillisBehindLatest()).andReturn(SHARD0_LAG_MILLIS).once();\n    EasyMock.expect(getRecordsResult1.getMillisBehindLatest()).andReturn(SHARD1_LAG_MILLIS).once();\n\n    replayAll();\n\n    Set<StreamPartition<String>> partitions = ImmutableSet.of(\n        StreamPartition.of(STREAM, SHARD_ID0),\n        StreamPartition.of(STREAM, SHARD_ID1)\n    );\n\n\n    recordSupplier = new KinesisRecordSupplier(\n        kinesis,\n        recordsPerFetch,\n        0,\n        2,\n        true,\n        100,\n        5000,\n        5000,\n        60000,\n        100,\n        true\n    );\n\n    recordSupplier.assign(partitions);\n    recordSupplier.seekToEarliest(partitions);\n    recordSupplier.start();\n\n    for (int i = 0; i < 10 && recordSupplier.bufferSize() < 12; i++) {\n      Thread.sleep(100);\n    }\n\n    List<OrderedPartitionableRecord<String, String>> polledRecords = cleanRecords(recordSupplier.poll(\n        POLL_TIMEOUT_MILLIS));\n\n    verifyAll();\n\n    Assert.assertEquals(partitions, recordSupplier.getAssignment());\n    Assert.assertTrue(polledRecords.containsAll(ALL_RECORDS));\n    Assert.assertEquals(SHARDS_LAG_MILLIS, recordSupplier.getPartitionResourcesTimeLag());\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisRecordSupplierTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":676,"status":"M"}],"commitId":"118b50195e5c2989e04e0f5290aa72cae114db39","commitMessage":"@@@Introduce KafkaRecordEntity to support Kafka headers in InputFormats (#10730)\n\nToday Kafka message support in streaming indexing tasks is limited to\nmessage values.  and does not provide a way to expose Kafka headers. \ntimestamps.  or keys.  which may be of interest to more specialized\nDruid input formats. For instance.  Kafka headers may be used to indicate\npayload format/encoding or additional metadata.  and timestamps are often\nomitted from values in Kafka streams applications.  since they are\nincluded in the record.\n\nThis change proposes to introduce KafkaRecordEntity as InputEntity. \nwhich would give input formats full access to the underlying Kafka record. \nincluding headers.  key.  timestamps. It would also open access to low-level\ninformation such as topic.  partition.  offset if needed.\n\nKafkaEntity is a subclass of ByteEntity for backwards compatibility with\nexisting input formats.  and to avoid introducing unnecessary complexity\nfor Kinesis indexing tasks.","date":"2021-01-09 08:04:37","modifiedFileCount":"30","status":"M","submitter":"Xavier L?aut?"}]
