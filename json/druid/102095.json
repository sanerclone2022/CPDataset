[{"authorTime":"2020-04-10 07:21:43","codes":[{"authorDate":"2020-03-23 07:43:55","commitOrder":3,"curCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && !(right instanceof DruidJoinQueryRel);\n  }\n","date":"2020-03-23 07:43:55","endLine":71,"groupId":"8088","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/58/c6562440379eb7b1232f137b78ef62e09e458d.src","preCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && !(right instanceof DruidJoinQueryRel);\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"NB"},{"authorDate":"2020-04-10 07:21:43","commitOrder":3,"curCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && left.getPartialDruidQuery().getWhereFilter() == null) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","date":"2020-04-10 07:21:43","endLine":173,"groupId":"16792","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/0d1e900578da571f18412c5dd0ce83b3ba0063.src","preCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && left.getPartialDruidQuery().getWhereFilter() == null) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"MB"}],"commitId":"75c543b50f40d7b6739ff0d6e10a81315be29736","commitMessage":"@@@SQL: More straightforward handling of join planning. (#9648)\n\n* SQL: More straightforward handling of join planning.\n\nTwo changes that simplify how joins are planned:\n\n1) Stop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead.  add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n2) Remove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal).  but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now.  and revisit reordering when we can add more smarts to\nthe cost estimator.\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\".  and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6'.  'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\n\nFixes #9646.\n\n* Fix comments.\n\n* Fix tests.","date":"2020-04-10 07:21:43","modifiedFileCount":"12","status":"M","submitter":"Gian Merlino"},{"authorTime":"2020-04-10 07:21:43","codes":[{"authorDate":"2020-08-28 22:57:06","commitOrder":4,"curCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","date":"2020-08-28 22:57:06","endLine":87,"groupId":"8088","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b9/f8f349a0408a465aab39347bef2143e9e313e6.src","preCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && !(right instanceof DruidJoinQueryRel);\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"M"},{"authorDate":"2020-04-10 07:21:43","commitOrder":4,"curCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && left.getPartialDruidQuery().getWhereFilter() == null) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","date":"2020-04-10 07:21:43","endLine":173,"groupId":"16792","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/38/0d1e900578da571f18412c5dd0ce83b3ba0063.src","preCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && left.getPartialDruidQuery().getWhereFilter() == null) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"N"}],"commitId":"5cd7610fb61405108820de4b2173e690b8df3011","commitMessage":"@@@SQL support for union datasources. (#10324)\n\n* SQL support for union datasources.\n\nExposed via the \"UNION ALL\" operator. This means that there are now two\ndifferent implementations of UNION ALL: one at the top level of a query\nthat works by concatenating subquery results.  and one at the table level\nthat works by creating a UnionDataSource.\n\nThe SQL documentation is updated to discuss these two use cases and how\nthey behave.\n\nFuture work could unify these by building support for a native datasource\nthat represents the union of multiple subqueries. (Today.  UnionDataSource\ncan only represent the union of tables.  not subqueries.)\n\n* Fixes.\n\n* Error message for sanity check.\n\n* Additional test fixes.\n\n* Add some error messages.","date":"2020-08-28 22:57:06","modifiedFileCount":"10","status":"M","submitter":"Gian Merlino"},{"authorTime":"2021-03-05 02:39:21","codes":[{"authorDate":"2020-08-28 22:57:06","commitOrder":5,"curCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","date":"2020-08-28 22:57:06","endLine":87,"groupId":"8088","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b9/f8f349a0408a465aab39347bef2143e9e313e6.src","preCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2021-03-05 02:39:21","commitOrder":5,"curCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final Filter leftFilter;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n      leftFilter = left.getPartialDruidQuery().getWhereFilter();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n      leftFilter = null;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        leftFilter,\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","date":"2021-03-05 02:39:21","endLine":185,"groupId":"8087","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ac/93b6951bf7a0a88d50772ba503aa8862426074.src","preCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && left.getPartialDruidQuery().getWhereFilter() == null) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"M"}],"commitId":"1a15987432fab044fc83a99af8ab497d887aeda1","commitMessage":"@@@Supporting filters in the left base table for join datasources (#10697)\n\n* where filter left first draft\n\n* Revert changes in calcite test\n\n* Refactor a bit\n\n* Fixing the Tests\n\n* Changes\n\n* Adding tests\n\n* Add tests for correlated queries\n\n* Add comment\n\n* Fix typos","date":"2021-03-05 02:39:21","modifiedFileCount":"26","status":"M","submitter":"Abhishek Agarwal"},{"authorTime":"2021-03-10 05:07:34","codes":[{"authorDate":"2020-08-28 22:57:06","commitOrder":6,"curCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","date":"2020-08-28 22:57:06","endLine":87,"groupId":"8088","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b9/f8f349a0408a465aab39347bef2143e9e313e6.src","preCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2021-03-10 05:07:34","commitOrder":6,"curCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final Filter leftFilter;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n    final boolean isLeftDirectAccessPossible = enableLeftScanDirect && (left instanceof DruidQueryRel);\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && (isLeftDirectAccessPossible || left.getPartialDruidQuery().getWhereFilter() == null)) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n      leftFilter = left.getPartialDruidQuery().getWhereFilter();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n      leftFilter = null;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        leftFilter,\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","date":"2021-03-10 05:07:34","endLine":192,"groupId":"8087","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b2/77a8a5158ed0c223ef26fb296106495ea13545.src","preCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final Filter leftFilter;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n      leftFilter = left.getPartialDruidQuery().getWhereFilter();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n      leftFilter = null;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        leftFilter,\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"}],"commitId":"c66951a59e2963369bbb447dba51ea7651a1cdb1","commitMessage":"@@@Add flag in SQL to disable left base filter optimization for joins (#10947)\n\n* Add flag to disable left base filter\n\n* code coverage\n\n* Draft\n\n* Review comments\n\n* code coverage\n\n* add docs\n\n* Add old tests","date":"2021-03-10 05:07:34","modifiedFileCount":"13","status":"M","submitter":"Abhishek Agarwal"},{"authorTime":"2021-07-23 23:27:19","codes":[{"authorDate":"2021-07-23 23:27:19","commitOrder":7,"curCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType(), right)\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","date":"2021-07-23 23:27:19","endLine":97,"groupId":"102095","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b6/92a986fb0cee757480580056c73273ce163aed.src","preCode":"  public boolean matches(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    \r\n    \r\n    \r\n    return canHandleCondition(join.getCondition(), join.getLeft().getRowType())\n           && left.getPartialDruidQuery() != null\n           && right.getPartialDruidQuery() != null;\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2021-07-23 23:27:19","commitOrder":7,"curCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final Filter leftFilter;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType(), right).get();\n    final boolean isLeftDirectAccessPossible = enableLeftScanDirect && (left instanceof DruidQueryRel);\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && (isLeftDirectAccessPossible || left.getPartialDruidQuery().getWhereFilter() == null)) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n      leftFilter = left.getPartialDruidQuery().getWhereFilter();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n      leftFilter = null;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        leftFilter,\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","date":"2021-07-23 23:27:19","endLine":196,"groupId":"102095","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b6/92a986fb0cee757480580056c73273ce163aed.src","preCode":"  public void onMatch(RelOptRuleCall call)\n  {\n    final Join join = call.rel(0);\n    final DruidRel<?> left = call.rel(1);\n    final DruidRel<?> right = call.rel(2);\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n\n    final DruidRel<?> newLeft;\n    final DruidRel<?> newRight;\n    final Filter leftFilter;\n    final List<RexNode> newProjectExprs = new ArrayList<>();\n\n    \r\n    \r\n    ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n    final boolean isLeftDirectAccessPossible = enableLeftScanDirect && (left instanceof DruidQueryRel);\n\n    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && (isLeftDirectAccessPossible || left.getPartialDruidQuery().getWhereFilter() == null)) {\n      \r\n      \r\n      final RelNode leftScan = left.getPartialDruidQuery().getScan();\n      final Project leftProject = left.getPartialDruidQuery().getSelectProject();\n      leftFilter = left.getPartialDruidQuery().getWhereFilter();\n\n      \r\n      newProjectExprs.addAll(leftProject.getProjects());\n      newLeft = left.withPartialQuery(PartialDruidQuery.create(leftScan));\n      conditionAnalysis = conditionAnalysis.pushThroughLeftProject(leftProject);\n    } else {\n      \r\n      for (int i = 0; i < left.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(rexBuilder.makeInputRef(join.getRowType().getFieldList().get(i).getType(), i));\n      }\n\n      newLeft = left;\n      leftFilter = null;\n    }\n\n    if (right.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n        && right.getPartialDruidQuery().getWhereFilter() == null\n        && !right.getPartialDruidQuery().getSelectProject().isMapping()\n        && conditionAnalysis.onlyUsesMappingsFromRightProject(right.getPartialDruidQuery().getSelectProject())) {\n      \r\n      \r\n      final RelNode rightScan = right.getPartialDruidQuery().getScan();\n      final Project rightProject = right.getPartialDruidQuery().getSelectProject();\n\n      \r\n      Iterables.addAll(\n          newProjectExprs,\n          RexUtil.shift(rightProject.getProjects(), newLeft.getRowType().getFieldCount())\n      );\n      newRight = right.withPartialQuery(PartialDruidQuery.create(rightScan));\n      conditionAnalysis = conditionAnalysis.pushThroughRightProject(rightProject);\n    } else {\n      \r\n      for (int i = 0; i < right.getRowType().getFieldCount(); i++) {\n        newProjectExprs.add(\n            rexBuilder.makeInputRef(\n                join.getRowType().getFieldList().get(left.getRowType().getFieldCount() + i).getType(),\n                newLeft.getRowType().getFieldCount() + i\n            )\n        );\n      }\n\n      newRight = right;\n    }\n\n    \r\n    final DruidJoinQueryRel druidJoin = DruidJoinQueryRel.create(\n        join.copy(\n            join.getTraitSet(),\n            conditionAnalysis.getCondition(rexBuilder),\n            newLeft,\n            newRight,\n            join.getJoinType(),\n            join.isSemiJoinDone()\n        ),\n        leftFilter,\n        left.getQueryMaker()\n    );\n\n    final RelBuilder relBuilder =\n        call.builder()\n            .push(druidJoin)\n            .project(\n                RexUtil.fixUp(\n                    rexBuilder,\n                    newProjectExprs,\n                    RelOptUtil.getFieldTypeList(druidJoin.getRowType())\n                )\n            );\n\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":100,"status":"M"}],"commitId":"c98e7c3aa3d1b883f76f0edaafe29cf426fb119d","commitMessage":"@@@Fix left join SQL queries with IS NOT NULL filter (#11434)\n\nThis PR fixes the incorrect results for query : \n\nSELECT dim1.  l1.k FROM foo LEFT JOIN (select k || '' as k from lookup.lookyloo group by 1) l1 ON foo.dim1 = l1.k WHERE l1.k IS NOT NULL (in CalciteQueryTests)\nIn the current code.  the WHERE clause gets removed from the top of the left join and is pushed to the table foo\nleading to incorrect results.\nThe fix for such a situation is done by :\n\nConverting such left joins into inner joins (since logically the mentioned left join query is equivalent to an inner join) using Calcite while maintaining that the druid execution layer can execute such inner joins.\nPreferring converted inner joins over original left joins in our cost model","date":"2021-07-23 23:27:19","modifiedFileCount":"7","status":"M","submitter":"Rohan Garg"}]
