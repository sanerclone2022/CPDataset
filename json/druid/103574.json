[{"authorTime":"2019-10-19 05:59:44","codes":[{"authorDate":"2019-10-19 05:59:44","commitOrder":1,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          SqlTypeName.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","date":"2019-10-19 05:59:44","endLine":207,"groupId":"23321","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/0b/5b9438f6d1d18f839199bbda4eed92253e1e7f.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          SqlTypeName.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchApproxQuantileSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"B"},{"authorDate":"2019-10-19 05:59:44","commitOrder":1,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          SqlTypeName.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","date":"2019-10-19 05:59:44","endLine":138,"groupId":"18529","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/41/bed2f314006834cf8ee2695b898dd4f78a23be.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          SqlTypeName.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchObjectSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"B"}],"commitId":"d88075237af1aca8ed22316b41860d14e4f0b6e4","commitMessage":"@@@Add initial SQL support for non-expression sketch postaggs (#8487)\n\n* Add initial SQL support for non-expression sketch postaggs\n\n* Checkstyle.  spotbugs\n\n* checkstyle\n\n* imports\n\n* Update SQL docs\n\n* Checkstyle\n\n* Fix theta sketch operator docs\n\n* PR comments\n\n* Checkstyle fixes\n\n* Add missing entries for HLL sketch module\n\n* PR comments.  add round param to HLL estimate operator.  fix optional HLL param\n","date":"2019-10-19 05:59:44","modifiedFileCount":"16","status":"B","submitter":"Jonathan Wei"},{"authorTime":"2020-08-27 01:53:44","codes":[{"authorDate":"2020-08-27 01:53:44","commitOrder":2,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","date":"2020-08-27 01:53:44","endLine":208,"groupId":"23321","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/62/f97fd12ed1df9780c37a391b8e104ed8abc2a0.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          SqlTypeName.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchApproxQuantileSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2020-08-27 01:53:44","commitOrder":2,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","date":"2020-08-27 01:53:44","endLine":139,"groupId":"18529","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ba/0493c4c08d866a703be9e6ea6379ce5d610eac.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          SqlTypeName.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchObjectSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"ab606610089f7bb9b4b1b68ac488764f394723fd","commitMessage":"@@@refactor internal type system (#9638)\n\n* better type tracking: add typed postaggs.  finalized types for agg factories\n\n* more javadoc\n\n* adjustments\n\n* transition to getTypeName to be used exclusively for complex types\n\n* remove unused fn\n\n* adjust\n\n* more better\n\n* rename getTypeName to getComplexTypeName\n\n* setup expression post agg for type inference existing\n\n* more javadocs\n\n* fixup\n\n* oops\n\n* more test\n\n* more test\n\n* more comments/javadoc\n\n* nulls\n\n* explicitly handle only numeric and complex aggregators for incremental index\n\n* checkstyle\n\n* more tests\n\n* adjust\n\n* more tests to showcase difference in behavior\n\n* timeseries longsum array","date":"2020-08-27 01:53:44","modifiedFileCount":"176","status":"M","submitter":"Clint Wylie"},{"authorTime":"2021-04-13 13:21:24","codes":[{"authorDate":"2021-04-13 13:21:24","commitOrder":3,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":209,"groupId":"23321","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/c2/e27dab5fe37322fe1fcea77ddca3ad32644278.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchApproxQuantileSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"},{"authorDate":"2021-04-13 13:21:24","commitOrder":3,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":140,"groupId":"18529","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/17/b94dcbd956c59fbf7c9d3b1ae887a5bbd8c6fc.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Expressions.toDruidExpression(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchObjectSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"M"}],"commitId":"25db8787b3d7eac87aa3be8e32d48d0e823298af","commitMessage":"@@@Fix CAST being ignored when aggregating on strings after cast (#11083)\n\n* Fix CAST being ignored when aggregating on strings after cast\n\n* fix checkstyle and dependency\n\n* unused import","date":"2021-04-13 13:21:24","modifiedFileCount":"21","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-05-11 04:41:48","codes":[{"authorDate":"2021-05-11 04:41:48","commitOrder":4,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput =\n              virtualColumnRegistry.findVirtualColumns(theFactory.requiredFields())\n                                   .stream()\n                                   .findFirst()\n                                   .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess() && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression().equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","date":"2021-05-11 04:41:48","endLine":198,"groupId":"18966","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/69/a07dd36893ccd67b619b06facc90a07cd70cbc.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput = existing.getVirtualColumns()\n                                                     .stream()\n                                                     .filter(\n                                                         virtualColumn ->\n                                                             virtualColumn.getOutputName()\n                                                                          .equals(theFactory.getFieldName())\n                                                     )\n                                                     .findFirst()\n                                                     .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess()\n                           && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression()\n                                                                   .equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchApproxQuantileSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2021-05-11 04:41:48","commitOrder":4,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","date":"2021-05-11 04:41:48","endLine":135,"groupId":"15551","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/76/d3e9cbe93044adf0a25e2f69d36c35f8afab90.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    final List<VirtualColumn> virtualColumns = new ArrayList<>();\n\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      virtualColumns.add(virtualColumn);\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        virtualColumns,\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchObjectSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"f6662b4893a9b8cc8a0ebb77e63daddde882148d","commitMessage":"@@@fix count and average SQL aggregators on constant virtual columns (#11208)\n\n* fix count and average SQL aggregators on constant virtual columns\n\n* style\n\n* even better.  why are we tracking virtual columns in aggregations at all if we have a virtual column registry\n\n* oops missed a few\n\n* remove unused\n\n* this will fix it","date":"2021-05-11 04:41:48","modifiedFileCount":"27","status":"M","submitter":"Clint Wylie"},{"authorTime":"2021-09-01 05:56:37","codes":[{"authorDate":"2021-09-01 05:56:37","commitOrder":5,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput =\n              virtualColumnRegistry.findVirtualColumns(theFactory.requiredFields())\n                                   .stream()\n                                   .findFirst()\n                                   .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess() && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression().equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k,\n          getMaxStreamLengthFromQueryContext(plannerContext.getQueryContext())\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k,\n          getMaxStreamLengthFromQueryContext(plannerContext.getQueryContext())\n      );\n    }\n\n    return Aggregation.create(\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","date":"2021-09-01 05:56:37","endLine":204,"groupId":"103574","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8c/ab843126fb26163acc10450d26633687939ff9.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final RexNode probabilityArg = Expressions.fromFieldAccess(\n        rowSignature,\n        project,\n        aggregateCall.getArgList().get(1)\n    );\n\n    if (!probabilityArg.isA(SqlKind.LITERAL)) {\n      \r\n      return null;\n    }\n\n    final float probability = ((Number) RexLiteral.value(probabilityArg)).floatValue();\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 3) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(2)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    for (final Aggregation existing : existingAggregations) {\n      for (AggregatorFactory factory : existing.getAggregatorFactories()) {\n        if (factory instanceof DoublesSketchAggregatorFactory) {\n          final DoublesSketchAggregatorFactory theFactory = (DoublesSketchAggregatorFactory) factory;\n\n          \r\n          final boolean inputMatches;\n          final VirtualColumn virtualInput =\n              virtualColumnRegistry.findVirtualColumns(theFactory.requiredFields())\n                                   .stream()\n                                   .findFirst()\n                                   .orElse(null);\n\n          if (virtualInput == null) {\n            inputMatches = input.isDirectColumnAccess() && input.getDirectColumn().equals(theFactory.getFieldName());\n          } else {\n            inputMatches = ((ExpressionVirtualColumn) virtualInput).getExpression().equals(input.getExpression());\n          }\n\n          final boolean matches = inputMatches\n                                  && theFactory.getK() == k;\n\n          if (matches) {\n            \r\n            return Aggregation.create(\n                ImmutableList.of(),\n                new DoublesSketchToQuantilePostAggregator(\n                    name,\n                    new FieldAccessPostAggregator(\n                        factory.getName(),\n                        factory.getName()\n                    ),\n                    probability\n                )\n            );\n          }\n        }\n      }\n    }\n\n    \r\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        ImmutableList.of(aggregatorFactory),\n        new DoublesSketchToQuantilePostAggregator(\n            name,\n            new FieldAccessPostAggregator(\n                histogramName,\n                histogramName\n            ),\n            probability\n        )\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchApproxQuantileSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2021-09-01 05:56:37","commitOrder":5,"curCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k,\n          DoublesSketchApproxQuantileSqlAggregator.getMaxStreamLengthFromQueryContext(plannerContext.getQueryContext())\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k,\n          DoublesSketchApproxQuantileSqlAggregator.getMaxStreamLengthFromQueryContext(plannerContext.getQueryContext())\n      );\n    }\n\n    return Aggregation.create(\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","date":"2021-09-01 05:56:37","endLine":137,"groupId":"103574","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"toDruidAggregation","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalVirtualColumnRegistryvirtualColumnRegistry@finalRexBuilderrexBuilder@finalStringname@finalAggregateCallaggregateCall@finalProjectproject@finalList<Aggregation>existingAggregations@finalbooleanfinalizeAggregations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d9/b84e7145fdc3b83b278da797d312543ef2e2fd.src","preCode":"  public Aggregation toDruidAggregation(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final VirtualColumnRegistry virtualColumnRegistry,\n      final RexBuilder rexBuilder,\n      final String name,\n      final AggregateCall aggregateCall,\n      final Project project,\n      final List<Aggregation> existingAggregations,\n      final boolean finalizeAggregations\n  )\n  {\n    final DruidExpression input = Aggregations.toDruidExpressionForNumericAggregator(\n        plannerContext,\n        rowSignature,\n        Expressions.fromFieldAccess(\n            rowSignature,\n            project,\n            aggregateCall.getArgList().get(0)\n        )\n    );\n    if (input == null) {\n      return null;\n    }\n\n    final AggregatorFactory aggregatorFactory;\n    final String histogramName = StringUtils.format(\"%s:agg\", name);\n    final int k;\n\n    if (aggregateCall.getArgList().size() >= 2) {\n      final RexNode resolutionArg = Expressions.fromFieldAccess(\n          rowSignature,\n          project,\n          aggregateCall.getArgList().get(1)\n      );\n\n      if (!resolutionArg.isA(SqlKind.LITERAL)) {\n        \r\n        return null;\n      }\n\n      k = ((Number) RexLiteral.value(resolutionArg)).intValue();\n    } else {\n      k = DoublesSketchAggregatorFactory.DEFAULT_K;\n    }\n\n    \r\n    if (input.isDirectColumnAccess()) {\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          input.getDirectColumn(),\n          k\n      );\n    } else {\n      VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n          plannerContext,\n          input,\n          ValueType.FLOAT\n      );\n      aggregatorFactory = new DoublesSketchAggregatorFactory(\n          histogramName,\n          virtualColumn.getOutputName(),\n          k\n      );\n    }\n\n    return Aggregation.create(\n        ImmutableList.of(aggregatorFactory),\n        null\n    );\n  }\n","realPath":"extensions-core/datasketches/src/main/java/org/apache/druid/query/aggregation/datasketches/quantiles/sql/DoublesSketchObjectSqlAggregator.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"7e90d00cc0e3e9a01d1a3a7730f5bbf6d276999b","commitMessage":"@@@Configurable maxStreamLength for doubles sketches (#11574)\n\n* Configurable maxStreamLength for doubles sketches\n\n* fix equals/hashcode and it test failure\n\n* fix test\n\n* fix it test\n\n* benchmark\n\n* doc\n\n* grouping key\n\n* fix comment\n\n* dependency check\n\n* Update docs/development/extensions-core/datasketches-quantiles.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\n* Update docs/querying/sql.md\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>\n\nCo-authored-by: Charles Smith <techdocsmith@gmail.com>","date":"2021-09-01 05:56:37","modifiedFileCount":"14","status":"M","submitter":"Jihoon Son"}]
