[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(DruidNodeDiscoveryProvider.NODE_TYPE_MM))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        DruidNodeDiscoveryProvider.NODE_TYPE_MM,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2018-08-31 00:56:26","endLine":563,"groupId":"2413","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/73/09452adaa0ef961132121053aac282dac857ce.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(DruidNodeDiscoveryProvider.NODE_TYPE_MM))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        DruidNodeDiscoveryProvider.NODE_TYPE_MM,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":403,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(DruidNodeDiscoveryProvider.NODE_TYPE_MM))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        DruidNodeDiscoveryProvider.NODE_TYPE_MM,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2018-08-31 00:56:26","endLine":726,"groupId":"6109","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/73/09452adaa0ef961132121053aac282dac857ce.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(DruidNodeDiscoveryProvider.NODE_TYPE_MM))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        DruidNodeDiscoveryProvider.NODE_TYPE_MM,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":566,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-10-15 11:49:38","codes":[{"authorDate":"2018-10-15 11:49:38","commitOrder":2,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2018-10-15 11:49:38","endLine":564,"groupId":"20245","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/86/194f13dc65bea32aea34fd05ffc40562caa0ce.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(DruidNodeDiscoveryProvider.NODE_TYPE_MM))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        DruidNodeDiscoveryProvider.NODE_TYPE_MM,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":404,"status":"M"},{"authorDate":"2018-10-15 11:49:38","commitOrder":2,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2018-10-15 11:49:38","endLine":727,"groupId":"20246","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/86/194f13dc65bea32aea34fd05ffc40562caa0ce.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(DruidNodeDiscoveryProvider.NODE_TYPE_MM))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        DruidNodeDiscoveryProvider.NODE_TYPE_MM,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":567,"status":"M"}],"commitId":"aa121da25f019ad3345c747ce56261fbb7e77885","commitMessage":"@@@Use NodeType enum instead of Strings (#6377)\n\n* Use NodeType enum instead of Strings\n\n* Make NodeType constants uppercase\n\n* Fix CommonCacheNotifier and NodeType/ServerType comments\n\n* Reconsidering comment\n\n* Fix import\n\n* Add a comment to CommonCacheNotifier.NODE_TYPES\n","date":"2018-10-15 11:49:38","modifiedFileCount":"30","status":"M","submitter":"Roman Leventov"},{"authorTime":"2018-10-16 05:19:40","codes":[{"authorDate":"2018-10-16 05:19:40","commitOrder":3,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2018-10-16 05:19:40","endLine":564,"groupId":"20245","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/56/ec10a6be6a61fe4c70bf0027f22c01dd54822b.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":404,"status":"M"},{"authorDate":"2018-10-16 05:19:40","commitOrder":3,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2018-10-16 05:19:40","endLine":727,"groupId":"20246","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/56/ec10a6be6a61fe4c70bf0027f22c01dd54822b.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig() {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    ) {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker);\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper, httpClient, config, exec, listener, worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":567,"status":"M"}],"commitId":"85a89e27033b046c58346bbcedc8db37aa59dbf9","commitMessage":"@@@make druid node bind address configurable (#6464)\n\n* make druid node bind address configurable\n\n* fix tests\n\n* fix travis-ci\n","date":"2018-10-16 05:19:40","modifiedFileCount":"38","status":"M","submitter":"QiuMM"},{"authorTime":"2019-02-05 01:18:12","codes":[{"authorDate":"2019-02-05 01:18:12","commitOrder":4,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2019-02-05 01:18:12","endLine":593,"groupId":"20245","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/0a/dcf266014fddb5c0501d1cfdd9bdfb0b97c7be.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"M"},{"authorDate":"2019-02-05 01:18:12","commitOrder":4,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2019-02-05 01:18:12","endLine":767,"groupId":"20246","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/0a/dcf266014fddb5c0501d1cfdd9bdfb0b97c7be.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    Map<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":596,"status":"M"}],"commitId":"0e926e865276f892ddc5b62685d331b822104022","commitMessage":"@@@Prohibit assigning concurrent maps into Map-typed variables and fields and fix a race condition in CoordinatorRuleManager (#6898)\n\n* Prohibit assigning concurrent maps into Map-types variables and fields; Fix a race condition in CoordinatorRuleManager; improve logic in DirectDruidClient and ResourcePool\n\n* Enforce that if compute().  computeIfAbsent().  computeIfPresent() or merge() is called on a ConcurrentHashMap.  it's stored in a ConcurrentHashMap-typed variable.  not ConcurrentMap; add comments explaining get()-before-computeIfAbsent() optimization; refactor Counters; fix a race condition in Intialization.java\n\n* Remove unnecessary comment\n\n* Checkstyle\n\n* Fix getFromExtensions()\n\n* Add a reference to the comment about guarded computeIfAbsent() optimization; IdentityHashMap optimization\n\n* Fix UriCacheGeneratorTest\n\n* Workaround issue with MaterializedViewQueryQueryToolChest\n\n* Strengthen Appenderator's contract regarding concurrency\n","date":"2019-02-05 01:18:12","modifiedFileCount":"101","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-07-30 08:06:33","codes":[{"authorDate":"2019-07-30 08:06:33","commitOrder":5,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2019-07-30 08:06:33","endLine":593,"groupId":"20245","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a9/4dd5e9475d8a3fb39f7d1a15d71b14b886cfc5.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"M"},{"authorDate":"2019-07-30 08:06:33","commitOrder":5,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2019-07-30 08:06:33","endLine":767,"groupId":"20246","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a9/4dd5e9475d8a3fb39f7d1a15d71b14b886cfc5.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForNodeType(NodeType.MIDDLE_MANAGER))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":596,"status":"M"}],"commitId":"640b7afc1cee911a27de7bf938dda24a85ba1510","commitMessage":"@@@Add CliIndexer process type and initial task runner implementation (#8107)\n\n* Add CliIndexer process type and initial task runner implementation\n\n* Fix HttpRemoteTaskRunnerTest\n\n* Remove batch sanity check on PeonAppenderatorsManager\n\n* Fix paralle index tests\n\n* PR comments\n\n* Adjust Jersey resource logging\n\n* Additional cleanup\n\n* Fix SystemSchemaTest\n\n* Add comment to LocalDataSegmentPusherTest absolute path test\n\n* More PR comments\n\n* Use Server annotated with RemoteChatHandler\n\n* More PR comments\n\n* Checkstyle\n\n* PR comments\n\n* Add task shutdown to stopGracefully\n\n* Small cleanup\n\n* Compile fix\n\n* Address PR comments\n\n* Adjust TaskReportFileWriter and fix nits\n\n* Remove unnecessary closer\n\n* More PR comments\n\n* Minor adjustments\n\n* PR comments\n\n* ThreadingTaskRunner: cancel  task run future not shutdownFuture and remove thread from workitem\n","date":"2019-07-30 08:06:33","modifiedFileCount":"64","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2019-09-20 01:19:17","codes":[{"authorDate":"2019-09-20 01:19:17","commitOrder":6,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2019-09-20 01:19:17","endLine":599,"groupId":"20245","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4f/73e49200f2122eb935d974b650e1cb2e7d29f7.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":427,"status":"M"},{"authorDate":"2019-09-20 01:19:17","commitOrder":6,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2019-09-20 01:19:17","endLine":777,"groupId":"17266","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4f/73e49200f2122eb935d974b650e1cb2e7d29f7.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":602,"status":"M"}],"commitId":"62afbca7b9f535e00c75afce30963a8c3a81f669","commitMessage":"@@@update HRTR to account for task known to be running on a worker when it shows up (#8427)\n\n","date":"2019-09-20 01:19:17","modifiedFileCount":"4","status":"M","submitter":"Himanshu"},{"authorTime":"2019-10-18 03:57:19","codes":[{"authorDate":"2019-10-18 03:57:19","commitOrder":7,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2019-10-18 03:57:19","endLine":600,"groupId":"20245","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/dc/87de699bdbbd4b71f1df3c23830c59322f2504.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\")\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":428,"status":"M"},{"authorDate":"2019-10-18 03:57:19","commitOrder":7,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2019-10-18 03:57:19","endLine":778,"groupId":"17266","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/dc/87de699bdbbd4b71f1df3c23830c59322f2504.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\"))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":603,"status":"M"}],"commitId":"2c758ef5ff07891619b7ffedfb28dc31a6850c59","commitMessage":"@@@Support assign tasks to run on different categories of MiddleManagers (#7066)\n\n* Support assign tasks to run on different tiers of MiddleManagers\n\n* address comments\n\n* address comments\n\n* rename tier to category and docs\n\n* doc\n\n* fix doc\n\n* fix spelling errors\n\n* docs\n","date":"2019-10-18 03:57:19","modifiedFileCount":"27","status":"M","submitter":"Mingming Qiu"},{"authorTime":"2019-12-08 23:47:58","codes":[{"authorDate":"2019-12-08 23:47:58","commitOrder":8,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeRole.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2019-12-08 23:47:58","endLine":600,"groupId":"20245","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/74/5f3e5cf9a98b210dd703cdd5b4f7d5cc1554a1.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":428,"status":"M"},{"authorDate":"2019-12-08 23:47:58","commitOrder":8,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeRole.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY,\n            new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2019-12-08 23:47:58","endLine":781,"groupId":"394","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/74/5f3e5cf9a98b210dd703cdd5b4f7d5cc1554a1.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeType.MIDDLE_MANAGER,\n        ImmutableMap.of(WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY))\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":603,"status":"M"}],"commitId":"1c62987783e85867856f567b04aad807a26bb2e3","commitMessage":"@@@Add SelfDiscoveryResource; rename org.apache.druid.discovery.No? (#6702)\n\n* Add SelfDiscoveryResource\n\n* Rename org.apache.druid.discovery.NodeType to NodeRole. Refactor CuratorDruidNodeDiscoveryProvider. Make SelfDiscoveryResource to listen to updates only about a single node (itself).\n\n* Extended docs\n\n* Fix brace\n\n* Remove redundant throws in Lifecycle.Handler.stop()\n\n* Import order\n\n* Remove unresolvable link\n\n* Address comments\n\n* tmp\n\n* tmp\n\n* Rollback docker changes\n\n* Remove extra .sh files\n\n* Move filter\n\n* Fix SecurityResourceFilterTest\n","date":"2019-12-08 23:47:58","modifiedFileCount":"54","status":"M","submitter":"Roman Leventov"},{"authorTime":"2021-07-16 04:14:28","codes":[{"authorDate":"2019-12-08 23:47:58","commitOrder":9,"curCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeRole.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","date":"2019-12-08 23:47:58","endLine":600,"groupId":"104310","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearBeforeItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/74/5f3e5cf9a98b210dd703cdd5b4f7d5cc1554a1.src","preCode":"  public void testWorkerDisapperAndReappearBeforeItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public int getPendingTasksRunnerNumThreads()\n          {\n            return 3;\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeRole.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY, new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.success(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.success(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n\n            ),\n            ImmutableMap.of(),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isSuccess());\n    Assert.assertTrue(future2.get().isSuccess());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":428,"status":"N"},{"authorDate":"2021-07-16 04:14:28","commitOrder":9,"curCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeRole.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY,\n            new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n    Assert.assertNotNull(future1.get().getErrorMsg());\n    Assert.assertNotNull(future2.get().getErrorMsg());\n    Assert.assertTrue(\n        future1.get().getErrorMsg().startsWith(\n            \"The worker that this task was assigned disappeared and did not report cleanup within timeout\"\n        )\n    );\n    Assert.assertTrue(\n        future2.get().getErrorMsg().startsWith(\n            \"The worker that this task was assigned disappeared and did not report cleanup within timeout\"\n        )\n    );\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","date":"2021-07-16 04:14:28","endLine":803,"groupId":"104310","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkerDisapperAndReappearAfterItsCleanup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/aa/3f14e070e785d555a4b4d5362b1ed0580da0d8.src","preCode":"  public void testWorkerDisapperAndReappearAfterItsCleanup() throws Exception\n  {\n    TestDruidNodeDiscovery druidNodeDiscovery = new TestDruidNodeDiscovery();\n    DruidNodeDiscoveryProvider druidNodeDiscoveryProvider = EasyMock.createMock(DruidNodeDiscoveryProvider.class);\n    EasyMock.expect(druidNodeDiscoveryProvider.getForService(WorkerNodeService.DISCOVERY_SERVICE_KEY))\n            .andReturn(druidNodeDiscovery);\n    EasyMock.replay(druidNodeDiscoveryProvider);\n\n    ConcurrentMap<String, CustomFunction> workerHolders = new ConcurrentHashMap<>();\n\n    HttpRemoteTaskRunner taskRunner = new HttpRemoteTaskRunner(\n        TestHelper.makeJsonMapper(),\n        new HttpRemoteTaskRunnerConfig()\n        {\n          @Override\n          public Period getTaskCleanupTimeout()\n          {\n            return Period.millis(1);\n          }\n        },\n        EasyMock.createNiceMock(HttpClient.class),\n        DSuppliers.of(new AtomicReference<>(DefaultWorkerBehaviorConfig.defaultConfig())),\n        new NoopProvisioningStrategy<>(),\n        druidNodeDiscoveryProvider,\n        EasyMock.createNiceMock(TaskStorage.class),\n        EasyMock.createNiceMock(CuratorFramework.class),\n        new IndexerZkConfig(new ZkPathsConfig(), null, null, null, null)\n    )\n    {\n      @Override\n      protected WorkerHolder createWorkerHolder(\n          ObjectMapper smileMapper,\n          HttpClient httpClient,\n          HttpRemoteTaskRunnerConfig config,\n          ScheduledExecutorService workersSyncExec,\n          WorkerHolder.Listener listener,\n          Worker worker,\n          List<TaskAnnouncement> knownAnnouncements\n      )\n      {\n        if (workerHolders.containsKey(worker.getHost())) {\n          return workerHolders.get(worker.getHost()).apply(\n              smileMapper,\n              httpClient,\n              config,\n              workersSyncExec,\n              listener,\n              worker,\n              knownAnnouncements\n          );\n        } else {\n          throw new ISE(\"No WorkerHolder for [%s].\", worker.getHost());\n        }\n      }\n    };\n\n    taskRunner.start();\n\n    Task task1 = NoopTask.create(\"task-id-1\", 0);\n    Task task2 = NoopTask.create(\"task-id-2\", 0);\n\n    DiscoveryDruidNode druidNode = new DiscoveryDruidNode(\n        new DruidNode(\"service\", \"host\", false, 1234, null, true, false),\n        NodeRole.MIDDLE_MANAGER,\n        ImmutableMap.of(\n            WorkerNodeService.DISCOVERY_SERVICE_KEY,\n            new WorkerNodeService(\"ip1\", 2, \"0\", WorkerConfig.DEFAULT_CATEGORY)\n        )\n    );\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(),\n            ImmutableMap.of(\n                task1, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task1,\n                        TaskStatus.running(task1.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                ),\n                task2, ImmutableList.of(\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.unknown()\n                    ),\n                    TaskAnnouncement.create(\n                        task2,\n                        TaskStatus.running(task2.getId()),\n                        TaskLocation.create(\"host\", 1234, 1235)\n                    )\n                )\n            ),\n            new AtomicInteger(),\n            ImmutableSet.of()\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Future<TaskStatus> future1 = taskRunner.run(task1);\n    Future<TaskStatus> future2 = taskRunner.run(task2);\n\n    while (taskRunner.getPendingTasks().size() > 0) {\n      Thread.sleep(100);\n    }\n\n    druidNodeDiscovery.listener.nodesRemoved(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    Assert.assertTrue(future1.get().isFailure());\n    Assert.assertTrue(future2.get().isFailure());\n\n    AtomicInteger ticks = new AtomicInteger();\n    Set<String> actualShutdowns = new ConcurrentHashSet<>();\n\n    workerHolders.put(\n        \"host:1234\",\n        (mapper, httpClient, config, exec, listener, worker, knownAnnouncements) -> createWorkerHolder(\n            mapper,\n            httpClient,\n            config,\n            exec,\n            listener,\n            worker,\n            knownAnnouncements,\n            ImmutableList.of(\n                TaskAnnouncement.create(\n                    task1,\n                    TaskStatus.success(task1.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                ),\n                TaskAnnouncement.create(\n                    task2,\n                    TaskStatus.running(task2.getId()),\n                    TaskLocation.create(\"host\", 1234, 1235)\n                )\n            ),\n            ImmutableMap.of(),\n            ticks,\n            actualShutdowns\n        )\n    );\n\n    druidNodeDiscovery.listener.nodesAdded(\n        ImmutableList.of(\n            druidNode\n        )\n    );\n\n    while (ticks.get() < 1) {\n      Thread.sleep(100);\n    }\n\n    Assert.assertEquals(ImmutableSet.of(task2.getId()), actualShutdowns);\n    Assert.assertTrue(taskRunner.run(task1).get().isFailure());\n    Assert.assertTrue(taskRunner.run(task2).get().isFailure());\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":613,"status":"M"}],"commitId":"8729b4089319a0bbb4e5c0b9a59c8cfa15dc0bd7","commitMessage":"@@@Add the error message in taskStatus for task failures in overlord (#11419)\n\n* add error messages in taskStatus for task failures in overlord\n\n* unused imports\n\n* add helper message for logs to look up\n\n* fix tests\n\n* fix counting the same task failures more than once\n\n* same fix for HttpRemoteTaskRunner","date":"2021-07-16 04:14:28","modifiedFileCount":"9","status":"M","submitter":"Jihoon Son"}]
